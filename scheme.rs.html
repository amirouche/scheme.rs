<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>scheme.rs</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>Let’s agree that <em>serif</em> fonts do not always carry boring stuff. And have a taste of it:</p>
<blockquote>
<p>Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary. — <a href="http://r7rs.org/">Revised 7 Report on the Algorithmic Language Scheme</a>, Introduction.</p>
</blockquote>
<p>Otherwise said, Scheme offers a minimalist core of powerful primitives upon which one can build abstractions to solve (real world) problems.</p>
<p>The Scheme universe is vast and prolific. As programming languages, Scheme dialects target various niches and implement various paradigms. Some of them are part of the de facto standards (namely RnRS and SRFIs).</p>
<p>The best-known paradigm of agreed-upon practices revolve around Functional Programming.</p>
<p>Scheme might be a dynamically typed language, but it can compete with its scions and siblings when performance matters.</p>
<p>Few programming languages can compete with Scheme when it comes to computer science whether it is Programming Language Theory, or Artificial Intelligence.</p>
<p>That being said, Scheme implementations might be missing some love. That’s a good opportunity for you to learn something useful and give something back.</p>
<p>Or, like others, to make it your secret sauce.</p>
<h2 id="discourse"><a href="/discourse/">Discourse</a></h2>
<h2 id="tutorial"><a href="/tutorial/">Tutorial</a></h2>
<h2 id="standard-library">Standard Library</h2>
<ul>
<li><a href="/scheme/base/"><code>(scheme base)</code></a> R7RS-small</li>
<li><a href="/scheme/bitwise/"><code>(scheme bitwise)</code></a></li>
<li><a href="/scheme/box/"><code>(scheme box)</code></a></li>
<li><a href="/scheme/bytevector/"><code>(scheme bytevector)</code></a></li>
<li><a href="/scheme/case-lambda/"><code>(scheme case-lambda)</code></a> R7RS-small</li>
<li><a href="/scheme/char/"><code>(scheme char)</code></a> R7RS-small</li>
<li><a href="/scheme/charset/"><code>(scheme charset)</code></a></li>
<li><a href="/scheme/comparator/"><code>(scheme comparator)</code></a></li>
<li><a href="/scheme/complex/"><code>(scheme complex)</code></a> R7RS-small</li>
<li><a href="/scheme/cxr/"><code>(scheme cxr)</code></a> R7RS-small</li>
<li><a href="/scheme/division/"><code>(scheme division)</code></a></li>
<li><a href="/scheme/ephemeron/"><code>(scheme ephemeron)</code></a></li>
<li><a href="/scheme/eval/"><code>(scheme eval)</code></a> R7RS-small</li>
<li><a href="/scheme/file/"><code>(scheme file)</code></a> R7RS-small</li>
<li><a href="/scheme/fixnum/"><code>(scheme fixnum)</code></a></li>
<li><a href="/scheme/flonum/"><code>(scheme flonum)</code></a></li>
<li><a href="/scheme/generator/"><code>(scheme generator)</code></a></li>
<li><a href="/scheme/hash-table/"><code>(scheme hash-table)</code></a></li>
<li><a href="/scheme/idque/"><code>(scheme idque)</code></a></li>
<li><a href="/scheme/ilist/"><code>(scheme ilist)</code></a></li>
<li><a href="/scheme/inexact/"><code>(scheme inexact)</code></a> R7RS-small</li>
<li><a href="/scheme/lazy/"><code>(scheme lazy)</code></a> R7RS-small</li>
<li><a href="/scheme/list/"><code>(scheme list)</code></a></li>
<li><a href="/scheme/list-queue/"><code>(scheme list-queue)</code></a></li>
<li><a href="/scheme/load/"><code>(scheme load)</code></a> R7RS-small</li>
<li><a href="/scheme/lseq/"><code>(scheme lseq)</code></a></li>
<li><a href="/scheme/mapping/"><code>(scheme mapping)</code></a></li>
<li><a href="/scheme/mapping-hash/"><code>(scheme mapping-hash)</code></a></li>
<li><a href="/scheme/process-context/"><code>(scheme process-context)</code></a> R7RS-small</li>
<li><a href="/scheme/r5rs/"><code>(scheme r5rs)</code></a> R7RS-small</li>
<li><a href="/scheme/read/"><code>(scheme read)</code></a> R7RS-small</li>
<li><a href="/scheme/regex/"><code>(scheme regex)</code></a></li>
<li><a href="/scheme/repl/"><code>(scheme repl)</code></a> R7RS-small</li>
<li><a href="/scheme/rlist/"><code>(scheme rlist)</code></a></li>
<li><a href="/scheme/set/"><code>(scheme set)</code></a></li>
<li><a href="/scheme/show/"><code>(scheme show)</code></a></li>
<li><a href="/scheme/sort/"><code>(scheme sort)</code></a></li>
<li><a href="/scheme/stream/"><code>(scheme stream)</code></a></li>
<li><a href="/scheme/text/"><code>(scheme text)</code></a></li>
<li><a href="/scheme/time/"><code>(scheme time)</code></a> R7RS-small</li>
<li><a href="/scheme/vector/"><code>(scheme vector)</code></a></li>
<li><a href="/scheme/write/"><code>(scheme write)</code></a> R7RS-small</li>
</ul>
<h2 id="source-and-single-page-files">Source, and single page files</h2>
<p>You can find the <a href="https://git.sr.ht/~amirouche/scheme.rs">source over the rainbow</a>. There is available a <a href="scheme.rs.md">single markdown file</a>, and a <a href="scheme.rs.html">single html file</a> and a <a href="scheme.rs.html">pdf</a>;</p>
<h2 id="license">LICENSE</h2>
<p>Except otherwise noted, this documentation is licensed under the SRFI license:</p>
<p>Copyright (C) Amirouche Amazigh BOUBEKKI, and contributors (2021).</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. # A cheatsheet on Discourse.</p>
<h2 id="the-three-gates-of-speech">The three gates of speech</h2>
<p>Before you speak, let your words pass through three gates.</p>
<ul>
<li>At the first gate, ask yourself, is it true.</li>
<li>At the second gate ask, is it necessary.</li>
<li>At the third gate ask, is it kind.</li>
</ul>
<h2 id="rogerian-rhetoric">Rogerian rhetoric</h2>
<blockquote>
<ol type="1">
<li><p>You should attempt to re-express your target’s position so clearly, vividly, and fairly that your target says, “Thanks, I wish I’d thought of putting it that way.”</p></li>
<li><p>You should list any points of agreement (especially if they are not matters of general or widespread agreement).</p></li>
<li><p>You should mention anything you have learned from your target.</p></li>
<li><p>Only then are you permitted to say so much as a word of rebuttal or criticism.</p></li>
</ol>
<p>— <a href="https://wikiless.org/wiki/Rogerian_rhetoric?lang=en#Dennett&#39;s_version">Dennett’s version of Rapoport’s Rules</a></p>
</blockquote>
<h2 id="argument-ranking">Argument Ranking</h2>
<ul>
<li><p>●●●●● - High-level generators - Disagreements that remain when everyone understands exactly what’s being argued, and agrees on what all the evidence says, but have vague and hard-to-define reasons for disagreeing.</p></li>
<li><p>●●●●○ - Operationalizing - Where both parties understand they’re in a cooperative effort to fix exactly what they’re arguing about.</p></li>
<li><p>●●●○○ - Survey of evidence - Not trying to devastate the other person with a mountain of facts and start looking at the studies and arguments on both sides and figuring out what kind of complex picture they paint.</p></li>
<li><p>●●●○○ - Disputing definitions - Argument hinges on the meaning of words, or whether something counts as a member of a category or not.</p></li>
<li><p>●●○○○ - Single Studies - Better than scattered facts, proving they at least looked into the issue formally.</p></li>
<li><p>●●○○○ - Demands for rigor - Attempts to demand that an opposing argument be held to such strict standards that nothing could possibly clear the bar.</p></li>
<li><p>●○○○○ - Single Facts- One fact, which admittedly does support their argument, but presented as if it solves the debate in and of itself.</p></li>
<li><p>●○○○○ - Gotchas - Short claims that purport to be devastating proof that one side can’t possibly be right.</p></li>
<li><p>○○○○○ - Social shaming- A demand for listeners to place someone outside the boundary of whom deserve to be heard.</p></li>
</ul>
<blockquote>
<p>“How to apologize: Quickly, specifically, sincerely.”</p>
<p>— Kevin Kelly</p>
</blockquote>
<h3 id="arguments">Arguments</h3>
<ul>
<li><strong>Ad baculum</strong> : Argument relying on an appeal to fear or a threat.</li>
<li><strong>Ad ignorantiam</strong> : Argument relying on people’s ignorance.</li>
<li><strong>Ad populum</strong> : Argument relying on sentimental weakness.</li>
<li><strong>Ad verecundiam</strong> : Argument relying on the the words of an “expert”, or authority.</li>
<li><strong>Ex silentio</strong> : Argument relying on ignorance.</li>
<li><strong>Ex nihilo</strong> : An argument that bears no relation to the previous topic of discussion.</li>
<li><strong>Non sequitur</strong> : An inference that does not follow from established premises or evidence.</li>
</ul>
<h3 id="responses">Responses</h3>
<ul>
<li><strong>Akrasia</strong> : State of acting against one’s better judgment.</li>
<li><strong>Connotation</strong> : Emotional association with a word.</li>
<li><strong>Intransigence</strong> : Refusal to change one’s views or to agree about something.</li>
<li><strong>Inferential distance</strong> : Gap between the background knowledge and epistemology of a person trying to explain an idea, and the background knowledge and epistemology of the person trying to understand it.</li>
<li><strong>Straw man</strong> : Creating a false or made up scenario and then attacking it. Painting your opponent with false colors only deflects the purpose of the argument.</li>
<li><strong>Steel man</strong> : To steelman is to address the strongest possible variant or the most charitable interpretation of an idea, rather than the most available phrasings.</li>
<li><strong>Red herring</strong> : A diversion from the active topic.</li>
<li><strong>Rationalization</strong> : Starts from a conclusion, and then works backward to arrive at arguments apparently favouring that conclusion. Rationalization argues for a side already selected.</li>
<li><strong>Dogpiling</strong> : A disagreement wherein one person says something wrong or offensive, and a large number of people comment in response to tell them how wrong they are, and continue to disparage the original commenter beyond any reasonable time limit.</li>
<li><strong>Grandstanding</strong> : An action that is intended to make people notice and admire you, behaving in a way that makes people pay attention to you instead of thinking about more important matters.</li>
<li><strong>Whataboutism</strong> : An attempt to discredit an opponent’s position by charging them with hypocrisy without directly refuting or disproving their argument.</li>
<li><strong>Dissensus</strong> : The deliberate avoidance of consensus.</li>
</ul>
<h3 id="beliefs">Beliefs</h3>
<ul>
<li><p><strong>Belief</strong> : The mental state in which an individual holds a proposition to be true.</p></li>
<li><p><strong>Priors</strong> : The beliefs an agent holds regarding a fact, hypothesis or consequence, before being presented with evidence.</p></li>
<li><p><strong>Alief</strong> : An independent source of emotional reaction which can coexist with a contradictory belief. Example The fear felt when a monster jumps out of the darkness in a scary movie is based on the alief that the monster is about to attack you, even though you believe that it cannot.</p></li>
<li><p><strong>Proper belief</strong> : Requires observations, gets updated upon encountering new evidence, and provides practical benefit in anticipated experience.</p></li>
<li><p><strong>Improper belief</strong> : Is a belief that isn’t concerned with describing the territory. Note that the fact that a belief just happens to be true doesn’t mean you’re right to have it. If you buy a lottery ticket, certain that it’s a winning ticket (for no reason), and it happens to be, believing that was still a mistake.</p></li>
<li><p><strong>Belief in belief</strong> : Where it is difficult to believe a thing, it is often much easier to believe that you ought to believe it. Were you to really believe and not just believe in belief, the consequences of error would be much more severe. When someone makes up excuses in advance, it would seem to require that belief, and belief in belief, have become unsynchronized.</p></li>
<li><p><strong>A Priori</strong> : Knowledge which we can be sure of without any empirical evidence(evidence from our senses). So, knowledge that you could realize if you were just a mind floating in a void unconnected to a body.</p></li>
</ul>
<blockquote>
<p>“A leader is best when people barely know they exists, when their work is done, their aim fulfilled, people will say: we did it ourselves.”</p>
<p>— 老子(Lao Tse), 道德經(Dao De Jing)</p>
</blockquote>
<p>The first principle of Wikipedia etiquette has been said to be <strong>Assume Good Faith</strong>, also they <strong>Be Bold, but not Reckless</strong>.</p>
<p><strong>Wrong discourse</strong></p>
<ul>
<li><p>Answer: Jumping into a conversation with endless unapplicable, unrealistic or unrelated answers to the question.</p></li>
<li><p>Question: Spouting accusations while cowardly hiding behind the claim of just asking questions, and ignoring the answers. Asking loaded questions.</p></li>
</ul>
<p><strong>Good discourse</strong></p>
<ul>
<li><p>Answer: A clear and honest response to the central point of a question without an aggressive attempt to convince.</p></li>
<li><p>Question: question asked with the intention to be fair, open, and honest, regardless of the outcome of the interaction.</p></li>
</ul>
<p>Social rules are expected to be broken from time to time, in that regard they are different from a code of conduct.</p>
<h3 id="response-ranking">Response Ranking</h3>
<ul>
<li>●●●●●● - Central point - Commit to refute explicitly the central point.</li>
<li>●●●●●○ - Refutation - Argue a conflicting passage, explain why it’s mistaken.</li>
<li>●●●●○○ - Counterargument - Contradict with added reasoning or evidence.</li>
<li>●●●○○○ - Contradiction - State the opposing case, what.</li>
<li>●●○○○○ - Responding to Tone - Responding to the author’s tone, how.</li>
<li>●○○○○○ - Ad Hominem - Attacking the author directly, who.</li>
</ul>
<h3 id="interaction-ranking">Interaction Ranking</h3>
<h4 id="discussion">Discussion</h4>
<ul>
<li><p>●●●●● - Release - Initiating a discussion on the lessons learnt from a project.</p></li>
<li><p>●●●●○ - Update - Presenting the recent development of a personal experience, ongoing event or work in progress.</p></li>
<li><p>●●●○○ - Soapbox - Spontaneous and or enthusiastic posts about a general topic of interest or finding.</p></li>
</ul>
<h4 id="low-effort">Low-Effort</h4>
<ul>
<li><p>●●○○○ - Rant- Venting frustration publicly without explicitly looking to have a conversation about the matter.</p></li>
<li><p>●○○○○ - Shitpost - Aggressively or ironically looking for the biggest reaction with the least effort possible. Includes subtoots and vague-posting.</p></li>
</ul>
<h3 id="emotional-reaction">Emotional Reaction</h3>
<ul>
<li><p><strong>Seduction</strong> - You are led to feel that the fulfillment of your dreams depends on your doing what the other is encouraging you to do.</p></li>
<li><p><strong>Alignment</strong> - The interests of the system are presented as fulfilling your emotional needs. You are led to feel that your survival, your viability in society or your very identity depends on your doing what the other is requiring of you.</p></li>
<li><p><strong>Reduction</strong> - Complex subjects are reduced to a single, emotionally charged issue.</p></li>
<li><p><strong>Polarization</strong> - Issues are presented in such a way that you are either right or wrong. You are told that any dialogue between different perspectives is suspect, dangerous or simply not permissible.</p></li>
<li><p><strong>Marginalization</strong> - You are made to feel that your own interests (or interests that run counter to the interests of the other) are inconsequential.</p></li>
<li><p><strong>Framing</strong> - The terms of a debate are set so that issues that threaten the system cannot be articulated or discussed. You are led to ignore aspects of the issue that may be vitally important to your own interests but are contrary to the interests of the other that is seeking to make you act in their interests.</p></li>
</ul>
<h2 id="quotes">Quotes</h2>
<blockquote>
<p>“Kings speak for the realm, governors for the state, popes for the church. Indeed, the titled, as titled, cannot speak <strong>with</strong> annyone.”</p>
<p>— James P. Carse, Finite and Infinite Games</p>
</blockquote>
<blockquote>
<p>“Instead of trying to prove your opponent wrong, try to see in what sense he might be right.” — Robert Nozick, Anarchy, State, and Utopia</p>
</blockquote>
<blockquote>
<p>“I don’t argue: I just say what I know or what I believe, as the case may be.” — John W. Cohan</p>
</blockquote>
<blockquote>
<p>“You should mention anything you have learned from your target.”</p>
</blockquote>
<h2 id="license-1">LICENSE</h2>
<p>The whole page is licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0">cc-by-nc-sa</a>; it is slightly adapted from https://wiki.xxiivv.com/site/discourse.html to be able to support the static site generator used on https://scheme.rs and to avoid the words “bad” (replaced with “wrong”) and “faith” (replaced with “discourse”), a few other changes, see <a href="https://git.sr.ht/~amirouche/scheme.rs/log/main/item/discourse/index.md">history</a> for complete log. # Tutorial</p>
<h2 id="basics">Basics</h2>
<h3 id="continuation">Continuation</h3>
<p>After reading this section you will be able to write basic Scheme programs. In particular, you will study:</p>
<ul>
<li><p>How to comment code</p></li>
<li><p>How to write literals for builtin types</p></li>
<li><p>How to call a procedure</p></li>
<li><p>How to define a variable</p></li>
<li><p>How to compare objects</p></li>
<li><p>How to define a procedure</p></li>
</ul>
<h3 id="how-to-comment-code">How to comment code</h3>
<p>You can comment code with the semi-colon, that is <code>;</code>. Idiomatic code use two semi-colons:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">;; Everything after one semi-colon is a comment.</span></span></code></pre></div>
<p>The following sections will use two semi-colons with followed by an arrow <code>=&gt;</code> to describe the return value.</p>
<h3 id="how-to-write-literals-for-builtin-types">How to write literals for builtin types</h3>
<h4 id="number">number</h4>
<ul>
<li>Integers can be written as usual <code>42</code></li>
<li>Inexact reals can be written as usual <code>3.1415</code></li>
<li>There is more number types. It is called the <a href="https://en.wikipedia.org/wiki/Numerical_tower">Numerical tower</a></li>
</ul>
<h4 id="boolean">boolean</h4>
<ul>
<li>false: <code>#f</code></li>
<li>true: <code>#t</code></li>
</ul>
<h4 id="characters">characters</h4>
<p>Characters can be written with their natural representation prefixed with <code>#\\</code>, for instance the character <code>x</code> is represented in Scheme code as follow:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ch">#\x</span></span></code></pre></div>
<h4 id="string">string</h4>
<p>A string is written with double quotes, that is <code>"</code>, for instance:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;hello world&quot;</span></span></code></pre></div>
<h4 id="symbol">symbol</h4>
<p>A symbol is most of the time written with a simple quote prefix, that is <code>'</code>. For instance:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>&#39;unique</span></code></pre></div>
<h4 id="pair">pair</h4>
<p>A pair of the symbol <code>'pi</code> and the value <code>3.1415</code> can be written as:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>&#39;(pi <span class="op">.</span> <span class="fl">3.1415</span>)</span></code></pre></div>
<h4 id="list">list</h4>
<p>A list can be written as literals separated by one space and enclosed by parenthesis. For instance, the following list has three items:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>&#39;(unique <span class="st">&quot;hello world&quot;</span> (pi <span class="op">.</span> <span class="fl">3.1415</span>))`</span></code></pre></div>
<p>The first item is the symbol <code>'unique</code>, the second item is a string, the third item is a pair.</p>
<p>The empty list is written <code>'()</code>.</p>
<h4 id="vector">vector</h4>
<p>A vector looks somewhat like a list but without the explicit simple quote. It use a hash prefix. For instance, the following vector has three items:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>#(unique <span class="st">&quot;hello world&quot;</span> <span class="dv">42</span>)</span></code></pre></div>
<p>The first item is the symbol <code>'unique</code>, the second item is a string, the third item is a number.</p>
<h4 id="bytevector">bytevector</h4>
<p>A bytevector is like vector but can contain only bytes. It looks like a list of integers, prefixed with <code>#vu8</code>. For instance, the following bytevector has three bytes:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>#vu8(<span class="dv">0</span> <span class="dv">42</span> <span class="dv">255</span>)</span></code></pre></div>
<h3 id="how-to-call-a-procedure">How to call a procedure</h3>
<p>A procedure call looks like a list without the simple quote prefix.</p>
<p>The following describe the addition 21 and 21:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span> <span class="dv">21</span> <span class="dv">21</span>) <span class="co">;; =&gt; 42</span></span></code></pre></div>
<p>It returns <code>42</code>. So does the following multiplication:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">*</span> <span class="dv">21</span> <span class="dv">2</span>) <span class="co">;; =&gt; 42</span></span></code></pre></div>
<p>The first item is a procedure object. Most of the time, procedure names are made of letters separated with dashes. That usually called <code>kebab-case</code>.</p>
<p>Here is another procedure call:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">string-append</span> <span class="st">&quot;hello&quot;</span> <span class="st">&quot; &quot;</span> <span class="st">&quot;world&quot;</span>) <span class="co">;; =&gt; &quot;hello world&quot;</span></span></code></pre></div>
<p>It will return a string <code>"hello world"</code>.</p>
<h3 id="how-to-define-a-variable">How to define a variable</h3>
<p>The first kind of variables that you encountered are procedures, things like <code>+</code>, <code>*</code> or <code>string-append</code>.</p>
<p>Variables can also contain constants. You can use <code>define</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> %thruth </span><span class="dv">42</span>)</span></code></pre></div>
<p>The above code will create a variable called <code>%thruth</code> that contains <code>42</code>.</p>
<p>Look at this very complicated computation:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span> %thruth <span class="dv">1</span> (<span class="op">*</span> <span class="dv">2</span> <span class="dv">647</span>)) <span class="co">;; =&gt; 1337</span></span></code></pre></div>
<h3 id="how-to-compare-objects">How to compare objects</h3>
<h4 id="identity-equivalence">Identity equivalence</h4>
<p>To compare by identity, in pratice, whether two object represent the same memory location, you can use the procedure <code>eq?</code>.</p>
<p>In the case where you are comparing symbols you can use the procedure <code>eq?</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">eq?</span> &#39;unique &#39;unique) <span class="co">;; =&gt; #t</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">eq?</span> &#39;unique &#39;singleton) <span class="co">;; =&gt; #f</span></span></code></pre></div>
<h3 id="equivalence">Equivalence</h3>
<p>If you do not know the type of the compared objects, or the objects can be of different types, you can use the procedure <code>equal?</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">equal?</span> <span class="dv">#t</span> <span class="st">&quot;true&quot;</span>) <span class="co">;; =&gt; #f</span></span></code></pre></div>
<p>The string <code>"true"</code> is not equivalent to the boolean <code>#t</code>.</p>
<p>It is rare to use <code>equal?</code>, because, usually, you know the type of the compared objects and the compared object have the same type.</p>
<h3 id="equivalence-predicates">Equivalence predicates</h3>
<p>The astute reader might have recognized a pattern in the naming of the equivalence procedures <code>eq?</code> and <code>equal?</code>: both end with a question mark. That is a convention that all procedures that can only return a boolean should end with a question mark. Those are called <em>predicates</em>.</p>
<p>They are predicates for every builtin types. For instance string type has a string equivalence predicate written <code>string=?</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">string=?</span> <span class="st">&quot;hello&quot;</span> <span class="st">&quot;hello world&quot;</span> <span class="st">&quot;hello, world!&quot;</span>) <span class="co">;; =&gt; #f</span></span></code></pre></div>
<p>The predicate procedure <code>string=?</code> will return <code>#t</code> if all arguments are the same string, in the sense they contain the same characters.</p>
<h3 id="how-to-define-a-procedure">How to define a procedure</h3>
<p>The simplest procedure ever, is the procedure that takes no argument and returns itself:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(ruse)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  ruse)</span></code></pre></div>
<p>The above is sugar syntax for the following:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> ruse </span>(<span class="kw">lambda</span> () ruse))</span></code></pre></div>
<p>A procedure that takes no arguments is called a <em>thunk</em>. Indentation and the newline are cosmetic conventions. If you call the procedure <code>ruse</code>, it will return <code>ruse</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">eq?</span> ruse (ruse))</span></code></pre></div>
<p>One can define a procedure that adds one as follow:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(add1 number)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  (<span class="op">+</span> number <span class="dv">1</span>))</span></code></pre></div>
<p>The predicate to compare numbers is <code>=</code>. Hence, the following:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">=</span> <span class="dv">2006</span> (add1 <span class="dv">2005</span>)) <span class="co">;; =&gt; #t</span></span></code></pre></div>
<p>Mind the fact that it returns a new number. It does not mutate the value even if it is passed as a variable.</p>
<p>Let’s imagine a procedure that appends a name to the string <code>"Hello"</code>. For instance, given <code>"Aziz"</code> or a variable containing <code>"Aziz"</code>, it will return <code>"Hello Aziz"</code>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> name </span><span class="st">&quot;Aziz&quot;</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(say-hello name)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">string-append</span> <span class="st">&quot;Hello &quot;</span> name))</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>(<span class="kw">string=?</span> <span class="st">&quot;Hello Aziz&quot;</span> (say-hello name)) <span class="co">;; =&gt; #t</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co">;; XXX: the variable name still contains &quot;Aziz&quot;</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>(<span class="kw">string=?</span> name <span class="st">&quot;Aziz&quot;</span>)) <span class="co">;; =&gt; #t</span></span></code></pre></div>
<p>It does not matter for the callee whether the arguments are passed as variables or literals:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">string=?</span> <span class="st">&quot;Hello John&quot;</span>  (say-hello <span class="st">&quot;John&quot;</span>)) <span class="co">;; =&gt; #t</span></span></code></pre></div>
<h3 id="backtrack">Backtrack</h3>
<p>In this section you learned:</p>
<ul>
<li><p>How to comment code using a semi-colon character <code>;</code></p></li>
<li><p>How to write literals for builtin types</p>
<ul>
<li>integer: <code>42</code></li>
<li>float: <code>3.1415</code></li>
<li>symbol: <code>'unique</code></li>
<li>string: <code>"hello world"</code></li>
<li>pair: <code>(pi . 3.1415)</code></li>
<li>list: <code>'(42 "hello world" (pi . 3.1415))</code></li>
<li>vector: <code>#(42 "hello world" (pi . 3.1415))</code></li>
<li>bytevector: <code>#vu8(1 42 255)</code></li>
</ul></li>
<li><p>How to call a procedure <code>(string-append "hello " "Aziz")</code></p></li>
<li><p>How to define a variable <code>(define %thruth 42)</code></p></li>
<li><p>How to compare objects using their type specific predicates. For instance: <code>(string=? "hello" "hello")</code></p></li>
<li><p>How to define a procedure again using <code>define</code> with slightly different syntax <code>(define (add1 number) (+ number 1))</code></p></li>
</ul>
<h2 id="forward">Forward</h2>
<h3 id="continuation-1">Continuation</h3>
<p>After reading this section you will be able to write more complex Scheme code. In particular you will study:</p>
<ul>
<li><p>How to create lexical bindings</p></li>
<li><p>How to set a variable</p></li>
<li><p>How to do a branch <code>if</code></p></li>
<li><p>How to create a new type</p></li>
<li><p>How to write a named-let</p></li>
</ul>
<h3 id="how-to-create-lexical-bindings">How to create lexical bindings</h3>
<p>Lexical bindings can be created with <code>let</code>, <code>let*</code>, <code>letrec</code> and <code>letrec*</code>. They have slightly different behaviors, but the same syntax:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> (&lt;binding&gt; <span class="op">...</span>) &lt;expression&gt; <span class="op">...</span>)</span></code></pre></div>
<p>Where <code>&lt;binding&gt;</code> looks like an association of a variable name with the initial value it is holding. For instance:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> ((a <span class="dv">1</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>      (b <span class="dv">2</span>))</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  (<span class="op">+</span> a b <span class="dv">3</span>)) <span class="co">;; =&gt; 6</span></span></code></pre></div>
<p>The above <code>let</code> form will bind <code>a</code> to <code>1</code>, <code>b</code> to <code>2</code> and return the output of <code>(+ a b 3)</code> that is <code>6</code>.</p>
<h3 id="how-to-set-a-variable">How to set a variable</h3>
<p>To change what a variable holds without overriding it or mutating the object contained in the varialbe, you can use <code>set!</code>. Mind the exclamation mark, it is a convention that forms that have a side-effect ends with a exclamation mark. For instance:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> %thruth </span><span class="dv">42</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">display</span> %truth)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">newline</span>)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>(<span class="kw">set!</span> %thruth <span class="dv">101</span>)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>(<span class="kw">display</span> %truth)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>(<span class="kw">newline</span>)</span></code></pre></div>
<h3 id="how-to-do-a-branch-if">How to do a branch <code>if</code></h3>
<p>Scheme <code>if</code> will consider false, only the object <code>#f</code>. Hence, one can do the following:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">if</span> <span class="dv">#t</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">display</span> <span class="st">&quot;true&quot;</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">display</span> <span class="st">&quot;never executed&quot;</span>))</span></code></pre></div>
<p>Similarly:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">if</span> <span class="dv">#f</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">display</span> <span class="st">&quot;never executed&quot;</span>)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">display</span> <span class="st">&quot;false&quot;</span>))</span></code></pre></div>
<p>In particular, the number zero is true according to scheme <code>if</code>:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">if</span> <span class="dv">0</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">display</span> <span class="st">&quot;zero is true&quot;</span>)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">display</span> <span class="st">&quot;never executed&quot;</span>))</span></code></pre></div>
<p>If you want to check whether a value is zero you can use the predicate <code>zero?</code> like so:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">if</span> (<span class="kw">zero?</span> %thruth)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>   (<span class="kw">display</span> <span class="st">&quot;%thruth is zero&quot;</span>)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>   (<span class="kw">display</span> <span class="st">&quot;%thruth is not zero&quot;</span>))</span></code></pre></div>
<p>Or the less idiomatic predicate <code>=</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">if</span> (<span class="op">=</span> %truth <span class="dv">0</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">display</span> <span class="st">&quot;%thruth is zero&quot;</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">display</span> <span class="st">&quot;%thruth is not zero&quot;</span>))</span></code></pre></div>
<h3 id="how-to-create-a-new-type">How to create a new type</h3>
<p>To create a new type you can use the macro <code>define-record-type</code>. For instance, in a todo list application, we will need an <code>&lt;item&gt;</code> type that can be defined as:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">define-record-type</span> &lt;item&gt;</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  (make-item title body status)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  item?</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>  (title item-title item-title!)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>  (body item-body item-body!)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>  (status item-status item-status!))</span></code></pre></div>
<p>Where:</p>
<ul>
<li><code>&lt;item&gt;</code> is the record name,</li>
<li><code>make-item</code> is the constructor of record instances,</li>
<li><code>item?</code> is the predicate that allows to tell whether an object is a <code>&lt;item&gt;</code> type,</li>
<li><code>title</code>, <code>body</code> and <code>status</code> are fields with their associated getters and setters. Setters ends with an exclamation mark. They will mutate the object. Setters are optional.</li>
</ul>
<p>Here is an example use of the above <code>&lt;item&gt;</code> definition:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> item </span>(make-item <span class="st">&quot;Learn Scheme&quot;</span> <span class="st">&quot;The Scheme programming language is awesome, I should learn it&quot;</span> &#39;todo))</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co">;; To change the status, one can do the following:</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>(item-status! item &#39;wip)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="co">;; to get the title, one can do the following:</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>(<span class="kw">display</span> (item-title item))</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>(<span class="kw">newline</span>)</span></code></pre></div>
<h3 id="how-to-write-a-named-let">How to write a named-let</h3>
<p>A named-let allows to do recursion without going through the ceremony of defining a separate procedure. In pratice, it used in similar contexts such as <code>for</code> or <code>while</code> loop in other languages. Given the procedure <code>(cons item items)</code> that will return a new list with <code>ITEMS</code> as tail and <code>ITEM</code> as first item, study the following code:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> loop ((index <span class="dv">0</span>)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>           (out &#39;())</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (<span class="op">=</span> index <span class="dv">10</span>)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">display</span> out)</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>      (loop (<span class="op">+</span> index <span class="dv">1</span>) (<span class="kw">cons</span> index out))))</span></code></pre></div>
<p>It is equivalent to the following:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(loop index out)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (<span class="op">=</span> index <span class="dv">10</span>)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">display</span> out)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>      (loop (<span class="op">+</span> index <span class="dv">1</span>) (<span class="kw">cons</span> index out))))</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>(loop <span class="dv">0</span> &#39;())</span></code></pre></div>
<p>A named-let, look like a <code>let</code> form that can be used to bind variables prefixed with a name. Here is some pseudo-code that describe the syntax of the named-let form:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> &lt;name&gt; (&lt;binding&gt; <span class="op">...</span>) expression <span class="op">...</span>))</span></code></pre></div>
<p>So <code>&lt;binding&gt;</code> and <code>&lt;expression&gt;</code> are very similar to a <code>let</code>. <code>&lt;name&gt;</code> will be bound to a procedure that takes as many argument as there is <code>&lt;binding&gt;</code> and its body will be <code>&lt;expression&gt; ...</code>. It will be called with the associated objects in <code>&lt;binding&gt; ...</code>. <code>expression</code> can call <code>&lt;name&gt;</code> most likely in tail call position but not necessarly. If the named-let is not tail-recursive, it is also known to be a <em>grow the stack recursive call</em>. Another way to see the named-let is pseudo-code:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> &lt;name&gt; </span>(<span class="kw">lambda</span> &lt;formals&gt; &lt;expression&gt; <span class="op">...</span>))</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>(&lt;name&gt; &lt;arguments&gt; <span class="op">...</span>)</span></code></pre></div>
<p>Where:</p>
<ul>
<li><code>&lt;formals&gt;</code> are the variable names from <code>&lt;binding&gt; ...</code></li>
<li><code>&lt;arguments&gt;</code> are the initial object bound in <code>&lt;binding&gt; ...</code></li>
</ul>
<p>That is all.</p>
<h3 id="backtrack-1">Backtrack</h3>
<ul>
<li><p>How to create lexical bindings with <code>let</code>, <code>let*</code>, <code>letrec</code> and <code>letrec*</code>,</p></li>
<li><p>How to set a variable using <code>(set! %thruth 42)</code>,</p></li>
<li><p>How to do a <code>if</code> with <code>(if %thruth (display "That is true") (display   "That is false"))</code>,</p></li>
<li><p>How to create a new type using <code>define-record-type</code> that can look like:</p></li>
</ul>
<div class="sourceCode" id="cb38"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">define-record-type</span> &lt;record-name&gt;</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  (make-record-name field0 <span class="op">...</span>)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  record-name?</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>  (field0 record-name-field0 record-name-field0!))</span></code></pre></div>
<ul>
<li>How to write a named-let, for instance an infinite loop will look like:</li>
</ul>
<div class="sourceCode" id="cb39"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> loop ((index <span class="dv">0</span>))</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">display</span> index)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  (loop (<span class="op">+</span> index <span class="dv">1</span>)))</span></code></pre></div>
<h2 id="beyond">Beyond</h2>
<h3 id="continuation-2">Continuation</h3>
<p>After reading this section you will be able to create libraries.</p>
<h3 id="backtrack-2">Backtrack</h3>
<h2 id="elements-of-style">Elements of Style</h2>
<!--
- See scheme style guides
- See common lisp style guides
- See clojure style guides
- Better to avoid `eqv?` -->
<h1 id="scheme-fixnum"><code>(scheme fixnum)</code></h1>
<p>This is based on <a href="https://srfi.schemers.org/srfi-143/">SRFI-143</a>.</p>
<p>This library describes arithmetic procedures applicable to a limited range of exact integers only. These procedures are semantically similar to the corresponding generic-arithmetic procedures, but allow more efficient implementations.</p>
<h2 id="fx-width"><code>fx-width</code></h2>
<p>Bound to the value w that specifies the implementation-defined range. (R6RS fixnum-width is a procedure that always returns this value.)</p>
<h2 id="fx-greatest"><code>fx-greatest</code></h2>
<p>Bound to the value 2w-1-1, the largest representable fixnum. (R6RS greatest-fixnum is a procedure that always returns this value.)</p>
<h2 id="fx-least"><code>fx-least</code></h2>
<p>Bound to the value -2w-1, the smallest representable fixnum. (R6RS least-fixnum is a procedure that always returns this value.)</p>
<h2 id="fixnum-obj"><code>(fixnum? obj)</code></h2>
<p>Returns #t if obj is an exact integer within the fixnum range, and #f otherwise.</p>
<h2 id="fx-i-..."><code>(fx=? i ...)</code></h2>
<p>Semantically equivalent to =.</p>
<h2 id="fx-i-...-1"><code>(fx&lt;? i ...)</code></h2>
<p>Semantically equivalent to &lt;.</p>
<h2 id="fx-i-...-2"><code>(fx&gt;? i ...)</code></h2>
<p>Semantically equivalent to &gt;.</p>
<h2 id="fx-i-...-3"><code>(fx&lt;=? i ...)</code></h2>
<p>Semantically equivalent to &lt;=.</p>
<h2 id="fx-i-...-4"><code>(fx&gt;=? i ...)</code></h2>
<p>Semantically equivalent to &gt;=.</p>
<h2 id="fxzero-i"><code>(fxzero? i)</code></h2>
<p>Semantically equivalent to zero?.</p>
<h2 id="fxpositive-i"><code>(fxpositive? i)</code></h2>
<p>Semantically equivalent to positive?.</p>
<h2 id="fxnegative-i"><code>(fxnegative? i)</code></h2>
<p>Semantically equivalent to negative?.</p>
<h2 id="fxodd-i"><code>(fxodd? i)</code></h2>
<p>Semantically equivalent to odd?.</p>
<h2 id="fxeven-i"><code>(fxeven? i)</code></h2>
<p>Semantically equivalent to even?.</p>
<h2 id="fxmax-i-j-..."><code>(fxmax i j ...)</code></h2>
<p>Semantically equivalent to max.</p>
<h2 id="fxmin-i-j-..."><code>(fxmin i j ...)</code></h2>
<p>Semantically equivalent to min.</p>
<h2 id="fx-i-j"><code>(fx+ i j)</code></h2>
<p>Semantically equivalent to +, but accepts exactly two arguments.</p>
<h2 id="fx--i-j"><code>(fx- i j)</code></h2>
<p>Semantically equivalent to -, but accepts exactly two arguments.</p>
<h2 id="fxneg-i"><code>(fxneg i)</code></h2>
<p>Semantically equivalent to -, but accepts exactly one argument.</p>
<h2 id="fx-i-j-1"><code>(fx* i j)</code></h2>
<p>Semantically equivalent to *, but accepts exactly two arguments.</p>
<h2 id="fxquotient-i-j"><code>(fxquotient i j)</code></h2>
<p>Semantically equivalent to quotient.</p>
<h2 id="fxremainder-i-j"><code>(fxremainder i j)</code></h2>
<p>Semantically equivalent to remainder.</p>
<h2 id="fxabs-i"><code>(fxabs i)</code></h2>
<p>Semantically equivalent to abs. In accordance with the fixnum rule, has undefined results when applied to fx-least.</p>
<h2 id="fxsquare-i"><code>(fxsquare i)</code></h2>
<p>Semantically equivalent to square.</p>
<h2 id="fxsqrt-i"><code>(fxsqrt i)</code></h2>
<p>Semantically equivalent to exact-integer-sqrt (not sqrt).</p>
<h2 id="fxcarry-i-j-k"><code>(fx+/carry i j k)</code></h2>
<p>Returns the two fixnum results of the following computation:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let*-values</span> (((s) (<span class="op">+</span> i j k))</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>       ((q r) (balanced/ s (<span class="kw">expt</span> <span class="dv">2</span> fx-width))))</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">values</span> r q))</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fx-/carry</span> i j k)</span></code></pre></div>
<p>Returns the two fixnum results of the following computation:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let*-values</span> (((d) (<span class="op">-</span> i j k))</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>       ((q r) (balanced/ d (<span class="kw">expt</span> <span class="dv">2</span> fx-width))))</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">values</span> r q))</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fx*/carry</span> i j k)</span></code></pre></div>
<p>Returns the two fixnum results of the following computation:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let*-values</span> (((s) (<span class="op">+</span> (<span class="op">*</span> i j) k))</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>       ((q r) (balanced/ s (<span class="kw">expt</span> <span class="dv">2</span> fx-width))))</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">values</span> r q))</span></code></pre></div>
<p>The balanced/ procedure is available in SRFI 141, and also in the R6RS base library under the name of div0-and-mod0. Bitwise operations</p>
<p>The following procedures are the fixnum counterparts of certain bitwise operations from SRFI 151 and the R6RS (rnrs arithmetic fixnums) library. In case of disagreement, SRFI 151 is preferred. The prefixes bitwise- and integer- are dropped for brevity and compatibility.</p>
<h2 id="fxnot-i"><code>(fxnot i)</code></h2>
<p>Semantically equivalent to bitwise-not.</p>
<h2 id="fxand-i-..."><code>(fxand i ...)</code></h2>
<p>Semantically equivalent to bitwise-and.</p>
<h2 id="fxior-i-..."><code>(fxior i ...)</code></h2>
<p>Semantically equivalent to bitwise-ior.</p>
<h2 id="fxxor-i-..."><code>(fxxor i ...)</code></h2>
<p>Semantically equivalent to bitwise-xor.</p>
<h2 id="fxarithmetic-shift-i-count"><code>(fxarithmetic-shift i count)</code></h2>
<p>Semantically equivalent to arithmetic-shift, except that it is an error for the absolute value of count to exceed w-1.</p>
<h2 id="fxarithmetic-shift-left-i-count"><code>(fxarithmetic-shift-left i count)</code></h2>
<p>The same as fxarithmetic-shift except that a negative value of count is an error. This is provided for additional efficiency.</p>
<h2 id="fxarithmetic-shift-right-i-count"><code>(fxarithmetic-shift-right i count)</code></h2>
<p>The same as fxarithmetic-shift except that a non-negative value of count specifies the number of bits to shift right, and a negative value is an error. This is provided for additional efficiency.</p>
<h2 id="fxbit-count-i"><code>(fxbit-count i)</code></h2>
<p>Semantically equivalent to SRFI 151 bit-count.</p>
<h2 id="fxlength-i"><code>(fxlength i)</code></h2>
<p>Semantically equivalent to integer-length.</p>
<h2 id="fxif-mask-i-j"><code>(fxif mask i j)</code></h2>
<p>Semantically equivalent to bitwise-if. It can be implemented as (fxior (fxand mask i) (fxand (fxnot mask) j))).</p>
<h2 id="fxbit-set-index-i"><code>(fxbit-set? index i)</code></h2>
<p>Semantically equivalent to SRFI 151 bit-set?, except that it is an error for index to be larger than or equal to fx-width.</p>
<h2 id="fxcopy-bit-index-i-boolean"><code>(fxcopy-bit index i boolean)</code></h2>
<p>Semantically equivalent to SRFI 151 copy-bit, except that it is an error for index to be larger than or equal to fx-width.</p>
<h2 id="fxfirst-set-bit-i"><code>(fxfirst-set-bit i)</code></h2>
<p>Semantically equivalent to first-set-bit.</p>
<h2 id="fxbit-field-i-start-end"><code>(fxbit-field i start end)</code></h2>
<p>Semantically equivalent to bit-field.</p>
<h2 id="fxbit-field-rotate-i-count-start-end"><code>(fxbit-field-rotate i count start end)</code></h2>
<p>Semantically equivalent to SRFI 151 bit-field-rotate.</p>
<h2 id="fxbit-field-reverse-i-start-end"><code>(fxbit-field-reverse i start end)</code></h2>
<p>Semantically equivalent to bit-field-reverse. # <code>(scheme stream)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-41/">SRFI-41</a>.</p>
<p>Streams, sometimes called lazy lists, are a sequential data structure containing elements computed only on demand. A stream is either null or is a pair with a stream in its cdr. Since elements of a stream are computed only when accessed, streams can be infinite. Once computed, the value of a stream element is cached in case it is needed again.</p>
<p>Streams without memoization were first described by Peter Landin in 1965. Memoization became accepted as an essential feature of streams about a decade later. Today, streams are the signature data type of functional programming languages such as Haskell.</p>
<p>This Scheme Request for Implementation describes two libraries for operating on streams: a canonical set of stream primitives and a set of procedures and syntax derived from those primitives that permits convenient expression of stream operations. They rely on facilities provided by R6RS, including libraries, records, and error reporting. To load both stream libraries, say:</p>
<pre><code>(import (scheme stream))</code></pre>
<h2 id="stream-null"><code>stream-null</code></h2>
<p>Stream-null is a promise that, when forced, is a single object, distinguishable from all other objects, that represents the null stream. Stream-null is immutable and unique.</p>
<h2 id="stream-cons-object-stream"><code>(stream-cons object stream)</code></h2>
<p>Stream-cons is a macro that accepts an object and a stream and creates a newly-allocated stream containing a promise that, when forced, is a stream-pair with the object in its stream-car and the stream in its stream-cdr. Stream-cons must be syntactic, not procedural, because neither object nor stream is evaluated when stream-cons is called. Since stream is not evaluated, when the stream-pair is created, it is not an error to call stream-cons with a stream that is not of type stream; however, doing so will cause an error later when the stream-cdr of the stream-pair is accessed. Once created, a stream-pair is immutable; there is no stream-set-car! or stream-set-cdr! that modifies an existing stream-pair. There is no dotted-pair or improper stream as with lists.</p>
<h2 id="stream-object"><code>(stream? object)</code></h2>
<p>Stream? is a procedure that takes an object and returns #t if the object is a stream and #f otherwise. If object is a stream, stream? does not force its promise. If (stream? obj) is #t, then one of (stream-null? obj) and (stream-pair? obj) will be #t and the other will be #f; if (stream? obj) is #f, both (stream-null? obj) and (stream-pair? obj) will be #f.</p>
<h2 id="stream-null-object"><code>(stream-null? object)</code></h2>
<p>Stream-null? is a procedure that takes an object and returns #t if the object is the distinguished null stream and #f otherwise. If object is a stream, stream-null? must force its promise in order to distinguish stream-null from stream-pair.</p>
<h2 id="stream-pair-object"><code>(stream-pair? object)</code></h2>
<p>Stream-pair? is a procedure that takes an object and returns #t if the object is a stream-pair constructed by stream-cons and #f otherwise. If object is a stream, stream-pair? must force its promise in order to distinguish stream-null from stream-pair.</p>
<h2 id="stream-car-stream"><code>(stream-car stream)</code></h2>
<p>Stream-car is a procedure that takes a stream and returns the object stored in the stream-car of the stream. Stream-car signals an error if the object passed to it is not a stream-pair. Calling stream-car causes the object stored there to be evaluated if it has not yet been; the object’s value is cached in case it is needed again.</p>
<h2 id="stream-cdr-stream">`(stream-cdr stream)</h2>
<p>Stream-cdr is a procedure that takes a stream and returns the stream stored in the stream-cdr of the stream. Stream-cdr signals an error if the object passed to it is not a stream-pair. Calling stream-cdr does not force the promise containing the stream stored in the stream-cdr of the stream.</p>
<h2 id="stream-lambda-args-body"><code>(stream-lambda args body)</code></h2>
<p>Stream-lambda creates a procedure that returns a promise to evaluate the body of the procedure. The last body expression to be evaluated must yield a stream. As with normal lambda, args may be a single variable name, in which case all the formal arguments are collected into a single list, or a list of variable names, which may be null if there are no arguments, proper if there are an exact number of arguments, or dotted if a fixed number of arguments is to be followed by zero or more arguments collected into a list. Body must contain at least one expression, and may contain internal definitions preceding any expressions to be evaluated.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> strm123</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>  (stream-cons <span class="dv">1</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    (stream-cons <span class="dv">2</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>      (stream-cons <span class="dv">3</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>        stream-null))))</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>(stream-car strm123) ⇒ <span class="dv">1</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>(stream-car (stream-cdr strm123) ⇒ <span class="dv">2</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>(stream-pair?</span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>  (stream-cdr</span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>    (stream-cons (<span class="op">/</span> <span class="dv">1</span> <span class="dv">0</span>) stream-null))) ⇒ <span class="dv">#f</span></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>(stream? (<span class="kw">list</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)) ⇒ <span class="dv">#f</span></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> iter</span></span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>  (stream-lambda (f x)</span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a>    (stream-cons x (iter f (f x)))))</span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> nats </span>(iter (<span class="kw">lambda</span> (x) (<span class="op">+</span> x <span class="dv">1</span>)) <span class="dv">0</span>))</span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true" tabindex="-1"></a>(stream-car (stream-cdr nats)) ⇒ <span class="dv">1</span></span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-25"><a href="#cb44-25" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> stream-add</span></span>
<span id="cb44-26"><a href="#cb44-26" aria-hidden="true" tabindex="-1"></a>  (stream-lambda (s1 s2)</span>
<span id="cb44-27"><a href="#cb44-27" aria-hidden="true" tabindex="-1"></a>    (stream-cons</span>
<span id="cb44-28"><a href="#cb44-28" aria-hidden="true" tabindex="-1"></a>      (<span class="op">+</span> (stream-car s1) (stream-car s2))</span>
<span id="cb44-29"><a href="#cb44-29" aria-hidden="true" tabindex="-1"></a>      (stream-add (stream-cdr s1)</span>
<span id="cb44-30"><a href="#cb44-30" aria-hidden="true" tabindex="-1"></a>                  (stream-cdr s2)))))</span>
<span id="cb44-31"><a href="#cb44-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-32"><a href="#cb44-32" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> evens </span>(stream-add nats nats))</span>
<span id="cb44-33"><a href="#cb44-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-34"><a href="#cb44-34" aria-hidden="true" tabindex="-1"></a>(stream-car evens) ⇒ <span class="dv">0</span></span>
<span id="cb44-35"><a href="#cb44-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-36"><a href="#cb44-36" aria-hidden="true" tabindex="-1"></a>(stream-car (stream-cdr evens)) ⇒ <span class="dv">2</span></span>
<span id="cb44-37"><a href="#cb44-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-38"><a href="#cb44-38" aria-hidden="true" tabindex="-1"></a>(stream-car (stream-cdr (stream-cdr evens))) ⇒ <span class="dv">4</span></span></code></pre></div>
<h2 id="define-stream-name-args-body-syntax"><code>(define-stream (name args) body)</code> syntax</h2>
<p>Define-stream creates a procedure that returns a stream, and may appear anywhere a normal define may appear, including as an internal definition, and may have internal definitions of its own, including other define-streams. The defined procedure takes arguments in the same way as stream-lambda. Define-stream is syntactic sugar on stream-lambda; see also stream-let, which is also a sugaring of stream-lambda.</p>
<p>A simple version of stream-map that takes only a single input stream calls itself recursively:</p>
<pre><code>(define-stream (stream-map proc strm)
  (if (stream-null? strm)
      stream-null
      (stream-cons
        (proc (stream-car strm))
        (stream-map proc (stream-cdr strm))))))</code></pre>
<h2 id="list-stream-list-of-objects"><code>(list-&gt;stream list-of-objects)</code></h2>
<p>[α] → {α}</p>
<p>List-&gt;stream takes a list of objects and returns a newly-allocated stream containing in its elements the objects in the list. Since the objects are given in a list, they are evaluated when list-&gt;stream is called, before the stream is created. If the list of objects is null, as in (list-&gt;stream ’()), the null stream is returned. See also stream.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> strm123 </span>(list-&gt;stream &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)))</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="co">; fails with divide-by-zero error</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> s </span>(list-&gt;stream (<span class="kw">list</span> <span class="dv">1</span> (<span class="op">/</span> <span class="dv">1</span> <span class="dv">0</span>) -<span class="dv">1</span>)))</span></code></pre></div>
<h2 id="port-stream-port"><code>(port-&gt;stream [port])</code></h2>
<p>port → {char}</p>
<p>Port-&gt;stream takes a port and returns a newly-allocated stream containing in its elements the characters on the port. If port is not given it defaults to the current input port. The returned stream has finite length and is terminated by stream-null.</p>
<p>It looks like one use of port-&gt;stream would be this:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> s </span><span class="co">;wrong!</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">with-input-from-file</span> filename</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">lambda</span> () (port-&gt;stream))))</span></code></pre></div>
<p>But that fails, because with-input-from-file is eager, and closes the input port prematurely, before the first character is read. To read a file into a stream, say:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>(define-stream (file-&gt;stream filename)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((p (<span class="kw">open-input-file</span> filename)))</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    (stream-let loop ((c (<span class="kw">read-char</span> p)))</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">if</span> (<span class="kw">eof-object?</span> c)</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>          (<span class="kw">begin</span> (<span class="kw">close-input-port</span> p)</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>                 stream-null)</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>          (stream-cons c</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>            (loop (<span class="kw">read-char</span> p)))))))</span></code></pre></div>
<h2 id="stream-object-..."><code>(stream object ...)</code></h2>
<p>Stream is syntax that takes zero or more objects and creates a newly-allocated stream containing in its elements the objects, in order. Since stream is syntactic, the objects are evaluated when they are accessed, not when the stream is created. If no objects are given, as in (stream), the null stream is returned. See also list-&gt;stream.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> strm123 </span>(stream <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>))</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="co">; (/ 1 0) not evaluated when stream is created</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> s </span>(stream <span class="dv">1</span> (<span class="op">/</span> <span class="dv">1</span> <span class="dv">0</span>) -<span class="dv">1</span>))</span></code></pre></div>
<h2 id="stream-list-n-stream"><code>(stream-&gt;list [n] stream)</code></h2>
<p>nat × {α} → [α]</p>
<p>Stream-&gt;list takes a natural number n and a stream and returns a newly-allocated list containing in its elements the first n items in the stream. If the stream has less than n items all the items in the stream will be included in the returned list. If n is not given it defaults to infinity, which means that unless stream is finite stream-&gt;list will never return.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>(stream-&gt;list <span class="dv">10</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>  (stream-map (<span class="kw">lambda</span> (x) (<span class="op">*</span> x x))</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    (stream-from <span class="dv">0</span>)))</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>  ⇒ (<span class="dv">0</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">9</span> <span class="dv">16</span> <span class="dv">25</span> <span class="dv">36</span> <span class="dv">49</span> <span class="dv">64</span> <span class="dv">81</span>)</span></code></pre></div>
<h2 id="stream-append-stream-..."><code>(stream-append stream ...)</code></h2>
<p>{α} … → {α}</p>
<p>Stream-append returns a newly-allocated stream containing in its elements those elements contained in its input streams, in order of input. If any of the input streams is infinite, no elements of any of the succeeding input streams will appear in the output stream; thus, if x is infinite, (stream-append x y) ≡ x. See also stream-concat.</p>
<p>Quicksort can be used to sort a stream, using stream-append to build the output; the sort is lazy; so if only the beginning of the output stream is needed, the end of the stream is never sorted.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>(define-stream (qsort lt? strm)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (stream-null? strm)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>      stream-null</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">let</span> ((x (stream-car strm))</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>            (xs (stream-cdr strm)))</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>        (stream-append</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>          (qsort lt?</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>            (stream-filter</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>              (<span class="kw">lambda</span> (u) (lt? u x))</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>              xs))</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>          (stream x)</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>          (qsort lt?</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>            (stream-filter</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>              (<span class="kw">lambda</span> (u) (<span class="kw">not</span> (lt? u x)))</span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>              xs))))))</span></code></pre></div>
<p>Note also that, when used in tail position as in qsort, stream-append does not suffer the poor performance of append on lists. The list version of append requires re-traversal of all its list arguments except the last each time it is called. But stream-append is different. Each recursive call to stream-append is suspended; when it is later forced, the preceding elements of the result have already been traversed, so tail-recursive loops that produce streams are efficient even when each element is appended to the end of the result stream. This also implies that during traversal of the result only one promise needs to be kept in memory at a time.</p>
<h2 id="stream-concat-stream"><code>(stream-concat stream)</code></h2>
<p>{{α}} … → {α}</p>
<p>Stream-concat takes a stream consisting of one or more streams and returns a newly-allocated stream containing all the elements of the input streams. If any of the streams in the input stream is infinite, any remaining streams in the input stream will never appear in the output stream. See also stream-append.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>(stream-&gt;list</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>  (stream-concat</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    (stream</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>      (stream <span class="dv">1</span> <span class="dv">2</span>) (stream) (stream <span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span>))))</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>  ⇒ (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span>)</span></code></pre></div>
<p>The permutations of a finite stream can be determined by interleaving each element of the stream in all possible positions within each permutation of the other elements of the stream. Interleave returns a stream of streams with x inserted in each possible position of yy:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>(define-stream (interleave x yy)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>  (stream-match yy</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    (() (stream (stream x)))</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    ((y <span class="op">.</span> ys)</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>      (stream-append</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>        (stream (stream-cons x yy))</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>        (stream-map</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>          (<span class="kw">lambda</span> (z) (stream-cons y z))</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>          (interleave x ys))))))</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>(define-stream (perms xs)</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (stream-null? xs)</span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>      (stream (stream))</span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>      (stream-concat</span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>        (stream-map</span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>          (<span class="kw">lambda</span> (ys)</span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>            (interleave (stream-car xs) ys))</span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>          (perms (stream-cdr xs))))))</span></code></pre></div>
<h2 id="stream-constant-object-..."><code>(stream-constant object ...)</code></h2>
<p>α … → {α}</p>
<p>Stream-constant takes one or more objects and returns a newly-allocated stream containing in its elements the objects, repeating the objects in succession forever.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>(stream-constant <span class="dv">1</span>) ⇒ <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="op">...</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>(stream-constant <span class="dv">#t</span> <span class="dv">#f</span>) ⇒ <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="op">...</span></span></code></pre></div>
<h2 id="stream-drop-n-stream-procedure"><code>(stream-drop n stream) procedure</code></h2>
<p>nat × {α} → {α}</p>
<p>Stream-drop returns the suffix of the input stream that starts at the next element after the first n elements. The output stream shares structure with the input stream; thus, promises forced in one instance of the stream are also forced in the other instance of the stream. If the input stream has less than n elements, stream-drop returns the null stream. See also stream-take.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(stream-split n strm)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">values</span> (stream-take n strm)</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>          (stream-drop n strm)))</span></code></pre></div>
<h2 id="stream-drop-while-pred-stream"><code>(stream-drop-while pred? stream)</code></h2>
<p>(α → boolean) × {α} → {α}</p>
<p>Stream-drop-while returns the suffix of the input stream that starts at the first element x for which (pred? x) is #f. The output stream shares structure with the input stream. See also stream-take-while.</p>
<p>Stream-unique creates a new stream that retains only the first of any sub-sequences of repeated elements.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>(define-stream (stream-unique eql? strm)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (stream-null? strm)</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>      stream-null</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>      (stream-cons (stream-car strm)</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>        (stream-unique eql?</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>          (stream-drop-while</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>            (<span class="kw">lambda</span> (x)</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>              (eql? (stream-car strm) x))</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>            strm)))))</span></code></pre></div>
<h2 id="stream-filter-pred-stream"><code>(stream-filter pred? stream)</code></h2>
<p>(α → boolean) × {α} → {α}</p>
<p>Stream-filter returns a newly-allocated stream that contains only those elements x of the input stream for which (pred? x) is non-#f.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>(stream-filter <span class="kw">odd?</span> (stream-from <span class="dv">0</span>))</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>   ⇒ <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">7</span> <span class="dv">9</span> <span class="op">...</span></span></code></pre></div>
<h2 id="stream-fold-proc-base-stream"><code>(stream-fold proc base stream)</code></h2>
<p>(α × β → α) × α × {β} → α</p>
<p>Stream-fold applies a binary procedure to base and the first element of stream to compute a new base, then applies the procedure to the new base and the next element of stream to compute a succeeding base, and so on, accumulating a value that is finally returned as the value of stream-fold when the end of the stream is reached. Stream must be finite, or stream-fold will enter an infinite loop. See also stream-scan, which is similar to stream-fold, but useful for infinite streams. For readers familiar with other functional languages, this is a left-fold; there is no corresponding right-fold, since right-fold relies on finite streams that are fully-evaluated, at which time they may as well be converted to a list.</p>
<p>Stream-fold is often used to summarize a stream in a single value, for instance, to compute the maximum element of a stream.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(stream-maximum lt? strm)</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>  (stream-fold</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">lambda</span> (x y) (<span class="kw">if</span> (lt? x y) y x))</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    (stream-car strm)</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    (stream-cdr strm)))</span></code></pre></div>
<p>Sometimes, it is useful to have stream-fold defined only on non-null streams:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(stream-fold-one proc strm)</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>  (stream-fold proc</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>    (stream-car strm)</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    (stream-cdr strm)))</span></code></pre></div>
<p>Stream-minimum can then be defined as:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(stream-minimum lt? strm)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>  (stream-fold-one</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">lambda</span> (x y) (<span class="kw">if</span> (lt? x y) x y))</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    strm))</span></code></pre></div>
<p>Stream-fold can also be used to build a stream:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>(define-stream (isort lt? strm)</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    (define-stream (insert strm x)</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>      (stream-match strm</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>        (() (stream x))</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>        ((y <span class="op">.</span> ys)</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>          (<span class="kw">if</span> (lt? y x)</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>              (stream-cons y (insert ys x))</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>              (stream-cons x strm)))))</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>    (stream-fold insert stream-null strm))</span></code></pre></div>
<h2 id="stream-for-each-proc-stream-..."><code>(stream-for-each proc stream ...)</code></h2>
<p>(α × β × …) × {α} × {β} …</p>
<p>Stream-for-each applies a procedure element-wise to corresponding elements of the input streams for its side-effects; it returns nothing. Stream-for-each stops as soon as any of its input streams is exhausted.</p>
<p>The following procedure displays the contents of a file:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(display-file filename)</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>  (stream-for-each <span class="kw">display</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    (file-&gt;stream filename)))</span></code></pre></div>
<h2 id="stream-from-first-step"><code>(stream-from first [step])</code></h2>
<p>number × number → {number}</p>
<p>Stream-from creates a newly-allocated stream that contains first as its first element and increments each succeeding element by step. If step is not given it defaults to 1. First and step may be of any numeric type. Stream-from is frequently useful as a generator in stream-of expressions. See also stream-range for a similar procedure that creates finite streams.</p>
<p>Stream-from could be implemented as (stream-iterate (lambda (x) (+ x step)) first).</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> nats </span>(stream-from <span class="dv">0</span>)) ⇒ <span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="op">...</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> odds </span>(stream-from <span class="dv">1</span> <span class="dv">2</span>)) ⇒ <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="op">...</span></span></code></pre></div>
<h2 id="stream-iterate-proc-base"><code>(stream-iterate proc base)</code></h2>
<p>(α → α) × α → {α}</p>
<p>Stream-iterate creates a newly-allocated stream containing base in its first element and applies proc to each element in turn to determine the succeeding element. See also stream-unfold and stream-unfolds.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>(stream-iterate (<span class="kw">lambda</span> (x) (<span class="op">+</span> x <span class="dv">1</span>)) <span class="dv">0</span>)</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>  ⇒ <span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="op">...</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>(stream-iterate (<span class="kw">lambda</span> (x) (<span class="op">*</span> x <span class="dv">2</span>)) <span class="dv">1</span>)</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>  ⇒ <span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span> <span class="dv">8</span> <span class="dv">16</span> <span class="op">...</span></span></code></pre></div>
<p>Given a seed between 0 and 232, exclusive, the following expression creates a stream of pseudo-random integers between 0 and 232, exclusive, beginning with seed, using the method described by Stephen Park and Keith Miller:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>(stream-iterate</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> (x) (<span class="kw">modulo</span> (<span class="op">*</span> x <span class="dv">16807</span>) <span class="dv">2147483647</span>))</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>  seed)</span></code></pre></div>
<p>Successive values of the continued fraction shown below approach the value of the “golden ratio” φ ≈ 1.618:</p>
<p>Continued fraction</p>
<p>The fractions can be calculated by the stream</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>(stream-iterate (<span class="kw">lambda</span> (x) (<span class="op">+</span> <span class="dv">1</span> (<span class="op">/</span> x))) <span class="dv">1</span>)</span></code></pre></div>
<h2 id="stream-length-stream"><code>(stream-length stream)</code></h2>
<p>{α} → nat</p>
<p>Stream-length takes an input stream and returns the number of elements in the stream; it does not evaluate its elements. Stream-length may only be used on finite streams; it enters an infinite loop with infinite streams.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>(stream-length strm123) ⇒ <span class="dv">3</span></span></code></pre></div>
<h2 id="stream-let-tag-var-expr-...-body-syntax"><code>(stream-let tag ((var expr) ...) body)</code> syntax</h2>
<p>Stream-let creates a local scope that binds each variable to the value of its corresponding expression. It additionally binds tag to a procedure which takes the bound variables as arguments and body as its defining expressions, binding the tag with stream-lambda. Tag is in scope within body, and may be called recursively. When the expanded expression defined by the stream-let is evaluated, stream-let evaluates the expressions in its body in an environment containing the newly-bound variables, returning the value of the last expression evaluated, which must yield a stream.</p>
<p>Stream-let provides syntactic sugar on stream-lambda, in the same manner as normal let provides syntactic sugar on normal lambda. However, unlike normal let, the tag is required, not optional, because unnamed stream-let is meaningless.</p>
<p>Stream-member returns the first stream-pair of the input strm with a stream-car x that satisfies (eql? obj x), or the null stream if x is not present in strm.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>(define-stream (stream-member eql? obj strm)</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>  (stream-let loop ((strm strm))</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">cond</span> ((stream-null? strm) strm)</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>          ((eql? obj (stream-car strm)) strm)</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>          (<span class="kw">else</span> (loop (stream-cdr strm))))))</span></code></pre></div>
<h2 id="stream-map-proc-stream-..."><code>(stream-map proc stream ...)</code></h2>
<p>(α × β … → ω) × {α} × {β} … → {ω}</p>
<p>Stream-map applies a procedure element-wise to corresponding elements of the input streams, returning a newly-allocated stream containing elements that are the results of those procedure applications. The output stream has as many elements as the minimum-length input stream, and may be infinite.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(square x) (<span class="op">*</span> x x))</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>(stream-map square (stream <span class="dv">9</span> <span class="dv">3</span>)) ⇒ <span class="dv">81</span> <span class="dv">9</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(sigma f m n)</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>  (stream-fold <span class="op">+</span> <span class="dv">0</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>    (stream-map f (stream-range m (<span class="op">+</span> n <span class="dv">1</span>)))))</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>(sigma square <span class="dv">1</span> <span class="dv">100</span>) ⇒ <span class="dv">338350</span></span></code></pre></div>
<p>In some functional languages, stream-map takes only a single input stream, and stream-zipwith provides a companion function that takes multiple input streams.</p>
<h2 id="stream-match-stream-clause-...-syntax"><code>(stream-match stream clause ...)</code> syntax</h2>
<p>Stream-match provides the syntax of pattern-matching for streams. The input stream is an expression that evaluates to a stream. Clauses are of the form (pattern [fender] expr), consisting of a pattern that matches a stream of a particular shape, an optional fender that must succeed if the pattern is to match, and an expression that is evaluated if the pattern matches. There are four types of patterns:</p>
<ul>
<li>() — Matches the null stream.</li>
<li>(pat0 pat1 …) — Matches a finite stream with length exactly equal to the number of pattern elements.</li>
<li>(pat0 pat1 … . patrest) — Matches an infinite stream, or a finite stream with length at least as great as the number of pattern elements before the literal dot.</li>
<li>pat — Matches an entire stream. Should always appear last in the list of clauses; it’s not an error to appear elsewhere, but subsequent clauses could never match.</li>
</ul>
<p>Each pattern element pati may be either:</p>
<ul>
<li>An identifier — Matches any stream element. Additionally, the value of the stream element is bound to the variable named by the identifier, which is in scope in the fender and expression of the corresponding clause. Each identifier in a single pattern must be unique.</li>
<li>A literal underscore — Matches any stream element, but creates no bindings.</li>
</ul>
<p>The patterns are tested in order, left-to-right, until a matching pattern is found; if fender is present, it must evaluate as non-#f for the match to be successful. Pattern variables are bound in the corresponding fender and expression. Once the matching pattern is found, the corresponding expression is evaluated and returned as the result of the match. An error is signaled if no pattern matches the input stream.</p>
<p>Stream-match is often used to distinguish null streams from non-null streams, binding head and tail:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(len strm)</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>  (stream-match strm</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>    (() <span class="dv">0</span>)</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>    ((head <span class="op">.</span> tail) (<span class="op">+</span> <span class="dv">1</span> (len tail)))))</span></code></pre></div>
<p>Fenders can test the common case where two stream elements must be identical; the else pattern is an identifier bound to the entire stream, not a keyword as in cond.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>(stream-match strm</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>  ((x y <span class="op">.</span> <span class="op">_</span>) (<span class="kw">equal?</span> x y) &#39;ok)</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">else</span> &#39;error))</span></code></pre></div>
<p>A more complex example uses two nested matchers to match two different stream arguments; (stream-merge lt? . strms) stably merges two or more streams ordered by the lt? predicate:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>(define-stream (stream-merge lt? <span class="op">.</span> strms)</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>  (define-stream (merge xx yy)</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>    (stream-match xx (() yy) ((x <span class="op">.</span> xs)</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>      (stream-match yy (() xx) ((y <span class="op">.</span> ys)</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">if</span> (lt? y x)</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>            (stream-cons y (merge xx ys))</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>            (stream-cons x (merge xs yy))))))))</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>  (stream-let loop ((strms strms))</span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">cond</span> ((<span class="kw">null?</span> strms) stream-null)</span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>          ((<span class="kw">null?</span> (<span class="kw">cdr</span> strms)) (<span class="kw">car</span> strms))</span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>          (<span class="kw">else</span> (merge (<span class="kw">car</span> strms)</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>                       (apply stream-merge lt?</span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>                         (<span class="kw">cdr</span> strms)))))))</span></code></pre></div>
<h2 id="stream-of-expr-clause-...-syntax"><code>(stream-of expr clause ...)</code> syntax</h2>
<p>Stream-of provides the syntax of stream comprehensions, which generate streams by means of looping expressions. The result is a stream of objects of the type returned by expr. There are four types of clauses:</p>
<ul>
<li>(var in stream-expr) — Loop over the elements of stream-expr, in order from the start of the stream, binding each element of the stream in turn to var. Stream-from and stream-range are frequently useful as generators for stream-expr.</li>
<li>(var is expr) — Bind var to the value obtained by evaluating expr.</li>
<li>(pred? expr) — Include in the output stream only those elements x for which (pred? x) is non-#f.</li>
</ul>
<p>The scope of variables bound in the stream comprehension is the clauses to the right of the binding clause (but not the binding clause itself) plus the result expression.</p>
<p>When two or more generators are present, the loops are processed as if they are nested from left to right; that is, the rightmost generator varies fastest. A consequence of this is that only the first generator may be infinite and all subsequent generators must be finite. If no generators are present, the result of a stream comprehension is a stream containing the result expression; thus, (stream-of 1) produces a finite stream containing only the element 1.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>(stream-of (<span class="op">*</span> x x)</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>  (x in (stream-range <span class="dv">0</span> <span class="dv">10</span>))</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">even?</span> x))</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>  ⇒ <span class="dv">0</span> <span class="dv">4</span> <span class="dv">16</span> <span class="dv">36</span> <span class="dv">64</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>(stream-of (<span class="kw">list</span> a b)</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>  (a in (stream-range <span class="dv">1</span> <span class="dv">4</span>))</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>  (b in (stream-range <span class="dv">1</span> <span class="dv">3</span>)))</span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>  ⇒ (<span class="dv">1</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">2</span>) (<span class="dv">2</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">2</span>) (<span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">3</span> <span class="dv">2</span>)</span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>(stream-of (<span class="kw">list</span> i j)</span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>  (i in (stream-range <span class="dv">1</span> <span class="dv">5</span>))</span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>  (j in (stream-range (<span class="op">+</span> i <span class="dv">1</span>) <span class="dv">5</span>)))</span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a>  ⇒ (<span class="dv">1</span> <span class="dv">2</span>) (<span class="dv">1</span> <span class="dv">3</span>) (<span class="dv">1</span> <span class="dv">4</span>) (<span class="dv">2</span> <span class="dv">3</span>) (<span class="dv">2</span> <span class="dv">4</span>) (<span class="dv">3</span> <span class="dv">4</span>)</span></code></pre></div>
<h2 id="stream-range-first-past-step"><code>(stream-range first past [step])</code></h2>
<p>number × number × number → {number}</p>
<p>Stream-range creates a newly-allocated stream that contains first as its first element and increments each succeeding element by step. The stream is finite and ends before past, which is not an element of the stream. If step is not given it defaults to 1 if first is less than past and -1 otherwise. First, past and step may be of any numeric type. Stream-range is frequently useful as a generator in stream-of expressions. See also stream-from for a similar procedure that creates infinite streams.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>(stream-range <span class="dv">0</span> <span class="dv">10</span>) ⇒ <span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">9</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>(stream-range <span class="dv">0</span> <span class="dv">10</span> <span class="dv">2</span>) → <span class="dv">0</span> <span class="dv">2</span> <span class="dv">4</span> <span class="dv">6</span> <span class="dv">8</span></span></code></pre></div>
<p>Successive elements of the stream are calculated by adding step to first, so if any of first, past or step are inexact, the length of the output stream may differ from (ceiling (- (/ (- past first) step) 1).</p>
<h2 id="stream-ref-stream-n"><code>(stream-ref stream n)</code></h2>
<p>{α} × nat → α</p>
<p>Stream-ref returns the nth element of stream, counting from zero. An error is signaled if n is greater than or equal to the length of stream.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(fact n)</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>  (stream-ref</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>    (stream-scan <span class="op">*</span> <span class="dv">1</span> (stream-from <span class="dv">1</span>))</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>    n))</span></code></pre></div>
<h2 id="stream-reverse-stream"><code>(stream-reverse stream)</code></h2>
<p>{α} → {α}</p>
<p>Stream-reverse returns a newly-allocated stream containing the elements of the input stream but in reverse order. Stream-reverse may only be used with finite streams; it enters an infinite loop with infinite streams. Stream-reverse does not force evaluation of the elements of the stream.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> (<span class="ex">define</span><span class="fu"> s </span>(stream <span class="dv">1</span> (<span class="op">/</span> <span class="dv">1</span> <span class="dv">0</span>) -<span class="dv">1</span>))</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> (<span class="ex">define</span><span class="fu"> r </span>(stream-reverse s))</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> (stream-ref r <span class="dv">0</span>)</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> (stream-ref r <span class="dv">2</span>)</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> (stream-ref r <span class="dv">1</span>)</span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>error: division by zero</span></code></pre></div>
<h2 id="stream-scan-proc-base-stream"><code>(stream-scan proc base stream)</code></h2>
<p>(α × β → α) × α × {β} → {α}</p>
<p>Stream-scan accumulates the partial folds of an input stream into a newly-allocated output stream. The output stream is the base followed by (stream-fold proc base (stream-take i stream)) for each of the first i elements of stream.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>(stream-scan <span class="op">+</span> <span class="dv">0</span> (stream-from <span class="dv">1</span>))</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>  ⇒ (stream <span class="dv">0</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">6</span> <span class="dv">10</span> <span class="dv">15</span> <span class="op">...</span>)</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>(stream-scan <span class="op">*</span> <span class="dv">1</span> (stream-from <span class="dv">1</span>))</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>  ⇒ (stream <span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">6</span> <span class="dv">24</span> <span class="dv">120</span> <span class="op">...</span>)</span></code></pre></div>
<h2 id="stream-take-n-stream"><code>(stream-take n stream)</code></h2>
<p>nat × {α} → {α}</p>
<p>Stream-take takes a non-negative integer n and a stream and returns a newly-allocated stream containing the first n elements of the input stream. If the input stream has less than n elements, so does the output stream. See also stream-drop.</p>
<p>Mergesort splits a stream into two equal-length pieces, sorts them recursively and merges the results:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>(define-stream (msort lt? strm)</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let*</span> ((n (<span class="kw">quotient</span> (stream-length strm) <span class="dv">2</span>))</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>         (ts (stream-take n strm))</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>         (ds (stream-drop n strm)))</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">if</span> (<span class="kw">zero?</span> n)</span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>        strm</span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>        (stream-merge lt?</span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>          (msort <span class="op">&lt;</span> ts) (msort <span class="op">&lt;</span> ds)))))</span></code></pre></div>
<h2 id="stream-take-while-pred-stream"><code>(stream-take-while pred? stream)</code></h2>
<p>(α → boolean) × {α} → {α}</p>
<p>Stream-take-while takes a predicate and a stream and returns a newly-allocated stream containing those elements x that form the maximal prefix of the input stream for which (pred? x) is non-#f. See also stream-drop-while.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>(stream-car</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>  (stream-reverse</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>    (stream-take-while</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">lambda</span> (x) (<span class="op">&lt;</span> x <span class="dv">1000</span>))</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>        primes))) ⇒ <span class="dv">997</span></span></code></pre></div>
<h2 id="stream-unfold-map-pred-gen-base"><code>(stream-unfold map pred? gen base)</code></h2>
<p>(α → β) × (α → boolean) × (α → α) × α → {β}</p>
<p>Stream-unfold is the fundamental recursive stream constructor. It constructs a stream by repeatedly applying gen to successive values of base, in the manner of stream-iterate, then applying map to each of the values so generated, appending each of the mapped values to the output stream as long as (pred? base) is non-#f. See also stream-iterate and stream-unfolds.</p>
<p>The expression below creates the finite stream 0 1 4 9 16 25 36 49 64 81. Initially the base is 0, which is less than 10, so map squares the base and the mapped value becomes the first element of the output stream. Then gen increments the base by 1, so it becomes 1; this is less than 10, so map squares the new base and 1 becomes the second element of the output stream. And so on, until the base becomes 10, when pred? stops the recursion and stream-null ends the output stream.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>(stream-unfold</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> (x) (<span class="kw">expt</span> x <span class="dv">2</span>)) <span class="co">; map</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> (x) (<span class="op">&lt;</span> x <span class="dv">10</span>))   <span class="co">; pred?</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> (x) (<span class="op">+</span> x <span class="dv">1</span>))    <span class="co">; gen</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>  <span class="dv">0</span>)                      <span class="co">; base</span></span></code></pre></div>
<h2 id="stream-unfolds-proc-seed"><code>(stream-unfolds proc seed)</code></h2>
<p>(α → (values α × β …)) × α → (values {β} …)</p>
<p>Stream-unfolds returns n newly-allocated streams containing those elements produced by successive calls to the generator proc, which takes the current seed as its argument and returns n+1 values</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>(proc seed → seed result0 <span class="op">...</span> resultn-1</span></code></pre></div>
<p>where the returned seed is the input seed to the next call to the generator and resulti indicates how to produce the next element of the ith result stream:</p>
<ul>
<li>(value) — value is the next car of the result stream</li>
<li>#f — no value produced by this iteration of the generator proc for the result stream</li>
<li>() — the end of the result stream</li>
</ul>
<p>It may require multiple calls of proc to produce the next element of any particular result stream. See also stream-iterate and stream-unfold.</p>
<p>Stream-unfolds is especially useful when writing expressions that return multiple streams. For instance, (stream-partition pred? strm) is equivalent to</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">values</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>  (stream-filter pred? strm)</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>  (stream-filter</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">lambda</span> (x) (<span class="kw">not</span> (pred? x))) strm))</span></code></pre></div>
<p>but only tests pred? once for each element of strm.</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(stream-partition pred? strm)</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>  (stream-unfolds</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">lambda</span> (s)</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">if</span> (stream-null? s)</span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>          (<span class="kw">values</span> s &#39;() &#39;())</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>          (<span class="kw">let</span> ((a (stream-car s))</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>                (d (stream-cdr s)))</span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>            (<span class="kw">if</span> (pred? a)</span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a>                (<span class="kw">values</span> d (<span class="kw">list</span> a) <span class="dv">#f</span>)</span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a>                (<span class="kw">values</span> d <span class="dv">#f</span> (<span class="kw">list</span> a))))))</span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a>    strm))</span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-13"><a href="#cb83-13" aria-hidden="true" tabindex="-1"></a>(<span class="kw">call-with-values</span></span>
<span id="cb83-14"><a href="#cb83-14" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> ()</span>
<span id="cb83-15"><a href="#cb83-15" aria-hidden="true" tabindex="-1"></a>    (stream-partition <span class="kw">odd?</span></span>
<span id="cb83-16"><a href="#cb83-16" aria-hidden="true" tabindex="-1"></a>      (stream-range <span class="dv">1</span> <span class="dv">6</span>)))</span>
<span id="cb83-17"><a href="#cb83-17" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> (odds evens)</span>
<span id="cb83-18"><a href="#cb83-18" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">list</span> (stream-&gt;list odds)</span>
<span id="cb83-19"><a href="#cb83-19" aria-hidden="true" tabindex="-1"></a>          (stream-&gt;list evens))))</span>
<span id="cb83-20"><a href="#cb83-20" aria-hidden="true" tabindex="-1"></a>  ⇒ ((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span>) (<span class="dv">2</span> <span class="dv">4</span>))</span></code></pre></div>
<h2 id="stream-zip-stream-..."><code>(stream-zip stream ...)</code></h2>
<p>{α} × {β} × … → {[α β …]}</p>
<p>Stream-zip takes one or more input streams and returns a newly-allocated stream in which each element is a list (not a stream) of the corresponding elements of the input streams. The output stream is as long as the shortest input stream, if any of the input streams is finite, or is infinite if all the input streams are infinite.</p>
<p>A common use of stream-zip is to add an index to a stream, as in (stream-finds eql? obj strm), which returns all the zero-based indices in strm at which obj appears; (stream-find eql? obj strm) returns the first such index, or #f if obj is not in strm.</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>(define-stream (stream-finds eql? obj strm)</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>  (stream-of (<span class="kw">car</span> x)</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>    (x in (stream-zip (stream-from <span class="dv">0</span>) strm))</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>    (eql? obj (<span class="kw">cadr</span> x))))</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(stream-find eql? obj strm)</span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>  (stream-car</span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>    (stream-append</span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>      (stream-finds eql? obj strm)</span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>      (stream <span class="dv">#f</span>))))</span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a>(stream-find <span class="kw">char=?</span> <span class="ch">#\l</span></span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a>  (list-&gt;stream</span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">string-&gt;list</span> <span class="st">&quot;hello&quot;</span>))) ⇒ <span class="dv">2</span></span>
<span id="cb84-15"><a href="#cb84-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-16"><a href="#cb84-16" aria-hidden="true" tabindex="-1"></a>(stream-find <span class="kw">char=?</span> <span class="ch">#\l</span></span>
<span id="cb84-17"><a href="#cb84-17" aria-hidden="true" tabindex="-1"></a>  (list-&gt;stream</span>
<span id="cb84-18"><a href="#cb84-18" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">string-&gt;list</span> <span class="st">&quot;goodbye&quot;</span>))) ⇒ <span class="dv">#f</span></span></code></pre></div>
<p>Stream-find is not as inefficient as it looks; although it calls stream-finds, which finds all matching indices, the matches are computed lazily, and only the first match is needed for stream-find. # <code>(scheme comparator)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-128/">SRFI-128</a>.</p>
<p>A comparator is an object of a disjoint type. It is a bundle of procedures that are useful for comparing two objects either for equality or for ordering. There are four procedures in the bundle:</p>
<ul>
<li><p>The type test predicate returns #t if its argument has the correct type to be passed as an argument to the other three procedures, and #f otherwise.</p></li>
<li><p>The equality predicate returns #t if the two objects are the same in the sense of the comparator, and #f otherwise. It is the programmer’s responsibility to ensure that it is reflexive, symmetric, transitive, and can handle any arguments that satisfy the type test predicate.</p></li>
<li><p>The comparison procedure returns -1, 0, or 1 if the first object precedes the second, is equal to the second, or follows the second, respectively, in a total order defined by the comparator. It is the programmer’s responsibility to ensure that it is reflexive, weakly antisymmetric, transitive, can handle any arguments that satisfy the type test predicate, and returns 0 iff the equality predicate returns #t.</p></li>
<li><p>The hash function takes one argument, and returns an exact non-negative integer. It is the programmer’s responsibility to ensure that it can handle any argument that satisfies the type test predicate, and that it returns the same value on two objects if the equality predicate says they are the same (but not necessarily the converse).</p></li>
</ul>
<p>It is also the programmer’s responsibility to ensure that all four procedures provide the same result whenever they are applied to the same object(s) (in the sense of eqv?), unless the object(s) have been mutated since the last invocation. In particular, they must not depend in any way on memory addresses in implementations where the garbage collector can move objects in memory.</p>
<p>B&gt; Limitations: The comparator objects defined in this library are not B&gt; applicable to circular structure or to NaNs or objects containing B&gt; them. Attempts to pass any such objects to any procedure defined B&gt; here, or to any procedure that is part of a comparator defined B&gt; here, is an error except as otherwise noted.</p>
<h2 id="comparator-obj"><code>(comparator? obj)</code></h2>
<p>Returns #t if obj is a comparator, and #f otherwise.</p>
<h2 id="comparator-comparison-procedure-comparator"><code>(comparator-comparison-procedure? comparator)</code></h2>
<p>Returns #t if comparator has a supplied comparison procedure, and #f otherwise.</p>
<h2 id="comparator-hash-function-comparator"><code>(comparator-hash-function? comparator)</code></h2>
<p>Returns #t if comparator has a supplied hash function, and #f otherwise.</p>
<h2 id="boolean-comparator"><code>boolean-comparator</code></h2>
<p>Compares booleans using the total order #f &lt; #t.</p>
<h2 id="char-comparator"><code>char-comparator</code></h2>
<p>Compares characters using the total order implied by char&lt;?. On R6RS and R7RS systems, this is Unicode codepoint order.</p>
<h2 id="char-ci-comparator"><code>char-ci-comparator</code></h2>
<p>Compares characters using the total order implied by char-ci&lt;? On R6RS and R7RS systems, this is Unicode codepoint order after the characters have been folded to lower case.</p>
<h2 id="string-comparator"><code>string-comparator</code></h2>
<p>Compares strings using the total order implied by string&lt;?. Note that this order is implementation-dependent.</p>
<h2 id="string-ci-comparator"><code>string-ci-comparator</code></h2>
<p>Compares strings using the total order implied by string-ci&lt;?. Note that this order is implementation-dependent.</p>
<h2 id="symbol-comparator"><code>symbol-comparator</code></h2>
<p>Compares symbols using the total order implied by applying symbol-&gt;string to the symbols and comparing them using the total order implied by string&lt;?. It is not a requirement that the hash function of symbol-comparator be consistent with the hash function of string-comparator, however.</p>
<h2 id="exact-integer-comparator"><code>exact-integer-comparator</code></h2>
<h2 id="integer-comparator"><code>integer-comparator</code></h2>
<h2 id="rational-comparator"><code>rational-comparator</code></h2>
<h2 id="real-comparator"><code>real-comparator</code></h2>
<h2 id="complex-comparator"><code>complex-comparator</code></h2>
<h2 id="number-comparator"><code>number-comparator</code></h2>
<p>These comparators compare exact integers, integers, rational numbers, real numbers, complex numbers, and any numbers using the total order implied by &lt;. They must be compatible with the R5RS numerical tower in the following sense: If S is a subtype of the numerical type T and the two objects are members of S , then the equality predicate and comparison procedures (but not necessarily the hash function) of S-comparator and T-comparator compute the same results on those objects.</p>
<p>Since non-real numbers cannot be compared with &lt;, the following least-surprising ordering is defined: If the real parts are &lt; or &gt;, so are the numbers; otherwise, the numbers are ordered by their imaginary parts. This can still produce surprising results if one real part is exact and the other is inexact.</p>
<h2 id="pair-comparator"><code>pair-comparator</code></h2>
<p>This comparator compares pairs using default-comparator (see below) on their cars. If the cars are not equal, that value is returned. If they are equal, default-comparator is used on their cdrs and that value is returned.</p>
<h2 id="list-comparator"><code>list-comparator</code></h2>
<p>This comparator compares lists lexicographically, as follows:</p>
<ul>
<li><p>The empty list compares equal to itself.</p></li>
<li><p>The empty list compares less than any non-empty list.</p></li>
<li><p>Two non-empty lists are compared by comparing their cars. If the cars are not equal when compared using default-comparator (see below), then the result is the result of that comparison. Otherwise, the cdrs are compared using list-comparator.</p></li>
</ul>
<h2 id="vector-comparator"><code>vector-comparator</code></h2>
<h2 id="bytevector-comparator"><code>bytevector-comparator</code></h2>
<p>These comparators compare vectors and bytevectors by comparing their lengths. A shorter argument is always less than a longer one. If the lengths are equal, then each element is compared in turn using default-comparator (see below) until a pair of unequal elements is found, in which case the result is the result of that comparison. If all elements are equal, the arguments are equal.</p>
<p>If the implementation does not support bytevectors, bytevector-comparator has a type testing procedure that always returns #f.</p>
<h2 id="default-comparator"><code>default-comparator</code></h2>
<p>This is a comparator that accepts any two Scheme values (with the exceptions listed in the Limitations section) and orders them in some implementation-defined way, subject to the following conditions:</p>
<ul>
<li><p>The following ordering between types must hold: the empty list precedes pairs, which precede booleans, which precede characters, which precede strings, which precede symbols, which precede numbers, which precede vectors, which precede bytevectors, which precede all other objects.</p></li>
<li><p>When applied to pairs, booleans, characters, strings, symbols, numbers, vectors, or bytevectors, its behavior must be the same as pair-comparator, boolean-comparator, character-comparator, string-comparator, symbol-comparator, number-comparator, vector-comparator, and bytevector-comparator respectively. The same should be true when applied to an object or objects of a type for which a standard comparator is defined elsewhere.</p></li>
<li><p>Given disjoint types a and b, one of three conditions must hold:</p>
<ul>
<li><p>All objects of type a compare less than all objects of type b.</p></li>
<li><p>All objects of type a compare greater than all objects of type b.</p></li>
<li><p>All objects of either type a or type b compare equal to each other. This is not permitted for any of the standard types mentioned above.</p></li>
</ul></li>
</ul>
<h2 id="make-comparator-type-test-equality-compare-hash"><code>(make-comparator type-test equality compare hash)</code></h2>
<p>Returns a comparator which bundles the type-test, equality, compare, and hash procedures provided. As a convenience, the following additional values are accepted:</p>
<ul>
<li><p>If type-test is #t, a type-test procedure that accepts any arguments is provided.</p></li>
<li><p>If equality is #t, an equality predicate is provided that returns #t iff compare returns 0.</p></li>
<li><p>If compare or hash is #f, a procedure is provided that signals an error on application. The predicates comparator-comparison-procedure? and/or comparator-hash-function?, respectively, will return #f in these cases.</p></li>
</ul>
<h2 id="make-inexact-real-comparator-epsilon-rounding-nan-handling"><code>(make-inexact-real-comparator epsilon rounding nan-handling)</code></h2>
<p>Returns a comparator that compares inexact real numbers including NaNs as follows: if after rounding to the nearest epsilon they are the same, they compare equal; otherwise they compare as specified by &lt;. The direction of rounding is specified by the rounding argument, which is either a procedure accepting two arguments (the number and epsilon, or else one of the symbols floor, ceiling, truncate, or round.</p>
<p>The argument nan-handling specifies how to compare NaN arguments to non-NaN arguments. If it is a procedure, the procedure is invoked on the other argument if either argument is a NaN. If it is the symbol min, NaN values precede all other values; if it is the symbol max, they follow all other values, and if it is the symbol error, an error is signaled if a NaN value is compared. If both arguments are NaNs, however, they always compare as equal.</p>
<h2 id="make-list-comparator-element-comparator"><code>(make-list-comparator element-comparator)</code></h2>
<h2 id="make-vector-comparator-element-comparator"><code>(make-vector-comparator element-comparator)</code></h2>
<h2 id="make-bytevector-comparator-element-comparator"><code>(make-bytevector-comparator element-comparator)</code></h2>
<p>These procedures return comparators which compare two lists, vectors, or bytevectors in the same way as list-comparator, vector-comparator, and bytevector-comparator respectively, but using element-comparator rather than default-comparator.</p>
<p>If the implementation does not support bytevectors, the result of invoking make-bytevector-comparator is a comparator whose type testing procedure always returns #f.</p>
<h2 id="make-listwise-comparator-type-test-element-comparator-empty-head-tail"><code>(make-listwise-comparator type-test element-comparator empty? head tail)</code></h2>
<p>Returns a comparator which compares two objects that satisfy type-test as if they were lists, using the empty? procedure to determine if an object is empty, and the head and tail procedures to access particular elements.</p>
<h2 id="make-vectorwise-comparator-type-test-element-comparator-length-ref"><code>(make-vectorwise-comparator type-test element-comparator length ref)</code></h2>
<p>Returns a comparator which compares two objects that satisfy type-test as if they were vectors, using the length procedure to determine the length of the object, and the ref procedure to access a particular element.</p>
<h2 id="make-car-comparator-comparator"><code>(make-car-comparator comparator)</code></h2>
<p>Returns a comparator that compares pairs on their cars alone using comparator.</p>
<h2 id="make-cdr-comparator-comparator"><code>(make-cdr-comparator comparator)</code></h2>
<p>Returns a comparator that compares pairs on their cdrs alone using comparator.</p>
<h2 id="make-pair-comparator-car-comparator-cdr-comparator"><code>(make-pair-comparator car-comparator cdr-comparator)</code></h2>
<p>Returns a comparator that compares pairs first on their cars using car-comparator. If the cars are equal, it compares the cdrs using cdr-comparator.</p>
<h2 id="make-improper-list-comparator-element-comparator"><code>(make-improper-list-comparator element-comparator)</code></h2>
<p>Returns a comparator that compares arbitrary objects as follows: the empty list precedes all pairs, which precede all other objects. Pairs are compared as if with (make-pair-comparator element-comparator element-comparator). All other objects are compared using element-comparator.</p>
<h2 id="make-selecting-comparator-comparator1-comparator2-..."><code>(make-selecting-comparator comparator1 comparator2 ...)</code></h2>
<p>Returns a comparator whose procedures make use of the comparators as follows:</p>
<p>The type test predicate passes its argument to the type test predicates of comparators in the sequence given. If any of them returns #t, so does the type test predicate; otherwise, it returns #f.</p>
<p>The arguments of the equality, compare, and hash functions are passed to the type test predicate of each comparator in sequence. The first comparator whose type test predicate is satisfied on all the arguments is used when comparing those arguments. All other comparators are ignored. If no type test predicate is satisfied, an error is signaled.</p>
<h2 id="make-refining-comparator-comparator1-comparator2-..."><code>(make-refining-comparator comparator1 comparator2 ...)</code></h2>
<p>Returns a comparator that makes use of the comparators in the same way as make-selecting-comparator, except that its procedures can look past the first comparator whose type test predicate is satisfied. If the comparison procedure of that comparator returns zero, then the next comparator whose type test predicate is satisfied is tried in place of it until one returns a non-zero value. If there are no more such comparators, then the comparison procedure returns zero. The equality predicate is defined in the same way. If no type test predicate is satisfied, an error is signaled.</p>
<p>The hash function of the result returns a value which depends, in an implementation-defined way, on the results of invoking the hash functions of the comparators whose type test predicates are satisfied on its argument. In particular, it may depend solely on the first or last such hash function. If no type test predicate is satisfied, an error is signaled.</p>
<p>This procedure is analogous to the expression type refine-compare from SRFI 67.</p>
<h2 id="make-reverse-comparator-comparator"><code>(make-reverse-comparator comparator)</code></h2>
<p>Returns a comparator that behaves like comparator, except that the compare procedure returns 1, 0, and -1 instead of -1, 0, and 1 respectively. This allows ordering in reverse.</p>
<h2 id="make-debug-comparator-comparator"><code>(make-debug-comparator comparator)</code></h2>
<p>Returns a comparator that behaves exactly like comparator, except that whenever any of its procedures are invoked, it verifies all the programmer responsibilities (except stability), and an error is signaled if any of them are violated. Because it requires three arguments, transitivity is not tested on the first call to a debug comparator; it is tested on all future calls using an arbitrarily chosen argument from the previous invocation. Note that this may cause unexpected storage leaks.</p>
<h2 id="eq-comparator"><code>eq-comparator</code></h2>
<h2 id="eqv-comparator"><code>eqv-comparator</code></h2>
<h2 id="equal-comparator"><code>equal-comparator</code></h2>
<p>The equality predicates of these comparators are eq?, eqv?, and equal? respectively. When their comparison procedures are applied to non-equal objects, their behavior is implementation-defined. The type test predicates always return #t.</p>
<p>These comparators accept circular structure (in the case of equal-comparator, provided the implementation’s equal does so) and NaNs.</p>
<h2 id="comparator-type-test-procedure-comparator"><code>(comparator-type-test-procedure comparator)</code></h2>
<p>Returns the type test predicate of comparator.</p>
<h2 id="comparator-equality-predicate-comparator"><code>(comparator-equality-predicate comparator)</code></h2>
<p>Returns the equality predicate of comparator.</p>
<h2 id="comparator-comparison-procedure-comparator-1"><code>(comparator-comparison-procedure comparator)</code></h2>
<p>Returns the comparison procedure of comparator.</p>
<h2 id="comparator-hash-function-comparator-1"><code>(comparator-hash-function comparator)</code></h2>
<p>Returns the hash function of comparator.</p>
<h2 id="comparator-test-type-comparator-obj"><code>(comparator-test-type comparator obj)</code></h2>
<p>Invokes the type test predicate of comparator on obj and returns what it returns.</p>
<h2 id="comparator-check-type-comparator-obj"><code>(comparator-check-type comparator obj)</code></h2>
<p>Invokes the type test predicate of comparator on obj and returns true if it returns true and signals an error otherwise.</p>
<h2 id="comparator-equal-comparator-obj1-obj2"><code>(comparator-equal? comparator obj1 obj2)</code></h2>
<p>Invokes the equality predicate of comparator on obj1 and obj2 and returns what it returns.</p>
<h2 id="comparator-compare-comparator-obj1-obj2"><code>(comparator-compare comparator obj1 obj2)</code></h2>
<p>Invokes the comparison procedure of comparator on obj1 and obj2 and returns what it returns.</p>
<h2 id="comparator-hash-comparator-obj"><code>(comparator-hash comparator obj)</code></h2>
<p>Invokes the hash function of comparator on obj and returns what it returns.</p>
<h2 id="make-comparison-lt-pred"><code>(make-comparison&lt; lt-pred)</code></h2>
<h2 id="make-comparison-gt-pred"><code>(make-comparison&gt; gt-pred)</code></h2>
<h2 id="make-comparison-le-pred"><code>(make-comparison&lt;= le-pred)</code></h2>
<h2 id="make-comparison-ge-pred"><code>(make-comparison&gt;= ge-pred)</code></h2>
<h2 id="make-comparison-eq-pred-lt-pred"><code>(make-comparison=/&lt; eq-pred lt-pred)</code></h2>
<h2 id="make-comparison-eq-pred-gt-pred"><code>(make-comparison=/&gt; eq-pred gt-pred)</code></h2>
<p>These procedures return a comparison procedure, given a less-than predicate, a greater-than predicate, a less-than-or-equal-to predicate, a greater-than-or-equal-to predicate, or the combination of an equality predicate and either a less-than or a greater-than predicate.</p>
<h2 id="if3-expr-less-equal-greater"><code>(if3 &lt;expr&gt; &lt;less&gt; &lt;equal&gt; &lt;greater&gt;)</code></h2>
<p>The expression <code>&lt;expr&gt;</code> is evaluated; it will typically, but not necessarily, be a call on a comparison procedure. If the result is -1, <code>&lt;less&gt;</code> is evaluated and its value(s) are returned; if the result is 0, <code>&lt;equal&gt;</code> is evaluated and its value(s) are returned; if the result is 1, <code>&lt;greater&gt;</code> is evaluated and its value(s) are returned. Otherwise an error is signaled.</p>
<h2 id="if-expr-consequent-alternate"><code>(if=? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h2>
<h2 id="if-expr-consequent-alternate-1"><code>(if&lt;? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h2>
<h2 id="if-expr-consequent-alternate-2"><code>(if&gt;? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h2>
<h2 id="if-expr-consequent-alternate-3"><code>(if&lt;=? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h2>
<h2 id="if-expr-consequent-alternate-4"><code>(if&gt;=? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h2>
<h2 id="if-not-expr-consequent-alternate"><code>(if-not=? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h2>
<p>The expression <code>&lt;expr&gt;</code> is evaluated; it will typically, but not necessarily, be a call on a comparison procedure. It is an error if its value is not -1, 0, or 1. If the value is consistent with the specified relation, <code>&lt;consequent&gt;</code> is evaluated and its value(s) are returned. Otherwise, if <code>&lt;alternate&gt;</code> is present, it is evaluated and its value(s) are returned; if it is absent, an unspecified value is returned.</p>
<h2 id="comparator-object1-object2-object3-..."><code>(=? comparator object1 object2 object3 ...)</code></h2>
<h2 id="comparator-object1-object2-object3-...-1"><code>(&lt;? comparator object1 object2 object3 ...)</code></h2>
<h2 id="comparator-object1-object2-object3-...-2"><code>(&gt;? comparator object1 object2 object3 ...)</code></h2>
<h2 id="comparator-object1-object2-object3-...-3"><code>(&lt;=? comparator object1 object2 object3 ...)</code></h2>
<h2 id="comparator-object1-object2-object3-...-4"><code>(&gt;=? comparator object1 object2 object3 ...)</code></h2>
<p>These procedures are analogous to the number, character, and string comparison predicates of Scheme. They allow the convenient use of comparators in situations where the expression types are not usable. They are also analogous to the similarly named procedures SRFI 67, but handle arbitrary numbers of arguments, which in SRFI 67 requires the use of the variants whose names begin with chain.</p>
<p>These procedures apply the comparison procedure of comparator to the objects as follows. If the specified relation returns #t for all objecti and objectj where n is the number of objects and 1 &lt;= i &lt; j &lt;= n, then the procedures return #t, but otherwise #f.</p>
<p>The order in which the values are compared is unspecified. Because the relations are transitive, it suffices to compare each object with its successor.</p>
<h2 id="make-comparator"><code>(make=? comparator)</code></h2>
<h2 id="make-comparator-1"><code>(make&lt;? comparator)</code></h2>
<h2 id="make-comparator-2"><code>(make&gt;? comparator)</code></h2>
<h2 id="make-comparator-3"><code>(make&lt;=? comparator)</code></h2>
<h2 id="make-comparator-4"><code>(make&gt;=? comparator)</code></h2>
<p>These procedures return predicates which, when applied to two or more arguments, return #t if comparing obj1 and obj2 using the equality or comparison procedures of comparator shows that the objects bear the specified relation to one another. Such predicates can be used in contexts that do not understand or expect comparators.</p>
<h2 id="in-open-interval-comparator-obj1-obj2-obj3"><code>(in-open-interval? [comparator] obj1 obj2 obj3)</code></h2>
<p>Return #t if obj1 is less than obj2, which is less thanobj3, and #f otherwise.</p>
<h2 id="in-closed-interval-comparator-obj1-obj2-obj3"><code>(in-closed-interval? [comparator] obj1 obj2 obj3)</code></h2>
<p>Returns #t if obj1 is less than or equal to obj2, which is less than or equal to obj3, and #f otherwise.</p>
<h2 id="in-open-closed-interval-comparator-obj1-obj2-obj3"><code>(in-open-closed-interval? [comparator] obj1 obj2 obj3)</code></h2>
<p>Returns #t if obj1 is less than obj2, which is less than or equal to obj3, and #f otherwise.</p>
<h2 id="in-closed-open-interval-comparator-obj1-obj2-obj3"><code>(in-closed-open-interval? [comparator] obj1 obj2 obj3)</code></h2>
<p>Returns #t if obj1 is less than or equal to obj2, which is less than obj3, and #f otherwise.</p>
<h2 id="comparator-min-comparator-object1-object2-..."><code>(comparator-min comparator object1 object2 ...)</code></h2>
<h2 id="comparator-max-comparator-object1-object2-..."><code>(comparator-max comparator object1 object2 ...)</code></h2>
<p>These procedures are analogous to min and max respectively. They apply the comparison procedure of comparator to the objects to find and return a minimal (or maximal) object. The order in which the values are compared is unspecified. # <code>(scheme set)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-113/">SRFI-113</a>.</p>
<p>Sets and bags (also known as multisets) are unordered collections that can contain any Scheme object. Sets enforce the constraint that no two elements can be the same in the sense of the set’s associated equality predicate; bags do not.</p>
<h2 id="set-comparator-element-..."><code>(set comparator element ... )</code></h2>
<p>Returns a newly allocated empty set. The comparator argument is a SRFI 114 comparator, which is used to control and distinguish the elements of the set. The elements are used to initialize the set.</p>
<h2 id="set-unfold-comparator-stop-mapper-successor-seed"><code>(set-unfold comparator stop? mapper successor seed)</code></h2>
<p>Create a newly allocated set as if by set using comparator. If the result of applying the predicate stop? to seed is true, return the set. Otherwise, apply the procedure mapper to seed. The value that mapper returns is added to the set. Then get a new seed by applying the procedure successor to seed, and repeat this algorithm. Predicates</p>
<h2 id="set-obj"><code>(set? obj)</code></h2>
<p>Returns #t if obj is a set, and #f otherwise.</p>
<h2 id="set-contains-set-element"><code>(set-contains? set element)</code></h2>
<p>Returns #t if element is a member of set and #f otherwise.</p>
<h2 id="set-empty-set"><code>(set-empty? set)</code></h2>
<p>Returns #t if set has no elements and #f otherwise.</p>
<h2 id="set-disjoint-set1-set2"><code>(set-disjoint? set1 set2)</code></h2>
<p>Returns #t if set1 and set2 have no elements in common and #f otherwise.</p>
<h2 id="set-member-set-element-default"><code>(set-member set element default)</code></h2>
<p>Returns the element of set that is equal, in the sense of set’s equality predicate, to element. If element is not a member of set, default is returned.</p>
<h2 id="set-element-comparator-set"><code>(set-element-comparator set)</code></h2>
<p>Returns the comparator used to compare the elements of set.</p>
<h2 id="set-adjoin-set-element-..."><code>(set-adjoin set element ...)</code></h2>
<p>The set-adjoin procedure returns a newly allocated set that uses the same comparator as set and contains all the values of set, and in addition each element unless it is already equal (in the sense of the comparator) to one of the existing or newly added members. It is an error to add an element to set that does not return #t when passed to the type test procedure of the comparator.</p>
<h2 id="set-adjoin-set-element-...-1"><code>(set-adjoin! set element ...)</code></h2>
<p>The set-adjoin! procedure is the same as set-adjoin, except that it is permitted to mutate and return the set argument rather than allocating a new set.</p>
<h2 id="set-replace-set-element"><code>(set-replace set element)</code></h2>
<p>The set-replace procedure returns a newly allocated set that uses the same comparator as set and contains all the values of set except as follows: If element is equal (in the sense of set’s comparator) to an existing member of set, then that member is omitted and replaced by element. If there is no such element in set, then set is returned unchanged.</p>
<h2 id="set-replace-set-element-1"><code>(set-replace! set element)</code></h2>
<p>The set-replace! procedure is the same asset-replace, except that it is permitted to mutate and return the set argument rather than allocating a new set.</p>
<h2 id="set-delete-set-element-..."><code>(set-delete set element ...)</code></h2>
<h2 id="set-delete-set-element-...-1"><code>(set-delete! set element ...)</code></h2>
<h2 id="set-delete-all-set-element-list"><code>(set-delete-all set element-list)</code></h2>
<h2 id="set-delete-all-set-element-list-1"><code>(set-delete-all! set element-list)</code></h2>
<p>The set-delete procedure returns a newly allocated set containing all the values of set except for any that are equal (in the sense of set’s comparator) to one or more of the elements. Any element that is not equal to some member of the set is ignored.</p>
<p>The set-delete! procedure is the same as set-delete, except that it is permitted to mutate and return the set argument rather than allocating a new set.</p>
<p>The set-delete-all and set-delete-all! procedures are the same as set-delete and set-delete!, except that they accept a single argument which is a list of elements to be deleted.</p>
<h2 id="set-search-set-element-failure-success"><code>(set-search! set element failure success)</code></h2>
<p>The set is searched for element. If it is not found, then the failure procedure is tail-called with two continuation arguments, insert and ignore, and is expected to tail-call one of them. If element is found, then the success procedure is tail-called with the matching element of set and two continuations, update and remove, and is expected to tail-call one of them.</p>
<p>The effects of the continuations are as follows (where obj is any Scheme object):</p>
<ul>
<li><p>Invoking (insert obj) causes element to be inserted into set.</p></li>
<li><p>Invoking (ignore obj) causes set to remain unchanged.</p></li>
<li><p>Invoking (update new-element obj) causes new-element to be inserted into set in place of element.</p></li>
<li><p>Invoking (remove obj) causes the matching element of set to be removed from it.</p></li>
</ul>
<p>In all cases, two values are returned: the possibly updated set and obj.</p>
<h2 id="set-size-set"><code>(set-size set)</code></h2>
<p>Returns the number of elements in set as an exact integer.</p>
<h2 id="set-find-predicate-set-failure"><code>(set-find predicate set failure)</code></h2>
<p>Returns an arbitrarily chosen element of set that satisfies predicate, or the result of invoking failure with no arguments if there is none.</p>
<h2 id="set-count-predicate-set"><code>(set-count predicate set)</code></h2>
<p>Returns the number of elements of set that satisfy predicate as an exact integer.</p>
<h2 id="set-any-predicate-set"><code>(set-any? predicate set)</code></h2>
<p>Returns #t if any element of set satisfies predicate, or #f otherwise. Note that this differs from the SRFI 1 analogue because it does not return an element of the set.</p>
<h2 id="set-every-predicate-set"><code>(set-every? predicate set)</code></h2>
<p>Returns #t if every element of set satisfies predicate, or #f otherwise. Note that this differs from the SRFI 1 analogue because it does not return an element of the set.</p>
<h2 id="set-map-comparator-proc-set"><code>(set-map comparator proc set)</code></h2>
<p>Applies proc to each element of set in arbitrary order and returns a newly allocated set, created as if by (set comparator), which contains the results of the applications. For example:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>        (set-map string-ci-comparator <span class="kw">symbol-&gt;string</span> (set <span class="kw">eq?</span> &#39;foo &#39;bar &#39;baz))</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>             <span class="op">=&gt;</span> (set string-ci-comparator <span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span> <span class="st">&quot;baz&quot;</span>)</span></code></pre></div>
<p>Note that, when proc defines a mapping that is not 1:1, some of the mapped objects may be equivalent in the sense of comparator’s equality predicate, and in this case duplicate elements are omitted as in the set constructor. For example:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>(set-map (<span class="kw">lambda</span> (x) (<span class="kw">quotient</span> x <span class="dv">2</span>))</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>         integer-comparator</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>         (set integer-comparator <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>))</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a> <span class="op">=&gt;</span> (set integer-comparator <span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span>)</span></code></pre></div>
<p>If the elements are the same in the sense of eqv?, it is unpredictable which one will be preserved in the result.</p>
<h2 id="set-for-each-proc-set"><code>(set-for-each proc set)</code></h2>
<p>Applies proc to set in arbitrary order, discarding the returned values. Returns an unspecified result.</p>
<h2 id="set-fold-proc-nil-set"><code>(set-fold proc nil set)</code></h2>
<p>Invokes proc on each member of set in arbitrary order, passing the result of the previous invocation as a second argument. For the first invocation, nil is used as the second argument. Returns the result of the last invocation, or nil if there was no invocation.</p>
<h2 id="set-filter-predicate-set"><code>(set-filter predicate set)</code></h2>
<p>Returns a newly allocated set with the same comparator as set, containing just the elements of set that satisfy predicate.</p>
<h2 id="set-filter-predicate-set-1"><code>(set-filter! predicate set)</code></h2>
<p>A linear update procedure that returns a set containing just the elements of set that satisfy predicate.</p>
<h2 id="set-remove-predicate-set"><code>(set-remove predicate set)</code></h2>
<p>Returns a newly allocated set with the same comparator as set, containing just the elements of set that do not satisfy predicate.</p>
<h2 id="set-remove-predicate-set-1"><code>(set-remove! predicate set)</code></h2>
<p>A linear update procedure that returns a set containing just the elements of set that do not satisfy predicate.</p>
<h2 id="set-partition-predicate-set"><code>(set-partition predicate set)</code></h2>
<p>Returns two values: a newly allocated set with the same comparator as set that contains just the elements of set that satisfy predicate, and another newly allocated set, also with the same comparator, that contains just the elements of set that do not satisfy predicate.</p>
<h2 id="set-partition-predicate-set-1"><code>(set-partition! predicate set)</code></h2>
<p>A linear update procedure that returns two sets containing the elements of set that do and do not, respectively, not satisfy predicate.</p>
<h2 id="set-copy-set"><code>(set-copy set)</code></h2>
<p>Returns a newly allocated set containing the elements of set, and using the same comparator.</p>
<h2 id="set-list-set"><code>(set-&gt;list set)</code></h2>
<p>Returns a newly allocated list containing the members of set in unspecified order.</p>
<h2 id="list-set-comparator-list"><code>(list-&gt;set comparator list)</code></h2>
<p>Returns a newly allocated set, created as if by set using comparator, that contains the elements of list. Duplicate elements (in the sense of the equality predicate) are omitted.</p>
<h2 id="list-set-set-list"><code>(list-&gt;set! set list)</code></h2>
<p>Returns a set that contains the elements of both set and list. Duplicate elements (in the sense of the equality predicate) are omitted.</p>
<h2 id="set-set1-set2-..."><code>(set=? set1 set2 ...)</code></h2>
<p>Returns #t if each set contains the same elements.</p>
<h2 id="set-set1-set2-...-1"><code>(set&lt;? set1 set2 ...)</code></h2>
<p>Returns #t if each set other than the last is a proper subset of the following set, and #f otherwise.</p>
<h2 id="set-set1-set2-...-2"><code>(set&gt;? set1 set2 ...)</code></h2>
<p>Returns #t if each set other than the last is a proper superset of the following set, and #f otherwise.</p>
<h2 id="set-set1-set2-...-3"><code>(set&lt;=? set1 set2 ...)</code></h2>
<p>Returns #t if each set other than the last is a subset of the following set, and #f otherwise.</p>
<h2 id="set-set1-set2-...-4"><code>(set&gt;=? set1 set2 ...)</code></h2>
<p>Returns #t if each set other than the last is a superset of the following set, and #f otherwise.</p>
<h2 id="set-union-set1-set2-..."><code>(set-union set1 set2 ...)</code></h2>
<h2 id="set-intersection-set1-set2-..."><code>(set-intersection set1 set2 ...)</code></h2>
<h2 id="set-difference-set1-set2-..."><code>(set-difference set1 set2 ...)</code></h2>
<h2 id="set-xor-set1-set2"><code>(set-xor set1 set2)</code></h2>
<p>Return a newly allocated set that is the union, intersection, asymmetric difference, or symmetric difference of the sets. Asymmetric difference is extended to more than two sets by taking the difference between the first set and the union of the others. Symmetric difference is not extended beyond two sets. Elements in the result set are drawn from the first set in which they appear.</p>
<h2 id="set-union-set1-set2-...-1"><code>(set-union! set1 set2 ...)</code></h2>
<h2 id="set-intersection-set1-set2-...-1"><code>(set-intersection! set1 set2 ...)</code></h2>
<h2 id="set-difference-set1-set2-...-1"><code>(set-difference! set1 set2 ...)</code></h2>
<h2 id="set-xor-set1-set2-1"><code>(set-xor! set1 set2)</code></h2>
<p>Linear update procedures returning a set that is the union, intersection, asymmetric difference, or symmetric difference of the sets. Asymmetric difference is extended to more than two sets by taking the difference between the first set and the union of the others. Symmetric difference is not extended beyond two sets. Elements in the result set are drawn from the first set in which they appear.</p>
<h2 id="bag-comparator-element-..."><code>(bag comparator element ...)</code></h2>
<h2 id="bag-unfold-..."><code>(bag-unfold ...)</code></h2>
<h2 id="bag-obj"><code>(bag? obj)</code></h2>
<h2 id="bag-contains-..."><code>(bag-contains? ...)</code></h2>
<h2 id="bag-empty-obj">(bag-empty? obj)`</h2>
<h2 id="bag-disjoint">(bag-disjoint? …)</h2>
<h2 id="bag-member-..."><code>(bag-member ...)</code></h2>
<h2 id="bag-element-comparator">`(bag-element-comparator …)</h2>
<h2 id="bag-adjoin-..."><code>(bag-adjoin ...)</code></h2>
<h2 id="bag-adjoin-...-1"><code>(bag-adjoin! ...)</code></h2>
<h2 id="bag-replace-..."><code>(bag-replace ...)</code></h2>
<h2 id="bag-replace-...-1"><code>(bag-replace! ...)</code></h2>
<h2 id="bag-delete-..."><code>(bag-delete ...)</code></h2>
<h2 id="bag-delete-...-1"><code>(bag-delete! ...)</code></h2>
<h2 id="bag-delete-all-..."><code>(bag-delete-all ...)</code></h2>
<h2 id="bag-delete-all-...-1"><code>(bag-delete-all! ...)</code></h2>
<h2 id="bag-search-..."><code>(bag-search! ...)</code></h2>
<h2 id="bag-size-..."><code>(bag-size ...)</code></h2>
<h2 id="bag-find-..."><code>(bag-find ...)</code></h2>
<h2 id="bag-count-..."><code>(bag-count ...)</code></h2>
<h2 id="bag-any-..."><code>(bag-any? ...)</code></h2>
<h2 id="bag-every-..."><code>(bag-every? ...)</code></h2>
<h2 id="bag-map-..."><code>(bag-map ...)</code></h2>
<h2 id="bag-for-each-..."><code>(bag-for-each ...)</code></h2>
<h2 id="bag-fold-..."><code>(bag-fold ...)</code></h2>
<h2 id="bag-filter-..."><code>(bag-filter ...)</code></h2>
<h2 id="bag-remove-..."><code>(bag-remove ...)</code></h2>
<h2 id="bag-partition-..."><code>(bag-partition ...)</code></h2>
<h2 id="bag-filter-...-1"><code>(bag-filter! ...)</code></h2>
<h2 id="bag-remove-...-1"><code>(bag-remove! ...)</code></h2>
<h2 id="bag-partition-...-1"><code>(bag-partition! ...)</code></h2>
<h2 id="bag-copy-..."><code>(bag-copy ...)</code></h2>
<h2 id="bag-list-..."><code>(bag-&gt;list ...)</code></h2>
<h2 id="list-bag-..."><code>(list-&gt;bag ...)</code></h2>
<h2 id="list-bag-...-1"><code>(list-&gt;bag! ...)</code></h2>
<h2 id="bag-..."><code>(bag=? ...)</code></h2>
<h2 id="bag-...-1"><code>(bag&lt;? ...)</code></h2>
<h2 id="bag-...-2"><code>(bag&gt;? ...)</code></h2>
<h2 id="bag-...-3"><code>(bag&lt;=? ...)</code></h2>
<h2 id="bag-...-4"><code>(bag&gt;=? ...)</code></h2>
<h2 id="bag-union-..."><code>(bag-union ...)</code></h2>
<h2 id="bag-intersection-..."><code>(bag-intersection ...)</code></h2>
<h2 id="bag-difference-..."><code>(bag-difference ...)</code></h2>
<h2 id="bag-xor-..."><code>(bag-xor ...)</code></h2>
<h2 id="bag-union-...-1"><code>(bag-union! ...)</code></h2>
<h2 id="bag-intersection-...-1"><code>(bag-intersection! ...)</code></h2>
<h2 id="bag-difference-...-1"><code>(bag-difference! ...)</code></h2>
<h2 id="bag-xor-...-1"><code>(bag-xor! ...)</code></h2>
<h2 id="bag-sum-set1-set2-..."><code>(bag-sum set1 set2 ... )</code></h2>
<h2 id="bag-sum-bag1-bag2-..."><code>(bag-sum! bag1 bag2 ... )</code></h2>
<p>The bag-sum procedure returns a newly allocated bag containing all the unique elements in all the bags, such that the count of each unique element in the result is equal to the sum of the counts of that element in the arguments. It differs from bag-union by treating identical elements as potentially distinct rather than attempting to match them up.</p>
<p>The bag-sum! procedure is equivalent except that it is linear-update.</p>
<h2 id="bag-product-n-bag"><code>(bag-product n bag)</code></h2>
<h2 id="bag-product-n-bag-1"><code>(bag-product! n bag)</code></h2>
<p>The bag-product procedure returns a newly allocated bag containing all the unique elements in bag, where the count of each unique element in the bag is equal to the count of that element in bag multiplied by n.</p>
<p>The bag-product! procedure is equivalent except that it is linear-update.</p>
<h2 id="bag-unique-size-bag"><code>(bag-unique-size bag)</code></h2>
<p>Returns the number of unique elements of bag.</p>
<h2 id="bag-element-count-bag-element"><code>(bag-element-count bag element)</code></h2>
<p>Returns an exact integer representing the number of times that element appears in bag.</p>
<h2 id="bag-for-each-unique-proc-bag"><code>(bag-for-each-unique proc bag)</code></h2>
<p>Applies proc to each unique element of bag in arbitrary order, passing the element and the number of times it occurs in bag, and discarding the returned values. Returns an unspecified result.</p>
<h2 id="bag-fold-unique-proc-nil-bag"><code>(bag-fold-unique proc nil bag)</code></h2>
<p>Invokes proc on each unique element of bag in arbitrary order, passing the number of occurrences as a second argument and the result of the previous invocation as a third argument. For the first invocation, nil is used as the third argument. Returns the result of the last invocation.</p>
<h2 id="bag-increment-bag-element-count"><code>(bag-increment! bag element count)</code></h2>
<h2 id="bag-decrement-bag-element-count"><code>(bag-decrement! bag element count)</code></h2>
<p>Linear update procedures that return a bag with the same elements as bag, but with the element count of element in bag increased or decreased by the exact integer count (but not less than zero).</p>
<h2 id="bag-set-bag"><code>(bag-&gt;set bag)</code></h2>
<h2 id="set-bag-set"><code>(set-&gt;bag set)</code></h2>
<h2 id="set-bag-bag-set"><code>(set-&gt;bag! bag set)</code></h2>
<p>The bag-&gt;set procedure returns a newly allocated set containing the unique elements (in the sense of the equality predicate) of bag. The set-&gt;bag procedure returns a newly allocated bag containing the elements of set. The set-&gt;bag! procedure returns a bag containing the elements of both bag and set. In all cases, the comparator of the result is the same as the comparator of the argument or arguments.</p>
<h2 id="bag-alist-bag"><code>(bag-&gt;alist bag)</code></h2>
<h2 id="alist-bag-comparator-alist"><code>(alist-&gt;bag comparator alist)</code></h2>
<p>The bag-&gt;alist procedure returns a newly allocated alist whose keys are the unique elements of bag and whose values are the number of occurrences of each element. The alist-&gt;bag returning a newly allocated bag based on comparator, where the keys of alist specify the elements and the corresponding values of alist specify how many times they occur. Comparators</p>
<h2 id="set-comparator"><code>set-comparator</code></h2>
<h2 id="bag-comparator"><code>bag-comparator</code></h2>
<p>Note that these comparators do not provide comparison procedures, as there is no ordering between sets or bags. It is an error to compare sets or bags with different element comparators. # <code>(scheme complex)</code></p>
<h2 id="angle"><code>angle</code></h2>
<p>TODO</p>
<h2 id="imag-part"><code>imag-part</code></h2>
<p>TODO</p>
<h2 id="magnitude"><code>magnitude</code></h2>
<p>TODO</p>
<h2 id="make-polar"><code>make-polar</code></h2>
<p>TODO</p>
<h2 id="make-rectangular"><code>make-rectangular</code></h2>
<p>TODO</p>
<h2 id="real-part"><code>real-part</code></h2>
<p>TODO # <code>(scheme division)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-141/">SRFI-141</a>.</p>
<p>This SRFI provides a fairly complete set of integral division and remainder operators.</p>
<h2 id="floor-numerator-denominator"><code>(floor/ numerator denominator)</code></h2>
<h2 id="floor-quotient-numerator-denominator"><code>(floor-quotient numerator denominator)</code></h2>
<h2 id="floor-remainder-numerator-denominator"><code>(floor-remainder numerator denominator)</code></h2>
<blockquote>
<p>q = floor(n/d)</p>
</blockquote>
<p>Thus r is negative iff d is negative.</p>
<h2 id="ceiling-numerator-denominator"><code>(ceiling/ numerator denominator)</code></h2>
<h2 id="ceiling-quotient-numerator-denominator"><code>(ceiling-quotient numerator denominator)</code></h2>
<h2 id="ceiling-remainder-numerator-denominator"><code>(ceiling-remainder numerator denominator)</code></h2>
<blockquote>
<p>q = ceiling(n/d)</p>
</blockquote>
<p>Thus r is negative iff d is non-negative.</p>
<p>If denominator is the number of units in a block, and <numerator> is some number of units, then (ceiling-quotient numerator denominator) gives the number of blocks needed to cover numerator units. For example, denominator might be the number of bytes in a disk sector, and numerator the number of bytes in a file; then the quotient is the number of disk sectors needed to store the contents of the file. For another example, denominator might be the number of octets in the output of a cryptographic hash function, and numerator the number of octets desired in a key for a symmetric cipher, to be derived using the cryptographic hash function; then the quotient is the number of hash values needed to concatenate to make a key.</p>
<h2 id="truncate-numerator-denominator"><code>(truncate/ numerator denominator)</code></h2>
<h2 id="truncate-quotient-numerator-denominator"><code>(truncate-quotient numerator denominator)</code></h2>
<h2 id="truncate-remainder-numerator-denominator"><code>(truncate-remainder numerator denominator)</code></h2>
<blockquote>
<p>q = truncate(n/d)</p>
</blockquote>
<p>Thus r is negative iff n is negative. However, by any non-unit denominator, the quotient of +1, 0, or -1 is 0; that is, three contiguous numerators by a common denominator share a common quotient. Of the other division operator pairs, only the round pair exhibits this property.</p>
<h2 id="round-numerator-denominator"><code>(round/ numerator denominator)</code></h2>
<h2 id="round-quotient-numerator-denominator"><code>(round-quotient numerator denominator)</code></h2>
<h2 id="round-remainder-numerator-denominator"><code>(round-remainder numerator denominator)</code></h2>
<blockquote>
<p>q = round(n/d)</p>
</blockquote>
<p>The round function rounds to the nearest integer, breaking ties by choosing the nearest even integer. Nothing general can be said about the sign of r. Like the truncate operator pair, the quotient of +1, 0, or -1 by any non-unit denominator is 0, so that three contiguous numerators by a common denominator share a common quotient.</p>
<h2 id="euclidean-numerator-denominator"><code>(euclidean/ numerator denominator)</code></h2>
<h2 id="euclidean-quotient-numerator-denominator"><code>(euclidean-quotient numerator denominator)</code></h2>
<h2 id="euclidean-remainder-numerator-denominator"><code>(euclidean-remainder numerator denominator)</code></h2>
<p>If d &gt; 0, q = floor(n/d); if d &lt; 0, q = ceiling(n/d).</p>
<p>This division operator pair satisfies the stronger property</p>
<blockquote>
<p>0 &lt;= r &lt; |d|,</p>
</blockquote>
<p>used often in mathematics. Thus, for example, (euclidean-remainder numerator denominator) is always a valid index into a vector whose length is at least the absolute value of denominator. This division operator pair is so named because it is the subject of the Euclidean division algorithm.</p>
<h2 id="balanced-numerator-denominator"><code>(balanced/ numerator denominator)</code></h2>
<h2 id="balanced-quotient-numerator-denominator"><code>(balanced-quotient numerator denominator)</code></h2>
<h2 id="balanced-remainder-numerator-denominator"><code>(balanced-remainder numerator denominator)</code></h2>
<p>This division operator pair satisfies the property</p>
<blockquote>
<p>-|d/2| &lt;= r &lt; |d/2|.</p>
</blockquote>
<p>When d is a power of 2, say 2k for some k, this reduces to</p>
<blockquote>
<p>-2(k - 1) &lt;= r &lt; 2(k - 1).</p>
</blockquote>
<p>Computer scientists will immediately recognize this as the interval of integers representable in two’s-complement with k bits. # <code>(scheme bytevector)</code></p>
<p>This is based on <a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-3.html#node_chap_2">R6RS bytevectors library</a></p>
<h2 id="endianness-endianess-symbol-syntax"><code>(endianness &lt;endianess symbol&gt;)</code> syntax</h2>
<h2 id="native-endianness"><code>(native-endianness)</code></h2>
<p>Returns the endianness symbol associated implementation’s preferred endianness (usually that of the underlying machine architecture). This may be any <code>&lt;endianness symbol&gt;</code>, including a symbol other than big and little.</p>
<h2 id="bytevector-obj"><code>(bytevector? obj)</code></h2>
<p>Returns #t if obj is a bytevector, otherwise returns #f.</p>
<h2 id="make-bytevector-k-fill"><code>(make-bytevector k [fill])</code></h2>
<p>Returns a newly allocated bytevector of <code>K</code> bytes.</p>
<p>If the <code>FILL</code> argument is missing, the initial contents of the returned bytevector are unspecified.</p>
<p>If the <code>FILL</code> argument is present, it must be an exact integer object in the interval {-128, … 255} that specifies the initial value for the bytes of the bytevector: If <code>FILL</code> is positive, it is interpreted as an octet; if it is negative, it is interpreted as a byte.</p>
<h2 id="bytevector-length-bytevector"><code>(bytevector-length bytevector)</code></h2>
<p>Returns, as an exact integer object, the number of bytes in bytevector.</p>
<h2 id="bytevector-bytevector1-bytevector2"><code>(bytevector=? bytevector1 bytevector2)</code></h2>
<p>Returns #t if bytevector1 and bytevector2 are equal-that is, if they have the same length and equal bytes at all valid indices. It returns #f otherwise.</p>
<h2 id="bytevector-fill-bytevector-fill"><code>(bytevector-fill! bytevector fill)</code></h2>
<p>The fill argument is as in the description of the make-bytevector procedure. The bytevector-fill! procedure stores fill in every element of bytevector and returns unspecified values. Analogous to vector-fill!.</p>
<h2 id="bytevector-copy-source-source-start-target-target-start-k"><code>(bytevector-copy! source source-start‌‌ target target-start k)</code></h2>
<h2 id="bytevector-copy-bytevector"><code>(bytevector-copy bytevector)‌‌</code></h2>
<p>Returns a newly allocated copy of bytevector.</p>
<h2 id="bytevector-u8-ref-bytevector-k"><code>(bytevector-u8-ref bytevector k)‌‌</code></h2>
<p>The bytevector-u8-ref procedure returns the byte at index k of bytevector, as an octet.</p>
<h2 id="bytevector-s8-ref-bytevector-k"><code>(bytevector-s8-ref bytevector k)‌‌</code></h2>
<p>The bytevector-s8-ref procedure returns the byte at index k of bytevector, as a (signed) byte.</p>
<h2 id="bytevector-u8-set-bytevector-k-octet"><code>(bytevector-u8-set! bytevector k octet)‌‌</code></h2>
<p>The bytevector-u8-set! procedure stores octet in element k of bytevector.</p>
<h2 id="bytevector-s8-set-bytevector-k-byte"><code>(bytevector-s8-set! bytevector k byte)‌‌</code></h2>
<p>The bytevector-s8-set! procedure stores the two’s-complement representation of byte in element k of bytevector.</p>
<h2 id="bytevector-u8-list-bytevector"><code>(bytevector-&gt;u8-list bytevector)‌‌</code></h2>
<p>The bytevector-&gt;u8-list procedure returns a newly allocated list of the octets of bytevector in the same order.</p>
<h2 id="u8-list-bytevector-list"><code>(u8-list-&gt;bytevector list)‌‌</code></h2>
<p>The u8-list-&gt;bytevector procedure returns a newly allocated bytevector whose elements are the elements of list list, in the same order. It is analogous to list-&gt;vector.</p>
<h2 id="bytevector-uint-ref-bytevector-k-endianness-size"><code>(bytevector-uint-ref bytevector k endianness size)‌‌</code></h2>
<h2 id="bytevector-sint-ref-bytevector-k-endianness-size"><code>(bytevector-sint-ref bytevector k endianness size)‌‌</code></h2>
<h2 id="bytevector-uint-set-bytevector-k-n-endianness-size"><code>(bytevector-uint-set! bytevector k n endianness size)‌‌</code></h2>
<h2 id="bytevector-sint-set-bytevector-k-n-endianness-size"><code>(bytevector-sint-set! bytevector k n endianness size)‌‌</code></h2>
<h2 id="bytevector-uint-list-bytevector-endianness-size"><code>(bytevector-&gt;uint-list bytevector endianness size)‌‌</code></h2>
<h2 id="bytevector-sint-list-bytevector-endianness-sizee"><code>(bytevector-&gt;sint-list bytevector endianness sizee‌‌</code></h2>
<h2 id="uint-list-bytevector-list-endianness-size"><code>(uint-list-&gt;bytevector list endianness size)‌‌</code></h2>
<h2 id="sint-list-bytevector-list-endianness-size"><code>(sint-list-&gt;bytevector list endianness size)‌‌</code></h2>
<h2 id="bytevector-u16-ref-bytevector-k-endianness"><code>(bytevector-u16-ref bytevector k endianness)‌‌</code></h2>
<h2 id="bytevector-s16-ref-bytevector-k-endianness"><code>(bytevector-s16-ref bytevector k endianness)‌‌</code></h2>
<h2 id="bytevector-u16-native-ref-bytevector-k"><code>(bytevector-u16-native-ref bytevector k)‌‌</code></h2>
<h2 id="bytevector-s16-native-ref-bytevector-k"><code>(bytevector-s16-native-ref bytevector k)‌‌</code></h2>
<h2 id="bytevector-u16-set-bytevector-k-n-endianness"><code>(bytevector-u16-set! bytevector k n endianness)‌‌</code></h2>
<h2 id="bytevector-s16-set-bytevector-k-n-endianness"><code>(bytevector-s16-set! bytevector k n endianness)‌‌</code></h2>
<h2 id="bytevector-u16-native-set-bytevector-k-n"><code>(bytevector-u16-native-set! bytevector k n)‌‌</code></h2>
<h2 id="bytevector-s16-native-set-bytevector-k-n"><code>(bytevector-s16-native-set! bytevector k n)‌‌</code></h2>
<h2 id="bytevector-u32-ref-bytevector-k-endianness"><code>(bytevector-u32-ref bytevector k endianness)‌‌</code></h2>
<h2 id="bytevector-s32-ref-bytevector-k-endianness"><code>(bytevector-s32-ref bytevector k endianness)‌‌</code></h2>
<h2 id="bytevector-u32-native-ref-bytevector-k"><code>(bytevector-u32-native-ref bytevector k)‌‌</code></h2>
<h2 id="bytevector-s32-native-ref-bytevector-k"><code>(bytevector-s32-native-ref bytevector k)‌‌</code></h2>
<h2 id="bytevector-u32-set-bytevector-k-n-endianness"><code>(bytevector-u32-set! bytevector k n endianness)‌‌</code></h2>
<h2 id="bytevector-s32-set-bytevector-k-n-endianness"><code>(bytevector-s32-set! bytevector k n endianness)‌‌</code></h2>
<h2 id="bytevector-u32-native-set-bytevector-k-n"><code>(bytevector-u32-native-set! bytevector k n)‌‌</code></h2>
<h2 id="bytevector-s32-native-set-bytevector-k-n"><code>(bytevector-s32-native-set! bytevector k n)‌‌</code></h2>
<h2 id="bytevector-u64-ref-bytevector-k-endianness"><code>(bytevector-u64-ref bytevector k endianness)‌‌</code></h2>
<h2 id="bytevector-s64-ref-bytevector-k-endianness"><code>(bytevector-s64-ref bytevector k endianness)‌‌</code></h2>
<h2 id="bytevector-u64-native-ref-bytevector-k"><code>(bytevector-u64-native-ref bytevector k)‌‌</code></h2>
<h2 id="bytevector-s64-native-ref-bytevector-k"><code>(bytevector-s64-native-ref bytevector k)‌‌</code></h2>
<h2 id="bytevector-u64-set-bytevector-k-n-endianness"><code>(bytevector-u64-set! bytevector k n endianness)‌‌</code></h2>
<h2 id="bytevector-s64-set-bytevector-k-n-endianness"><code>(bytevector-s64-set! bytevector k n endianness)‌‌</code></h2>
<h2 id="bytevector-u64-native-set-bytevector-k-n"><code>(bytevector-u64-native-set! bytevector k n)‌‌</code></h2>
<h2 id="bytevector-s64-native-set-bytevector-k-n"><code>(bytevector-s64-native-set! bytevector k n)‌‌</code></h2>
<h2 id="bytevector-ieee-single-native-ref-bytevector-k"><code>(bytevector-ieee-single-native-ref bytevector k)‌‌</code></h2>
<h2 id="bytevector-ieee-single-ref-bytevector-k-endianness"><code>(bytevector-ieee-single-ref bytevector k endianness)‌‌</code></h2>
<h2 id="bytevector-ieee-double-native-ref-bytevector-k"><code>(bytevector-ieee-double-native-ref bytevector k)‌‌</code></h2>
<h2 id="bytevector-ieee-double-ref-bytevector-k-endianness"><code>(bytevector-ieee-double-ref bytevector k endianness)‌‌</code></h2>
<h2 id="bytevector-ieee-single-native-set-bytevector-k-x"><code>(bytevector-ieee-single-native-set! bytevector k x)‌‌</code></h2>
<h2 id="bytevector-ieee-single-set-bytevector-k-x-endianness"><code>(bytevector-ieee-single-set! bytevector ‌k x endianness)</code></h2>
<h2 id="bytevector-ieee-double-native-set-bytevector-k-x"><code>(bytevector-ieee-double-native-set! bytevector k x)‌‌</code></h2>
<h2 id="bytevector-ieee-double-set-bytevector-k-x-endianness"><code>(bytevector-ieee-double-set! bytevector k x endianness)‌</code></h2>
<h2 id="string-utf8-string"><code>(string-&gt;utf8 string)‌‌</code></h2>
<h2 id="string-utf16-string"><code>(string-&gt;utf16 string)‌‌</code></h2>
<h2 id="string-utf16-string-endianness"><code>(string-&gt;utf16 string endianness)‌‌</code></h2>
<h2 id="string-utf32-string"><code>(string-&gt;utf32 string)‌‌</code></h2>
<h2 id="string-utf32-string-endianness"><code>(string-&gt;utf32 string endianness)‌‌</code></h2>
<h2 id="utf8-string-bytevector"><code>(utf8-&gt;string bytevector)‌‌</code></h2>
<h2 id="utf16-string-bytevector-endianness"><code>(utf16-&gt;string bytevector endianness)‌‌</code></h2>
<h2 id="utf16-string-bytevector-endianness-endianness-mandatory"><code>(utf16-&gt;string bytevector‌ endianness endianness-mandatory)</code></h2>
<h2 id="utf32-string-bytevector-endianness"><code>(utf32-&gt;string bytevector endianness)‌‌</code></h2>
<h2 id="utf32-string-bytevector-endianness-endianness-mandatory"><code>(utf32-&gt;string bytevector‌ endianness endianness-mandatory)</code></h2>
<h1 id="scheme-generator"><code>(scheme generator)</code></h1>
<p>This is based on <a href="https://srfi.schemers.org/srfi-158/srfi-158.html">SRFI-158</a></p>
<p>This SRFI defines utility procedures that create, transform, and consume generators. A generator is simply a procedure with no arguments that works as a source of values. Every time it is called, it yields a value. Generators may be finite or infinite; a finite generator returns an end-of-file object to indicate that it is exhausted. For example, read-char, read-line, and read are generators that generate characters, lines, and objects from the current input port. Generators provide lightweight laziness.</p>
<p>This SRFI also defines procedures that return accumulators. An accumulator is the inverse of a generator: it is a procedure of one argument that works as a sink of values.</p>
<h2 id="generator-arg-..."><code>(generator arg ...)</code></h2>
<p>The simplest finite generator. Generates each of its arguments in turn. When no arguments are provided, it returns an empty generator that generates no values.</p>
<h2 id="circular-generator-arg-..."><code>(circular-generator arg ...)</code></h2>
<p>The simplest infinite generator. Generates each of its arguments in turn, then generates them again in turn, and so on forever.</p>
<h2 id="make-iota-generator-count-start-step"><code>(make-iota-generator count [start [step]])</code></h2>
<p>Creates a finite generator of a sequence of count numbers. The sequence begins with start (which defaults to 0) and increases by step (which defaults to 1). If both start and step are exact, it generates exact numbers; otherwise it generates inexact numbers. The exactness of count doesn’t affect the exactness of the results.</p>
<h2 id="make-range-generator-start-end-step"><code>(make-range-generator start [end [step]])</code></h2>
<p>Creates a generator of a sequence of numbers. The sequence begins with start, increases by step (default 1), and continues while the number is less than end, or forever if end is omitted. If both start and step are exact, it generates exact numbers; otherwise it generates inexact numbers. The exactness of end doesn’t affect the exactness of the results.</p>
<h2 id="make-coroutine-generator-proc"><code>(make-coroutine-generator proc)</code></h2>
<p>Creates a generator from a coroutine.</p>
<p>The proc argument is a procedure that takes one argument, yield. When called, make-coroutine-generator immediately returns a generator g. When g is called, proc runs until it calls yield. Calling yield causes the execution of proc to be suspended, and g returns the value passed to yield.</p>
<p>Whether this generator is finite or infinite depends on the behavior of proc. If proc returns, it is the end of the sequence — g returns an end-of-file object from then on. The return value of proc is ignored.</p>
<p>The following code creates a generator that produces a series 0, 1, and 2 (effectively the same as (make-range-generator 0 3)) and binds it to g.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> g</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>  (make-coroutine-generator</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>   (<span class="kw">lambda</span> (yield) (<span class="kw">let</span> loop ((i <span class="dv">0</span>))</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>               (when (<span class="op">&lt;</span> i <span class="dv">3</span>) (yield i) (loop (<span class="op">+</span> i <span class="dv">1</span>)))))))</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list g) <span class="co">;; =&gt; (0 1 2)</span></span></code></pre></div>
<h2 id="list-generator-list"><code>(list-&gt;generator list)</code></h2>
<p>Convert <code>LIST</code> into a generator.</p>
<h2 id="vector-generator-vector-start-end"><code>(vector-&gt;generator vector [start [end]])</code></h2>
<h2 id="reverse-vector-generator-vector-start-end"><code>(reverse-vector-&gt;generator vector [start [end]])</code></h2>
<h2 id="string-generator-string-start-end"><code>(string-&gt;generator string [start [end]])</code></h2>
<h2 id="bytevector-generator-bytevector-start-end"><code>(bytevector-&gt;generator bytevector [start [end]])</code></h2>
<p>These procedures return generators that yield each element of the given argument. Mutating the underlying object will affect the results of the generator.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (list-&gt;generator &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)))</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; =&gt; (1 2 3 4 5)</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (vector-&gt;generator &#39;#(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)))</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; =&gt; (1 2 3 4 5)</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (reverse-vector-&gt;generator &#39;#(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)))</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; =&gt; (5 4 3 2 1)</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (string-&gt;generator <span class="st">&quot;abcde&quot;</span>))</span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; =&gt; (#\a #\b #\c #\d #\e)</span></span></code></pre></div>
<p>The generators returned by the constructors are exhausted once all elements are retrieved; the optional start-th and end-th arguments can limit the range the generator walks across.</p>
<p>For reverse-vector-&gt;generator, the first value is the element right before the end-th element, and the last value is the start-th element. For all the other constructors, the first value the generator yields is the start-th element, and it ends right before the end-th element.</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (vector-&gt;generator &#39;#(a b c d e) <span class="dv">2</span>))</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; =&gt; (c d e)</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (vector-&gt;generator &#39;#(a b c d e) <span class="dv">2</span> <span class="dv">4</span>))</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; =&gt; (c d)</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (reverse-vector-&gt;generator &#39;#(a b c d e) <span class="dv">2</span>))</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; =&gt; (e d c)</span></span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (reverse-vector-&gt;generator &#39;#(a b c d e) <span class="dv">2</span> <span class="dv">4</span>))</span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; =&gt; (d c)</span></span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (reverse-vector-&gt;generator &#39;#(a b c d e) <span class="dv">0</span> <span class="dv">2</span>))</span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; =&gt; (b a)</span></span></code></pre></div>
<h2 id="make-for-each-generator-for-each-obj"><code>(make-for-each-generator for-each obj)</code></h2>
<p>A generator constructor that converts any collection obj to a generator that returns its elements using a for-each procedure appropriate for obj. This must be a procedure that when called as (for-each proc obj) calls proc on each element of obj. Examples of such procedures are for-each, string-for-each, and vector-for-each from R7RS. The value returned by for-each is ignored. The generator is finite if the collection is finite, which would typically be the case.</p>
<p>The collections need not be conventional ones (lists, strings, etc.) as long as for-each can invoke a procedure on everything that counts as a member. For example, the following procedure allows for-each-generator to generate the digits of an integer from least to most significant:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(for-each-digit proc n)</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>  (when (<span class="op">&gt;</span> n <span class="dv">0</span>)</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">let-values</span> (((<span class="kw">div</span> rem) (truncate/ n <span class="dv">10</span>)))</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>      (proc rem)</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>      (for-each-digit proc <span class="kw">div</span>))))</span></code></pre></div>
<h2 id="make-unfold-generator-stop-mapper-successor-seed"><code>(make-unfold-generator stop? mapper successor seed)</code></h2>
<p>A generator constructor similar to <code>(scheme list)</code> unfold.</p>
<p>The stop? predicate takes a seed value and determines whether to stop. The mapper procedure calculates a value to be returned by the generator from a seed value. The successor procedure calculates the next seed value from the current seed value.</p>
<p>For each call of the resulting generator, stop? is called with the current seed value. If it returns true, then the generator returns an end-of-file object. Otherwise, it applies mapper to the current seed value to get the value to return, and uses successor to update the seed value.</p>
<p>This generator is finite unless stop? never returns true.</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (make-unfold-generator</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>                      (<span class="kw">lambda</span> (s) (<span class="op">&gt;</span> s <span class="dv">5</span>))</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>                      (<span class="kw">lambda</span> (s) (<span class="op">*</span> s <span class="dv">2</span>))</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>                      (<span class="kw">lambda</span> (s) (<span class="op">+</span> s <span class="dv">1</span>))</span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>                      <span class="dv">0</span>))</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; =&gt; (0 2 4 6 8 10)</span></span></code></pre></div>
<h2 id="gcons-item-...-generator"><code>(gcons* item ... generator)</code></h2>
<p>Returns a generator that adds items in front of gen. Once the items have been consumed, the generator is guaranteed to tail-call gen.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (gcons* &#39;a &#39;b (make-range-generator <span class="dv">0</span> <span class="dv">2</span>)))</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a> <span class="co">;; =&gt; (a b 0 1)</span></span></code></pre></div>
<h2 id="gappend-generator-..."><code>(gappend generator ...)</code></h2>
<p>Returns a generator that yields the items from the first given generator, and once it is exhausted, from the second generator, and so on.</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (gappend (make-range-generator <span class="dv">0</span> <span class="dv">3</span>) (make-range-generator <span class="dv">0</span> <span class="dv">2</span>)))</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a> <span class="co">;; =&gt; (0 1 2 0 1)</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (gappend))</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a> <span class="co">;; =&gt; ()</span></span></code></pre></div>
<h2 id="gflatten-generator"><code>(gflatten generator)</code></h2>
<p>Returns a generator that yields the elements of the lists produced by the given generator.</p>
<h2 id="ggroup-generator-k-padding"><code>(ggroup generator k [padding])</code></h2>
<p>Returns a generator that yields lists of k items from the given generator. If fewer than k elements are available for the last list, and padding is absent, the short list is returned; otherwise, it is padded by padding to length k.</p>
<h2 id="gmerge-less-than-generator1-..."><code>(gmerge less-than generator1 ...)</code></h2>
<p>Returns a generator that yields the items from the given generators in the order dictated by less-than. If the items are equal, the leftmost item is used first. When all of given generators are exhausted, the returned generator is exhausted also.</p>
<p>As a special case, if only one generator is given, it is returned.</p>
<h2 id="gmap-proc-generator-..."><code>(gmap proc generator ...)</code></h2>
<p>When only one generator is given, returns a generator that yields the items from the given generator after invoking proc on them.</p>
<p>When more than one generator is given, each item of the resulting generator is a result of applying proc to the items from each generator. If any of input generator is exhausted, the resulting generator is also exhausted.</p>
<p>Note: This differs from generator-map-&gt;list, which consumes all values at once and returns the results as a list, while gmap returns a generator immediately without consuming input.</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (gmap <span class="op">-</span> (make-range-generator <span class="dv">0</span> <span class="dv">3</span>)))</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a> <span class="co">;; =&gt; (0 -1 -2)</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (gmap <span class="kw">cons</span> (generator <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) (generator <span class="dv">4</span> <span class="dv">5</span>)))</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a> <span class="co">;; =&gt; ((1 . 4) (2 . 5))</span></span></code></pre></div>
<h2 id="gcombine-proc-seed-generator-generator2"><code>(gcombine proc seed generator generator2)</code></h2>
<p>A generator for mapping with state. It yields a sequence of sub-folds over proc.</p>
<p>The proc argument is a procedure that takes as many arguments as the input generators plus one. It is called as (proc v1 v2 … seed), where v1, v2, … are the values yielded from the input generators, and seed is the current seed value. It must return two values, the yielding value and the next seed. The result generator is exhausted when any of the genn generators is exhausted, at which time all the others are in an undefined state.</p>
<h2 id="gfilter-predicate-generator"><code>(gfilter predicate generator)</code></h2>
<h2 id="gremove-predicate-generator"><code>(gremove predicate generator)</code></h2>
<p>Returns generators that yield the items from the source generator, except those on which pred answers false or true respectively.</p>
<h2 id="gstate-filter-proc-seed-generator"><code>(gstate-filter proc seed generator)</code></h2>
<p>Returns a generator that obtains items from the source generator and passes an item and a state (whose initial value is seed) as arguments to proc. Proc in turn returns two values, a boolean and a new value of the state. If the boolean is true, the item is returned; otherwise, this algorithm is repeated until gen is exhausted, at which point the returned generator is also exhausted. The final value of the state is discarded.</p>
<h2 id="gtake-gen-k-padding"><code>(gtake gen k [padding])</code></h2>
<h2 id="gdrop-gen-k"><code>(gdrop gen k)</code></h2>
<p>These are generator analogues of SRFI 1 take and drop. Gtake returns a generator that yields (at most) the first k items of the source generator, while gdrop returns a generator that skips the first k items of the source generator.</p>
<p>These won’t complain if the source generator is exhausted before generating k items. By default, the generator returned by gtake terminates when the source generator does, but if you provide the padding argument, then the returned generator will yield exactly k items, using the padding value as needed to provide sufficient additional values.</p>
<h2 id="gtake-while-pred-gen"><code>gtake-while pred gen</code></h2>
<h2 id="gdrop-while-pred-gen"><code>gdrop-while pred gen</code></h2>
<p>The generator analogues of SRFI-1 take-while and drop-while. The generator returned from gtake-while yields items from the source generator as long as pred returns true for each. The generator returned from gdrop-while first reads and discards values from the source generator while pred returns true for them, then starts yielding items returned by the source.</p>
<h2 id="gdelete-item-gen"><code>(gdelete item gen [=])</code></h2>
<p>Creates a generator that returns whatever gen returns, except for any items that are the same as item in the sense of =, which defaults to equal?. The = predicate is passed exactly two arguments, of which the first was generated by gen before the second.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (gdelete <span class="dv">3</span> (generator <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">3</span> <span class="dv">6</span> <span class="dv">7</span>)))</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; =&gt; (1 2 4 5 6 7)</span></span></code></pre></div>
<h2 id="gdelete-neighbor-dups-gen"><code>(gdelete-neighbor-dups gen [=])</code></h2>
<p>Creates a generator that returns whatever gen returns, except for any items that are equal to the preceding item in the sense of =, which defaults to equal?. The = predicate is passed exactly two arguments, of which the first was generated by gen before the second.</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (gdelete-neighbor-dups (list-&gt;generator &#39;(a a b c a a a d c))))</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; =&gt; (a b c a d c)</span></span></code></pre></div>
<h2 id="gindex-value-gen-index-gen"><code>(gindex value-gen index-gen)</code></h2>
<p>Creates a generator that returns elements of value-gen specified by the indices (non-negative exact integers) generated by index-gen. It is an error if the indices are not strictly increasing, or if any index exceeds the number of elements generated by value-gen. The result generator is exhausted when either generator is exhausted, at which time the other is in an undefined state.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (gindex (list-&gt;generator &#39;(a b c d e f))</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>                         (list-&gt;generator &#39;(<span class="dv">0</span> <span class="dv">2</span> <span class="dv">4</span>))))</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; =&gt; (a c e)</span></span></code></pre></div>
<h2 id="gselect-value-gen-truth-gen"><code>(gselect value-gen truth-gen)</code></h2>
<p>Creates a generator that returns elements of value-gen that correspond to the values generated by truth-gen. If the current value of truth-gen is true, the current value of value-gen is generated, but otherwise not. The result generator is exhausted when either generator is exhausted, at which time the other is in an undefined state.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>(generator-&gt;list (gselect (list-&gt;generator &#39;(a b c d e f))</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>                          (list-&gt;generator &#39;(<span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#f</span>))))</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; =&gt; (a d e)</span></span></code></pre></div>
<h2 id="generator-list-generator-k"><code>(generator-&gt;list generator [k])</code></h2>
<p>Reads items from generator and returns a newly allocated list of them. By default, it reads until the generator is exhausted.</p>
<p>If an optional argument k is given, it must be a non-negative integer, and the list ends when either k items are consumed, or generator is exhausted; therefore generator can be infinite in this case.</p>
<h2 id="generator-reverse-list-generator-k"><code>(generator-&gt;reverse-list generator [k])</code></h2>
<p>Reads items from generator and returns a newly allocated list of them in reverse order. By default, this reads until the generator is exhausted.</p>
<p>If an optional argument k is given, it must be a non-negative integer, and the list ends when either k items are read, or generator is exhausted; therefore generator can be infinite in this case.</p>
<h2 id="generator-vector-generator-k"><code>(generator-&gt;vector generator [k])</code></h2>
<p>Reads items from generator and returns a newly allocated vector of them. By default, it reads until the generator is exhausted.</p>
<p>If an optional argument k is given, it must be a non-negative integer, and the list ends when either k items are consumed, or generator is exhausted; therefore generator can be infinite in this case.</p>
<h2 id="generator-vector-vector-at-generator"><code>(generator-&gt;vector! vector at generator)</code></h2>
<p>Reads items from generator and puts them into vector starting at index at, until vector is full or generator is exhausted. Generator can be infinite. The number of elements generated is returned.</p>
<h2 id="generator-string-generator-k"><code>(generator-&gt;string generator [k])</code></h2>
<p>Reads items from generator and returns a newly allocated string of them. It is an error if the items are not characters. By default, it reads until the generator is exhausted.</p>
<p>If an optional argument k is given, it must be a non-negative integer, and the string ends when either k items are consumed, or generator is exhausted; therefore generator can be infinite in this case.</p>
<h2 id="generator-fold-proc-seed-generator-..."><code>(generator-fold proc seed generator ...)</code></h2>
<p>Works like <code>(scheme list)</code> fold on the values generated by the generator arguments.</p>
<p>When one generator is given, for each value v generated by gen, proc is called as (proc v r), where r is the current accumulated result; the initial value of the accumulated result is seed, and the return value from proc becomes the next accumulated result. When gen is exhausted, the accumulated result at that time is returned from generator-fold.</p>
<p>When more than one generator is given, proc is invoked on the values returned by all the generator arguments followed by the current accumulated result. The procedure terminates when any of the genn generators is exhausted, at which time all the others are in an undefined state.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>(with-input-from-string <span class="st">&quot;a b c d e&quot;</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> () (generator-fold <span class="kw">cons</span> &#39;z <span class="kw">read</span>)))</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; =&gt; (e d c b a . z)</span></span></code></pre></div>
<h2 id="generator-for-each-proc-generator-..."><code>(generator-for-each proc generator ...)</code></h2>
<p>A generator analogue of for-each that consumes generated values using side effects. Repeatedly applies proc on the values yielded by gen, gen2 … until any one of the generators is exhausted, at which time all the others are in an undefined state. The values returned from proc are discarded. Returns an unspecified value.</p>
<h2 id="generator-map-list-proc-generator-..."><code>(generator-map-&gt;list proc generator ...)</code></h2>
<p>A generator analogue of map that consumes generated values, processes them through a mapping function, and returns a list of the mapped values. Repeatedly applies proc on the values yielded by gen, gen2 … until any one of the generators is exhausted, at which time all the others are in an undefined state. The values returned from proc are accumulated into a list, which is returned.</p>
<h2 id="generator-find-predicate-generator"><code>(generator-find predicate generator)</code></h2>
<p>Returns the first item from the generator gen that satisfies the predicate pred, or #f if no such item is found before gen is exhausted. If gen is infinite, generator-find will not return if it cannot find an appropriate item.</p>
<h2 id="generator-count-predicate-generator"><code>(generator-count predicate generator)</code></h2>
<p>Returns the number of items available from the generator gen that satisfy the predicate pred.</p>
<h2 id="generator-any-predicate-generator"><code>(generator-any predicate generator)</code></h2>
<p>Applies predicate to each item from gen. As soon as it yields a true value, the value is returned without consuming the rest of gen. If gen is exhausted, returns #f.</p>
<h2 id="generator-every-predicate-generator"><code>(generator-every predicate generator)</code></h2>
<p>Applies pred to each item from gen. As soon as it yields a false value, the value is returned without consuming the rest of gen. If gen is exhausted, returns the last value returned by pred, or #t if pred was never called.</p>
<h2 id="generator-unfold-gen-unfold-arg-..."><code>(generator-unfold gen unfold arg ...)</code></h2>
<p>Equivalent to <code>(unfold eof-object? (lambda (x) x) (lambda (x) (gen)) (gen) arg ...)</code>. The values of gen are unfolded into the collection that unfold creates.</p>
<p>The signature of the unfold procedure is (unfold stop? mapper successor seed args …). Note that the vector-unfold and vector-unfold-right of SRFI 43 and SRFI 133 do not have this signature and cannot be used with this procedure. To unfold into a vector, use SRFI 1’s unfold and then apply list-&gt;vector to the result.</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="co">;; Iterates over string and unfolds into a list using SRFI 1 unfold</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>(generator-unfold (make-for-each-generator string-for-each <span class="st">&quot;abc&quot;</span>) unfold)</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a><span class="co">;; =&gt; (#\a #\b #\c)</span></span></code></pre></div>
<h2 id="make-accumulator-kons-knil-finalizer"><code>(make-accumulator kons knil finalizer)</code></h2>
<p>Returns an accumulator that, when invoked on an object other than an end-of-file object, invokes kons on its argument and the accumulator’s current state, using the same order as a function passed to fold. It then sets the accumulator’s state to the value returned by kons and returns an unspecified value. The initial state of the accumulator is set to knil. However, if an end-of-file object is passed to the accumulator, it returns the result of tail-calling the procedure finalizer on the state. Repeated calls with an end-of-file object will reinvoke finalizer.</p>
<h2 id="count-accumulator"><code>(count-accumulator)</code></h2>
<p>qReturns an accumulator that, when invoked on an object, adds 1 to a count inside the accumulator and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the count.</p>
<h2 id="list-accumulator"><code>(list-accumulator)</code></h2>
<p>Returns an accumulator that, when invoked on an object, adds that object to a list inside the accumulator in order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the list.</p>
<h2 id="reverse-list-accumulator"><code>(reverse-list-accumulator)</code></h2>
<p>Returns an accumulator that, when invoked on an object, adds that object to a list inside the accumulator in reverse order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the list.</p>
<h2 id="vector-accumulator"><code>(vector-accumulator)</code></h2>
<p>Returns an accumulator that, when invoked on an object, adds that object to a vector inside the accumulator in order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the vector.</p>
<h2 id="reverse-vector-accumulator"><code>(reverse-vector-accumulator)</code></h2>
<p>Returns an accumulator that, when invoked on an object, adds that object to a vector inside the accumulator in reverse order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the vector.</p>
<h2 id="vector-accumulator-vector-at"><code>(vector-accumulator! vector at)</code></h2>
<p>Returns an accumulator that, when invoked on an object, adds that object to consecutive positions of vector starting at at in order of accumulation. It is an error to try to accumulate more objects than vector will hold. An unspecified value is returned. However, if an end-of-file object is passed, the accumulator returns vector.</p>
<h2 id="string-accumulator"><code>(string-accumulator)</code></h2>
<p>Returns an accumulator that, when invoked on a character, adds that character to a string inside the accumulator in order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the string.</p>
<h2 id="bytevector-accumulator"><code>(bytevector-accumulator)</code></h2>
<p>Returns an accumulator that, when invoked on a byte, adds that integer to a bytevector inside the accumulator in order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the bytevector.</p>
<h2 id="bytevector-accumulator-bytevector-at"><code>(bytevector-accumulator! bytevector at)</code></h2>
<p>Returns an accumulator that, when invoked on a byte, adds that byte to consecutive positions of bytevector starting at at in order of accumulation. It is an error to try to accumulate more bytes than vector will hold. An unspecified value is returned. However, if an end-of-file object is passed, the accumulator returns bytevector.</p>
<h2 id="sum-accumulator"><code>(sum-accumulator)</code></h2>
<p>Returns an accumulator that, when invoked on a number, adds that number to a sum inside the accumulator in order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the sum.</p>
<h2 id="product-accumulator"><code>(product-accumulator)</code></h2>
<p>Returns an accumulator that, when invoked on a number, multiplies that number to a product inside the accumulator in order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the product.</p>
<h1 id="scheme-flonum"><code>(scheme flonum)</code></h1>
<p>This is based on <a href="https://srfi.schemers.org/srfi-144/">SRFI-144</a>.</p>
<p>This library describes numeric procedures applicable to flonums, a subset of the inexact real numbers provided by a Scheme implementation. In most Schemes, the flonums and the inexact reals are the same. These procedures are semantically equivalent to the corresponding generic procedures, but allow more efficient implementations.</p>
<h2 id="fl-e"><code>fl-e</code></h2>
<p>Bound to the mathematical constant e. (C99 M_E)</p>
<h2 id="fl-1e"><code>fl-1/e</code></h2>
<p>Bound to 1/e. (C99 M_E)</p>
<h2 id="fl-e-2"><code>fl-e-2</code></h2>
<p>Bound to e2.</p>
<h2 id="fl-e-pi4"><code>fl-e-pi/4</code></h2>
<p>Bound to eπ/4.</p>
<h2 id="fl-log2-e"><code>fl-log2-e</code></h2>
<p>Bound to log2 e. (C99 M_LOG2E)</p>
<h2 id="fl-log10-e"><code>fl-log10-e</code></h2>
<p>Bound to log10 e. (C99 M_LOG10E)</p>
<h2 id="fl-log-2"><code>fl-log-2</code></h2>
<p>Bound to loge 2. (C99 M_LN2)</p>
<h2 id="fl-1log-2"><code>fl-1/log-2</code></h2>
<p>Bound to 1/loge 2. (C99 M_LN2)</p>
<h2 id="fl-log-3"><code>fl-log-3</code></h2>
<p>Bound to loge 3.</p>
<h2 id="fl-log-pi"><code>fl-log-pi</code></h2>
<p>Bound to loge π.</p>
<h2 id="fl-log-10"><code>fl-log-10</code></h2>
<p>Bound to loge 10. (C99 M_LN10)</p>
<h2 id="fl-1log-10"><code>fl-1/log-10</code></h2>
<p>Bound to 1/loge 10. (C99 M_LN10)</p>
<h2 id="fl-pi"><code>fl-pi</code></h2>
<p>Bound to the mathematical constant π. (C99 M_PI)</p>
<h2 id="fl-1pi"><code>fl-1/pi</code></h2>
<p>Bound to 1/π. (C99 M_1_PI)</p>
<h2 id="fl-2pi"><code>fl-2pi</code></h2>
<p>Bound to 2π.</p>
<h2 id="fl-pi2"><code>fl-pi/2</code></h2>
<p>Bound to π/2. (C99 M_PI_2)</p>
<h2 id="fl-pi4"><code>fl-pi/4</code></h2>
<p>Bound to π/4. (C99 M_PI_4)</p>
<h2 id="fl-pi-squared"><code>fl-pi-squared</code></h2>
<p>Bound to π2.</p>
<h2 id="fl-degree"><code>fl-degree</code></h2>
<p>Bound to π/180, the number of radians in a degree.</p>
<h2 id="fl-2pi-1"><code>fl-2/pi</code></h2>
<p>Bound to 2/π. (C99 M_2_PI)</p>
<h2 id="fl-2sqrt-pi"><code>fl-2/sqrt-pi</code></h2>
<p>Bound to 2/√π. (C99 M_2_SQRTPI)</p>
<h2 id="fl-sqrt-2"><code>fl-sqrt-2</code></h2>
<p>Bound to √2. (C99 M_SQRT2)</p>
<h2 id="fl-sqrt-3"><code>fl-sqrt-3</code></h2>
<p>Bound to √3.</p>
<h2 id="fl-sqrt-5"><code>fl-sqrt-5</code></h2>
<p>Bound to √5.</p>
<h2 id="fl-sqrt-10"><code>fl-sqrt-10</code></h2>
<p>Bound to √10.</p>
<h2 id="fl-1sqrt-2"><code>fl-1/sqrt-2</code></h2>
<p>Bound to 1/√2. (C99 M_SQRT1_2)</p>
<h2 id="fl-cbrt-2"><code>fl-cbrt-2</code></h2>
<p>Bound to ∛2.</p>
<h2 id="fl-cbrt-3"><code>fl-cbrt-3</code></h2>
<p>Bound to ∛3.</p>
<h2 id="fl-4thrt-2"><code>fl-4thrt-2</code></h2>
<p>Bound to ∜2.</p>
<h2 id="fl-phi">fl-phi`</h2>
<p>Bound to the mathematical constant φ.</p>
<h2 id="fl-log-phi"><code>fl-log-phi</code></h2>
<p>Bound to log(φ).</p>
<h2 id="fl-1log-phi"><code>fl-1/log-phi</code></h2>
<p>Bound to 1/log(φ).</p>
<h2 id="fl-euler"><code>fl-euler</code></h2>
<p>Bound to the mathematical constant γ (Euler’s constant).</p>
<h2 id="fl-e-euler"><code>fl-e-euler</code></h2>
<p>Bound to eγ.</p>
<h2 id="fl-sin-1"><code>fl-sin-1</code></h2>
<p>Bound to sin 1.</p>
<h2 id="fl-cos-1"><code>fl-cos-1</code></h2>
<p>Bound to cos 1.</p>
<h2 id="fl-gamma-12"><code>fl-gamma-1/2</code></h2>
<p>Bound to Γ(1/2).</p>
<h2 id="fl-gamma-13"><code>fl-gamma-1/3</code></h2>
<p>Bound to Γ(1/3).</p>
<h2 id="fl-gamma-23"><code>fl-gamma-2/3</code></h2>
<p>Bound to Γ(2/3).</p>
<h2 id="fl-greatest"><code>fl-greatest</code></h2>
<h2 id="fl-least"><code>fl-least</code></h2>
<p>Bound to the largest/smallest positive finite flonum. (e.g. C99 DBL_MAX and C11 DBL_TRUE_MIN)</p>
<h2 id="fl-epsilon"><code>fl-epsilon</code></h2>
<p>Bound to the appropriate machine epsilon for the hardware representation of flonums. (C99 DBL_EPSILON in &lt;float.h&gt;)</p>
<h2 id="fl-fast-fl"><code>fl-fast-fl+*</code></h2>
<p>Bound to #t if (fl+* x y z) executes about as fast as, or faster than, (fl+ (fl* x y) z); bound to #f otherwise. (C99 FP_FAST_FMA)</p>
<p>So that the value of this variable can be determined at compile time, R7RS implementations and other implementations that provide a features function should provide the feature fl-fast-fl+* if this variable is true, and not if it is false or the value is unknown at compile time.</p>
<h2 id="fl-integer-exponent-zero"><code>fl-integer-exponent-zero</code></h2>
<p>Bound to whatever exact integer is returned by (flinteger-exponent 0.0). (C99 FP_ILOGB0)</p>
<h2 id="fl-integer-exponent-nan"><code>fl-integer-exponent-nan</code></h2>
<p>Bound to whatever exact integer is returned by (flinteger-exponent +nan.0). (C99 FP_ILOGBNAN)</p>
<h2 id="flonum-number"><code>(flonum number)</code></h2>
<p>If number is an inexact real number and there exists a flonum that is the same (in the sense of =) to number, returns that flonum. If number is a negative zero, an infinity, or a NaN, return its flonum equivalent. If such a flonum does not exist, returns the nearest flonum, where “nearest” is implementation-dependent. If number is not a real number, it is an error. If number is exact, applies inexact or exact-&gt;inexact to number first.</p>
<h2 id="fladjacent-x-y"><code>(fladjacent x y)</code></h2>
<p>Returns a flonum adjacent to x in the direction of y. Specifically: if x &lt; y, returns the smallest flonum larger than x; if x &gt; y, returns the largest flonum smaller than x; if x = y, returns x. (C99 nextafter)</p>
<h2 id="flcopysign-x-y"><code>(flcopysign x y)</code></h2>
<p>Returns a flonum whose magnitude is the magnitude of x and whose sign is the sign of y. (C99 copysign)</p>
<h2 id="make-flonum-x-n"><code>(make-flonum x n)</code></h2>
<p>Returns x × 2n, where n is an integer with an implementation-dependent range. (C99 ldexp)</p>
<h2 id="flinteger-fraction-x"><code>(flinteger-fraction x)</code></h2>
<p>Returns two values, the integral part of x as a flonum and the fractional part of x as a flonum. (C99 modf)</p>
<h2 id="flexponent-x"><code>(flexponent x)</code></h2>
<p>Returns the exponent of x. (C99 logb)</p>
<h2 id="flinteger-exponent-x"><code>(flinteger-exponent x)</code></h2>
<p>Returns the same as flexponent truncated to an exact integer. If x is zero, returns fl-integer-exponent-zero; if x is a NaN, returns fl-integer-exponent-nan; if x is infinite, returns a large implementation-dependent exact integer. (C99 ilogb)</p>
<h2 id="flnormalized-fraction-exponent-x"><code>(flnormalized-fraction-exponent x)</code></h2>
<p>Returns two values, a correctly signed fraction y whose absolute value is between 0.5 (inclusive) and 1.0 (exclusive), and an exact integer exponent n such that x = y(2n). (C99 frexp)</p>
<h2 id="flsign-bit-x"><code>(flsign-bit x)</code></h2>
<p>Returns 0 for positive flonums and 1 for negative flonums and -0.0. The value of (flsign-bit +nan.0) is implementation-dependent, reflecting the sign bit of the underlying representation of NaNs. (C99 signbit)</p>
<h2 id="flonum-obj"><code>(flonum? obj)</code></h2>
<p>Returns #t if obj is a flonum and #f otherwise.</p>
<h2 id="fl-x-y-z-..."><code>(fl=? x y z ...)</code></h2>
<h2 id="fl-x-y-z-...-1"><code>(fl&lt;? x y z ...)</code></h2>
<h2 id="fl-x-y-z-...-2"><code>(fl&gt;? x y z ...)</code></h2>
<h2 id="fl-x-y-z-...-3"><code>(fl&lt;=? x y z ...)</code></h2>
<h2 id="fl-x-y-z-...-4"><code>(fl&gt;=? x y z ...)</code></h2>
<p>These procedures return #t if their arguments are (respectively): equal, monotonically increasing, monotonically decreasing, monotonically nondecreasing, or monotonically nonincreasing; they return #f otherwise. These predicates must be transitive. (C99 =, &lt;, &gt; &lt;=, &gt;= operators respectively)</p>
<h2 id="flunordered-x-y"><code>(flunordered? x y)</code></h2>
<p>Returns #t if x and y are unordered according to IEEE rules. This means that one of them is a NaN.</p>
<p>These numerical predicates test a flonum for a particular property, returning #t or #f.</p>
<h2 id="flinteger-x"><code>(flinteger? x)</code></h2>
<p>Tests whether x is an integral flonum.</p>
<h2 id="flzero-x"><code>(flzero? x)</code></h2>
<p>Tests whether x is zero. Beware of roundoff errors.</p>
<h2 id="flpositive-x"><code>(flpositive? x)</code></h2>
<p>Tests whether x is positive.</p>
<h2 id="flnegative-x"><code>(flnegative? x)</code></h2>
<p>Tests whether x is negative. Note that (flnegative? -0.0) must return #f; otherwise it would lose the correspondence with (fl&lt;? -0.0 0.0), which is #f according to IEEE 754.</p>
<h2 id="flodd-x"><code>(flodd? x)</code></h2>
<p>Tests whether the flonum x is odd. It is an error if x is not an integer.</p>
<h2 id="fleven-x"><code>(fleven? x)</code></h2>
<p>Tests whether the flonum x is even. It is an error if x is not an integer.</p>
<h2 id="flfinite-x"><code>(flfinite? x)</code></h2>
<p>Tests whether the flonum x is finite. (C99 isfinite)</p>
<h2 id="flinfinite-x"><code>(flinfinite? x)</code></h2>
<p>Tests whether the flonum x is infinite. (C99 isinf)</p>
<h2 id="flnan-x"><code>(flnan? x)</code></h2>
<p>Tests whether the flonum x is NaN. (C99 isnan)</p>
<h2 id="flnormalized-x"><code>(flnormalized? x)</code></h2>
<p>Tests whether the flonum x is normalized. (C11 isnormal; in C99, use fpclassify(x) == FP_NORMAL)</p>
<h2 id="fldenormalized-x"><code>(fldenormalized? x)</code></h2>
<p>Tests whether the flonum x is denormalized. (C11 issubnormal; in C99, use fpclassify(x) == FP_SUBNORMAL)</p>
<h2 id="flmax-x-..."><code>(flmax x ...)</code></h2>
<h2 id="flmin-x-..."><code>(flmin x ...)</code></h2>
<p>Return the maximum/minimum argument. If there are no arguments, these procedures return -inf.0 or +inf.0 if the implementation provides these numbers, and (fl- fl-greatest) or fl-greatest otherwise. (C99 fmax fmin)</p>
<h2 id="fl-x-..."><code>(fl+ x ...)</code></h2>
<h2 id="fl-x-...-1"><code>(fl* x ...)</code></h2>
<p>Return the flonum sum or product of their flonum arguments. (C99 + * operators respectively)</p>
<h2 id="fl-x-y-z"><code>(fl+* x y z)</code></h2>
<p>Returns xy + z as if to infinite precision and rounded only once. The boolean constant fl-fast-fl+* indicates whether this procedure executes about as fast as, or faster than, a multiply and an add of flonums. (C99 fma)</p>
<h2 id="fl--x-y-..."><code>(fl- x y ...)</code></h2>
<h2 id="fl-x-y-..."><code>(fl/ x y ...)</code></h2>
<p>With two or more arguments, these procedures return the difference or quotient of their arguments, associating to the left. With one argument, however, they return the additive or multiplicative inverse of their argument. (C99 - / operators respectively)</p>
<h2 id="flabs-x"><code>(flabs x)</code></h2>
<p>Returns the absolute value of x. (C99 fabs)</p>
<h2 id="flabsdiff-x-y"><code>(flabsdiff x y)</code></h2>
<p>Returns |x - y|.</p>
<h2 id="flposdiff-x-y"><code>(flposdiff x y)</code></h2>
<p>Returns the difference of x and y if it is non-negative, or zero if the difference is negative. (C99 fdim)</p>
<h2 id="flsgn-x"><code>(flsgn x)</code></h2>
<p>Returns (flcopysign 1.0 x).</p>
<h2 id="flnumerator-x"><code>(flnumerator x)</code></h2>
<h2 id="fldenominator-x"><code>(fldenominator x)</code></h2>
<p>Returns the numerator/denominator of x as a flonum; the result is computed as if x was represented as a fraction in lowest terms. The denominator is always positive. The numerator of an infinite flonum is itself. The denominator of an infinite or zero flonum is 1.0. The numerator and denominator of a NaN is a NaN.</p>
<h2 id="flfloor-x"><code>(flfloor x)</code></h2>
<p>Returns the largest integral flonum not larger than x. (C99 floor)</p>
<h2 id="flceiling-x"><code>(flceiling x)</code></h2>
<p>Returns the smallest integral flonum not smaller than x. (C99 ceil)</p>
<h2 id="flround-x"><code>(flround x)</code></h2>
<p>Returns the closest integral flonum to x, rounding to even when x represents a number halfway between two integers. (Not the same as C99 round, which rounds away from zero)</p>
<h2 id="fltruncate-x"><code>(fltruncate x)</code></h2>
<p>Returns the closest integral flonum to x whose absolute value is not larger than the absolute value of x (C99 trunc) Exponents and logarithms</p>
<h2 id="flexp-x"><code>(flexp x)</code></h2>
<p>Returns ex. (C99 exp)</p>
<h2 id="flexp2-x"><code>(flexp2 x)</code></h2>
<p>Returns 2x. (C99 exp2)</p>
<h2 id="flexp-1-x"><code>(flexp-1 x)</code></h2>
<p>Returns ex - 1, but is much more accurate than flexp for very small values of x. It is recommended for use in algorithms where accuracy is important. (C99 expm1)</p>
<h2 id="flsquare-x"><code>(flsquare x)</code></h2>
<p>Returns x2.</p>
<h2 id="flsqrt-x"><code>(flsqrt x)</code></h2>
<p>Returns √x. For -0.0, flsqrt should return -0.0. (C99 sqrt)</p>
<h2 id="flcbrt-x"><code>(flcbrt x)</code></h2>
<p>Returns ∛x. (C99 cbrt)</p>
<h2 id="flhypot-x-y"><code>(flhypot x y)</code></h2>
<p>Returns the length of the hypotenuse of a right triangle whose sides are of length |x| and |y|. (C99 hypot)</p>
<h2 id="flexpt-x-y"><code>(flexpt x y)</code></h2>
<p>Returns xy. If x is zero, then the result is zero. (C99 pow)</p>
<h2 id="fllog-x"><code>(fllog x)</code></h2>
<p>Returns loge x. (C99 log)</p>
<h2 id="fllog1-x"><code>(fllog1+ x)</code></h2>
<p>Returns loge (x+ 1), but is much more accurate than fllog for values of x near 0. It is recommended for use in algorithms where accuracy is important. (C99 log1p)</p>
<h2 id="fllog2-x"><code>(fllog2 x)</code></h2>
<p>Returns log2 x. (C99 log2)</p>
<h2 id="fllog10-x"><code>(fllog10 x)</code></h2>
<p>Returns log10 x. (C99 log10)</p>
<h2 id="make-fllog-base-x"><code>(make-fllog-base x)</code></h2>
<p>Returns a procedure that calculates the base-x logarithm of its argument. If x is 1.0 or less than 1.0, it is an error.</p>
<h2 id="flsin-x"><code>(flsin x)</code></h2>
<p>Returns sin x. (C99 sin)</p>
<h2 id="flcos-x"><code>(flcos x)</code></h2>
<p>Returns cos x. (C99 cos)</p>
<h2 id="fltan-x"><code>(fltan x)</code></h2>
<p>Returns tan x. (C99 tan)</p>
<h2 id="flasin-x"><code>(flasin x)</code></h2>
<p>Returns arcsin x. (C99 asin)</p>
<h2 id="flacos-x"><code>(flacos x)</code></h2>
<p>Returns arccos x. (C99 acos)</p>
<h2 id="flatan-y-x"><code>(flatan [y] x)</code></h2>
<p>Returns arctan x. (C99 atan)</p>
<p>With two arguments, returns arctan(y/x). in the range [-π,π], using the signs of x and y to choose the correct quadrant for the result. (C99 atan2)</p>
<h2 id="flsinh-x"><code>(flsinh x)</code></h2>
<p>Returns sinh x. (C99 sinh)</p>
<h2 id="flcosh-x"><code>(flcosh x)</code></h2>
<p>Returns cosh x. (C99 cosh)</p>
<h2 id="fltanh-x"><code>(fltanh x)</code></h2>
<p>Returns tanh x. (C99 tanh)</p>
<h2 id="flasinh-x"><code>(flasinh x)</code></h2>
<p>Returns arcsinh x. (C99 asinh)</p>
<h2 id="flacosh-x"><code>(flacosh x)</code></h2>
<p>Returns arccosh x. (C99 acosh)</p>
<h2 id="flatanh-x"><code>(flatanh x)</code></h2>
<p>Returns arctanh x. (C99 atanh)</p>
<h2 id="flquotient-x-y"><code>(flquotient x y)</code></h2>
<p>Returns the quotient of x/y as an integral flonum, truncated towards zero.</p>
<h2 id="flremainder-x-y"><code>(flremainder x y)</code></h2>
<p>Returns the truncating remainder of x/y as an integral flonum.</p>
<h2 id="flremquo-x-y"><code>(flremquo x y)</code></h2>
<p>` Returns two values, the rounded remainder of x/y and the low-order n bits (as a correctly signed exact integer) of the rounded quotient. The value of n is implementation-dependent but at least 3. This procedure can be used to reduce the argument of the inverse trigonometric functions, while preserving the correct quadrant or octant. (C99 remquo)</p>
<h2 id="flgamma-x"><code>(flgamma x)</code></h2>
<p>Returns Γ(x), the gamma function applied to x. This is equal to (x-1)! for integers. (C99 tgamma)</p>
<h2 id="flloggamma-x"><code>(flloggamma x)</code></h2>
<p>Returns two values, log |Γ(x)| without internal overflow, and the sign of Γ(x) as 1.0 if it is positive and -1.0 if it is negative. (C99 lgamma)</p>
<h2 id="flfirst-bessel-n-x"><code>(flfirst-bessel n x)</code></h2>
<p>Returns the nth order Bessel function of the first kind applied to x, Jn(x). (jn, which is an XSI Extension of C99)</p>
<h2 id="flsecond-bessel-n-x"><code>(flsecond-bessel n x)</code></h2>
<p>Returns the nth order Bessel function of the second kind applied to x, Yn(x). (yn, which is an XSI Extension of C99)</p>
<h2 id="flerf-x"><code>(flerf x)</code></h2>
<p>Returns the error function erf(x). (C99 erf)</p>
<h2 id="flerfc-x"><code>(flerfc x)</code></h2>
<p>Returns the complementary error function, 1 - erf(x). (C99 erfc) # <code>(scheme charset)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-14/">SRFI-14</a>.</p>
<p>The ability to efficiently represent and manipulate sets of characters is an unglamorous but very useful capability for text-processing code – one that tends to pop up in the definitions of other libraries.</p>
<h2 id="char-set-obj"><code>(char-set? obj)</code></h2>
<p>Is the object obj a character set?</p>
<h2 id="char-set-cs1-..."><code>(char-set= cs1 ...)</code></h2>
<p>Are the character sets equal?</p>
<p>Boundary cases:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>(char-set=) <span class="op">=&gt;</span> true</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>(char-set= cs) <span class="op">=&gt;</span> true</span></code></pre></div>
<p>Rationale: transitive binary relations are generally extended to n-ary relations in Scheme, which enables clearer, more concise code to be written. While the zero-argument and one-argument cases will almost certainly not arise in first-order uses of such relations, they may well arise in higher-order cases or macro-generated code. E.g., consider</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>(apply char-set= cset-list)</span></code></pre></div>
<p>This is well-defined if the list is empty or a singleton list. Hence we extend these relations to any number of arguments. Implementors have reported actual uses of n-ary relations in higher-order cases allowing for fewer than two arguments. The way of Scheme is to handle the general case; we provide the fully general extension.</p>
<p>A counter-argument to this extension is that R5RS’s transitive binary arithmetic relations (=, &lt;, etc.) require at least two arguments, hence this decision is a break with the prior convention – although it is at least one that is backwards-compatible.</p>
<h2 id="char-set-cs1-...-1"><code>(char-set&lt;= cs1 ...)</code></h2>
<p>Returns true if every character set csi is a subset of character set csi+1.</p>
<p>Boundary cases:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>(char-set&lt;=) <span class="op">=&gt;</span> true</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>(char-set&lt;= cs) <span class="op">=&gt;</span> true</span></code></pre></div>
<p>Rationale: See char-set= for discussion of zero- and one-argument applications. Consider testing a list of char-sets for monotonicity with</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>(apply char-set&lt;= cset-list)</span></code></pre></div>
<h2 id="char-set-hash-cs-bound"><code>(char-set-hash cs [bound])</code></h2>
<p>Compute a hash value for the character set cs. Bound is a non-negative exact integer specifying the range of the hash function. A positive value restricts the return value to the range [0,bound).</p>
<p>If bound is either zero or not given, the implementation may use an implementation-specific default value, chosen to be as large as is efficiently practical. For instance, the default range might be chosen for a given implementation to map all strings into the range of integers that can be represented with a single machine word.</p>
<p>Invariant:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>(char-set= cs1 cs2) <span class="op">=&gt;</span> (<span class="op">=</span> (char-set-hash cs1 b) (char-set-hash cs2 b))</span></code></pre></div>
<p>A legal but nonetheless discouraged implementation:</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(char-set-hash cs <span class="op">.</span> maybe-bound) <span class="dv">1</span>)</span></code></pre></div>
<p>Rationale: allowing the user to specify an explicit bound simplifies user code by removing the mod operation that typically accompanies every hash computation, and also may allow the implementation of the hash function to exploit a reduced range to efficiently compute the hash value. E.g., for small bounds, the hash function may be computed in a fashion such that intermediate values never overflow into bignum integers, allowing the implementor to provide a fixnum-specific “fast path” for computing the common cases very rapidly.</p>
<h2 id="char-set-cursor-cset"><code>(char-set-cursor cset)</code></h2>
<h2 id="char-set-ref-cset-cursor"><code>(char-set-ref cset cursor)</code></h2>
<h2 id="char-set-cursor-next-cset-cursor"><code>(char-set-cursor-next cset cursor)</code></h2>
<h2 id="end-of-char-set-cursor"><code>(end-of-char-set? cursor)</code></h2>
<p>Cursors are a low-level facility for iterating over the characters in a set. A cursor is a value that indexes a character in a char set. char-set-cursor produces a new cursor for a given char set. The set element indexed by the cursor is fetched with char-set-ref. A cursor index is incremented with char-set-cursor-next; in this way, code can step through every character in a char set. Stepping a cursor “past the end” of a char set produces a cursor that answers true to end-of-char-set?. It is an error to pass such a cursor to char-set-ref or to char-set-cursor-next.</p>
<p>A cursor value may not be used in conjunction with a different character set; if it is passed to char-set-ref or char-set-cursor-next with a character set other than the one used to create it, the results and effects are undefined.</p>
<p>Cursor values are not necessarily distinct from other types. They may be integers, linked lists, records, procedures or other values. This license is granted to allow cursors to be very “lightweight” values suitable for tight iteration, even in fairly simple implementations.</p>
<p>Note that these primitives are necessary to export an iteration facility for char sets to loop macros.</p>
<p>Example:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>    (<span class="ex">define</span><span class="fu"> cs </span>(char-set <span class="ch">#\G</span> <span class="ch">#\a</span> <span class="ch">#\T</span> <span class="ch">#\e</span> <span class="ch">#\c</span> <span class="ch">#\h</span>))</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; Collect elts of CS into a list.</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">let</span> lp ((cur (char-set-cursor cs)) (ans &#39;()))</span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">if</span> (end-of-char-set? cur) ans</span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a>          (lp (char-set-cursor-next cs cur)</span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a>              (<span class="kw">cons</span> (char-set-ref cs cur) ans))))</span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>      <span class="op">=&gt;</span> (<span class="ch">#\G</span> <span class="ch">#\T</span> <span class="ch">#\a</span> <span class="ch">#\c</span> <span class="ch">#\e</span> <span class="ch">#\h</span>)</span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; Equivalently, using a list unfold (from SRFI 1):</span></span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a>    (unfold-right end-of-char-set?</span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a>                  (curry char-set-ref cs)</span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a>              (curry char-set-cursor-next cs)</span>
<span id="cb107-14"><a href="#cb107-14" aria-hidden="true" tabindex="-1"></a>              (char-set-cursor cs))</span>
<span id="cb107-15"><a href="#cb107-15" aria-hidden="true" tabindex="-1"></a>      <span class="op">=&gt;</span> (<span class="ch">#\G</span> <span class="ch">#\T</span> <span class="ch">#\a</span> <span class="ch">#\c</span> <span class="ch">#\e</span> <span class="ch">#\h</span>)</span></code></pre></div>
<p>Rationale: Note that the cursor API’s four functions “fit” the functional protocol used by the unfolders provided by the list, string and char-set SRFIs (see the example above). By way of contrast, here is a simpler, two-function API that was rejected for failing this criterion. Besides char-set-cursor, it provided a single function that mapped a cursor and a character set to two values, the indexed character and the next cursor. If the cursor had exhausted the character set, then this function returned false instead of the character value, and another end-of-char-set cursor. In this way, the other three functions of the current API were combined together.</p>
<h2 id="char-set-fold-kons-knil-cs"><code>(char-set-fold kons knil cs)</code></h2>
<p>This is the fundamental iterator for character sets. Applies the function kons across the character set cs using initial state value knil. That is, if cs is the empty set, the procedure returns knil. Otherwise, some element c of cs is chosen; let cs’ be the remaining, unchosen characters. The procedure returns</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>    (char-set-fold kons (kons c knil) cs&#39;)</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>    Examples:</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; CHAR-SET-MEMBERS</span></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">lambda</span> (cs) (char-set-fold <span class="kw">cons</span> &#39;() cs))</span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; CHAR-SET-SIZE</span></span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">lambda</span> (cs) (char-set-fold (<span class="kw">lambda</span> (c i) (<span class="op">+</span> i <span class="dv">1</span>)) <span class="dv">0</span> cs))</span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; How many vowels in the char set?</span></span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">lambda</span> (cs)</span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a>      (char-set-fold (<span class="kw">lambda</span> (c i) (<span class="kw">if</span> (vowel? c) (<span class="op">+</span> i <span class="dv">1</span>) i))</span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true" tabindex="-1"></a>                     <span class="dv">0</span> cs))</span></code></pre></div>
<h2 id="char-set-unfold-f-p-g-seed-base-cs"><code>(char-set-unfold f p g seed [base-cs])</code></h2>
<h2 id="char-set-unfold-f-p-g-seed-base-cs-1"><code>(char-set-unfold! f p g seed base-cs)</code></h2>
<p>This is a fundamental constructor for char-sets.</p>
<ul>
<li><p>G is used to generate a series of “seed” values from the initial seed: seed, (g seed), (g2 seed), (g3 seed), …</p></li>
<li><p>P tells us when to stop – when it returns true when applied to one of these seed values.</p></li>
<li><p>F maps each seed value to a character. These characters are added to the base character set base-cs to form the result; base-cs defaults to the empty set. char-set-unfold! adds the characters to base-cs in a linear-update – it is allowed, but not required, to side-effect and use base-cs’s storage to construct the result.</p></li>
</ul>
<p>More precisely, the following definitions hold, ignoring the optional-argument issues:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>    (<span class="ex">define</span><span class="fu"> </span>(char-set-unfold p f g seed base-cs)</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>      (char-set-unfold! p f g seed (char-set-copy base-cs)))</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>    (<span class="ex">define</span><span class="fu"> </span>(char-set-unfold! p f g seed base-cs)</span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">let</span> lp ((seed seed) (cs base-cs))</span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>            (<span class="kw">if</span> (p seed) cs                                 <span class="co">; P says we are done.</span></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a>                (lp (g seed)                                <span class="co">; Loop on (G SEED).</span></span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a>                    (char-set-adjoin! cs (f seed))))))      <span class="co">; Add (F SEED) to set.</span></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a>    (Note that the actual implementation may be more efficient.)</span></code></pre></div>
<p>Examples:</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>    (port-&gt;char-set p) <span class="op">=</span> (char-set-unfold <span class="kw">eof-object?</span> <span class="kw">values</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>                                          (<span class="kw">lambda</span> (x) (<span class="kw">read-char</span> p))</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>                                          (<span class="kw">read-char</span> p))</span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>    (list-&gt;char-set lis) <span class="op">=</span> (char-set-unfold <span class="kw">null?</span> <span class="kw">car</span> <span class="kw">cdr</span> lis)</span></code></pre></div>
<h2 id="char-set-for-each-proc-cs"><code>(char-set-for-each proc cs)</code></h2>
<p>Apply procedure proc to each character in the character set cs. Note that the order in which proc is applied to the characters in the set is not specified, and may even change from one procedure application to another.</p>
<p>Nothing at all is specified about the value returned by this procedure; it is not even required to be consistent from call to call. It is simply required to be a value (or values) that may be passed to a command continuation, e.g. as the value of an expression appearing as a non-terminal subform of a begin expression. Note that in R5RS, this restricts the procedure to returning a single value; non-R5RS systems may not even provide this restriction. char-set-map proc cs -&gt; char-set proc is a char-&gt;char procedure. Apply it to all the characters in the char-set cs, and collect the results into a new character set.</p>
<p>Essentially lifts proc from a char-&gt;char procedure to a char-set -&gt; char-set procedure.</p>
<p>Example:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a>(char-set-map <span class="kw">char-downcase</span> cset)</span></code></pre></div>
<h2 id="char-set-copy-cs"><code>(char-set-copy cs)</code></h2>
<p>Returns a copy of the character set cs. “Copy” means that if either the input parameter or the result value of this procedure is passed to one of the linear-update procedures described below, the other character set is guaranteed not to be altered.</p>
<p>A system that provides pure-functional implementations of the linear-operator suite could implement this procedure as the identity function – so copies are not guaranteed to be distinct by eq?.</p>
<h2 id="char-set-char1-..."><code>(char-set char1 ...)</code></h2>
<p>Return a character set containing the given characters.</p>
<h2 id="list-char-set-char-list-base-cs"><code>(list-&gt;char-set  char-list [base-cs])</code></h2>
<h2 id="list-char-set-char-list-base-cs-1"><code>(list-&gt;char-set! char-list base-cs)</code></h2>
<p>Return a character set containing the characters in the list of characters char-list.</p>
<p>If character set base-cs is provided, the characters from char-list are added to it. list-&gt;char-set! is allowed, but not required, to side-effect and reuse the storage in base-cs; list-&gt;char-set produces a fresh character set.</p>
<h2 id="string-char-set-s-base-cs"><code>(string-&gt;char-set  s [base-cs])</code></h2>
<h2 id="string-char-set-s-base-cs-1"><code>(string-&gt;char-set! s base-cs)</code></h2>
<p>Return a character set containing the characters in the string s.</p>
<p>If character set base-cs is provided, the characters from s are added to it. string-&gt;char-set! is allowed, but not required, to side-effect and reuse the storage in base-cs; string-&gt;char-set produces a fresh character set.</p>
<h2 id="char-set-filter-pred-cs-base-cs"><code>(char-set-filter  pred cs [base-cs])</code></h2>
<h2 id="char-set-filter-pred-cs-base-cs-1"><code>(char-set-filter! pred cs base-cs)</code></h2>
<p>Returns a character set containing every character c in cs such that (pred c) returns true.</p>
<p>If character set base-cs is provided, the characters specified by pred are added to it. char-set-filter! is allowed, but not required, to side-effect and reuse the storage in base-cs; char-set-filter produces a fresh character set.</p>
<p>An implementation may not save away a reference to pred and invoke it after char-set-filter or char-set-filter! returns – that is, “lazy,” on-demand implementations are not allowed, as pred may have external dependencies on mutable data or have other side-effects.</p>
<p>Rationale: This procedure provides a means of converting a character predicate into its equivalent character set; the cs parameter allows the programmer to bound the predicate’s domain. Programmers should be aware that filtering a character set such as char-set:full could be a very expensive operation in an implementation that provided an extremely large character type, such as 32-bit Unicode. An earlier draft of this library provided a simple predicate-&gt;char-set procedure, which was rejected in favor of char-set-filter for this reason.</p>
<h2 id="ucs-range-char-set-lower-upper-error-base-cs"><code>(ucs-range-&gt;char-set  lower upper [error? base-cs])</code></h2>
<h2 id="ucs-range-char-set-lower-upper-error-base-cs-1"><code>(ucs-range-&gt;char-set! lower upper error? base-cs)</code></h2>
<p>Lower and upper are exact non-negative integers; lower &lt;= upper.</p>
<p>Returns a character set containing every character whose ISO/IEC 10646 UCS-4 code lies in the half-open range [lower,upper).</p>
<p>If the requested range includes unassigned UCS values, these are silently ignored (the current UCS specification has “holes” in the space of assigned codes).</p>
<p>If the requested range includes “private” or “user space” codes, these are handled in an implementation-specific manner; however, a UCS- or Unicode-based Scheme implementation should pass them through transparently.</p>
<p>If any code from the requested range specifies a valid, assigned UCS character that has no corresponding representative in the implementation’s character type, then (1) an error is raised if error? is true, and (2) the code is ignored if error? is false (the default). This might happen, for example, if the implementation uses ASCII characters, and the requested range includes non-ASCII characters.</p>
<p>If character set base-cs is provided, the characters specified by the range are added to it. ucs-range-&gt;char-set! is allowed, but not required, to side-effect and reuse the storage in base-cs; ucs-range-&gt;char-set produces a fresh character set.</p>
<p>Note that ASCII codes are a subset of the Latin-1 codes, which are in turn a subset of the 16-bit Unicode codes, which are themselves a subset of the 32-bit UCS-4 codes. We commit to a specific encoding in this routine, regardless of the underlying representation of characters, so that client code using this library will be portable. I.e., a conformant Scheme implementation may use EBCDIC or SHIFT-JIS to encode characters; it must simply map the UCS characters from the given range into the native representation when possible, and report errors when not possible.</p>
<h2 id="char-set-x"><code>(-&gt;char-set x)</code></h2>
<p>Coerces x into a char-set. X may be a string, character or char-set. A string is converted to the set of its constituent characters; a character is converted to a singleton set; a char-set is returned as-is. This procedure is intended for use by other procedures that want to provide “user-friendly,” wide-spectrum interfaces to their clients.</p>
<h2 id="char-set-size-cs"><code>(char-set-size cs)</code></h2>
<p>Returns the number of elements in character set cs.</p>
<h2 id="char-set-count-pred-cs"><code>(char-set-count pred cs)</code></h2>
<p>Apply pred to the chars of character set cs, and return the number of chars that caused the predicate to return true.</p>
<h2 id="char-set-list-cs"><code>(char-set-&gt;list cs)</code></h2>
<p>This procedure returns a list of the members of character set cs. The order in which cs’s characters appear in the list is not defined, and may be different from one call to another.</p>
<h2 id="char-set-string-cs"><code>(char-set-&gt;string cs)</code></h2>
<p>This procedure returns a string containing the members of character set cs. The order in which cs’s characters appear in the string is not defined, and may be different from one call to another.</p>
<h2 id="char-set-contains-cs-char"><code>(char-set-contains? cs char)</code></h2>
<p>This procedure tests char for membership in character set cs.</p>
<p>The MIT Scheme character-set package called this procedure char-set-member?, but the argument order isn’t consistent with the name.</p>
<h2 id="char-set-every-pred-cs"><code>(char-set-every pred cs)</code></h2>
<h2 id="char-set-any-pred-cs"><code>(char-set-any   pred cs)</code></h2>
<p>The char-set-every procedure returns true if predicate pred returns true of every character in the character set cs. Likewise, char-set-any applies pred to every character in character set cs, and returns the first true value it finds. If no character produces a true value, it returns false. The order in which these procedures sequence through the elements of cs is not specified.</p>
<p>Note that if you need to determine the actual character on which a predicate returns true, use char-set-any and arrange for the predicate to return the character parameter as its true value, e.g.</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>    (char-set-any (<span class="kw">lambda</span> (c) (<span class="kw">and</span> (<span class="kw">char-upper-case?</span> c) c))</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>                  cs)</span></code></pre></div>
<h2 id="char-set-adjoin-cs-char1-..."><code>(char-set-adjoin cs char1 ...)</code></h2>
<h2 id="char-set-delete-cs-char1-..."><code>(char-set-delete cs char1 ...)</code></h2>
<p>Add/delete the chari characters to/from character set cs.</p>
<h2 id="char-set-adjoin-cs-char1-...-1"><code>(char-set-adjoin! cs char1 ...)</code></h2>
<h2 id="char-set-delete-cs-char1-...-1"><code>(char-set-delete! cs char1 ...)</code></h2>
<p>Linear-update variants. These procedures are allowed, but not required, to side-effect their first parameter.</p>
<h2 id="char-set-complement-cs"><code>(char-set-complement cs)</code></h2>
<h2 id="char-set-union-cs1-..."><code>(char-set-union cs1 ...)</code></h2>
<h2 id="char-set-intersection-cs1-..."><code>(char-set-intersection cs1 ...)</code></h2>
<h2 id="char-set-difference-cs1-cs2-..."><code>(char-set-difference cs1 cs2 ...)</code></h2>
<h2 id="char-set-xor-cs1-..."><code>(char-set-xor cs1 ...)</code></h2>
<h2 id="char-set-diffintersection-cs1-cs2-..."><code>(char-set-diff+intersection cs1 cs2 ...)</code></h2>
<p>These procedures implement set complement, union, intersection, difference, and exclusive-or for character sets. The union, intersection and xor operations are n-ary. The difference function is also n-ary, associates to the left (that is, it computes the difference between its first argument and the union of all the other arguments), and requires at least one argument.</p>
<p>Boundary cases:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>(char-set-union) <span class="op">=&gt;</span> char-set:empty</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>(char-set-intersection) <span class="op">=&gt;</span> char-set:full</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>(char-set-xor) <span class="op">=&gt;</span> char-set:empty</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>(char-set-difference cs) <span class="op">=&gt;</span> cs</span></code></pre></div>
<p>char-set-diff+intersection returns both the difference and the intersection of the arguments – it partitions its first parameter. It is equivalent to</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">values</span> (char-set-difference cs1 cs2 <span class="op">...</span>)</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>        (char-set-intersection cs1 (char-set-union cs2 <span class="op">...</span>)))</span></code></pre></div>
<p>but can be implemented more efficiently.</p>
<p>Programmers should be aware that char-set-complement could potentially be a very expensive operation in Scheme implementations that provide a very large character type, such as 32-bit Unicode. If this is a possibility, sets can be complimented with respect to a smaller universe using char-set-difference.</p>
<h2 id="char-set-complement-cs-1"><code>(char-set-complement! cs)</code></h2>
<h2 id="char-set-union-cs1-cs2-..."><code>(char-set-union! cs1 cs2 ...)</code></h2>
<h2 id="char-set-intersection-cs1-cs2-..."><code>(char-set-intersection! cs1 cs2 ...)</code></h2>
<h2 id="char-set-difference-cs1-cs2-...-1"><code>(char-set-difference! cs1 cs2 ...)</code></h2>
<h2 id="char-set-xor-cs1-cs2-..."><code>(char-set-xor! cs1 cs2 ...)</code></h2>
<h2 id="char-set-diffintersection-cs1-cs2-cs3-..."><code>(char-set-diff+intersection! cs1 cs2 cs3 ...)</code></h2>
<p>These are linear-update variants of the set-algebra functions. They are allowed, but not required, to side-effect their first (required) parameter.</p>
<p>char-set-diff+intersection! is allowed to side-effect both of its two required parameters, cs1 and cs2.</p>
<h2 id="char-setlower-case"><code>char-set:lower-case</code></h2>
<p>Lower-case letters</p>
<h2 id="char-setupper-case"><code>char-set:upper-case</code></h2>
<p>Upper-case letters</p>
<h2 id="char-settitle-case"><code>char-set:title-case</code></h2>
<p>Title-case letters</p>
<h2 id="char-setletter"><code>char-set:letter</code></h2>
<p>Letters</p>
<h2 id="char-setdigit"><code>char-set:digit</code></h2>
<p>Digits</p>
<h2 id="char-setletterdigit"><code>char-set:letter+digit</code></h2>
<p>Letters and digits</p>
<h2 id="char-setgraphic"><code>char-set:graphic</code></h2>
<p>Printing characters except spaces</p>
<h2 id="char-setprinting"><code>char-set:printing</code></h2>
<p>Printing characters including spaces</p>
<h2 id="char-setwhitespace"><code>char-set:whitespace</code></h2>
<p>Whitespace characters</p>
<h2 id="char-setiso-control"><code>char-set:iso-control</code></h2>
<p>The ISO control characters</p>
<h2 id="char-setpunctuation"><code>char-set:punctuation</code></h2>
<p>Punctuation characters</p>
<h2 id="char-setsymbol"><code>char-set:symbol</code></h2>
<p>Symbol characters</p>
<h2 id="char-sethex-digit"><code>char-set:hex-digit</code></h2>
<p>A hexadecimal digit: 0-9, A-F, a-f</p>
<h2 id="char-setblank"><code>char-set:blank</code></h2>
<p>Blank characters – horizontal whitespace</p>
<h2 id="char-setascii"><code>char-set:ascii</code></h2>
<p>All characters in the ASCII set.</p>
<h2 id="char-setempty"><code>char-set:empty</code></h2>
<p>Empty set</p>
<h2 id="char-setfull"><code>char-set:full</code></h2>
<p>All characters # <code>(scheme process-context)</code></p>
<h2 id="command-line"><code>(command-line)</code></h2>
<p>Returns the command line passed to the process as a list of strings. The first string corresponds to the command name, and is implementation-dependent. It is an error to mutate any of these .</p>
<h2 id="emergency-exit-obj"><code>(emergency-exit [obj])</code></h2>
<p>Terminates the program without running any outstanding dynamic-wind after procedures and communicates an exit value to the operating sstem the same manner as exit.</p>
<h2 id="exit-obj"><code>(exit [obj])</code></h2>
<p>Runs all outstanding dynamic-wind after procedures, terminates the running program, and communicates an exit value to the operating system. If no argument is supplied, or if obj is #t, the exit procedure should communicate to the operating system that the program exited normally. If obj is #f, the exit procedure should communicate to the operating system that the program exited abnormally. Otherwise, exit should translate obj into an appropriate exit value for the oerating , if possible.</p>
<h2 id="get-environment-variable-name"><code>(get-environment-variable name)</code></h2>
<p>Many operating systems provide each running process with an environment consisting of environment variables. Both the name and value of an environment variable are strings. The procedure get-environment-variable returns the value of the environment variable name, or #f if the named environment variable is not found. It may use locale information to encode the name and decode the value of the environment variable. It is an error if get-environment-variable canâ€™t decode the value. It is also an error to mutate the resulting .</p>
<h2 id="get-environment-variables"><code>(get-environment-variables)</code></h2>
<p>Returns the names and values of all the environment variables as an alist, where the car of each entry is the name of an environment variable and the cdr is its value, both as strings. The order of the list is unspecified. It is an error to mutate any of these strings or the alist itself.</p>
<h1 id="scheme-case-lambda"><code>(scheme case-lambda)</code></h1>
<h2 id="case-lambda-clause1-...-syntax"><code>(case-lambda &lt;clause1&gt; ...)</code> syntax</h2>
<p>Each clause is of the form <code>(&lt;formals&gt; &lt;body&gt;)</code>, where <code>&lt;formals&gt;</code> and <code>&lt;body&gt;</code> have the same syntax as in a lambda expression.</p>
<p>A case-lambda expression evaluates to a procedure that accepts a variable number of arguments and is lexically scoped in the same manner as a procedure resulting from a lambda expression. When the procedure is called, the first clause for which the arguments agree with <code>&lt;formals&gt;</code> is selected, where agreement is specified as for the <code>&lt;formals&gt;</code> of a lambda expression. The variables of <code>&lt;formals&gt;</code> are bound to fresh locations, the values of the arguments are stored in those locations, the <code>&lt;body&gt;</code> is evaluated in the extended environment, and the results of <code>&lt;body&gt;</code> are returned as the results of the procedure call.</p>
<p>It is an error for the arguments not to agree with the <code>&lt;formals&gt;</code> of any clause`.</p>
<p>Example:</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> add1</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">case-lambda</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>    ((a) (add1 a <span class="dv">0</span>))</span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>    ((a b) (<span class="op">+</span> <span class="dv">1</span> a b))))</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>(add1 <span class="dv">1</span>) <span class="co">;; =&gt; 2</span></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a>(add1 <span class="dv">1</span> <span class="dv">2</span>) <span class="co">;; =&gt; 4</span></span></code></pre></div>
<h1 id="scheme-text"><code>(scheme text)</code></h1>
<p>This is based on <a href="https://srfi.schemers.org/srfi-135/">SRFI-135</a>.</p>
<p>In Scheme, strings are a mutable data type. Although it “is an error” (R5RS and R7RS) to use string-set! on literal strings or on strings returned by symbol-&gt;string, and any attempt to do so “should raise an exception” (R6RS), all other strings are mutable.</p>
<p>Although many mutable strings are never actually mutated, the mere possibility of mutation complicates specifications of libraries that use strings, encourages precautionary copying of strings, and precludes structure sharing that could otherwise be used to make procedures such as substring and string-append faster and more space-efficient.</p>
<p>This SRFI specifies a new data type of immutable texts. It comes with efficient and portable sample implementations that guarantee O(1) indexing for both sequential and random access, even in systems whose string-ref procedure takes linear time.</p>
<p>The operations of this new data type include analogues for all of the non-mutating operations on strings specified by the R7RS and most of those specified by SRFI 130, but the immutability of texts and uniformity of character-based indexing simplify the specification of those operations while avoiding several inefficiencies associated with the mutability of Scheme’s strings.</p>
<h2 id="text-obj"><code>(text? obj)</code></h2>
<p>Is obj an immutable text? In particular, (text? obj) returns false if (string? obj) returns true, which implies string? returns false if text? returns true. Must execute in O(1) time.</p>
<h2 id="textual-obj"><code>(textual? obj)</code></h2>
<p>Returns true if and only obj is an immutable text or a string. Must execute in O(1) time.</p>
<h2 id="textual-null-text"><code>(textual-null? text)</code></h2>
<p>Is text the empty text? Must execute in O(1) time.</p>
<h2 id="textual-every-pred-textual-start-end"><code>(textual-every pred textual [start end])</code></h2>
<h2 id="textual-any-pred-textual-start-end"><code>(textual-any   pred textual [start end])</code></h2>
<p>Checks to see if every/any character in textual satisfies pred, proceeding from left (index start) to right (index end). textual-every These procedures are short-circuiting: if pred returns false, textual-every does not call pred on subsequent characters; if pred returns true, textual-any does not call pred on subsequent characters; Both procedures are “witness-generating”:</p>
<ul>
<li><p>If textual-every is given an empty interval (with start = end), it returns #t.</p></li>
<li><p>If textual-every returns true for a non-empty interval (with start &lt; end), the returned true value is the one returned by the final call to the predicate on (text-ref (textual-copy text) (- end 1)).</p></li>
<li><p>If textual-any returns true, the returned true value is the one returned by the predicate.</p></li>
</ul>
<p>Note: The names of these procedures do not end with a question mark. This indicates a general value is returned instead of a simple boolean (#t or #f).</p>
<h2 id="make-text-len-char"><code>(make-text len char)</code></h2>
<p>Returns a text of the given length filled with the given character.</p>
<h2 id="text-char-..."><code>(text char ...)</code></h2>
<p>Returns a text consisting of the given characters.</p>
<h2 id="text-tabulate-proc-len"><code>(text-tabulate proc len)</code></h2>
<p>Proc is a procedure that accepts an exact integer as its argument and returns a character. Constructs a text of size len by calling proc on each value from 0 (inclusive) to len (exclusive) to produce the corresponding element of the text. The order in which proc is called on those indexes is not specified.</p>
<p>Rationale: Although text-unfold is more general, text-tabulate is likely to run faster for the common special case it implements.</p>
<h2 id="text-unfold-stop-mapper-successor-seed-base-make-final"><code>(text-unfold stop? mapper successor seed [base make-final])</code></h2>
<p>This is a fundamental constructor for texts.</p>
<ul>
<li><p>successor is used to generate a series of “seed” values from the initial seed:</p></li>
<li><p>seed, (successor seed), (successor2 seed), (successor3 seed), …</p></li>
<li><p>stop? tells us when to stop — when it returns true when applied to one of these seed values.</p></li>
<li><p>mapper maps each seed value to the corresponding character(s) in the result text, which are assembled into that text in left-to-right order. It is an error for mapper to return anything other than a character, string, or text.</p></li>
<li><p>base is the optional initial/leftmost portion of the constructed text, which defaults to the empty text (text). It is an error if base is anything other than a character, string, or text.</p></li>
<li><p>make-final is applied to the terminal seed value (on which stop? returns true) to produce the final/rightmost portion of the constructed text. It defaults to (lambda (x) (text)). It is an error for make-final to return anything other than a character, string, or text.</p></li>
</ul>
<p>text-unfold is a fairly powerful text constructor. You can use it to convert a list to a text, read a port into a text, reverse a text, copy a text, and so forth. Examples:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>    (port-&gt;text p) <span class="op">=</span> (text-unfold <span class="kw">eof-object?</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>                               <span class="kw">values</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>                               (<span class="kw">lambda</span> (x) (<span class="kw">read-char</span> p))</span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>                               (<span class="kw">read-char</span> p))</span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a>    (list-&gt;text lis) <span class="op">=</span> (text-unfold <span class="kw">null?</span> <span class="kw">car</span> <span class="kw">cdr</span> lis)</span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>    (text-tabulate f size) <span class="op">=</span> (text-unfold (<span class="kw">lambda</span> (i) (<span class="op">=</span> i size)) f add1 <span class="dv">0</span>)</span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>    To map f over a <span class="kw">list</span> lis, producing a text:</span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a>    (text-unfold <span class="kw">null?</span> (compose f <span class="kw">car</span>) <span class="kw">cdr</span> lis)</span></code></pre></div>
<p>Interested functional programmers may enjoy noting that textual-fold-right and text-unfold are in some sense inverses. That is, given operations knull?, kar, kdr, kons, and knil satisfying</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>(kons (kar x) (kdr x)) <span class="op">=</span> x  <span class="kw">and</span>  (knull? knil) <span class="op">=</span> <span class="dv">#t</span></span></code></pre></div>
<p>then</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>(textual-fold-right kons knil (text-unfold knull? kar kdr x)) <span class="op">=</span> x</span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>(text-unfold knull? kar kdr (textual-fold-right kons knil text)) <span class="op">=</span> text.</span></code></pre></div>
<p>This combinator pattern is sometimes called an “anamorphism.”</p>
<p>Note: Implementations should not allow the size of texts created by text-unfold to be limited by limits on stack size.</p>
<h2 id="text-unfold-right-stop-mapper-successor-seed-base-make-final"><code>(text-unfold-right stop? mapper successor seed [base make-final])</code></h2>
<p>This is a fundamental constructor for texts. It is the same as text-unfold except the results of mapper are assembled into the text in right-to-left order, base is the optional rightmost portion of the constructed text, and make-final produces the leftmost portion of the constructed text.</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>    (text-unfold-right (<span class="kw">lambda</span> (n) (<span class="op">&lt;</span> n (<span class="kw">char-&gt;integer</span> <span class="ch">#\A</span>)))</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>                       (<span class="kw">lambda</span> (n) (<span class="kw">char-downcase</span> (<span class="kw">integer-&gt;char</span> n)))</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>                       (<span class="kw">lambda</span> (n) (<span class="op">-</span> n <span class="dv">1</span>))</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>                       (<span class="kw">char-&gt;integer</span> <span class="ch">#\Z</span>)</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>                       <span class="ch">#\</span><span class="er">space</span></span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>                       (<span class="kw">lambda</span> (n) <span class="st">&quot; The English alphabet: &quot;</span>))</span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">=&gt;</span> « The English alphabet: abcdefghijklmnopqrstuvwxyz »</span></code></pre></div>
<h2 id="textual-text-textual"><code>(textual-&gt;text textual)</code></h2>
<p>When given a text, textual-&gt;text just returns that text. When given a string, textual-&gt;text returns the result of calling string-&gt;text on that string. Signals an error when its argument is neither string nor text.</p>
<h2 id="textual-string-textual-start-end"><code>(textual-&gt;string textual [start end])</code></h2>
<h2 id="textual-vector-textual-start-end"><code>(textual-&gt;vector textual [start end])</code></h2>
<h2 id="textual-list-textual-start-end"><code>(textual-&gt;list   textual [start end])</code></h2>
<p>textual-&gt;string, textual-&gt;vector, and textual-&gt;list return a newly allocated (unless empty) mutable string, vector, or list of the characters that make up the given subtext or substring.</p>
<h2 id="string-text-string-start-end"><code>(string-&gt;text string [start end])</code></h2>
<h2 id="vector-text-char-vector-start-end"><code>(vector-&gt;text char-vector [start end])</code></h2>
<h2 id="list-text-char-list-start-end"><code>(list-&gt;text   char-list [start end])</code></h2>
<p>These procedures return a text containing the characters of the given substring, subvector, or sublist. The behavior of the text will not be affected by subsequent mutation of the given string, vector, or list.</p>
<h2 id="reverse-list-text-char-list"><code>(reverse-list-&gt;text char-list)</code></h2>
<p>An efficient implementation of (compose list-&gt;text reverse):</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>(reverse-list-&gt;text &#39;(<span class="ch">#\a</span> <span class="ch">#\B</span> <span class="ch">#\c</span>)) → «cBa»</span></code></pre></div>
<p>This is a common idiom in the epilogue of text-processing loops that accumulate their result using a list in reverse order. (See also textual-concatenate-reverse for the “chunked” variant.)</p>
<h2 id="textual-utf8-textual-start-end"><code>(textual-&gt;utf8    textual [start end])</code></h2>
<h2 id="textual-utf16-textual-start-end"><code>(textual-&gt;utf16   textual [start end])</code></h2>
<h2 id="textual-utf16be-textual-start-end"><code>(textual-&gt;utf16be textual [start end])</code></h2>
<h2 id="textual-utf16le-textual-start-end"><code>(textual-&gt;utf16le textual [start end])</code></h2>
<p>These procedures return a newly allocated (unless empty) bytevector containing a UTF-8 or UTF-16 encoding of the given subtext or substring.</p>
<p>The bytevectors returned by textual-&gt;utf8, textual-&gt;utf16be, and textual-&gt;utf16le do not contain a byte-order mark (BOM). textual-&gt;utf16be returns a big-endian encoding, while textual-&gt;utf16le returns a little-endian encoding.</p>
<p>The bytevectors returned by textual-&gt;utf16 begin with a BOM that declares an implementation-dependent endianness, and the bytevector elements following that BOM encode the given subtext or substring using that endianness.</p>
<p>Rationale: These procedures are consistent with the Unicode standard. Unicode suggests UTF-16 should default to big-endian, but Microsoft prefers little-endian.</p>
<h2 id="utf8-text-bytevector-start-end"><code>(utf8-&gt;text    bytevector [start end])</code></h2>
<h2 id="utf16-text-bytevector-start-end"><code>(utf16-&gt;text   bytevector [start end])</code></h2>
<h2 id="utf16be-text-bytevector-start-end"><code>(utf16be-&gt;text bytevector [start end])</code></h2>
<h2 id="utf16le-text-bytevector-start-end"><code>(utf16le-&gt;text bytevector [start end])</code></h2>
<p>These procedures interpret their bytevector argument as a UTF-8 or UTF-16 encoding of a sequence of characters, and return a text containing that sequence.</p>
<p>The bytevector subrange given to utf16-&gt;text may begin with a byte order mark (BOM); if so, that BOM determines whether the rest of the subrange is to be interpreted as big-endian or little-endian; in either case, the BOM will not become a character in the returned text. If the subrange does not begin with a BOM, it is decoded using the same implementation-dependent endianness used by textual-&gt;utf16.</p>
<p>The utf16be-&gt;text and utf16le-&gt;text procedures interpret their inputs as big-endian or little-endian, respectively. If a BOM is present, it is treated as a normal character and will become part of the result.</p>
<p>It is an error if the bytevector subrange given to utf8-&gt;text contains invalid UTF-8 byte sequences. For the other three procedures, it is an error if start or end are odd, or if the bytevector subrange contains invalid UTF-16 byte sequences.</p>
<h2 id="text-length-text"><code>(text-length text)</code></h2>
<p>Returns the number of characters within the given text. Must execute in O(1) time.</p>
<h2 id="text-ref-text-idx"><code>(text-ref text idx)</code></h2>
<p>Returns character text[idx], using 0-origin indexing. Must execute in O(1) time.</p>
<h2 id="textual-length-textual"><code>(textual-length textual)</code></h2>
<h2 id="textual-ref-textual-idx"><code>(textual-ref textual idx)</code></h2>
<p>textual-length returns the number of characters in textual, and textual-ref returns the character at character index idx, using 0-origin indexing. These procedures are the generalizations of text-length and text-ref to accept strings as well as texts. If textual is a text, they must execute in O(1) time, but there is no such requirement if textual is a string.</p>
<p>Rationale: These procedures may be more convenient than the text-only versions, but compilers may generate faster code for calls to the text-only versions.</p>
<h2 id="subtext-text-start-end"><code>(subtext    text start end)</code></h2>
<h2 id="subtextual-textual-start-end"><code>(subtextual textual start end)</code></h2>
<p>These procedures return a text containing the characters of text or textual beginning with index start (inclusive) and ending with index end (exclusive).</p>
<p>If textual is a string, then that string does not share any storage with the result, so subsequent mutation of that string will not affect the text returned by subtextual. When the first argument is a text, as is required by subtext, implementations are encouraged to return a result that shares storage with that text, to whatever extent sharing is possible while maintaining some small fixed bound on the ratio of storage used by the shared representation divided by the storage that would be used by an unshared representation. In particular, these procedures should just return their first argument when that argument is a text, start is 0, and end is the length of that text.</p>
<h2 id="textual-copy-textual-start-end"><code>(textual-copy textual [start end])</code></h2>
<p>Returns a text containing the characters of textual beginning with index start (inclusive) and ending with index end (exclusive).</p>
<p>Unlike subtext and subtextual, the result of textual-copy never shares substructures that would retain characters or sequences of characters that are substructures of its first argument or previously allocated objects.</p>
<p>If textual-copy returns an empty text, that empty text may be eq? or eqv? to the text returned by (text). If the text returned by textual-copy is non-empty, then it is not eqv? to any previously extant object.</p>
<h2 id="textual-take-textual-nchars"><code>(textual-take       textual nchars)</code></h2>
<h2 id="textual-drop-textual-nchars"><code>(textual-drop       textual nchars)</code></h2>
<h2 id="textual-take-right-textual-nchars"><code>(textual-take-right textual nchars)</code></h2>
<h2 id="textual-drop-right-textual-nchars"><code>(textual-drop-right textual nchars)</code></h2>
<p>textual-take returns a text containing the first nchars of textual; textual-drop returns a text containing all but the first nchars of textual. textual-take-right returns a text containing the last nchars of textual; textual-drop-right returns a text containing all but the last nchars of textual.</p>
<p>If textual is a string, then that string does not share any storage with the result, so subsequent mutation of that string will not affect the text returned by these procedures. If textual is a text, implementations are encouraged to return a result that shares storage with that text (which is easily accomplished by using subtext to create the result).</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>(textual-take <span class="st">&quot;Pete Szilagyi&quot;</span> <span class="dv">6</span>) <span class="op">=&gt;</span> «Pete S»</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>(textual-drop <span class="st">&quot;Pete Szilagyi&quot;</span> <span class="dv">6</span>) <span class="op">=&gt;</span> «zilagyi»</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>(textual-take-right <span class="st">&quot;Beta rules&quot;</span> <span class="dv">5</span>) <span class="op">=&gt;</span> «rules»</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>(textual-drop-right <span class="st">&quot;Beta rules&quot;</span> <span class="dv">5</span>) <span class="op">=&gt;</span> «Beta »</span></code></pre></div>
<p>It is an error to take or drop more characters than are in the text:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>(textual-take <span class="st">&quot;foo&quot;</span> <span class="dv">37</span>) <span class="op">=&gt;</span> <span class="kw">error</span></span></code></pre></div>
<h2 id="textual-pad-textual-len-char-start-end"><code>(textual-pad       textual len [char start end])</code></h2>
<h2 id="textual-pad-right-textual-len-char-start-end"><code>(textual-pad-right textual len [char start end])</code></h2>
<p>Returns a text of length len comprised of the characters drawn from the given subrange of textual, padded on the left (right) by as many occurrences of the character char as needed. If textual has more than len chars, it is truncated on the left (right) to length len. char defaults to #.</p>
<p>If textual is a string, then that string does not share any storage with the result, so subsequent mutation of that string will not affect the text returned by these procedures. If textual is a text, implementations are encouraged to return a result that shares storage with that text whenever sharing would be space-efficient.</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>(textual-pad     <span class="st">&quot;325&quot;</span> <span class="dv">5</span>) <span class="op">=&gt;</span> «  <span class="dv">325</span>»</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>(textual-pad   <span class="st">&quot;71325&quot;</span> <span class="dv">5</span>) <span class="op">=&gt;</span> «<span class="dv">71325</span>»</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>(textual-pad <span class="st">&quot;8871325&quot;</span> <span class="dv">5</span>) <span class="op">=&gt;</span> «<span class="dv">71325</span>»</span></code></pre></div>
<h2 id="textual-trim-textual-pred-start-end"><code>(textual-trim       textual [pred start end])</code></h2>
<h2 id="textual-trim-right-textual-pred-start-end"><code>(textual-trim-right textual [pred start end])</code></h2>
<h2 id="textual-trim-both-textual-pred-start-end"><code>(textual-trim-both  textual [pred start end])</code></h2>
<p>Returns a text obtained from the given subrange of textual by skipping over all characters on the left / on the right / on both sides that satisfy the second argument pred: pred defaults to char-whitespace?.</p>
<p>If textual is a string, then that string does not share any storage with the result, so subsequent mutation of that string will not affect the text returned by these procedures. If textual is a text, implementations are encouraged to return a result that shares storage with that text whenever sharing would be space-efficient.</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>(textual-trim-both <span class="st">&quot;  The outlook wasn&#39;t brilliant,  </span><span class="ch">\n\r</span><span class="st">&quot;</span>)</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> «The outlook wasn&#39;t brilliant,»</span></code></pre></div>
<h2 id="textual-replace-textual1-textual2-start1-end1-start2-end2"><code>(textual-replace textual1 textual2 start1 end1 [start2 end2])</code></h2>
<p>Returns</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>    (textual-append (subtextual textual1 <span class="dv">0</span> start1)</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>                    (subtextual textual2 start2 end2)</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>                    (subtextual textual1 end1 (textual-length textual1)))</span></code></pre></div>
<p>That is, the segment of characters in textual1 from start1 to end1 is replaced by the segment of characters in textual2 from start2 to end2. If start1=end1, this simply splices the characters drawn from textual2 into textual1 at that position.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>    (textual-replace <span class="st">&quot;The TCL programmer endured daily ridicule.&quot;</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>                     <span class="st">&quot;another miserable perl drone&quot;</span> <span class="dv">4</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">22</span>)</span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">=&gt;</span> «The miserable perl programmer endured daily ridicule.»</span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>    (textual-replace <span class="st">&quot;It&#39;s easy to code it up in Scheme.&quot;</span> <span class="st">&quot;lots of fun&quot;</span> <span class="dv">5</span> <span class="dv">9</span>)</span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">=&gt;</span> «It&#39;s lots of fun to code it up in Scheme.»</span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a>    (<span class="ex">define</span><span class="fu"> </span>(textual-insert s i t) (textual-replace s t i i))</span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-10"><a href="#cb127-10" aria-hidden="true" tabindex="-1"></a>    (textual-insert <span class="st">&quot;It&#39;s easy to code it up in Scheme.&quot;</span> <span class="dv">5</span> <span class="st">&quot;really &quot;</span>)</span>
<span id="cb127-11"><a href="#cb127-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">=&gt;</span> «It&#39;s really easy to code it up in Scheme.»</span>
<span id="cb127-12"><a href="#cb127-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-13"><a href="#cb127-13" aria-hidden="true" tabindex="-1"></a>    (<span class="ex">define</span><span class="fu"> </span>(textual-set s i c) (textual-replace s (text c) i (<span class="op">+</span> i <span class="dv">1</span>)))</span>
<span id="cb127-14"><a href="#cb127-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-15"><a href="#cb127-15" aria-hidden="true" tabindex="-1"></a>    (textual-set <span class="st">&quot;Text-ref runs in O(n) time.&quot;</span> <span class="dv">19</span> <span class="ch">#\1</span>)</span>
<span id="cb127-16"><a href="#cb127-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">=&gt;</span> «Text-ref runs in O(<span class="dv">1</span>) time.»</span></code></pre></div>
<h2 id="textual-textual1-textual2-textual3-..."><code>(textual=? textual1 textual2 textual3 ...)</code></h2>
<p>Returns #t if all the texts have the same length and contain exactly the same characters in the same positions; otherwise returns #f.</p>
<h2 id="textual-textual1-textual2-textual3-...-1"><code>(textual&lt;?  textual1 textual2 textual3 ...)</code></h2>
<h2 id="textual-textual1-textual2-textual3-...-2"><code>(textual&gt;?  textual1 textual2 textual3 ...)</code></h2>
<h2 id="textual-textual1-textual2-textual3-...-3"><code>(textual&lt;=? textual1 textual2 textual3 ...)</code></h2>
<h2 id="textual-textual1-textual2-textual3-...-4"><code>(textual&gt;=? textual1 textual2 textual3 ...)</code></h2>
<p>These procedures return #t if their arguments are (respectively): monotonically increasing, monotonically decreasing, monotonically non-decreasing, or monotonically non-increasing.</p>
<p>These comparison predicates are required to be transitive.</p>
<p>These procedures compare texts in an implementation-defined way. One approach is to make them the lexicographic extensions to texts of the corresponding orderings on characters. In that case, text&lt;? would be the lexicographic ordering on texts induced by the ordering char&lt;? on characters, and if two texts differ in length but are the same up to the length of the shorter text, the shorter text would be considered to be lexicographically less than the longer string. However, implementations are also allowed to use more sophisticated locale-specific orderings.</p>
<p>In all cases, a pair of texts must satisfy exactly one of textual&lt;?, textual=?, and textual&gt;?, must satisfy textual&lt;=? if and only if they do not satisfy textual&gt;?, and must satisfy textual&gt;=? if and only if they do not satisfy textual&lt;?.</p>
<p>Note: Implementations are encouraged to use the same orderings for texts as are used by the corresponding comparisons on strings, but are allowed to use different orderings.</p>
<p>Rationale: The only portable way to ensure these comparison predicates use the same orderings used by the corresponding comparisons on strings is to convert all texts to strings, which would be unacceptably inefficient.</p>
<h2 id="textual-ci-textual1-textual2-textual3-..."><code>(textual-ci=? textual1 textual2 textual3 ...)</code></h2>
<p>Returns #t if, after calling textual-foldcase on each of the arguments, all of the case-folded texts would have the same length and contain the same characters in the same positions; otherwise returns #f.</p>
<h2 id="textual-ci-textual1-textual2-textual3-...-1"><code>(textual-ci&lt;?  textual1 textual2 textual3 ...)</code></h2>
<h2 id="textual-ci-textual1-textual2-textual3-...-2"><code>(textual-ci&gt;?  textual1 textual2 textual3 ...)</code></h2>
<h2 id="textual-ci-textual1-textual2-textual3-...-3"><code>(textual-ci&lt;=? textual1 textual2 textual3 ...)</code></h2>
<h2 id="textual-ci-textual1-textual2-textual3-...-4"><code>(textual-ci&gt;=? textual1 textual2 textual3 ...)</code></h2>
<p>These procedures behave as though they had called textual-foldcase on their arguments before applying the corresponding procedures without “-ci”.</p>
<h2 id="textual-prefix-length-textual1-textual2-start1-end1-start2-end2"><code>(textual-prefix-length textual1 textual2 [start1 end1 start2 end2])</code></h2>
<h2 id="textual-suffix-length-textual1-textual2-start1-end1-start2-end2"><code>(textual-suffix-length textual1 textual2 [start1 end1 start2 end2])</code></h2>
<p>Return the length of the longest common prefix/suffix of textual1 and textual2. For prefixes, this is equivalent to their “mismatch index” (relative to the start indexes).</p>
<p>The optional start/end indexes restrict the comparison to the indicated subtexts of textual1 and textual2.</p>
<h2 id="textual-prefix-textual1-textual2-start1-end1-start2-end2"><code>(textual-prefix? textual1 textual2 [start1 end1 start2 end2])</code></h2>
<h2 id="textual-suffix-textual1-textual2-start1-end1-start2-end2"><code>(textual-suffix? textual1 textual2 [start1 end1 start2 end2])</code></h2>
<p>Is textual1 a prefix/suffix of textual2?</p>
<p>The optional start/end indexes restrict the comparison to the indicated subtexts of textual1 and textual2.</p>
<h2 id="textual-index-textual-pred-start-end"><code>(textual-index       textual pred [start end])</code></h2>
<h2 id="textual-index-right-textual-pred-start-end"><code>(textual-index-right textual pred [start end])</code></h2>
<h2 id="textual-skip-textual-pred-start-end"><code>(textual-skip        textual pred [start end])</code></h2>
<h2 id="textual-skip-right-textual-pred-start-end"><code>(textual-skip-right  textual pred [start end])</code></h2>
<p>textual-index searches through the given subtext or substring from the left, returning the index of the leftmost character satisfying the predicate pred. textual-index-right searches from the right, returning the index of the rightmost character satisfying the predicate pred. If no match is found, these procedures return #f.</p>
<p>Rationale: The SRFI 130 analogues of these procedures return cursors, even when no match is found, and SRFI 130’s string-index-right returns the successor of the cursor for the first character that satisfies the predicate. As there are no cursors in this SRFI, it seems best to follow the more intuitive and long-standing precedent set by SRFI 13.</p>
<p>The start and end arguments specify the beginning and end of the search; the valid indexes relevant to the search include start but exclude end. Beware of “fencepost” errors: when searching right-to-left, the first index considered is (- end 1), whereas when searching left-to-right, the first index considered is start. That is, the start/end indexes describe the same half-open interval [start,end) in these procedures that they do in all other procedures specified by this SRFI.</p>
<p>The skip functions are similar, but use the complement of the criterion: they search for the first char that doesn’t satisfy pred. To skip over initial whitespace, for example, say</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>    (subtextual text</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>                (<span class="kw">or</span> (textual-skip text <span class="kw">char-whitespace?</span>)</span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>                    (textual-length text))</span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>                (textual-length text))</span></code></pre></div>
<p>These functions can be trivially composed with textual-take and textual-drop to produce take-while, drop-while, span, and break procedures without loss of efficiency.</p>
<h2 id="textual-contains-textual1-textual2-start1-end1-start2-end2"><code>(textual-contains       textual1 textual2 [start1 end1 start2 end2])</code></h2>
<h2 id="textual-contains-right-textual1-textual2-start1-end1-start2-end2"><code>(textual-contains-right textual1 textual2 [start1 end1 start2 end2])</code></h2>
<p>Does the subtext of textual1 specified by start1 and end1 contain the sequence of characters given by the subtext of textual2 specified by start2 and end2?</p>
<p>Returns #f if there is no match. If start2 = end2, textual-contains returns start1 but textual-contains-right returns end1. Otherwise returns the index in textual1 for the first character of the first/last match; that index lies within the half-open interval [start1,end1), and the match lies entirely within the [start1,end1) range of textual1.</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>(textual-contains <span class="st">&quot;eek -- what a geek.&quot;</span> <span class="st">&quot;ee&quot;</span> <span class="dv">12</span> <span class="dv">18</span>) <span class="co">; Searches &quot;a geek&quot;</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="dv">15</span></span></code></pre></div>
<p>Note: The names of these procedures do not end with a question mark. This indicates a useful value is returned when there is a match.</p>
<h2 id="textual-upcase-textual"><code>(textual-upcase   textual)</code></h2>
<h2 id="textual-downcase-textual"><code>(textual-downcase textual)</code></h2>
<h2 id="textual-foldcase-textual"><code>(textual-foldcase textual)</code></h2>
<h2 id="textual-titlecase-textual"><code>(textual-titlecase textual)</code></h2>
<p>These procedures return the text obtained by applying Unicode’s full uppercasing, lowercasing, case-folding, or title-casing algorithms to their argument. In some cases, the length of the result may be different from the length of the argument. Note that language-sensitive mappings and foldings are not used.</p>
<h2 id="textual-append-textual-..."><code>(textual-append textual ...)</code></h2>
<p>Returns a text whose sequence of characters is the concatenation of the sequences of characters in the given arguments.</p>
<h2 id="textual-concatenate-textual-list"><code>(textual-concatenate textual-list)</code></h2>
<p>Concatenates the elements of textual-list together into a single text.</p>
<p>If any elements of textual-list are strings, then those strings do not share any storage with the result, so subsequent mutation of those string will not affect the text returned by this procedure. Implementations are encouraged to return a result that shares storage with some of the texts in the list if that sharing would be space-efficient.</p>
<p>Rationale: Some implementations of Scheme limit the number of arguments that may be passed to an n-ary procedure, so the (apply textual-append textual-list) idiom, which is otherwise equivalent to using this procedure, is not as portable.</p>
<h2 id="textual-concatenate-reverse-textual-list-final-textual-end"><code>(textual-concatenate-reverse textual-list [final-textual end])</code></h2>
<p>With no optional arguments, calling this procedure is equivalent to</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>(textual-concatenate (<span class="kw">reverse</span> textual-list))</span></code></pre></div>
<p>If the optional argument final-textual is specified, it is effectively consed onto the beginning of textual-list before performing the list-reverse and textual-concatenate operations.</p>
<p>If the optional argument end is given, only the characters up to but not including end in final-textual are added to the result, thus producing</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>    (textual-concatenate</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">reverse</span> (<span class="kw">cons</span> (subtext final-textual <span class="dv">0</span> end)</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>                     textual-list)))</span></code></pre></div>
<p>For example:</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>(textual-concatenate-reverse &#39;(<span class="st">&quot; must be&quot;</span> <span class="st">&quot;Hello, I&quot;</span>) <span class="st">&quot;</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a><span class="st">    going.XXXX&quot;</span> <span class="dv">7</span>) <span class="op">=&gt;</span> «Hello, I must be going.» `` Rationale: This</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>    procedure is useful when constructing procedures that accumulate</span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a>    character data into lists of textual buffers, <span class="kw">and</span> wish to convert</span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a>    the accumulated data into a single text when done. The optional</span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a>    end argument accommodates that use <span class="kw">case</span> when final-textual is a</span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a>    mutable string, <span class="kw">and</span> is allowed (for uniformity) when final-textual</span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a>    is an immutable text.</span></code></pre></div>
<h2 id="textual-join-textual-list-delimiter-grammar"><code>(textual-join textual-list [delimiter grammar])</code></h2>
<p>This procedure is a simple unparser; it pastes texts together using the delimiter text.</p>
<p>textual-list is a list of texts and/or strings. delimiter is a text or a string. The grammar argument is a symbol that determines how the delimiter is used, and defaults to ’infix. It is an error for grammar to be any symbol other than these four:</p>
<ul>
<li><p>’infix means an infix or separator grammar: insert the delimiter between list elements. An empty list will produce an empty text.</p></li>
<li><p>’strict-infix means the same as ’infix if the textual-list is non-empty, but will signal an error if given an empty list. (This avoids an ambiguity shown in the examples below.)</p></li>
<li><p>’suffix means a suffix or terminator grammar: insert the delimiter after every list element.</p></li>
<li><p>’prefix means a prefix grammar: insert the delimiter before every list element.</p></li>
</ul>
<p>The delimiter is the text used to delimit elements; it defaults to a single space ” “.</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>    (textual-join &#39;(<span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span> <span class="st">&quot;baz&quot;</span>))</span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>             <span class="op">=&gt;</span> «foo bar baz»</span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>    (textual-join &#39;(<span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span> <span class="st">&quot;baz&quot;</span>) <span class="st">&quot;&quot;</span>)</span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a>             <span class="op">=&gt;</span> «foobarbaz»</span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a>    (textual-join &#39;(<span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span> <span class="st">&quot;baz&quot;</span>) «:»)</span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a>             <span class="op">=&gt;</span> «foo:bar:baz»</span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a>    (textual-join &#39;(<span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span> <span class="st">&quot;baz&quot;</span>) <span class="st">&quot;:&quot;</span> &#39;suffix)</span>
<span id="cb133-8"><a href="#cb133-8" aria-hidden="true" tabindex="-1"></a>             <span class="op">=&gt;</span> «foo:bar:baz:»</span>
<span id="cb133-9"><a href="#cb133-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-10"><a href="#cb133-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; Infix grammar is ambiguous wrt empty list vs. empty text:</span></span>
<span id="cb133-11"><a href="#cb133-11" aria-hidden="true" tabindex="-1"></a>    (textual-join &#39;()   <span class="st">&quot;:&quot;</span>) <span class="op">=&gt;</span> «»</span>
<span id="cb133-12"><a href="#cb133-12" aria-hidden="true" tabindex="-1"></a>    (textual-join &#39;(<span class="st">&quot;&quot;</span>) <span class="st">&quot;:&quot;</span>) <span class="op">=&gt;</span> «»</span>
<span id="cb133-13"><a href="#cb133-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-14"><a href="#cb133-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; Suffix and prefix grammars are not:</span></span>
<span id="cb133-15"><a href="#cb133-15" aria-hidden="true" tabindex="-1"></a>    (textual-join &#39;()   <span class="st">&quot;:&quot;</span> &#39;suffix)) <span class="op">=&gt;</span> «»</span>
<span id="cb133-16"><a href="#cb133-16" aria-hidden="true" tabindex="-1"></a>    (textual-join &#39;(<span class="st">&quot;&quot;</span>) <span class="st">&quot;:&quot;</span> &#39;suffix)) <span class="op">=&gt;</span> «:»</span></code></pre></div>
<h2 id="textual-fold-kons-knil-textual-start-end"><code>(textual-fold       kons knil textual [start end])</code></h2>
<h2 id="textual-fold-right-kons-knil-textual-start-end"><code>(textual-fold-right kons knil textual [start end])</code></h2>
<p>These are the fundamental iterators for texts.</p>
<p>The textual-fold procedure maps the kons procedure across the given text or string from left to right:</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">...</span> (kons textual<span class="op">[</span><span class="dv">2</span><span class="op">]</span> (kons textual<span class="op">[</span><span class="dv">1</span><span class="op">]</span> (kons textual<span class="op">[</span><span class="dv">0</span><span class="op">]</span> knil))))</span></code></pre></div>
<p>In other words, textual-fold obeys the (tail) recursion</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a>(textual-fold kons knil textual start end)</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (textual-fold kons (kons textual<span class="op">[</span>start<span class="op">]</span> knil) start+1 end)</span></code></pre></div>
<p>The textual-fold-right procedure maps kons across the given text or string from right to left:</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a>    (kons textual<span class="op">[</span><span class="dv">0</span><span class="op">]</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>          (<span class="op">...</span> (kons textual<span class="op">[</span>end-3<span class="op">]</span></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>                     (kons textual<span class="op">[</span>end-2<span class="op">]</span></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>                           (kons textual<span class="op">[</span>end-1<span class="op">]</span></span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a>                                 knil)))))</span></code></pre></div>
<p>obeying the (tail) recursion</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>      (textual-fold-right kons knil textual start end)</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">=</span> (textual-fold-right kons (kons textual<span class="op">[</span>end-1<span class="op">]</span> knil) start end-1)</span></code></pre></div>
<p>Examples:</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">;;; Convert a text or string to a list of chars.</span></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>    (textual-fold-right <span class="kw">cons</span> &#39;() textual)</span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">;;; Count the number of lower-case characters in a text or string.</span></span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>    (textual-fold (<span class="kw">lambda</span> (c count)</span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true" tabindex="-1"></a>                    (<span class="kw">if</span> (<span class="kw">char-lower-case?</span> c)</span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true" tabindex="-1"></a>                        (<span class="op">+</span> count <span class="dv">1</span>)</span>
<span id="cb138-8"><a href="#cb138-8" aria-hidden="true" tabindex="-1"></a>                        count))</span>
<span id="cb138-9"><a href="#cb138-9" aria-hidden="true" tabindex="-1"></a>                  <span class="dv">0</span></span>
<span id="cb138-10"><a href="#cb138-10" aria-hidden="true" tabindex="-1"></a>                  textual)</span></code></pre></div>
<p>The textual-fold-right combinator is sometimes called a “catamorphism.”</p>
<h2 id="textual-map-proc-textual1-textual2-..."><code>(textual-map proc textual1 textual2 ...)</code></h2>
<p>It is an error if proc does not accept as many arguments as the number of textual arguments passed to textual-map, does not accept characters as arguments, or returns a value that is not a character, string, or text.</p>
<p>The textual-map procedure applies proc element-wise to the characters of the textual arguments, converts each value returned by proc to a text, and returns the concatenation of those texts. If more than one textual argument is given and not all have the same length, then textual-map terminates when the shortest textual argument runs out. The dynamic order in which proc is called on the characters of the textual arguments is unspecified, as is the dynamic order in which the coercions are performed. If any strings returned by proc are mutated after they have been returned and before the call to textual-map has returned, then textual-map returns a text with unspecified contents; the textual-map procedure itself does not mutate those strings.</p>
<p>Example:</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a>    (textual-map (<span class="kw">lambda</span> (c0 c1 c2)</span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a>                   (<span class="kw">case</span> c0</span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a>                    ((<span class="ch">#\1</span>) c1)</span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a>                    ((<span class="ch">#\2</span>) (<span class="kw">string</span> c2))</span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a>                    ((<span class="ch">#\-</span>) (text <span class="ch">#\-</span> c1))))</span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>                 (string-&gt;text <span class="st">&quot;1222-1111-2222&quot;</span>)</span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a>                 (string-&gt;text <span class="st">&quot;Hi There!&quot;</span>)</span>
<span id="cb139-8"><a href="#cb139-8" aria-hidden="true" tabindex="-1"></a>                 (string-&gt;text <span class="st">&quot;Dear John&quot;</span>))</span>
<span id="cb139-9"><a href="#cb139-9" aria-hidden="true" tabindex="-1"></a>         <span class="op">=&gt;</span> «Hear-here!»</span></code></pre></div>
<h2 id="textual-for-each-proc-textual1-textual2-..."><code>(textual-for-each proc textual1 textual2 ...)</code></h2>
<p>It is an error if proc does not accept as many arguments as the number of textual arguments passed to textual-map or does not accept characters as arguments.</p>
<p>The textual-for-each procedure applies proc element-wise to the characters of the textual arguments, going from left to right. If more than one textual argument is given and not all have the same length, then textual-for-each terminates when the shortest textual argument runs out.</p>
<h2 id="textual-map-index-proc-textual-start-end"><code>(textual-map-index proc textual [start end])</code></h2>
<p>Calls proc on each valid index of the specified subtext or substring, converts the results of those calls into texts, and returns the concatenation of those texts. It is an error for proc to return anything other than a character, string, or text. The dynamic order in which proc is called on the indexes is unspecified, as is the dynamic order in which the coercions are performed. If any strings returned by proc are mutated after they have been returned and before the call to textual-map-index has returned, then textual-map-index returns a text with unspecified contents; the textual-map-index procedure itself does not mutate those strings.</p>
<h2 id="textual-for-each-index-proc-textual-start-end"><code>(textual-for-each-index proc textual [start end])</code></h2>
<p>Calls proc on each valid index of the specified subtext or substring, in increasing order, discarding the results of those calls. This is simply a safe and correct way to loop over a subtext or substring.</p>
<p>Example:</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">let</span> ((txt (string-&gt;text <span class="st">&quot;abcde&quot;</span>))</span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a>          (v &#39;()))</span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>      (textual-for-each-index</span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">lambda</span> (cur) (<span class="kw">set!</span> v (<span class="kw">cons</span> (<span class="kw">char-&gt;integer</span> (text-ref txt cur)) v)))</span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>        txt)</span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>      v) <span class="op">=&gt;</span> (<span class="dv">101</span> <span class="dv">100</span> <span class="dv">99</span> <span class="dv">98</span> <span class="dv">97</span>)</span></code></pre></div>
<h2 id="textual-count-textual-pred-start-end"><code>(textual-count textual pred [start end])</code></h2>
<p>Returns a count of the number of characters in the specified subtext of textual that satisfy the given predicate.</p>
<h2 id="textual-filter-pred-textual-start-end"><code>(textual-filter pred textual [start end])</code></h2>
<h2 id="textual-remove-pred-textual-start-end"><code>(textual-remove pred textual [start end])</code></h2>
<p>Filter the given subtext of textual, retaining only those characters that satisfy / do not satisfy pred.</p>
<p>If textual is a string, then that string does not share any storage with the result, so subsequent mutation of that string will not affect the text returned by these procedures. If textual is a text, implementations are encouraged to return a result that shares storage with that text whenever sharing would be space-efficient.</p>
<h2 id="textual-replicate-textual-from-to-start-end"><code>(textual-replicate textual from to [start end])</code></h2>
<p>This is an “extended subtext” procedure that implements replicated copying of a subtext or substring.</p>
<p>textual is a text or string; start and end are optional arguments that specify a subtext of textual, defaulting to 0 and the length of textual. This subtext is conceptually replicated both up and down the index space, in both the positive and negative directions. For example, if textual is “abcdefg”, start is 3, and end is6, then we have the conceptual bidirectionally-infinite text</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span>  d  e  f  d  e  f  d  e  f  d  e  f  d  e  f  d  e  f  d <span class="op">...</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>            -<span class="dv">9</span> -<span class="dv">8</span> -<span class="dv">7</span> -<span class="dv">6</span> -<span class="dv">5</span> -<span class="dv">4</span> -<span class="dv">3</span> -<span class="dv">2</span> -<span class="dv">1</span>  <span class="dv">0</span> +<span class="dv">1</span> +<span class="dv">2</span> +<span class="dv">3</span> +<span class="dv">4</span> +<span class="dv">5</span> +<span class="dv">6</span> +<span class="dv">7</span> +<span class="dv">8</span> +<span class="dv">9</span></span></code></pre></div>
<p>textual-replicate returns the subtext of this text beginning at index from, and ending at to. It is an error if from is greater than to.</p>
<p>You can use textual-replicate to perform a variety of tasks:</p>
<ul>
<li><p>To rotate a text left: (textual-replicate “abcdef” 2 8) =&gt; «cdefab»</p></li>
<li><p>To rotate a text right: (textual-replicate “abcdef” -2 4) =&gt; «efabcd»</p></li>
<li><p>To replicate a text: (textual-replicate “abc” 0 7) =&gt; «abcabca»</p></li>
</ul>
<p>Note that</p>
<ul>
<li><p>The from/to arguments give a half-open range containing the characters from index from up to, but not including, index to.</p></li>
<li><p>The from/to indexes are not expressed in the index space of textual. They refer instead to the replicated index space of the subtext defined by textual, start, and end.</p></li>
</ul>
<p>It is an error if start=end, unless from=to, which is allowed as a special case.</p>
<h2 id="textual-split-textual-delimiter-grammar-limit-start-end"><code>(textual-split textual delimiter [grammar limit start end])</code></h2>
<p>Returns a list of texts representing the words contained in the subtext of textual from start (inclusive) to end (exclusive). The delimiter is a text or string to be used as the word separator. This will often be a single character, but multiple characters are allowed for use cases such as splitting on “”. The returned list will have one more item than the number of non-overlapping occurrences of the delimiter in the text. If delimiter is an empty text, then the returned list contains a list of texts, each of which contains a single character.</p>
<p>The grammar is a symbol with the same meaning as in the textual-join procedure. If it is infix, which is the default, processing is done as described above, except an empty textual produces the empty list; if grammar is strict-infix, then an empty textual signals an error. The values prefix and suffix cause a leading/trailing empty text in the result to be suppressed.</p>
<p>If limit is a non-negative exact integer, at most that many splits occur, and the remainder of textual is returned as the final element of the list (so the result will have at most limit+1 elements). If limit is not specified or is #f, then as many splits as possible are made. It is an error if limit is any other value.</p>
<p>To split on a regular expression re, use SRFI 115’s regexp-split procedure:</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a>(map string-&gt;text (regexp-split re (textual-&gt;string txt)))</span></code></pre></div>
<p>Rationale: Although it would be more efficient to have a version of regexp-split that operates on texts directly, the scope of this SRFI is limited to specifying operations on texts analogous to those specified for strings by R7RS and SRFI 130. # <code>(scheme idque)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-134/">SRFI-134</a>.</p>
<p>This SRFI defines immutable deques. A deque is a double-ended queue, a sequence which allows elements to be added or removed efficiently from either end. A structure is immutable when all its operations leave the structure unchanged. Note that none of the procedures specified here ends with an exclamation point.</p>
<p>This SRFI describes immutable deques, or ideques. Immutable structures are sometimes called persistent and are closely related to pure functional (a.k.a. pure) structures. The availability of immutable data structures facilitates writing efficient programs in the pure-functional style. Immutable deques can also be seen as a bidirectional generalization of immutable lists, and some of the procedures documented below are most useful in that context. Unlike the immutable lists of SRFI 116, it is efficient to produce modified versions of an ideque; unlike the list queues of SRFI 117, it is possible to efficiently return an updated version of an ideque without mutating any earlier versions of it.</p>
<p>The specification was designed jointly by Kevin Wortman and John Cowan. John Cowan is the editor and shepherd. The two-list implementation was written by John Cowan.</p>
<h2 id="ideque-element-..."><code>(ideque element ...)</code></h2>
<p>Returns an ideque containing the elements. The first element (if any) will be at the front of the ideque and the last element (if any) will be at the back. Takes O(n) time, where n is the number of elements.</p>
<h2 id="ideque-tabulate-n-proc"><code>(ideque-tabulate n proc)</code></h2>
<p>Invokes the predicate proc on every exact integer from 0 (inclusive) to n (exclusive). Returns an ideque containing the results in order of generation. Takes O(n) time.</p>
<h2 id="ideque-unfold-stop-mapper-successor-seed"><code>(ideque-unfold stop? mapper successor seed)</code></h2>
<p>Invokes the predicate stop? on seed. If it returns false, generate the next result by applying mapper to seed, generate the next seed by applying successor to seed, and repeat this algorithm with the new seed. If stop? returns true, return an ideque containing the results in order of accumulation. Takes O(n) time.</p>
<h2 id="ideque-unfold-right-stop-mapper-successor-seed"><code>(ideque-unfold-right stop? mapper successor seed)</code></h2>
<p>Invokes the predicate stop? on seed. If it returns false, generate the next result by applying mapper to seed, generate the next seed by applying successor to seed, and repeat the algorithm with the new seed. If stop? returns true, return an ideque containing the results in reverse order of accumulation. Takes O(n) time. Predicates</p>
<h2 id="ideque-x"><code>(ideque? x)</code></h2>
<p>Returns #t if x is an ideque, and #f otherwise. Takes O(1) time.</p>
<h2 id="ideque-empty-idaeque"><code>(ideque-empty? idaeque)</code></h2>
<p>Returns #t if ideque contains zero elements, and #f otherwise. Takes O(1) time.</p>
<h2 id="ideque-elt-ideque-..."><code>(ideque= elt= ideque ...)</code></h2>
<p>Determines ideque equality, given an element-equality procedure. Ideque A equals ideque B if they are of the same length, and their corresponding elements are equal, as determined by elt=. If the element-comparison procedure’s first argument is from idequei, then its second argument is from idequei+1, i.e. it is always called as (elt= a b) for a an element of ideque A, and b an element of ideque B.</p>
<p>In the n-ary case, every idequei is compared to idequei+1 (as opposed, for example, to comparing ideque1 to every idequei, for i &gt; 1). If there are zero or one ideque arguments, ideque= simply returns true. The name does not end in a question mark for compatibility with the SRFI-1 procedure list=.</p>
<p>Note that the dynamic order in which the elt= procedure is applied to pairs of elements is not specified. For example, if ideque= is applied to three ideques, A, B, and C, it may first completely compare A to B, then compare B to C, or it may compare the first elements of A and B, then the first elements of B and C, then the second elements of A and B, and so forth.</p>
<p>The equality procedure must be consistent with eq?. Note that this implies that two ideques which are eq? are always ideque=, as well; implementations may exploit this fact to “short-cut” the element-by-element comparisons.</p>
<h2 id="ideque-any-pred-ideque"><code>(ideque-any pred ideque)</code></h2>
<h2 id="ideque-every-pred-ideque"><code>(ideque-every pred ideque)</code></h2>
<p>Invokes pred on the elements of the ideque in order until one call returns a true/false value, which is then returned. If there are no elements, returns #f/#t. Takes O(n) time. Queue operations</p>
<h2 id="ideque-front-ideque"><code>(ideque-front ideque)</code></h2>
<h2 id="ideque-back-ideque"><code>(ideque-back ideque)</code></h2>
<p>Returns the front/back element of ideque. It is an error for ideque to be empty. Takes O(1) time.</p>
<h2 id="ideque-remove-front-ideque"><code>(ideque-remove-front ideque)</code></h2>
<h2 id="ideque-remove-back-ideque"><code>(ideque-remove-back ideque)</code></h2>
<p>Returns an ideque with the front/back element of ideque removed. It is an error for ideque to be empty. Takes O(1) time.</p>
<h2 id="ideque-add-front-ideque-obj"><code>(ideque-add-front ideque obj)</code></h2>
<h2 id="ideque-add-back-ideque-obj"><code>(ideque-add-back ideque obj)</code></h2>
<p>Returns an ideque with obj pushed to the front/back of ideque. Takes O(1) time. Other accessors</p>
<h2 id="ideque-ref-ideque-n"><code>(ideque-ref ideque n)</code></h2>
<p>Returns the nth element of ideque. It is an error unless n is less than the length of ideque. Takes O(n) time.</p>
<h2 id="ideque-take-ideque-n"><code>(ideque-take ideque n)</code></h2>
<h2 id="ideque-take-right-ideque-n"><code>(ideque-take-right ideque n)</code></h2>
<p>Returns an ideque containing the first/last n elements of ideque. It is an error if n is greater than the length of ideque. Takes O(n) time.</p>
<h2 id="ideque-drop-ideque-n"><code>(ideque-drop ideque n)</code></h2>
<h2 id="ideque-drop-right-ideque-n"><code>(ideque-drop-right ideque n)</code></h2>
<p>Returns an ideque containing all but the first/last n elements of ideque. It is an error if n is greater than the length of ideque. Takes O(n) time.</p>
<h2 id="ideque-split-at-ideque-n"><code>(ideque-split-at ideque n)</code></h2>
<p>Returns two values, the results of (ideque-take ideque n) and (ideque-drop ideque n) respectively, but may be more efficient. Takes O(n) time. The whole ideque</p>
<h2 id="ideque-length-ideque"><code>(ideque-length ideque)</code></h2>
<p>Returns the length of ideque as an exact integer. May take O(n) time, though O(1) is optimal.</p>
<h2 id="ideque-append-ideque-..."><code>(ideque-append ideque ...)</code></h2>
<p>Returns an ideque with the contents of the ideque followed by the others, or an empty ideque if there are none. Takes O(kn) time, where k is the number of ideques and n is the number of elements involved, though O(k log n) is possible.</p>
<h2 id="ideque-reverse-ideque"><code>(ideque-reverse ideque)</code></h2>
<p>Returns an ideque containing the elements of ideque in reverse order. Takes O(1) time.</p>
<h2 id="ideque-count-pred-ideque"><code>(ideque-count pred ideque)</code></h2>
<p>Pred is a procedure taking a single value and returning a single value. It is applied element-wise to the elements of ideque, and a count is tallied of the number of elements that produce a true value. This count is returned. Takes O(n) time. The dynamic order of calls to pred is unspecified.</p>
<h2 id="ideque-zip-ideque1-ideque2-..."><code>(ideque-zip ideque1 ideque2 ...)</code></h2>
<p>Returns an ideque of lists (not ideques) each of which contains the corresponding elements of ideques in the order specified. Terminates when all the elements of any of the ideques have been processed. Takes O(kn) time, where k is the number of ideques and n is the number of elements in the shortest ideque.</p>
<h2 id="ideque-map-proc-ideque"><code>(ideque-map proc ideque)</code></h2>
<p>Applies proc to the elements of ideque and returns an ideque containing the results in order. The dynamic order of calls to proc is unspecified. Takes O(n) time.</p>
<h2 id="ideque-filter-map-proc-ideque"><code>(ideque-filter-map proc ideque)</code></h2>
<p>Applies proc to the elements of ideque and returns an ideque containing the true (i.e. non-#f) results in order. The dynamic order of calls to proc is unspecified. Takes O(n) time.</p>
<h2 id="ideque-for-each-proc-ideque"><code>(ideque-for-each proc ideque)</code></h2>
<h2 id="ideque-for-each-right-proc-ideque"><code>(ideque-for-each-right proc ideque)</code></h2>
<p>Applies proc to the elements of ideque in forward/reverse order and returns an unspecified result. Takes O(n) time.</p>
<h2 id="ideque-fold-proc-nil-ideque"><code>(ideque-fold proc nil ideque)</code></h2>
<h2 id="ideque-fold-right-proc-nil-ideque"><code>(ideque-fold-right proc nil ideque)</code></h2>
<p>Invokes proc on the elements of ideque in forward/reverse order, passing the result of the previous invocation as a second argument. For the first invocation, nil is used as the second argument. Returns the result of the last invocation, or nil if there was no invocation. Takes O(n) time.</p>
<h2 id="ideque-append-map-proc-ideque"><code>(ideque-append-map proc ideque)</code></h2>
<p>Applies proc to the elements of ideque. It is an error if the result is not a list. Returns an ideque containing the elements of the lists in order. Takes O(n) time, where n is the number of elements in all the lists returned.</p>
<h2 id="ideque-filter-pred-ideque"><code>(ideque-filter pred ideque)</code></h2>
<h2 id="ideque-remove-pred-ideque"><code>(ideque-remove pred ideque)</code></h2>
<p>Returns an ideque containing the elements of ideque that do/do not satisfy pred. Takes O(n) time.</p>
<h2 id="ideque-partition-proc-ideque"><code>(ideque-partition proc ideque)</code></h2>
<p>Returns two values, the results of (ideque-filter pred ideque) and (ideque-remove pred ideque) respectively, but may be more efficient. Takes O(n) time.</p>
<h2 id="ideque-find-pred-ideque-failure"><code>(ideque-find pred ideque [ failure ])</code></h2>
<h2 id="ideque-find-right-pred-ideque-failure"><code>(ideque-find-right pred ideque [ failure ])</code></h2>
<p>Returns the first/last element of ideque that satisfies pred. If there is no such element, returns the result of invoking the thunk failure; the default thunk is (lambda () #f). Takes O(n) time.</p>
<h2 id="ideque-take-while-pred-ideque"><code>(ideque-take-while pred ideque)</code></h2>
<h2 id="ideque-take-while-right-pred-ideque"><code>(ideque-take-while-right pred ideque)</code></h2>
<p>Returns an ideque containing the longest initial/final prefix of elements in ideque all of which satisfy pred. Takes O(n) time.</p>
<h2 id="ideque-drop-while-pred-ideque"><code>(ideque-drop-while pred ideque)</code></h2>
<h2 id="ideque-drop-while-right-pred-ideque"><code>(ideque-drop-while-right pred ideque)</code></h2>
<p>Returns an ideque which omits the longest initial/final prefix of elements in ideque all of which satisfy pred, but includes all other elements of ideque. Takes O(n) time.</p>
<h2 id="ideque-span-pred-ideque"><code>(ideque-span pred ideque)</code></h2>
<h2 id="ideque-break-pred-ideque"><code>(ideque-break pred ideque)</code></h2>
<p>Returns two values, the initial prefix of the elements of ideque which do/do not satisfy pred, and the remaining elements. Takes O(n) time.</p>
<h2 id="list-ideque-list"><code>(list-&gt;ideque list)</code></h2>
<h2 id="ideque-list-ideque"><code>(ideque-&gt;list ideque)</code></h2>
<p>Conversion between ideque and list structures. FIFO order is preserved, so the front of a list corresponds to the front of an ideque. Each operation takes O(n) time.</p>
<h2 id="generator-ideque-generator"><code>(generator-&gt;ideque generator)</code></h2>
<h2 id="ideque-generator-ideque"><code>(ideque-&gt;generator ideque)</code></h2>
<p>Conversion between SRFI 121 generators and ideques. Each operation takes O(n) time. A generator is a procedure that is called repeatedly with no arguments to generate consecutive values, and returns an end-of-file object when it has no more values to return. # <code>(scheme mapping)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-146/">SRFI-146</a>.</p>
<p>Mappings are finite sets of associations, where each association is a pair consisting of a key and an arbitrary Scheme value. The keys are elements of a suitable domain. Each mapping holds no more than one association with the same key. The fundamental mapping operation is retrieving the value of an association stored in the mapping when the key is given.</p>
<h2 id="mapping-comparator-key-value-..."><code>(mapping comparator [key value] ...)</code></h2>
<p>Returns a newly allocated mapping. The comparator argument is used to control and distinguish the keys of the mapping. The args alternate between keys and values and are used to initialize the mapping. In particular, the number of args has to be even. Earlier associations with equal keys take precedence over later arguments.</p>
<h2 id="mapping-unfold-stop-mapper-successor-seed-comparator"><code>(mapping-unfold stop? mapper successor seed comparator)</code></h2>
<p>Create a newly allocated mapping as if by mapping using comparator. If the result of applying the predicate stop? to seed is true, return the mapping. Otherwise, apply the procedure mapper to seed. Mapper returns two values which are added to the mapping as the key and the value, respectively. Then get a new seed by applying the procedure successor to seed, and repeat this algorithm. Associations earlier in the list take precedence over those that come later.</p>
<h2 id="mappingordered"><code>(mapping/ordered)</code></h2>
<h2 id="mapping-unfoldordered"><code>(mapping-unfold/ordered</code></h2>
<p>These are the same as mapping and mapping-unfold, except that it is an error if the keys are not in order, and they may be more efficient.</p>
<h2 id="mapping-obj"><code>(mapping? obj)</code></h2>
<p>Returns #t if obj is a mapping, and #f otherwise.</p>
<h2 id="mapping-contains-mapping-key"><code>(mapping-contains? mapping key)</code></h2>
<p>Returns #t if key is the key of an association of mapping and #f otherwise.</p>
<h2 id="mapping-empty-mapping"><code>(mapping-empty? mapping)</code></h2>
<p>Returns #t if mapping has no associations and #f otherwise.</p>
<h2 id="mapping-disjoint-mapping1-mapping2"><code>(mapping-disjoint? mapping1 mapping2)</code></h2>
<p>Returns #t if mapping1 and mapping2 have no keys in common and #f otherwise.</p>
<h2 id="mapping-ref-mapping-key-failure-success"><code>(mapping-ref mapping key [failure [success]])</code></h2>
<p>Extracts the value associated to key in the mapping mapping, invokes the procedure success in tail context on it, and returns its result; if success is not provided, then the value itself is returned. If key is not contained in mapping and failure is supplied, then failure is invoked in tail context on no arguments and its values are returned. Otherwise, it is an error.</p>
<h2 id="mapping-refdefault-mapping-key-default"><code>(mapping-ref/default mapping key default)</code></h2>
<h2 id="mapping-key-comparator-mapping"><code>(mapping-key-comparator mapping)</code></h2>
<p>Returns the comparator used to compare the keys of the mapping mapping.</p>
<h2 id="mapping-adjoin-mapping-arg-..."><code>(mapping-adjoin mapping arg ...)</code></h2>
<p>The mapping-adjoin procedure returns a newly allocated mapping that uses the same comparator as the mapping mapping and contains all the associations of mapping, and in addition new associations by processing the arguments from left to right. The args alternate between keys and values. Whenever there is a previous association for a key, the previous association prevails and the new association is skipped. It is an error to add an association to mapping whose key that does not return #t when passed to the type test procedure of the comparator.</p>
<h2 id="mapping-adjoin-mapping-arg-...-1"><code>(mapping-adjoin! mapping arg ...)</code></h2>
<p>The mapping-adjoin! procedure is the same as mapping-adjoin, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h2 id="mapping-set-mapping-arg-..."><code>(mapping-set mapping arg ...)</code></h2>
<p>The mapping-set procedure returns a newly allocated mapping that uses the same comparator as the mapping mapping and contains all the associations of mapping, and in addition new associations by processing the arguments from left to right. The args alternate between keys and values. Whenever there is a previous association for a key, it is deleted. It is an error to add an association to mapping whose key that does not return #t when passed to the type test procedure of the comparator.</p>
<h2 id="mapping-set-mapping-arg-...-1"><code>(mapping-set! mapping arg ...)</code></h2>
<p>The mapping-set! procedure is the same as mapping-set, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h2 id="mapping-replace-mapping-key-value"><code>(mapping-replace mapping key value)</code></h2>
<p>The mapping-replace procedure returns a newly allocated mapping that uses the same comparator as the mapping mapping and contains all the associations of mapping except as follows: If key is equal (in the sense of mapping’s comparator) to an existing key of mapping, then the association for that key is omitted and replaced the association defined by the pair key and value. If there is no such key in mapping, then mapping is returned unchanged.</p>
<h2 id="mapping-replace-mapping-key-value-1"><code>(mapping-replace! mapping key value)</code></h2>
<p>The mapping-replace! procedure is the same as mapping-replace, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h2 id="mapping-delete-mapping-key-..."><code>(mapping-delete mapping key ...)</code></h2>
<h2 id="mapping-delete-mapping-key-...-1"><code>(mapping-delete! mapping key ...)</code></h2>
<h2 id="mapping-delete-all-mapping-key-list"><code>(mapping-delete-all mapping key-list)</code></h2>
<h2 id="mapping-delete-all-mapping-key-list-1"><code>(mapping-delete-all! mapping key-list)</code></h2>
<p>The mapping-delete procedure returns a newly allocated mapping containing all the associations of the mapping mapping except for any whose keys are equal (in the sense of mapping’s comparator) to one or more of the keys. Any key that is not equal to some key of the mapping is ignored.</p>
<p>The mapping-delete! procedure is the same as mapping-delete, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<p>The mapping-delete-all and mapping-delete-all! procedures are the same as mapping-delete and mapping-delete!, respectively, except that they accept a single argument which is a list of keys whose associations are to be deleted.</p>
<h2 id="mapping-intern-mapping-key-failure"><code>(mapping-intern mapping key failure)</code></h2>
<p>Extracts the value associated to key in the mapping mapping, and returns mapping and the value as two values. If key is not contained in mapping, failure is invoked on no arguments. The procedure then returns two values, a newly allocated mapping that uses the same comparator as the mapping and contains all the associations of mapping, and in addition a new association mapping key to the result of invoking failure, and the result of invoking failure.</p>
<h2 id="mapping-intern-mapping-key-failure-1"><code>(mapping-intern! mapping key failure)</code></h2>
<p>The mapping-intern! procedure is the same as mapping-intern, except that it is permitted to mutate and return the mapping argument as its first value rather than allocating a new mapping.</p>
<h2 id="mapping-update-mapping-key-updater-failure-success"><code>(mapping-update mapping key updater [failure [success]])</code></h2>
<h2 id="mapping-update-mapping-key-updater-failure-success-1"><code>(mapping-update! mapping key updater [failure [success]])</code></h2>
<p>The mapping-update! procedure is the same as mapping-update, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h2 id="mapping-updatedefault-mapping-key-updater-default"><code>(mapping-update/default mapping key updater default)</code></h2>
<h2 id="mapping-updatedefault-mapping-key-updater-default-1"><code>(mapping-update!/default mapping key updater default)</code></h2>
<p>The mapping-update!/default procedure is the same as mapping-update/default, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h2 id="mapping-pop-mapping-failure"><code>(mapping-pop mapping [failure])</code></h2>
<p>The mapping-pop procedure exported from (srfi 146) chooses the association with the least key from mapping and returns three values, a newly allocated mapping that uses the same comparator as mapping and contains all associations of mapping except the chosen one, and the key and the value of the chosen association. If mapping contains no association and failure is supplied, then failure is invoked in tail context on no arguments and its values returned. Otherwise, it is an error.</p>
<h2 id="mapping-pop-mapping-failure-1"><code>(mapping-pop! mapping [failure])</code></h2>
<p>The mapping-pop! procedure is the same as mapping-pop, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h2 id="mapping-search-mapping-key-failure-success"><code>(mapping-search mapping key failure success)</code></h2>
<p>The mapping mapping is searched in order (that is in the order of the stored keys) for an association with key key. If it is not found, then the failure procedure is tail-called with two continuation arguments, insert and ignore, and is expected to tail-call one of them. If an association with key key is found, then the success procedure is tail-called with the matching key of mapping, the associated value, and two continuations, update and remove, and is expected to tail-call one of them.</p>
<p>It is an error if the continuation arguments are invoked, but not in tail position in the failure and success procedures. It is also an error if the failure and success procedures return to their implicit continuation without invoking one of their continuation arguments.</p>
<p>The effects of the continuations are as follows (where obj is any Scheme object):</p>
<ul>
<li><p>Invoking (insert value obj) causes a mapping to be newly allocated that uses the same comparator as the mapping mapping and contains all the associations of mapping, and in addition a new association mapping key to value.</p></li>
<li><p>Invoking (ignore obj) has no effects; in particular, no new mapping is allocated (but see below).</p></li>
<li><p>Invoking (update new-key new-value obj) causes a mapping to be newly allocated that uses the same comparator as the mapping and contains all the associations of mapping, except for the association with key key, which is replaced by a new association mapping new-key to new-value.</p></li>
<li><p>Invoking (remove obj) causes a mapping to be newly allocated that uses the same comparator as the mapping and contains all the associations of mapping, except for the association with key key.</p></li>
</ul>
<p>In all cases, two values are returned: the possibly newly allocated mapping and obj.</p>
<h2 id="mapping-search-mapping-key-failure-success-1"><code>(mapping-search! mapping key failure success)</code></h2>
<p>The mapping-search! procedure is the same as mapping-search, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h2 id="mapping-size-mapping"><code>(mapping-size mapping)</code></h2>
<p>Returns the number of associations in mapping as an exact integer.</p>
<h2 id="mapping-find-predicate-mapping-failure"><code>(mapping-find predicate mapping failure)</code></h2>
<p>Returns the association with the least key of the mapping mapping consisting of a key and value as two values such that predicate returns a true value when invoked with key and value as arguments, or the result of tail-calling failure with no arguments if there is none. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h2 id="mapping-count-predicate-mapping"><code>(mapping-count predicate mapping)</code></h2>
<p>Returns the number of associations of the mapping mapping that satisfy predicate (in the sense of mapping-find) as an exact integer. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h2 id="mapping-any-predicate-mapping"><code>(mapping-any? predicate mapping)</code></h2>
<p>Returns #t if any association of the mapping mapping satisfies predicate (in the sense of mapping-find), or #f otherwise. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h2 id="mapping-every-predicate-mapping"><code>(mapping-every? predicate mapping)</code></h2>
<p>Returns #t if every association of the mapping mapping satisfies predicate (in the sense of mapping-find), or #f otherwise. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h2 id="mapping-keys-mapping"><code>(mapping-keys mapping)</code></h2>
<p>Returns a newly allocated list of all the keys in increasing order in the mapping mapping.</p>
<h2 id="mapping-values-mapping"><code>(mapping-values mapping)</code></h2>
<p>Returns a newly allocated list of all the values in increasing order of the keys in the mapping mapping.</p>
<h2 id="mapping-entries-mapping"><code>(mapping-entries mapping)</code></h2>
<p>Returns two values, a newly allocated list of all the keys in the mapping mapping, and a newly allocated list of all the values in the mapping mapping in increasing order of the keys.</p>
<h2 id="mapping-map-proc-comparator-mapping"><code>(mapping-map proc comparator mapping)</code></h2>
<p>Applies proc, which returns two values, on two arguments, the key and value of each association of mapping in increasing order of the keys and returns a newly allocated mapping that uses the comparator comparator, and which contains the results of the applications inserted as keys and values.</p>
<h2 id="mapping-map-list-proc-mapping"><code>(mapping-map-&gt;list proc mapping)</code></h2>
<p>Calls proc for every association in increasing order of the keys in the mapping mapping with two arguments: the key of the association and the value of the association. The values returned by the invocations of proc are accumulated into a list, which is returned.</p>
<h2 id="mapping-for-each-proc-mapping"><code>(mapping-for-each proc mapping)</code></h2>
<p>Invokes proc for every association in the mapping mapping in increasing order of the keys, discarding the returned values, with two arguments: the key of the association and the value of the association. Returns an unspecified value.</p>
<h2 id="mapping-fold-proc-nil-mapping"><code>(mapping-fold proc nil mapping)</code></h2>
<p>Invokes proc for each association of the mapping mapping in increasing order of the keys with three arguments: the key of the association, the value of the association, and an accumulated result of the previous invocation. For the first invocation, nil is used as the third argument. Returns the result of the last invocation, or nil if there was no invocation.</p>
<h2 id="mapping-filter-predicate-mapping"><code>(mapping-filter predicate mapping)</code></h2>
<p>Returns a newly allocated mapping with the same comparator as the mapping mapping, containing just the associations of mapping that satisfy predicate (in the sense of mapping-find).</p>
<h2 id="mapping-filter-predicate-mapping-1"><code>(mapping-filter! predicate mapping)</code></h2>
<p>A linear update procedure that returns a mapping containing just the associations of mapping that satisfy predicate.</p>
<h2 id="mapping-remove-predicate-mapping"><code>(mapping-remove predicate mapping)</code></h2>
<p>Returns a newly allocated mapping with the same comparator as the mapping mapping, containing just the associations of mapping that do not satisfy predicate (in the sense of mapping-find).</p>
<h2 id="mapping-remove-predicate-mapping-1"><code>(mapping-remove! predicate mapping)</code></h2>
<p>A linear update procedure that returns a mapping containing just the associations of mapping that do not satisfy predicate.</p>
<h2 id="mapping-partition-predicate-mapping"><code>(mapping-partition predicate mapping)</code></h2>
<p>Returns two values: a newly allocated mapping with the same comparator as the mapping mapping that contains just the associations of mapping that satisfy predicate (in the sense of mapping-find), and another newly allocated mapping, also with the same comparator, that contains just the associations of mapping that do not satisfy predicate.</p>
<h2 id="mapping-partition-predicate-mapping-1"><code>(mapping-partition! predicate mapping)</code></h2>
<p>A linear update procedure that returns two mappings containing the associations of mapping that do and do not, respectively, satisfy predicate.</p>
<h2 id="mapping-copy-mapping"><code>(mapping-copy mapping)</code></h2>
<p>Returns a newly allocated mapping containing the associations of the mapping mapping, and using the same comparator.</p>
<h2 id="mapping-alist-mapping"><code>(mapping-&gt;alist mapping)</code></h2>
<p>Returns a newly allocated association list containing the associations of the mapping in increasing order of the keys. Each association in the list is a pair whose car is the key and whose cdr is the associated value.</p>
<h2 id="alist-mapping-comparator-alist"><code>(alist-&gt;mapping comparator alist)</code></h2>
<p>Returns a newly allocated mapping, created as if by mapping using the comparator comparator, that contains the associations in the list, which consist of a pair whose car is the key and whose cdr is the value. Associations earlier in the list take precedence over those that come later.</p>
<h2 id="alist-mapping-mapping-alist"><code>(alist-&gt;mapping! mapping alist)</code></h2>
<p>A linear update procedure that returns a mapping that contains the associations of both mapping and alist. Associations in the mapping and those earlier in the list take precedence over those that come later.</p>
<h2 id="mapping-comparator-mapping1-mapping2-..."><code>(mapping=? comparator mapping1 mapping2 ...)</code></h2>
<p>Returns #t if each mapping mapping contains the same associations, and #f otherwise.</p>
<p>Furthermore, it is explicitly not an error if mapping=? is invoked on mappings that do not share the same (key) comparator. In that case, #f is returned.</p>
<h2 id="mapping-comparator-mapping1-mapping2-...-1"><code>(mapping&lt;? comparator mapping1 mapping2 ...)</code></h2>
<p>Returns #t if the set of associations of each mapping mapping other than the last is a proper subset of the following mapping, and #f otherwise.</p>
<h2 id="mapping-comparator-mapping1-mapping2-...-2"><code>(mapping&gt;? comparator mapping1 mapping2 ...)</code></h2>
<p>Returns #t if each mapping mapping contains the same associations, and #f otherwise.</p>
<p>Furthermore, it is explicitly not an error if mapping=? is invoked on mappings that do not share the same (key) comparator. In that case, #f is returned.</p>
<h2 id="mapping-comparator-mapping1-mapping2-...-3"><code>(mapping&lt;=? comparator mapping1 mapping2 ...)</code></h2>
<p>Returns #t if the set of associations of each mapping mapping other than the last is a subset of the following mapping, and #f otherwise.</p>
<h2 id="mapping-comparator-mapping1-mapping2-...-4"><code>(mapping&gt;=? comparator mapping1 mapping2 ...)</code></h2>
<p>Returns #t if the set of associations of each mapping mapping other than the last is a superset of the following mapping, and #f otherwise.</p>
<h2 id="mapping-union-mapping1-mapping2-..."><code>(mapping-union mapping1 mapping2 ...)</code></h2>
<h2 id="mapping-intersection-mapping1-mapping2-..."><code>(mapping-intersection mapping1 mapping2 ...)</code></h2>
<h2 id="mapping-difference-mapping1-mapping2-..."><code>(mapping-difference mapping1 mapping2 ...)</code></h2>
<h2 id="mapping-xor-mapping1-mapping2-..."><code>(mapping-xor mapping1 mapping2 ...)</code></h2>
<p>Return a newly allocated mapping whose set of associations is the union, intersection, asymmetric difference, or symmetric difference of the sets of associations of the mappings mappings. Asymmetric difference is extended to more than two mappings by taking the difference between the first mapping and the union of the others. Symmetric difference is not extended beyond two mappings. When comparing associations, only the keys are compared. In case of duplicate keys (in the sense of the mappings comparators), associations in the result mapping are drawn from the first mapping in which they appear.</p>
<h2 id="mapping-union-mapping1-mapping2-...-1"><code>(mapping-union! mapping1 mapping2 ...)</code></h2>
<h2 id="mapping-intersection-mapping1-mapping2-...-1"><code>(mapping-intersection! mapping1 mapping2 ...)</code></h2>
<h2 id="mapping-difference-mapping1-mapping2-...-1"><code>(mapping-difference! mapping1 mapping2 ...)</code></h2>
<h2 id="mapping-xor-mapping1-mapping2-...-1"><code>(mapping-xor! mapping1 mapping2 ...)</code></h2>
<p>These procedures are the linear update analogs of the corresponding pure functional procedures above.</p>
<h2 id="mapping-min-key-mapping"><code>(mapping-min-key mapping)</code></h2>
<h2 id="mapping-max-key-mapping"><code>(mapping-max-key mapping)</code></h2>
<p>Returns the least/greatest key contained in the mapping mapping. It is an error for mapping to be empty.</p>
<h2 id="mapping-min-value-mapping"><code>(mapping-min-value mapping)</code></h2>
<h2 id="mapping-max-value-mapping"><code>(mapping-max-value mapping)</code></h2>
<p>Returns the value associated with the least/greatest key contained in the mapping mapping. It is an error for mapping to be empty.</p>
<h2 id="mapping-min-entry-mapping"><code>(mapping-min-entry mapping)</code></h2>
<h2 id="mapping-max-entry-mapping"><code>(mapping-max-entry mapping)</code></h2>
<p>Returns the entry associated with the least/greatest key contained in the mapping mapping as two values, the key and its associated value. It is an error for mapping to be empty.</p>
<h2 id="mapping-key-predecessor-mapping-obj-failure"><code>(mapping-key-predecessor mapping obj failure)</code></h2>
<h2 id="mapping-key-successor-mapping-obj-failure"><code>(mapping-key-successor mapping obj failure)</code></h2>
<p>Returns the key contained in the mapping mapping that immediately precedes/succeeds obj in the mapping’s order of keys. If no such key is contained in mapping (because obj is the minimum/maximum key, or because mapping is empty), returns the result of tail-calling the thunk failure.</p>
<h2 id="mapping-range-mapping-obj"><code>(mapping-range= mapping obj)</code></h2>
<h2 id="mapping-range-mapping-obj-1"><code>(mapping-range&lt; mapping obj)</code></h2>
<h2 id="mapping-range-mapping-obj-2"><code>(mapping-range&gt; mapping obj)</code></h2>
<h2 id="mapping-range-mapping-obj-3"><code>(mapping-range&lt;= mapping obj)</code></h2>
<h2 id="mapping-range-mapping-obj-4"><code>(mapping-range&gt;= mapping obj)</code></h2>
<p>Returns a mapping containing only the associations of the mapping whose keys are equal to, less than, greater than, less than or equal to, or greater than or equal to obj.</p>
<h2 id="mapping-range-mapping-obj-5"><code>(mapping-range=! mapping obj)</code></h2>
<h2 id="mapping-range-mapping-obj-6"><code>(mapping-range&lt;! mapping obj)</code></h2>
<h2 id="mapping-range-mapping-obj-7"><code>(mapping-range&gt;! mapping obj)</code></h2>
<h2 id="mapping-range-mapping-obj-8"><code>(mapping-range&lt;=! mapping obj)</code></h2>
<h2 id="mapping-range-mapping-obj-9"><code>(mapping-range&gt;=! mapping obj)</code></h2>
<p>Linear update procedures returning a mapping containing only the associations of the mapping whose keys are equal to, less than, greater than, less than or equal to, or greater than or equal to obj.</p>
<h2 id="mapping-split-mapping-obj"><code>(mapping-split mapping obj)</code></h2>
<p>Returns five values, equivalent to the results of invoking (mapping-range&lt; mapping obj), (mapping-range&lt;= mapping obj), (mapping-range= mapping obj), (mapping-range&gt;= mapping obj), and (mapping-range&gt; mapping obj), but may be more efficient.</p>
<h2 id="mapping-split-mapping-obj-1"><code>(mapping-split! mapping obj)</code></h2>
<p>The mapping-split! procedure is the same as mapping-split, except that it is permitted to mutate and return the mapping rather than allocating a new mapping.</p>
<h2 id="mapping-catenate-comparator-mapping1-key-value-mapping2"><code>(mapping-catenate comparator mapping1 key value mapping2)</code></h2>
<p>Returns a newly allocated mapping using the comparator comparator whose set of associations is the union of the sets of associations of the mapping mapping1, the association mapping key to value, and the associations of mapping2. It is an error if the keys contained in mapping1 in their natural order, the key key, and the keys contained in mapping2 in their natural order (in that order) do not form a strictly monotone sequence with respect to the ordering of comparator.</p>
<h2 id="mapping-catenate-comparator-mapping1-key-value-mapping2-1"><code>(mapping-catenate! comparator mapping1 key value mapping2)</code></h2>
<p>Returns a newly allocated mapping using the comparator comparator whose set of associations is the union of the sets of associations of the mapping mapping1, the association mapping key to value, and the associations of mapping2. It is an error if the keys contained in mapping1 in their natural order, the key key, and the keys contained in mapping2 in their natural order (in that order) do not form a strictly monotone sequence with respect to the ordering of comparator.</p>
<h2 id="mapping-mapmonotone-proc-comparator-mapping"><code>(mapping-map/monotone proc comparator mapping)</code></h2>
<p>Equivalent to (mapping-map proc comparator mapping), but it is an error if proc does not induce a strictly monotone mapping between the keys with respect to the ordering of the comparator of mapping and the ordering of comparator. Maybe be implemented more efficiently than mapping-map.</p>
<h2 id="mapping-mapmonotone-proc-comparator-mapping-1"><code>(mapping-map/monotone! proc comparator mapping)</code></h2>
<p>The mapping-map/monotone! procedure is the same as mapping-map/monotone, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h2 id="mapping-foldreverse-proc-nil-mapping"><code>(mapping-fold/reverse proc nil mapping)</code></h2>
<p>Equivalent to (mapping-fold proc nil mapping) except that the associations are processed in reverse order with respect to the natural ordering of the keys.</p>
<h2 id="comparator-obj-1"><code>(comparator? obj)</code></h2>
<p>Type predicate for comparators as exported by <code>(scheme comparator)</code>.</p>
<h2 id="mapping-comparator"><code>mapping-comparator</code></h2>
<p>mapping-comparator is constructed by invoking make-mapping-comparator on (make-default-comparator).</p>
<h2 id="make-mapping-comparator-comparator"><code>(make-mapping-comparator comparator)</code></h2>
<p>Returns a comparator for mappings that is compatible with the equality predicate (mapping=? comparator mapping1 mapping2). If make-mapping-comparator is imported from (srfi 146), it provides a (partial) ordering predicate that is applicable to pairs of mappings with the same (key) comparator. If (make-hashmap-comparator) is imported from (srfi 146 hash), it provides an implementation-dependent hash function.</p>
<p>If make-mapping-comparator is imported from (srfi 146), the lexicographic ordering with respect to the keys (and, in case a tiebreak is necessary, with respect to the ordering of the values) is used for mappings sharing a comparator.</p>
<p>The existence of comparators returned by make-mapping-comparator allows mappings whose keys are mappings themselves, and it allows to compare mappings whose values are mappings. # <code>(scheme eval)</code></p>
<h2 id="environment-list1-..."><code>(environment list1 ...)</code></h2>
<p>This procedure returns a specifier for the environment that results by starting with an empty environment and then importing each list, considered as an import set, into it. The bindings of the environment represented by the specifier are immutable, as is the environment itself.</p>
<h2 id="eval-expr-or-def-environment-specifier"><code>(eval expr-or-def environment-specifier)</code></h2>
<p>If <code>expr-or-def</code> is an expression, it is evaluated in the specified environment and its values are returned. If it is a definition, the specified identifier(s) are defined in the specified environment, provided the environment is not immutable. Implementations may extend <code>eval</code> to allow other objects. # <code>(scheme base)</code></p>
<h2 id="section"><code>_</code></h2>
<p>TODO (missing in r7rs?)</p>
<h2 id="section-1"><code>...</code></h2>
<p>It is called ellipsis. It signify that a pattern must be repeated.</p>
<h2 id="section-2"><code>=&gt;</code></h2>
<p>TODO</p>
<h2 id="else"><code>else</code></h2>
<p>Used in <code>cond</code> and <code>case</code> form as in the last clause as a fallback.</p>
<h2 id="number-..."><code>(* number ...)</code></h2>
<p>Multiplication procedure.</p>
<h2 id="number-...-1"><code>(+ number ...)</code></h2>
<p>Addition procedure.</p>
<h2 id="number-...-2"><code>(- number ...)</code></h2>
<p>Substraction procedure.</p>
<h2 id="number-...-3"><code>(/ number ...)</code></h2>
<p>Division procedure. Raise <code>'numerical-overflow</code> condition in case where denominator is zero.</p>
<h2 id="number-number-..."><code>(&lt; number number ...)</code></h2>
<p>Less than procedure. Return a boolean.</p>
<h2 id="number-number-...-1"><code>(&lt;= number number ...)</code></h2>
<p>Less than or equal procedure. Return a boolean.</p>
<h2 id="number-number-...-2"><code>(= number number ...)</code></h2>
<p>Return <code>#t</code> if the numbers passed as parameters are equal. And <code>#f</code> otherwise.</p>
<h2 id="number-number-...-3"><code>(&gt; number number ...)</code></h2>
<p>Greater than procedure. Return a boolean.</p>
<h2 id="number-number-...-4"><code>(&gt;= number number ...)</code></h2>
<p>Greater than or equal. Return a boolean.</p>
<h2 id="abs-number"><code>(abs number)</code></h2>
<p>Return the absolute value of <code>NUMBER</code>.</p>
<h2 id="and-test1-..."><code>(and test1 ...)</code></h2>
<p>The <code>test</code> expressions are evaluated from left to right, and if any expression evaluates to <code>#f</code>, then <code>#f</code> is returned. Any remaining expressions are not evaluated. If all the expressions evaluate to true values, the values of the last expression are returned. If there are no expressions, then <code>#t</code> is returned.</p>
<h2 id="append-lst-..."><code>(append lst ...)</code></h2>
<p>Return the list made of the list passed as parameters in the same order.</p>
<h2 id="apply-proc-arg1-...-args"><code>(apply proc arg1 ... args)</code></h2>
<p>The apply procedure calls proc with the elements of the list <code>(append (list arg1 ...) args)</code> as the actual arguments.</p>
<h2 id="assoc-obj-alist"><code>(assoc obj alist)</code></h2>
<p>Return the first pair which <code>car</code> is equal to <code>OBJ</code> according to the predicate <code>equal?</code>. Or it returns <code>#f</code>.</p>
<h2 id="assq-obj-alist"><code>(assq obj alist)</code></h2>
<p>Return the first pair which <code>car</code> is equal to <code>OBJ</code> according to the predicate <code>eq?</code>. Or it returns <code>#f</code>.</p>
<h2 id="assv-obj-alist"><code>(assv obj alist)</code></h2>
<p>Return the first pair which <code>car</code> is equal to <code>OBJ</code> according to the predicate <code>eqv?</code>. Or it returns <code>#f</code>.</p>
<h2 id="begin-syntax"><code>begin</code> syntax</h2>
<p>There is two uses of <code>begin</code>.</p>
<h3 id="begin-expression-or-definition-..."><code>(begin expression-or-definition ...)</code></h3>
<p>This form of begin can appear as part of a body, or at the outermost level of a program, or at the REPL, or directly nested in a begin that is itself of this form. It causes the contained expressions and definitions to be evaluated exactly as if the enclosing begin construct were not present.</p>
<p>TODO: example</p>
<h3 id="begin-expression1-expression2-..."><code>(begin expression1 expression2 ...)</code></h3>
<p>This form of begin can be used as an ordinary expression. The expressions are evaluated sequentially from left to right, and the values of the last expression are returned. This expression type is used to sequence side effects such as assignments or input and output.</p>
<p>TODO: example</p>
<h2 id="binary-port"><code>binary-port?</code></h2>
<p>TODO: not implemented</p>
<h2 id="boolean-obj-..."><code>(boolean=? obj ...)</code></h2>
<p>Return <code>#t</code> if the scheme objects passed as arguments are the same boolean. Otherwise it return <code>#f</code>.</p>
<h2 id="boolean-obj"><code>(boolean? obj)</code></h2>
<p>Return <code>#t</code> if <code>OBJ</code> is a boolean. Otherwise <code>#f</code>.</p>
<h2 id="bytevector-byte-..."><code>(bytevector byte ...)</code></h2>
<p>Returns a newly allocated bytevector containing its arguments.</p>
<h2 id="bytevector-append-bytevector-..."><code>(bytevector-append bytevector ...)</code></h2>
<p>Returns a newly allocated bytevector whose elements arethe concatenation of the elements in the given bytevectors.</p>
<h2 id="bytevector-copy-bytevector-start-end"><code>(bytevector-copy bytevector [start [end]])</code></h2>
<p>Returns a newly allocated bytevector containing the bytes in bytevector between start and end.</p>
<h2 id="bytevector-copy-to-at-from-start-end"><code>(bytevector-copy! to at from [start [end]])</code></h2>
<p>Copies the bytes of bytevector <code>from</code> between <code>start</code> and <code>end</code> to bytevector <code>TO</code>, starting at <code>at</code>. The order in which bytes are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary bytevector and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances.</p>
<h2 id="bytevector-length-bytevector-1"><code>(bytevector-length bytevector)</code></h2>
<p>Returns the length of bytevector in bytes as an exact integer.</p>
<h2 id="bytevector-u8-ref"><code>bytevector-u8-ref</code></h2>
<p>Returns the <code>K</code>th byte of <code>BYTEVECTOR</code>. It is an error if <code>K</code> is not a valid index of <code>BYTEVECTOR</code>.</p>
<h2 id="bytevector-u8-set"><code>bytevector-u8-set!</code></h2>
<p>Stores <code>BYTE</code> as the <code>K</code>th byte of <code>BYTEVECTOR</code>.</p>
<p>It is an error if <code>K</code> is not a valid index of <code>BYTEVECTOR</code>.</p>
<h2 id="bytevector-obj-1"><code>(bytevector? obj)</code></h2>
<p>Returns <code>#t</code> if <code>OBJ</code> is a bytevector. Otherwise, <code>#f</code> is returned.</p>
<h2 id="caar"><code>caar</code></h2>
<p>TODO</p>
<h2 id="cadr"><code>cadr</code></h2>
<p>TODO</p>
<h2 id="call-with-current-continuation-proc"><code>(call-with-current-continuation proc)</code></h2>
<p>It is an error if proc does not accept one argument.</p>
<p>The procedure call-with-current-continuation (or its equivalent abbreviation call/cc) packages the current continuation (see the rationale below) as an “escape procedure” and passes it as an argument to proc. The escape procedure is a Scheme procedure that, if it is later called, will abandon whatever continuation is in effect at that later time and will instead use the continuation that was in effect when the escape procedure was created. Calling the escape procedure will cause the invocation of before and after thunks installed using dynamic-wind.</p>
<p>The escape procedure accepts the same number of arguments as the continuation to the original call to call-with-current-continuation. Most continuations take only one value. Continuations created by the call-with-values procedure (including the initialization expressions of define-values, let-values, and let<em>-values expressions), take the number of values that the consumer expects. The continuations of all non-final expressions within a sequence of expressions, such as in lambda, case-lambda, begin, let, let</em>, letrec, letrec<em>, let-values, let</em>-values, let-syntax, letrec-syntax, parameterize, guard, case, cond, when, and unless expressions, take an arbitrary number of values because they discard the values passed to them in any event. The effect of passing no values or more than one value to continuations that were not created in one of these ways is unspecified.</p>
<p>The escape procedure that is passed to proc has unlimited extent just like any other procedure in Scheme. It can be stored in variables or data structures and can be called as many times as desired. However, like the raise and error procedures, it never returns to its caller.</p>
<p>TODO: example</p>
<h2 id="call-with-port-port-proc"><code>(call-with-port port proc)</code></h2>
<p>The <code>call-with-port</code> procedure calls <code>PROC</code> with <code>PORT</code> as an argument. If <code>PROC</code> returns, then the <code>PORT</code> is closed automatically and the values yielded by the <code>PROC</code> are returned. If <code>PROC</code> does not return, then the <code>PORT</code> must not be closed automatically unless it is possible to prove that the port will never again be used for a read or write operation.</p>
<p>It is an error if <code>PROC</code> does not accept one argument.</p>
<h2 id="call-with-values-producer-consumer"><code>(call-with-values producer consumer)</code></h2>
<p>Calls its producer argument with no arguments and a continuation that, when passed some values, calls the consumer procedure with those values as arguments. The continuation for the call to consumer is the continuation of the call to <code>call-with-values</code>.</p>
<h2 id="callcc-proc"><code>(call/cc proc)</code></h2>
<p>Abbreviation for <code>call-with-continuation</code>.</p>
<h2 id="car-pair"><code>(car pair)</code></h2>
<p>Returns the contents of the car field of pair. Note that it is an error to take the <code>car</code> of the empty list.</p>
<h2 id="case-key-clause1-clause2-...-syntax"><code>(case &lt;key&gt; &lt;clause1&gt; &lt;clause2&gt; ...)</code> syntax</h2>
<p>TODO</p>
<h2 id="cdar"><code>cdar</code></h2>
<p>TODO</p>
<h2 id="cddr"><code>cddr</code></h2>
<p>TODO</p>
<h2 id="cdr"><code>cdr</code></h2>
<p>Returns the contents of the <code>cdr</code> field of pair. Note that it is an error to take the <code>cdr</code> of the empty list.</p>
<h2 id="ceiling-x"><code>(ceiling x)</code></h2>
<p>The ceiling procedure returns the smallest integer not smaller than x.</p>
<h2 id="char-integer-char"><code>(char-&gt;integer char)</code></h2>
<p>Given a Unicode character, <code>char-&gt;integer</code> returns an exact integer between 0 and #xD7FF or between #xE000 and #x10FFFF which is equal to the Unicode scalar value of that character. Given a non-Unicode character, it returns an exact integer greater than #x10FFFF.</p>
<h2 id="char-ready-port"><code>(char-ready? [port])</code></h2>
<p>Returns #t if a character is ready on the textual input port and returns #f otherwise. If char-ready returns #t then the next read-char operation on the given port is guaranteed not to hang. If the port is at end of file then char-ready? returns #t.</p>
<h2 id="char"><code>char&lt;=?</code></h2>
<p>TODO</p>
<h2 id="char-1"><code>char&lt;?</code></h2>
<p>TODO</p>
<h2 id="char-2"><code>char=?</code></h2>
<p>TODO</p>
<h2 id="char-3"><code>char&gt;=?</code></h2>
<p>TODO</p>
<h2 id="char-4"><code>char&gt;?</code></h2>
<p>TODO</p>
<h2 id="char-5"><code>char?</code></h2>
<p>Returns #t if obj is a character, otherwise returns #f.</p>
<h2 id="close-input-port-port"><code>(close-input-port port)</code></h2>
<p>Closes the resource associated with port, rendering the port incapable of delivering or accepting data.</p>
<h2 id="close-output-port-port"><code>(close-output-port port)</code></h2>
<p>Closes the resource associated with port, rendering the port incapable of delivering or accepting data.</p>
<h2 id="close-port-port"><code>(close-port port)</code></h2>
<p>Closes the resource associated with port, rendering the port incapable of delivering or accepting data.</p>
<h2 id="complex-obj"><code>(complex? obj)</code></h2>
<p>Returns #t if obj is a complex number, otherwise returns #f.</p>
<h2 id="cond-clause1-..."><code>(cond &lt;clause1&gt; ...)</code></h2>
<p>TODO</p>
<h2 id="cond-expand"><code>cond-expand</code></h2>
<p>TODO: not implemented</p>
<h2 id="cons-obj1-obj2"><code>(cons obj1 obj2)</code></h2>
<p>Returns a newly allocated pair whose car is obj1 and whose cdr is obj2. The pair is guaranteed to be different (in the sense of eqv?) from every existing object.</p>
<h2 id="current-error-port-port"><code>(current-error-port [port])</code></h2>
<p>Returns the current default error port (an output port). That procedure is also a parameter object, which can be overridden with <code>parameterize</code>.</p>
<h2 id="current-input-port-port"><code>(current-input-port [port])</code></h2>
<p>Returns the current default input port. That procedure is also a parameter object, which can be overridden with <code>parameterize</code>.</p>
<h2 id="current-output-port"><code>current-output-port</code></h2>
<p>Returns the current default output port. That procedure is also a parameter object, which can be overridden with <code>parameterize</code>.</p>
<h2 id="define-name-expr"><code>(define &lt;name&gt; &lt;expr&gt;)</code></h2>
<p>TODO</p>
<h2 id="define-name-variable-...-expr-..."><code>(define (&lt;name&gt; &lt;variable&gt; ...) &lt;expr&gt; ...)</code></h2>
<p>TODO</p>
<h2 id="define-record-type-syntax"><code>define-record-type</code> syntax</h2>
<p>TODO</p>
<h2 id="define-syntax"><code>define-syntax</code></h2>
<p>TODO</p>
<h2 id="define-values-var1-...-expr-syntax"><code>(define-values var1 ... expr)</code> syntax</h2>
<p>creates multiple definitions from a single expression returning multiple values. It is allowed wherever define is allowed.</p>
<h2 id="denominator-q"><code>(denominator q)</code></h2>
<p>Return the denominator of their argument; the result is computed as if the argument was represented as a fraction in lowest terms. The denominator is always positive. The denominator of 0 is defined to be 1.</p>
<h2 id="do"><code>do</code></h2>
<p>TODO</p>
<h2 id="dynamic-wind-before-thunk-after"><code>(dynamic-wind before thunk after)</code></h2>
<p>TODO</p>
<h2 id="eof-object"><code>(eof-object)</code></h2>
<p>Returns an end-of-file object, not necessarily unique.</p>
<h2 id="eof-object-obj"><code>(eof-object? obj)</code></h2>
<p>Returns #t if obj is an end-of-file object, otherwise returns #f. A end-of-file object will ever be an object that can be read in using read.</p>
<h2 id="eq-obj1-obj2"><code>(eq? obj1 obj2)</code></h2>
<p>The eq? procedure is similar to eqv? except that in some cases it is capable of discerning distinctions finer than those detectable by eqv?. It must always return #f when eqv? also would, but may return #f in some cases where eqv? would return #t.</p>
<p>On symbols, booleans, the empty list, pairs, and records, and also on non-empty strings, vectors, and bytevectors, eq? and eqv? are guaranteed to have the same behavior. On procedures, eq? must return true if the arguments’ location tags are equal. On numbers and characters, eq?’s behavior is implementation-dependent, but it will always return either true or false. On empty strings, empty vectors, and empty bytevectors, eq? may also behave differently from eqv?.</p>
<h2 id="equal-obj1-obj2"><code>(equal? obj1 obj2)</code></h2>
<p>The equal? procedure, when applied to pairs, vectors, strings and bytevectors, recursively compares them, returning #t when the unfoldings of its arguments into (possibly infinite) trees are equal (in the sense of equal?) as ordered trees, and #f otherwise. It returns the same as eqv? when applied to booleans, symbols, numbers, characters, ports, procedures, and the empty list. If two objects are eqv?, they must be equal? as well. In all other cases, equal? may return either #t or #f.</p>
<p>Even if its arguments are circular data structures, equal? must always terminate.</p>
<h2 id="eqv-obj1-obj2"><code>(eqv? obj1 obj2)</code></h2>
<p>The eqv? procedure defines a useful equivalence relation on objects. Briefly, it returns #t if obj1 and obj2 are normally regarded as the same object.</p>
<p>TODO: complete based on r7rs small and guile.</p>
<h2 id="error-who-message-.-irritants"><code>(error [who] message . irritants)</code></h2>
<p>Raises an exception as if by calling raise on a newly allocated implementation-defined object which encapsulates the information provided by message, as well as any objs, known as the irritants. The procedure error-object? must return #t on such objects.</p>
<h2 id="error-object-irritants-error"><code>(error-object-irritants error)</code></h2>
<p>Returns a list of the irritants encapsulated by error.</p>
<h2 id="error-object-message-error"><code>(error-object-message error)</code></h2>
<p>Returns the message encapsulated by error.</p>
<h2 id="error-object-obj"><code>(error-object? obj)</code></h2>
<p>Returns #t if obj is an object created by <code>error</code> or one of an implementation-defined set of objects. Otherwise, it returns #f. The objects used to signal errors, including those which satisfy the predicates <code>file-error?</code> and <code>read-error?</code>, may or may not satisfy <code>error-object?</code>.</p>
<h2 id="even-number"><code>(even? number)</code></h2>
<p>Return <code>#t</code> if <code>NUMBER</code> is even. Otherwise <code>#f</code>.</p>
<h2 id="exact-z"><code>(exact z)</code></h2>
<p>TODO: FIXME</p>
<p>The procedure exact returns an exact representation of z. The value returned is the exact number that is numerically closest to the argument. For exact arguments, the result is the same as the argument. For inexact non-integral real arguments, the implementation may return a rational approximation, or may report an implementation violation. For inexact complex arguments, the result is a complex number whose real and imaginary parts are the result of applying exact to the real and imaginary parts of the argument, respectively. If an inexact argument has no reasonably close exact equivalent, (in the sense of <code>=</code>), then a violation of an implementation restriction may be reported.</p>
<h2 id="exact-integer-sqrt-k"><code>(exact-integer-sqrt k)</code></h2>
<p>TODO</p>
<h2 id="exact-integer-z"><code>(exact-integer? z)</code></h2>
<p>Returns #t if z is both exact and an integer; otherwise returns #f.</p>
<h2 id="exact-z-1"><code>(exact? z)</code></h2>
<p>Return <code>#t</code> if <code>Z</code> is exact. Otherwise <code>#f</code>.</p>
<h2 id="expt-z1-z2"><code>(expt z1 z2)</code></h2>
<p>Returns <code>z1</code> raised to the power <code>z2</code>.</p>
<h2 id="features"><code>features</code></h2>
<p>TODO: no implemented</p>
<h2 id="file-error-error"><code>(file-error? error)</code></h2>
<p>TODO: not implemented?</p>
<h2 id="floor-x"><code>(floor x)</code></h2>
<p>The floor procedure returns the largest integer not larger than x.</p>
<h2 id="floor-quotient"><code>floor-quotient</code></h2>
<p>TODO</p>
<h2 id="floor-remainder"><code>floor-remainder</code></h2>
<p>TODO</p>
<h2 id="floor"><code>floor/</code></h2>
<p>TODO</p>
<h2 id="flush-output-port-port"><code>(flush-output-port [port])</code></h2>
<p>Flushes any buffered output from the buffer of output-port to the underlying file or device and returns an unspecified value.</p>
<h2 id="for-each-proc-list1-..."><code>(for-each proc list1 ...)</code></h2>
<p>It is an error if proc does not accept as many arguments as there are lists.</p>
<p>The arguments to for-each are like the arguments to map, but for-each calls proc for its side effects rather than for its values. Unlike map, for-each is guaranteed to call proc on the elements of the lists in order from the first element(s) to the last, and the value returned by for-each is unspecified. If more than one list is given and not all lists have the same length, for-each terminates when the shortest list runs out. The lists can be circular, but it is an error if all of them are circular.</p>
<h2 id="gcd-n1-..."><code>(gcd n1 ...)</code></h2>
<p>Return the greatest common divisor.</p>
<h2 id="get-output-bytevector-port"><code>(get-output-bytevector port)</code></h2>
<p>It is an error if port was not created with <code>open-output-bytevector</code>.</p>
<p>Returns a bytevector consisting of the bytes that have been output to the port so far in the order they were output.</p>
<h2 id="get-output-string-port"><code>(get-output-string port)</code></h2>
<p>It is an error if port was not created with open-output-string.</p>
<p>Returns a string consisting of the characters that have been output to the port so far in the order they were output.</p>
<h2 id="guard-clause-...-syntax"><code>(guard &lt;clause&gt; ...)</code> syntax</h2>
<p>TODO</p>
<h2 id="if-expr-then-else"><code>(if &lt;expr&gt; &lt;then&gt; [&lt;else&gt;])</code></h2>
<p>TODO</p>
<h2 id="include"><code>include</code></h2>
<p>TODO</p>
<h2 id="include-ci"><code>include-ci</code></h2>
<p>TODO: not implemented</p>
<h2 id="inexact-z"><code>(inexact z)</code></h2>
<p>The procedure inexact returns an inexact representation of z. The value returned is the inexact number that is numerically closest to the argument. For inexact arguments, the result is the same as the argument. For exact complex numbers, the result is a complex number whose real and imaginary parts are the result of applying inexact to the real and imaginary parts of the argument, respectively. If an exact argument has no reasonably close inexact equivalent (in the sense of <code>=</code>), then a violation of an implementation restriction may be reported.</p>
<h2 id="inexact-z-1"><code>(inexact? z)</code></h2>
<p>Return <code>#t</code> if <code>Z</code> is inexact. Otherwise <code>#f</code>.</p>
<h2 id="input-port-open-port"><code>(input-port-open? port)</code></h2>
<p>Returns #t if port is still open and capable of performing input, and <code>#f</code> otherwise.</p>
<h2 id="input-port-obj"><code>(input-port? obj)</code></h2>
<p>Return <code>#t</code> if obj is an input port. Otherwise it return <code>#f</code>.</p>
<h2 id="integer-char-integer"><code>(integer-&gt;char integer)</code></h2>
<p>Given an exact integer that is the value returned by a character when char-&gt;integer is applied to it, integer-&gt;char returns that character.</p>
<h2 id="integer-obj"><code>(integer? obj)</code></h2>
<p>Return <code>#t</code> if <code>OBJ</code> is an integer. Otherwise <code>#f</code>.</p>
<h2 id="lambda-formals-expr-..."><code>(lambda &lt;formals&gt; &lt;expr&gt; ...)</code></h2>
<p>TODO</p>
<h2 id="lcm-n1-..."><code>(lcm n1 ...)</code></h2>
<p>Return the least common multiple of its arguments.</p>
<h2 id="length-list"><code>(length list)</code></h2>
<p>Returns the length of list.</p>
<h2 id="let"><code>let</code></h2>
<p>TODO</p>
<h2 id="let-1"><code>let*</code></h2>
<p>TODO</p>
<h2 id="let-values"><code>let*-values</code></h2>
<p>TODO</p>
<h2 id="let-syntax"><code>let-syntax</code></h2>
<p>TODO</p>
<h2 id="let-values-1"><code>let-values</code></h2>
<p>TODO</p>
<h2 id="letrec"><code>letrec</code></h2>
<p>TODO</p>
<h2 id="letrec-1"><code>letrec*</code></h2>
<p>TODO</p>
<h2 id="letrec-syntax"><code>letrec-syntax</code></h2>
<p>TODO</p>
<h2 id="list-obj-..."><code>(list obj ...)</code></h2>
<p>Returns a newly allocated list of its arguments.</p>
<h2 id="list-string-list"><code>(list-&gt;string list)</code></h2>
<p>It is an error if any element of list is not a character.</p>
<p>list-&gt;string returns a newly allocated string formed from the elements in the list list.</p>
<h2 id="list-vector-list"><code>(list-&gt;vector list)</code></h2>
<p>The list-&gt;vector procedure returns a newly created vector initialized to the elements of the list list.</p>
<h2 id="list-copy-obj"><code>(list-copy obj)</code></h2>
<p>Returns a newly allocated copy of the given obj if it is a list. Only the pairs themselves are copied; the cars of the result are the same (in the sense of eqv?) as the cars of list. If obj is an improper list, so is the result, and the final cdrs are the same in the sense of eqv?. An obj which is not a list is returned unchanged. It is an error if obj is a circular list.</p>
<h2 id="list-ref-list-k"><code>(list-ref list k)</code></h2>
<p>The list argument can be circular, but it is an error if list has fewer than k elements.</p>
<p>Returns the kth element of list. (This is the same as the car of (list-tail list k).)</p>
<h2 id="list-set-list-k-obj"><code>(list-set! list k obj)</code></h2>
<p>It is an error if k is not a valid index of list.</p>
<p>The list-set! procedure stores obj in element k of list.</p>
<h2 id="list-tail-list-k"><code>(list-tail list k)</code></h2>
<p>It is an error if list has fewer than k elements.</p>
<p>Returns the sublist of list obtained by omitting the first k elements.</p>
<h2 id="list-obj"><code>(list? obj)</code></h2>
<p>Return <code>#t</code> if <code>OBJ</code> is a list. Otherwise <code>#f</code>.</p>
<h2 id="make-bytevector-k-byte"><code>(make-bytevector k [byte])</code></h2>
<p>The make-bytevector procedure returns a newly allocated bytevector of length k. If byte is given, then all elements of the bytevector are initialized to byte, otherwise the contents of each element are unspecified.</p>
<h2 id="make-list-k-fill"><code>(make-list k [fill])</code></h2>
<p>Returns a newly allocated list of k elements. If a second argument is given, then each element is initialized to fill. Otherwise the initial contents of each element is unspecified.</p>
<h2 id="make-parameter-init-converter"><code>(make-parameter init [converter])</code></h2>
<p>Returns a newly allocated parameter object, which is a procedure that accepts zero arguments and returns the value associated with the parameter object. Initially, this value is the value of (converter init), or of init if the conversion procedure converter is not specified. The associated value can be temporarily changed using parameterize, which is described below.</p>
<h2 id="make-string-k-char"><code>(make-string k [char])</code></h2>
<p>The make-string procedure returns a newly allocated string of length k. If char is given, then all the characters of the string are initialized to char, otherwise the contents of the string are unspecified.</p>
<h2 id="make-vector-k-fill"><code>(make-vector k [fill])</code></h2>
<p>Returns a newly allocated vector of k elements. If a second argument is given, then each element is initialized to fill. Otherwise the initial contents of each element is unspecified.</p>
<h2 id="map-proc-list1-..."><code>(map proc list1 ...)</code></h2>
<p>It is an error if proc does not accept as many arguments as there are lists and return a single value.</p>
<p>The map procedure applies proc element-wise to the elements of the lists and returns a list of the results, in order. If more than one list is given and not all lists have the same length, map terminates when the shortest list runs out. The lists can be circular, but it is an error if all of them are circular. It is an error for proc to mutate any of the lists. The dynamic order in which proc is applied to the elements of the lists is unspecified. If multiple returns occur from map, the values returned by earlier returns are not mutated.</p>
<h2 id="max-x1-..."><code>(max x1 ...)</code></h2>
<p>Return the maximum of its arguments.</p>
<h2 id="member-obj-list-compare"><code>(member obj list [compare])</code></h2>
<p>Return the first sublist of list whose <code>car</code> is <code>obj</code>, where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list. If <code>obj</code> does not occur in <code>list</code>, then <code>#f</code> (not the empty list) is returned.</p>
<p>Uses <code>compare</code>, if given, and <code>equal?</code> otherwise.</p>
<h2 id="memq-obj-list"><code>(memq obj list)</code></h2>
<p>Return the first sublist of list whose <code>car</code> is <code>obj</code>, where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list. If <code>obj</code> does not occur in <code>list</code>, then <code>#f</code> (not the empty list) is returned.</p>
<p>Use <code>eq?</code> for comparison.</p>
<h2 id="memv-obj-list"><code>(memv obj list)</code></h2>
<p>Return the first sublist of list whose <code>car</code> is <code>obj</code>, where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list. If <code>obj</code> does not occur in <code>list</code>, then <code>#f</code> (not the empty list) is returned.</p>
<p>Uses <code>eqv?</code> for comparison.</p>
<h2 id="min-x1-..."><code>(min x1 ...)</code></h2>
<p>Return the minimum of its arguments.</p>
<h2 id="modulo-n1-n2"><code>(modulo n1 n2)</code></h2>
<p><code>modulo</code> is equivalent to <code>floor-remainder</code>. Provided for backward compatibility.</p>
<h2 id="negative-x"><code>(negative? x)</code></h2>
<p>Return <code>#t</code> if <code>X</code> is negative. Otherwise <code>#f</code>.</p>
<h2 id="newline-port"><code>(newline [port])</code></h2>
<p>Writes an end of line to output port.</p>
<h2 id="not-obj"><code>(not obj)</code></h2>
<p>The not procedure returns #t if obj is false, and returns #f otherwise.</p>
<h2 id="null-obj"><code>(null? obj)</code></h2>
<p>Returns #t if obj is the empty list, otherwise returns #f.</p>
<h2 id="number-string-z-radix"><code>(number-&gt;string z [radix])</code></h2>
<p>It is an error if radix is not one of 2, 8, 10, or 16.</p>
<h2 id="number-obj"><code>(number? obj)</code></h2>
<p>Return <code>#t</code> if <code>OBJ</code> is a number. Otherwise <code>#f</code>.</p>
<h2 id="numerator-q"><code>(numerator q)</code></h2>
<p>TODO</p>
<h2 id="odd-number"><code>(odd? number)</code></h2>
<p>Return <code>#t</code> if <code>NUMBER</code> is odd. Otherwise <code>#f</code>.</p>
<h2 id="open-input-bytevector-bytevector"><code>(open-input-bytevector bytevector)</code></h2>
<p>Takes a bytevector and returns a binary input port that delivers bytes from the bytevector.</p>
<h2 id="open-input-string-string"><code>(open-input-string string)</code></h2>
<p>Takes a string and returns a textual input port that delivers characters from the string. If the string is modified, the effect is unspecified.</p>
<h2 id="open-output-bytevector"><code>(open-output-bytevector)</code></h2>
<p>Returns a binary output port that will accumulate bytes for retrieval by <code>get-output-bytevector</code>.</p>
<h2 id="open-output-string"><code>(open-output-string)</code></h2>
<p>Returns a textual output port that will accumulate characters for retrieval by <code>get-output-string</code>.</p>
<h2 id="or-test1-...-syntax"><code>(or test1 ...)</code> syntax</h2>
<p>The <code>test</code> expressions are evaluated from left to right, and the value of the first expression that evaluates to a true value is returned. Any remaining expressions are not evaluated. If all expressions evaluate to #f or if there are no expressions, then #f is returned.</p>
<h2 id="output-port-open-port"><code>(output-port-open? port)</code></h2>
<p>Returns #t if port is still open and capable of performing output, and #f otherwise.</p>
<h2 id="output-port-obj"><code>(output-port? obj)</code></h2>
<p>Return #t if obj is an output port. Otherwise return #f.</p>
<h2 id="pair-obj"><code>(pair? obj)</code></h2>
<p>The pair? predicate returns #t if obj is a pair, and otherwise returns #f.</p>
<h2 id="parameterize-param1-value1-...-expr-..."><code>(parameterize ((param1 value1) ...) expr ...)</code></h2>
<p>A parameterize expression is used to change the values returned by specified parameter objects during the evaluation of the body.</p>
<p>The param and value expressions are evaluated in an unspecified order. The body is evaluated in a dynamic environment in which calls to the parameters return the results of passing the corresponding values to the conversion procedure specified when the parameters were created. Then the previous values of the parameters are restored without passing them to the conversion procedure. The results of the last expression in the body are returned as the results of the entire parameterize expression.</p>
<p>Note: If the conversion procedure is not idempotent, the results of (parameterize ((x (x))) …), which appears to bind the parameter x to its current value, might not be what the user expects.</p>
<p>If an implementation supports multiple threads of execution, then parameterize must not change the associated values of any parameters in any thread other than the current thread and threads created inside body.</p>
<p>Parameter objects can be used to specify configurable settings for a computation without the need to pass the value to every procedure in the call chain explicitly.</p>
<h2 id="peek-char-port"><code>(peek-char [port])</code></h2>
<p>Returns the next character available from the textual input port, but without updating the port to point to the following character. If no more characters are available, an end-of-file object is returned.</p>
<p>Note: The value returned by a call to peek-char is the same as the value that would have been returned by a call to read-char with the same port. The only difference is that the very next call to read-char or peek-char on that port will return the value returned by the preceding call to peek-char. In particular, a call to peek-char on an interactive port will hang waiting for input whenever a call to read-char would have hung.</p>
<h2 id="peek-u8-port"><code>(peek-u8 [port])</code></h2>
<p>Returns the next byte available from the binary input port, but without updating the port to point to the following byte. If no more bytes are available, an end-of-file object is returned.</p>
<h2 id="port-obj"><code>(port? obj)</code></h2>
<p>Return <code>#t</code> if <code>OBJ</code> is port. Otherwise <code>#f</code>.</p>
<h2 id="positive-x"><code>(positive? x)</code></h2>
<p>Return <code>#t</code> if <code>X</code> is positive. Otherwise <code>#f</code>.</p>
<h2 id="procedure-obj"><code>(procedure? obj)</code></h2>
<p>Return <code>#t</code> if <code>OBJ</code> is a procedure. Otherwise <code>#f</code>.</p>
<h2 id="quasiquote"><code>quasiquote</code></h2>
<p>TODO</p>
<h2 id="quote"><code>quote</code></h2>
<p>TODO</p>
<h2 id="quotient"><code>quotient</code></h2>
<p>TODO</p>
<h2 id="raise-obj"><code>(raise obj)</code></h2>
<p>Raises an exception by invoking the current exception handler on obj. The handler is called with the same dynamic environment as that of the call to raise, except that the current exception handler is the one that was in place when the handler being called was installed. If the handler returns, a secondary exception is raised in the same dynamic environment as the handler. The relationship between obj and the object raised by the secondary exception is unspecified.</p>
<h2 id="raise-continuable-obj"><code>(raise-continuable obj)</code></h2>
<p>Raises an exception by invoking the current exception handler on obj. The handler is called with the same dynamic environment as the call to raise-continuable, except that: (1) the current exception handler is the one that was in place when the handler being called was installed, and (2) if the handler being called returns, then it will again become the current exception handler. If the handler returns, the values it returns become the values returned by the call to raise-continuable.</p>
<h2 id="rational-obj"><code>(rational? obj)</code></h2>
<p>Return <code>#t</code> if <code>OBJ</code> is a rational number. Otherwise <code>#f</code>.</p>
<h2 id="rationalize-x-y"><code>(rationalize x y)</code></h2>
<p>The rationalize procedure returns the simplest rational number differing from x by no more than y.</p>
<h2 id="read-bytevector-k-port"><code>(read-bytevector k [port])</code></h2>
<p>Reads the next k bytes, or as many as are available before the end of file, from the binary input port into a newly allocated bytevector in left-to-right order and returns the bytevector. If no bytes are available before the end of file, an end-of-file object is returned.</p>
<h2 id="read-bytevector-bytevector-port-start-end"><code>(read-bytevector! bytevector [port [start [end]]])</code></h2>
<p>Reads the next end - start bytes, or as many as are available before the end of file, from the binary input port into bytevector in left-to-right order beginning at the start position. If end is not supplied, reads until the end of bytevector has been reached. If start is not supplied, reads beginning at position 0. Returns the number of bytes read. If no bytes are available, an end-of-file object is returned.</p>
<h2 id="read-char-port"><code>(read-char [port])</code></h2>
<p>Returns the next character available from the textual input port, updating the port to point to the following character. If no more characters are available, an end-of-file object is returned.</p>
<h2 id="read-error-obj"><code>(read-error? obj)</code></h2>
<p>Error type predicates. Returns #t if obj is an object raised by the read procedure. Otherwise, it returns #f.</p>
<h2 id="read-line-port"><code>(read-line [port])</code></h2>
<p>Returns the next line of text available from the textual input port, updating the port to point to the following character. If an end of line is read, a string containing all of the text up to (but not including) the end of line is returned, and the port is updated to point just past the end of line. If an end of file is encountered before any end of line is read, but some characters have been read, a string containing those characters is returned. If an end of file is encountered before any characters are read, an end-of-file object is returned. For the purpose of this procedure, an end of line consists of either a linefeed character, a carriage return character, or a sequence of a carriage return character followed by a linefeed character. Implementations may also recognize other end of line characters or sequences.</p>
<h2 id="read-string-k-port"><code>(read-string k [port])</code></h2>
<p>Reads the next k characters, or as many as are available before the end of file, from the textual input port into a newly allocated string in left-to-right order and returns the string. If no characters are available before the end of file, an end-of-file object is returned.</p>
<h2 id="read-u8-port"><code>(read-u8 [port])</code></h2>
<p>Returns the next byte available from the binary input port, updating the port to point to the following byte. If no more bytes are available, an end-of-file object is returned.</p>
<h2 id="real-obj"><code>(real? obj)</code></h2>
<p>Return #t if <code>OBJ</code> is real number. Otherwise <code>#f</code>.</p>
<h2 id="remainder-n1-n2"><code>(remainder n1 n2)</code></h2>
<p>TODO</p>
<h2 id="reverse-list"><code>(reverse list)</code></h2>
<p>Returns a newly allocated list consisting of the elements of list in reverse order.</p>
<h2 id="round-x"><code>(round x)</code></h2>
<p>TODO</p>
<h2 id="set-variable-expression-syntax"><code>(set! &lt;variable&gt; &lt;expression&gt;)</code> syntax</h2>
<p>Expression is evaluated, and the resulting value is stored in the location to which variable is bound. It is an error if variable is not bound either in some region enclosing the set! expression or else globally. The result of the set! expression is unspecified.</p>
<h2 id="set-car-pair-obj"><code>(set-car! pair obj)</code></h2>
<p>Stores <code>obj</code> in the car field of <code>pair</code>.</p>
<h2 id="set-cdr-pair-obj"><code>(set-cdr! pair obj)</code></h2>
<p>Stores obj in the cdr field of pair.</p>
<h2 id="square-z"><code>(square z)</code></h2>
<p>Returns the square of z. This is equivalent to (* z z).</p>
<h2 id="string-char-..."><code>(string char ...)</code></h2>
<p>Returns a newly allocated string composed of the arguments. It is analogous to list.</p>
<h2 id="string-list-string-start-end"><code>(string-&gt;list string [start [end]])</code></h2>
<p>The string-&gt;list procedure returns a newly allocated list of the characters of string between start and end.</p>
<h2 id="string-number-string-radix"><code>(string-&gt;number string [radix])</code></h2>
<p>Returns a number of the maximally precise representation expressed by the given string. It is an error if radix is not 2, 8, 10, or 16.</p>
<p>If supplied, radix is a default radix that will be overridden if an explicit radix prefix is present in string (e.g. “#o177”). If radix is not supplied, then the default radix is 10. If string is not a syntactically valid notation for a number, or would result in a number that the implementation cannot represent, then string-&gt;number returns #f. An error is never signaled due to the content of string.</p>
<h2 id="string-symbol-string"><code>(string-&gt;symbol string)</code></h2>
<p>Returns the symbol whose name is string. This procedure can create symbols with names containing special characters that would require escaping when written, but does not interpret escapes in its input.</p>
<h2 id="string-utf8-string-start-end"><code>(string-&gt;utf8 string [start [end]])</code></h2>
<p>The string-&gt;utf8 procedure encodes the characters of a string between start and end and returns the corresponding bytevector.</p>
<h2 id="string-vector-string-start-end"><code>(string-&gt;vector string [start [end]])</code></h2>
<p>The string-&gt;vector procedure returns a newly created vector initialized to the elements of the string string between start and end.</p>
<h2 id="string-append-string-..."><code>(string-append string ...)</code></h2>
<p>Returns a newly allocated string whose characters are the concatenation of the characters in the given strings.</p>
<h2 id="string-copy-string-start-end"><code>(string-copy string [start [end]])</code></h2>
<p>Returns a newly allocated copy of the part of the given string between start and end.</p>
<h2 id="string-copy-to-at-from-start-end"><code>(string-copy! to at from [start [end]])</code></h2>
<p>It is an error if at is less than zero or greater than the length of to. It is also an error if (- (string-length to) at) is less than (- end start).</p>
<p>Copies the characters of string from between start and end to string to, starting at at. The order in which characters are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary string and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances.</p>
<h2 id="string-fill-string-fill-start-end"><code>(string-fill! string fill [start [end]])</code></h2>
<p>It is an error if fill is not a character.</p>
<p>The string-fill! procedure stores fill in the elements of string between start and end.</p>
<h2 id="string-for-each-proc-string1-..."><code>(string-for-each proc string1 ...)</code></h2>
<p>It is an error if proc does not accept as many arguments as there are strings.</p>
<p>The arguments to string-for-each are like the arguments to string-map, but string-for-each calls proc for its side effects rather than for its values. Unlike string-map, string-for-each is guaranteed to call proc on the elements of the lists in order from the first element(s) to the last, and the value returned by string-for-each is unspecified. If more than one string is given and not all strings have the same length, string-for-each terminates when the shortest string runs out. It is an error for proc to mutate any of the strings.</p>
<h2 id="string-length-string"><code>(string-length string)</code></h2>
<p>Returns the number of characters in the given string.</p>
<h2 id="string-map-proc-string1-..."><code>(string-map proc string1 ...)</code></h2>
<p>It is an error if proc does not accept as many arguments as there are strings and return a single character.</p>
<p>The string-map procedure applies proc element-wise to the elements of the strings and returns a string of the results, in order. If more than one string is given and not all strings have the same length, string-map terminates when the shortest string runs out. The dynamic order in which proc is applied to the elements of the strings is unspecified. If multiple returns occur from string-map, the values returned by earlier returns are not mutated.</p>
<h2 id="string-ref-string-k"><code>(string-ref string k)</code></h2>
<p>It is an error if k is not a valid index of string.</p>
<p>The string-ref procedure returns character k of string using zero-origin indexing. There is no requirement for this procedure to execute in constant time.</p>
<h2 id="string-set-string-k-char"><code>(string-set! string k char)</code></h2>
<p>It is an error if k is not a valid index of string.</p>
<p>The string-set! procedure stores char in element k of string. There is no requirement for this procedure to execute in constant time.</p>
<h2 id="string-1"><code>string&lt;=?</code></h2>
<p>TODO</p>
<h2 id="string-2"><code>string&lt;?</code></h2>
<p>TODO</p>
<h2 id="string-string1-string2-..."><code>(string=? string1 string2 ...)</code></h2>
<p>Returns #t if all the strings are the same length and contain exactly the same characters in the same positions, otherwise returns #f.</p>
<h2 id="string-3"><code>string&gt;=?</code></h2>
<p>TODO</p>
<h2 id="string-4"><code>string&gt;?</code></h2>
<p>TODO</p>
<h2 id="string-obj"><code>(string? obj)</code></h2>
<p>Return <code>#t</code> if <code>OBJ</code> is string. Otherwise <code>#f</code>.</p>
<h2 id="substring-string-start-end"><code>(substring string start end)</code></h2>
<p>The substring procedure returns a newly allocated string formed from the characters of string beginning with index start and ending with index end. This is equivalent to calling string-copy with the same arguments, but is provided for backward compatibility and stylistic flexibility.</p>
<h2 id="symbol-string-symbol"><code>(symbol-&gt;string symbol)</code></h2>
<p>Returns the name of symbol as a string, but without adding escapes. It is an error to apply mutation procedures like string-set! to strings returned by this procedure.</p>
<h2 id="symbol-symbol1-symbol2-..."><code>(symbol=? symbol1 symbol2 ...)</code></h2>
<p>Returns #t if all the arguments are symbols and all have the same names in the sense of string=?.</p>
<h2 id="symbol-obj"><code>(symbol? obj)</code></h2>
<p>Returns #t if obj is a symbol, otherwise returns #f.</p>
<h2 id="syntax-error"><code>syntax-error</code></h2>
<p>TODO</p>
<h2 id="syntax-rules"><code>syntax-rules</code></h2>
<p>TODO</p>
<h2 id="textual-port"><code>textual-port?</code></h2>
<p>TODO</p>
<h2 id="truncate-x"><code>(truncate x)</code></h2>
<p>TODO</p>
<h2 id="truncate-quotient"><code>truncate-quotient</code></h2>
<p>TODO</p>
<h2 id="truncate-remainder"><code>truncate-remainder</code></h2>
<p>TODO</p>
<h2 id="truncate"><code>truncate/</code></h2>
<p>TODO</p>
<h2 id="u8-ready-port"><code>(u8-ready? [port])</code></h2>
<p>Returns #t if a byte is ready on the binary input port and returns #f otherwise. If u8-ready? returns #t then the next read-u8 operation on the given port is guaranteed not to hang. If the port is at end of file then u8-ready? returns #t.</p>
<h2 id="unless-test-expr-...-syntax"><code>(unless &lt;test&gt; &lt;expr&gt; ...)</code> syntax</h2>
<p>The test is evaluated, and if it evaluates to #f, the expressions are evaluated in order. The result of the unless expression is unspecified.</p>
<h2 id="unquote"><code>unquote</code></h2>
<p>TODO</p>
<h2 id="unquote-splicing"><code>unquote-splicing</code></h2>
<p>TODO</p>
<h2 id="utf8-string-bytevector-start-end"><code>(utf8-&gt;string bytevector [start [end]])</code></h2>
<p>It is an error for bytevector to contain invalid UTF-8 byte sequences.</p>
<p>The utf8-&gt;string procedure decodes the bytes of a bytevector between start and end and returns the corresponding string.</p>
<h2 id="values-obj-..."><code>(values obj ...)</code></h2>
<p>Delivers all of its arguments to its continuation.</p>
<h2 id="vector-obj-..."><code>(vector obj ...)</code></h2>
<p>Returns a newly allocated vector whose elements contain the given arguments. It is analogous to list.</p>
<h2 id="vector-list-vector-start-end"><code>(vector-&gt;list vector [start [end]])</code></h2>
<p>The vector-&gt;list procedure returns a newly allocated list of the objects contained in the elements of vector between start and end. The list-&gt;vector procedure returns a newly created vector initialized to the elements of the list list.</p>
<h2 id="vector-string-vector-start-end"><code>(vector-&gt;string vector [start [end]])</code></h2>
<p>It is an error if any element of vector between start and end is not a character.</p>
<p>The vector-&gt;string procedure returns a newly allocated string of the objects contained in the elements of vector between start and end. The string-&gt;vector procedure returns a newly created vector initialized to the elements of the string string between start and end.</p>
<h2 id="vector-append-vector-..."><code>(vector-append vector ...)</code></h2>
<p>Returns a newly allocated vector whose elements are the concatenation of the elements of the given vectors.</p>
<h2 id="vector-copy-vector-start-end"><code>(vector-copy vector [start [end]])</code></h2>
<p>Returns a newly allocated copy of the elements of the given vector between start and end. The elements of the new vector are the same (in the sense of eqv?) as the elements of the old.</p>
<h2 id="vector-copy-to-at-from-start-end"><code>(vector-copy! to at from [start [end]])</code></h2>
<p>It is an error if at is less than zero or greater than the length of to. It is also an error if (- (vector-length to) at) is less than (- end start).</p>
<p>Copies the elements of vector from between start and end to vector to, starting at at. The order in which elements are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary vector and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances.</p>
<h2 id="vector-fill-vector-fill-start-end"><code>(vector-fill! vector fill [start [end]])</code></h2>
<p>The vector-fill! procedure stores fill in the elements of vector between start and end.</p>
<h2 id="vector-for-each-proc-vector1-..."><code>(vector-for-each proc vector1 ...)</code></h2>
<p>It is an error if proc does not accept as many arguments as there are vectors.</p>
<p>The arguments to vector-for-each are like the arguments to vector-map, but vector-for-each calls proc for its side effects rather than for its values. Unlike vector-map, vector-for-each is guaranteed to call proc on the elements of the vectors in order from the first element(s) to the last, and the value returned by vector-for-each is unspecified. If more than one vector is given and not all vectors have the same length, vector-for-each terminates when the shortest vector runs out. It is an error for proc to mutate any of the vectors.</p>
<h2 id="vector-length-vector"><code>(vector-length vector)</code></h2>
<p>Returns the number of elements in vector as an exact integer.</p>
<h2 id="vector-map-proc-vector1-..."><code>(vector-map proc vector1 ...)</code></h2>
<p>It is an error if proc does not accept as many arguments as there are vectors and return a single value.</p>
<p>The vector-map procedure applies proc element-wise to the elements of the vectors and returns a vector of the results, in order. If more than one vector is given and not all vectors have the same length, vector-map terminates when the shortest vector runs out. The dynamic order in which proc is applied to the elements of the vectors is unspecified. If multiple returns occur from vector-map, the values returned by earlier returns are not mutated.</p>
<h2 id="vector-ref-vector-k"><code>(vector-ref vector k)</code></h2>
<p>It is an error if k is not a valid index of vector.</p>
<p>The vector-ref procedure returns the contents of element k of vector.</p>
<h2 id="vector-set-vector-k-obj"><code>(vector-set! vector k obj)</code></h2>
<p>It is an error if k is not a valid index of vector.</p>
<p>The vector-set! procedure stores obj in element k of vector.</p>
<h2 id="vector-1"><code>vector?</code></h2>
<p>Returns #t if obj is a bytevector. Otherwise, #f is returned.</p>
<h2 id="when-test-expr-...-syntax"><code>(when &lt;test&gt; &lt;expr&gt; ...)</code> syntax</h2>
<p>The test is evaluated, and if it evaluates to a true value, the expressions are evaluated in order. The result of the when expression is unspecified.</p>
<h2 id="with-exception-handler"><code>with-exception-handler</code></h2>
<p>TODO</p>
<h2 id="write-bytevector-bytevector-port-start-end"><code>(write-bytevector bytevector [port [start [end]]])</code></h2>
<p>Writes the bytes of bytevector from start to end in left-to-right order to the binary output port.</p>
<h2 id="write-char-char-port"><code>(write-char char [port])</code></h2>
<p>Writes the character char (not an external representation of the character) to the given textual output port and returns an unspecified value.</p>
<h2 id="write-string-string-port-start-end"><code>(write-string string [port [start [end]]])</code></h2>
<p>Writes the characters of string from start to end in left-to-right order to the textual output port.</p>
<h2 id="write-u8-byte-port"><code>(write-u8 byte [port])</code></h2>
<p>Writes the byte to the given binary output port and returns an unspecified value.</p>
<h2 id="zero-z"><code>(zero? z)</code></h2>
<p>Return <code>#t</code> if z is zero. Otherwise <code>#f</code>. # <code>(scheme time)</code></p>
<h2 id="current-jiffy"><code>(current-jiffy)</code></h2>
<p>Returns the number of jiffies as an exact integer that have elapsed since an arbitrary, implementation-defined epoch. A jiffy is an implementation-defined fraction of a second which is defined by the return value of the jiffies-per-second procedure. The starting epoch is guaranteed to be constant during a run of the program, but may vary between runs.</p>
<h2 id="current-second"><code>(current-second)</code></h2>
<p>Returns an inexact number representing the current time on the International Atomic Time (TAI) scale. The value 0.0 represents midnight on January 1, 1970 TAI (equivalent to ten seconds before midnight Universal Time) and the value 1.0 represents one TAI second later. Neither high accuracy nor high precision are required; in particular, returning Coordinated Universal Time plus a suitable constant might be the best an implementation can do.</p>
<h2 id="jiffies-per-second"><code>(jiffies-per-second)</code></h2>
<p>Returns an exact integer representing the number of jiffies per SI second. This value is an implementation-specified constant.</p>
<h1 id="scheme-char"><code>(scheme char)</code></h1>
<h2 id="char-alphabetic-char"><code>(char-alphabetic? char)</code></h2>
<p>TODO</p>
<h2 id="char-alphabetic-char-1"><code>(char-alphabetic? char)</code></h2>
<p>TODO</p>
<h2 id="char-ci-char"><code>(char-ci&lt;=? char)</code></h2>
<p>TODO</p>
<h2 id="char-ci-char-1"><code>(char-ci&lt;? char)</code></h2>
<p>TODO</p>
<h2 id="char-ci-char-2"><code>(char-ci=? char)</code></h2>
<p>TODO</p>
<h2 id="char-ci-char-3"><code>(char-ci&gt;=? char)</code></h2>
<p>TODO</p>
<h2 id="char-ci-char-4"><code>(char-ci&gt;? char)</code></h2>
<p>TODO</p>
<h2 id="char-downcase-char"><code>(char-downcase char)</code></h2>
<p>TODO</p>
<h2 id="char-foldcase-char"><code>(char-foldcase char)</code></h2>
<p>TODO</p>
<h2 id="char-lower-case-char"><code>(char-lower-case? char)</code></h2>
<p>TODO</p>
<h2 id="char-numeric-char"><code>(char-numeric? char)</code></h2>
<p>TODO</p>
<h2 id="char-upcase-char"><code>(char-upcase char)</code></h2>
<p>TODO</p>
<h2 id="char-upper-case-char"><code>(char-upper-case? char)</code></h2>
<p>TODO</p>
<h2 id="char-whitespace-char"><code>(char-whitespace? char)</code></h2>
<p>TODO</p>
<h2 id="string-ci-string1-string2-..."><code>(string-ci&lt;=? string1 string2 ...)</code></h2>
<p>TODO</p>
<h2 id="string-ci-string1-string2-...-1"><code>(string-ci&lt;? string1 string2 ...)</code></h2>
<p>TODO</p>
<h2 id="string-ci-string1-string2-...-2"><code>(string-ci=? string1 string2 ...)</code></h2>
<p>TODO</p>
<h2 id="string-ci-string1-string2-...-3"><code>(string-ci&gt;=? string1 string2 ...)</code></h2>
<p>TODO</p>
<h2 id="string-ci-string1-string2-...-4"><code>(string-ci&gt;? string1 string2 ...)</code></h2>
<p>TODO</p>
<h2 id="string-downcase-string"><code>(string-downcase string)</code></h2>
<p>TODO</p>
<h2 id="string-foldcase-string"><code>(string-foldcase string)</code></h2>
<p>TODO</p>
<h2 id="string-upcase-string"><code>(string-upcase string)</code></h2>
<p>TODO # <code>(scheme sort)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-132/">SRFI-132</a>.</p>
<p>This library describes the API for a full-featured sort toolkit.</p>
<h2 id="list-sorted-lis"><code>(list-sorted? &lt; lis)</code></h2>
<h2 id="vector-sorted-v-start-end"><code>(vector-sorted? &lt; v [start [ end ] ]</code></h2>
<p>These procedures return true iff their input list or vector is in sorted order, as determined by &lt;. Specifically, they return #f iff there is an adjacent pair … X Y … in the input list or vector such that Y &lt; X in the sense of &lt;. The optional start and end range arguments restrict vector-sorted? to examining the indicated subvector.</p>
<p>These procedures are equivalent to the SRFI 95 sorted? procedure when applied to lists or vectors respectively, except that they do not accept a key procedure.</p>
<h2 id="list-sort-lis"><code>(list-sort &lt; lis)</code></h2>
<h2 id="list-stable-sort-lis"><code>(list-stable-sort &lt; lis)</code></h2>
<p>These procedures do not alter their inputs, but are allowed to return a value that shares a common tail with a list argument.</p>
<p>The list-stable-sort procedure is equivalent to the R6RS list-sort procedure. It is also equivalent to the SRFI 95 sort procedure when applied to lists, except that it does not accept a key procedure.</p>
<h2 id="list-sort-lis-1"><code>(list-sort! &lt; lis)</code></h2>
<h2 id="list-stable-sort-lis-1"><code>(list-stable-sort! &lt; lis)</code></h2>
<p>These procedures are linear update operators — they are allowed, but not required, to alter the cons cells of their arguments to produce their results. They return a sorted list containing the same elements as lis.</p>
<p>The list-stable-sort! procedure is equivalent to the SRFI 95 sort! procedure when applied to lists, except that it does not accept a key procedure.</p>
<h2 id="vector-sort-v-start-end"><code>(vector-sort &lt; v [ start [ end ] ])</code></h2>
<h2 id="vector-stable-sort-v-start-end"><code>(vector-stable-sort &lt; v [ start [ end ] ])</code></h2>
<p>These procedures do not alter their inputs, but allocate a fresh vector as their result, of length end - start. The vector-stable-sort procedure with no optional arguments is equivalent to the R6RS vector-sort procedure. It is also equivalent to the SRFI 95 sort procedure when applied to vectors, except that it does not accept a key procedure.</p>
<h2 id="vector-sort-v-start-end-1"><code>(vector-sort! &lt; v [ start [ end ] ])</code></h2>
<h2 id="vector-stable-sort-v-start-end-1"><code>(vector-stable-sort! &lt; v [ start [ end ] ])</code></h2>
<p>These procedures sort their data in-place. (But note that vector-stable-sort! may allocate temporary storage proportional to the size of the input — there are no known O(n lg n) stable vector sorting algorithms that run in constant space.) They return an unspecified value.</p>
<p>The vector-sort! procedure with no optional arguments is equivalent to the R6RS vector-sort! procedure.</p>
<h2 id="list-merge-lis1-lis2"><code>(list-merge &lt; lis1 lis2)</code></h2>
<p>This procedure does not alter its inputs, and is allowed to return a value that shares a common tail with a list argument.</p>
<p>This procedure is equivalent to the SRFI 95 merge procedure when applied to lists, except that it does not accept a key procedure.</p>
<h2 id="list-merge-lis1-lis2-1"><code>(list-merge! &lt; lis1 lis2)</code></h2>
<p>This procedure makes only a single, iterative, linear-time pass over its argument lists, using set-cdr!s to rearrange the cells of the lists into the list that is returned — it works “in place.” Hence, any cons cell appearing in the result must have originally appeared in an input. It returns the sorted input.</p>
<p>Additionally, list-merge! is iterative, not recursive — it can operate on arguments of arbitrary size without requiring an unbounded amount of stack space. The intent of this iterative-algorithm commitment is to allow the programmer to be sure that if, for example, list-merge! is asked to merge two ten-million-element lists, the operation will complete without performing some extremely (possibly twenty-million) deep recursion.</p>
<p>This procedure is equivalent to the SRFI 95 merge! procedure when applied to lists, except that it does not accept a key procedure.</p>
<h2 id="vector-merge-v1-v2-start1-end1-start2-end2"><code>(vector-merge &lt; v1 v2 [ start1 [ end1 [ start2 [ end2 ] ] ] ])</code></h2>
<p>This procedure does not alter its inputs, and returns a newly allocated vector of length (end1 - start1) + (end2 - start2).</p>
<p>This procedure is equivalent to the SRFI 95 merge procedure when applied to vectors, except that it does not accept a key procedure.</p>
<h2 id="vector-merge-to-from1-from2-start-start1-end1-start2-end2"><code>(vector-merge! &lt; to from1 from2 [ start [ start1 [ end1 [ start2 [ end2 ] ] ] ] ])</code></h2>
<p>This procedure writes its result into vector to, beginning at index start, for indices less than end, which is defined as start + (end1 - start1) + (end2 - start2). The target subvector to[start, end) may not overlap either of the source subvectors from1[start1, end1] and from2[start2, end2]. It returns an unspecified value.</p>
<p>This procedure is equivalent to the SRFI 95 merge! procedure when applied to lists, except that it does not accept a key procedure.</p>
<h2 id="list-delete-neighbor-dups-lis"><code>(list-delete-neighbor-dups = lis)</code></h2>
<p>This procedure does not alter its input list, but its result may share storage with the input list.</p>
<h2 id="list-delete-neighbor-dups-lis-1"><code>(list-delete-neighbor-dups! = lis)</code></h2>
<p>This procedure mutates its input list in order to construct its result. It makes only a single, iterative, linear-time pass over its argument, using set-cdr!s to rearrange the cells of the list into the final result — it works “in place.” Hence, any cons cell appearing in the result must have originally appeared in the input.</p>
<h2 id="vector-delete-neighbor-dups-v-start-end"><code>(vector-delete-neighbor-dups = v [ start [ end ] ])</code></h2>
<p>This procedure does not alter its input vector, but rather newly allocates and returns a vector to hold the result.</p>
<h2 id="vector-delete-neighbor-dups-v-start-end-1"><code>(vector-delete-neighbor-dups! = v [ start [ end ] ])</code></h2>
<p>This procedure reuses its input vector to hold the answer, packing it into the index range [start, newend), where newend is the non-negative exact integer that is returned as its value. The vector is not altered outside the range [start, newend).</p>
<p>Examples:</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a>    (list-delete-neighbor-dups <span class="op">=</span> &#39;(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">7</span> <span class="dv">7</span> <span class="dv">7</span> <span class="dv">0</span> -<span class="dv">2</span> -<span class="dv">2</span>))</span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a>               <span class="op">=&gt;</span> (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">7</span> <span class="dv">0</span> -<span class="dv">2</span>)</span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>    (vector-delete-neighbor-dups <span class="op">=</span> &#39;#(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">7</span> <span class="dv">7</span> <span class="dv">7</span> <span class="dv">0</span> -<span class="dv">2</span> -<span class="dv">2</span>))</span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a>               <span class="op">=&gt;</span> #(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">7</span> <span class="dv">0</span> -<span class="dv">2</span>)</span>
<span id="cb143-6"><a href="#cb143-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-7"><a href="#cb143-7" aria-hidden="true" tabindex="-1"></a>    (vector-delete-neighbor-dups <span class="op">&lt;</span> &#39;#(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">7</span> <span class="dv">7</span> <span class="dv">7</span> <span class="dv">0</span> -<span class="dv">2</span> -<span class="dv">2</span>) <span class="dv">3</span> <span class="dv">7</span>))</span>
<span id="cb143-8"><a href="#cb143-8" aria-hidden="true" tabindex="-1"></a>               <span class="op">=&gt;</span> #(<span class="dv">7</span> <span class="dv">0</span> -<span class="dv">2</span>)</span>
<span id="cb143-9"><a href="#cb143-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-10"><a href="#cb143-10" aria-hidden="true" tabindex="-1"></a><span class="co">;; Result left in v[3,9):</span></span>
<span id="cb143-11"><a href="#cb143-11" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> ((v (<span class="kw">vector</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">6</span>)))</span>
<span id="cb143-12"><a href="#cb143-12" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">cons</span> (vector-delete-neighbor-dups! <span class="op">&lt;</span> v <span class="dv">3</span>)</span>
<span id="cb143-13"><a href="#cb143-13" aria-hidden="true" tabindex="-1"></a>        v))</span>
<span id="cb143-14"><a href="#cb143-14" aria-hidden="true" tabindex="-1"></a>              <span class="op">=&gt;</span> (<span class="dv">9</span> <span class="op">.</span> #(<span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">4</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">6</span>))</span></code></pre></div>
<h2 id="vector-find-median-v-knil-mean"><code>(vector-find-median &lt; v knil [ mean ])</code></h2>
<p>This procedure does not alter its input vector, but rather newly allocates a vector to hold the intermediate result. Runs in O(n) time.</p>
<h2 id="vector-find-median-v-knil-mean-1"><code>(vector-find-median! &lt; v knil [ mean ])</code></h2>
<p>This procedure reuses its input vector to hold the intermediate result, leaving it sorted, but is otherwise the same as vector-find-median. Runs in O(n ln n) time.</p>
<h2 id="vector-select-v-k-start-end"><code>(vector-select! &lt; v k [ start [ end ] ] )</code></h2>
<p>This procedure returns the kth smallest element (in the sense of the &lt; argument) of the region of a vector between start and end. Elements within the range may be reordered, whereas those outside the range are left alone. Runs in O(n) time.</p>
<h2 id="vector-separate-v-k-start-end"><code>(vector-separate! &lt; v k [ start [ end ] ] )</code></h2>
<p>This procedure places the smallest k elements (in the sense of the &lt; argument) of the region of a vector between start and end into the first k positions of that range, and the remaining elements into the remaining positions. Otherwise, the elements are not in any particular order. Elements outside the range are left alone. Runs in O(n) time. Returns an unspecified value. # <code>(scheme read)</code></p>
<h2 id="read-port"><code>(read [port])</code></h2>
<p>The <code>read</code> procedure converts external epresentations of Scheme objects into the objects themselves. That is, it is a parser for the non-terminal datum. It returns the next object parsable from the given textual input port, updating port to point to the first character past the end of the external representation of the object.</p>
<p>The current implementation is not fully compatible with R7RS. # <code>(scheme ilist)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-116/">SRFI-116</a>.</p>
<p>Scheme currently does not provide immutable pairs corresponding to its existing mutable pairs, although most uses of pairs do not exploit their mutability. The Racket system takes the radical approach of making Scheme’s pairs immutable, and providing a minimal library of mutable pairs with procedures named mpair?, mcons, mcar, mcdr, set-mcar!, set-mcdr!. This SRFI takes the opposite approach of leaving Scheme’s pairs unchanged and providing a full set of routines for creating and dealing with immutable pairs. The sample implementation is portable (to systems with SRFI 9) and efficient.</p>
<h2 id="ipair-a-d"><code>(ipair a d)</code></h2>
<p>The primitive constructor. Returns a newly allocated ipair whose icar is a and whose icdr is d. The ipair is guaranteed to be different (in the sense of eqv?) from every existing object.</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a>(ipair &#39;a &#39;())        <span class="op">=&gt;</span> (a)</span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>(ipair (iq a) (iq b c d)) <span class="op">=&gt;</span> ((a) b c d)</span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>(ipair <span class="st">&quot;a&quot;</span> (iq b c))    <span class="op">=&gt;</span> (<span class="st">&quot;a&quot;</span> b c)</span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>(ipair &#39;a <span class="dv">3</span>)          <span class="op">=&gt;</span> (a <span class="op">.</span> <span class="dv">3</span>)</span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>(ipair (iq a b) &#39;c)     <span class="op">=&gt;</span> ((a b ) <span class="op">.</span> c)</span></code></pre></div>
<h2 id="ilist-object-..."><code>(ilist object ...)</code></h2>
<p>Returns a newly allocated ilist of its arguments.</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a>(ilist &#39;a (<span class="op">+</span> <span class="dv">3</span> <span class="dv">4</span>) &#39;c) <span class="op">=&gt;</span>  (a <span class="dv">7</span> c)</span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a>(ilist)               <span class="op">=&gt;</span>  ()</span></code></pre></div>
<h2 id="xipair-d-a"><code>(xipair d a)</code></h2>
<div class="sourceCode" id="cb146"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> (d a) (ipair a d))</span></code></pre></div>
<p>Of utility only as a value to be conveniently passed to higher-order procedures.</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a>(xipair (iq b c) &#39;a) <span class="op">=&gt;</span> (a b c)</span></code></pre></div>
<p>The name stands for “eXchanged Immutable PAIR.”</p>
<h2 id="ipair-elt1-elt2">`(ipair* elt1 elt2 …)</h2>
<p>Like ilist, but the last argument provides the tail of the constructed ilist, returning</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a>(ipair elt1 (ipair elt2 (ipair <span class="op">...</span> eltn)))</span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a>(ipair* <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>) <span class="op">=&gt;</span> (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="op">.</span> <span class="dv">4</span>)</span>
<span id="cb148-4"><a href="#cb148-4" aria-hidden="true" tabindex="-1"></a>(ipair* <span class="dv">1</span>) <span class="op">=&gt;</span> <span class="dv">1</span></span></code></pre></div>
<h2 id="make-ilist-n-fill"><code>(make-ilist n [fill])</code></h2>
<p>Returns an n-element ilist, whose elements are all the value fill. If the fill argument is not given, the elements of the ilist may be arbitrary values.</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a>(make-ilist <span class="dv">4</span> &#39;c) <span class="op">=&gt;</span> (c c c c)</span></code></pre></div>
<h2 id="ilist-tabulate-n-init-proc"><code>(ilist-tabulate n init-proc)</code></h2>
<p>Returns an n-element ilist. Element i of the ilist, where 0 &lt;= i &lt; n, is produced by (init-proc i). No guarantee is made about the dynamic order in which init-proc is applied to these indices.</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a>(ilist-tabulate <span class="dv">4</span> <span class="kw">values</span>) <span class="op">=&gt;</span> (<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</span></code></pre></div>
<h2 id="ilist-copy-dilist"><code>(ilist-copy dilist)</code></h2>
<p>Copies the spine of the argument, including the ilist tail.</p>
<h2 id="iiota-count-start-step"><code>(iiota count [start step])</code></h2>
<p>Returns an ilist containing the elements</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a>(start start+step <span class="op">...</span> start+(count-1)*step)</span></code></pre></div>
<p>The start and step parameters default to 0 and 1, respectively. This procedure takes its name from the APL primitive.</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a>(iiota <span class="dv">5</span>) <span class="op">=&gt;</span> (<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)</span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a>(iiota <span class="dv">5</span> <span class="dv">0</span> -<span class="fl">0.1</span>) <span class="op">=&gt;</span> (<span class="dv">0</span> -<span class="fl">0.1</span> -<span class="fl">0.2</span> -<span class="fl">0.3</span> -<span class="fl">0.4</span>)</span></code></pre></div>
<h2 id="proper-ilist-x"><code>(proper-ilist? x)</code></h2>
<h2 id="ilist-x"><code>(ilist? x)</code></h2>
<p>These identifiers are bound either to the same procedure, or to procedures of equivalent behavior. In either case, true is returned iff x is a proper ilist — a ()-terminated ilist.</p>
<p>More carefully: The empty list is a proper ilist. An ipair whose icdr is a proper ilist is also a proper ilist. Everything else is a dotted ilist. This includes non-ipair, non-() values (e.g. symbols, numbers, mutable pairs), which are considered to be dotted ilists of length 0.</p>
<h2 id="dotted-ilist-x"><code>(dotted-ilist? x)</code></h2>
<p>True if x is a finite, non-nil-terminated ilist. That is, there exists an n &gt;= 0 such that icdrn(x) is neither an ipair nor (). This includes non-ipair, non-() values (e.g. symbols, numbers), which are considered to be dotted ilists of length 0.</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a>(dotted-ilist? x) <span class="op">=</span> (<span class="kw">not</span> (proper-ilist? x))</span></code></pre></div>
<h2 id="ipair-object"><code>(ipair? object)</code></h2>
<p>Returns #t if object is an ipair; otherwise, #f.</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a>(ipair? (ipair &#39;a &#39;b)) <span class="op">=&gt;</span>  <span class="dv">#t</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a>(ipair? (iq a b c)) <span class="op">=&gt;</span>  <span class="dv">#t</span></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a>(ipair? (<span class="kw">cons</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a>(ipair? &#39;())        <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a>(ipair? &#39;#(a b))    <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb154-6"><a href="#cb154-6" aria-hidden="true" tabindex="-1"></a>(ipair? <span class="dv">7</span>)          <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb154-7"><a href="#cb154-7" aria-hidden="true" tabindex="-1"></a>(ipair? &#39;a)         <span class="op">=&gt;</span>  <span class="dv">#f</span></span></code></pre></div>
<h2 id="null-ilist-ilist">`(null-ilist? ilist)</h2>
<p>Ilist is a proper ilist. This procedure returns true if the argument is the empty list (), and false otherwise. It is an error to pass this procedure a value which is not a proper ilist. This procedure is recommended as the termination condition for ilist-processing procedures that are not defined on dotted ilists.</p>
<h2 id="not-ipair-x"><code>(not-ipair? x)</code></h2>
<div class="sourceCode" id="cb155"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> (x) (<span class="kw">not</span> (ipair? x)))</span></code></pre></div>
<p>Provided as a procedure as it can be useful as the termination condition for ilist-processing procedures that wish to handle all ilists, both proper and dotted.</p>
<h2 id="ilist-elt-ilist1-..."><code>(ilist= elt= ilist1 ...)</code></h2>
<p>Determines ilist equality, given an element-equality procedure. Proper ilist A equals proper ilist B if they are of the same length, and their corresponding elements are equal, as determined by elt=. If the element-comparison procedure’s first argument is from ilisti, then its second argument is from ilisti+1, i.e. it is always called as (elt= a b) for a an element of ilist A, and b an element of ilist B.</p>
<p>In the n-ary case, every ilisti is compared to ilisti+1 (as opposed, for example, to comparing ilist1 to ilisti, for i&gt;1). If there are no ilist arguments at all, ilist= simply returns true.</p>
<p>It is an error to apply ilist= to anything except proper ilists. It cannot reasonably be extended to dotted ilists, as it provides no way to specify an equality procedure for comparing the ilist terminators.</p>
<p>Note that the dynamic order in which the elt= procedure is applied to pairs of elements is not specified. For example, if ilist= is applied to three ilists, A, B, and C, it may first completely compare A to B, then compare B to C, or it may compare the first elements of A and B, then the first elements of B and C, then the second elements of A and B, and so forth.</p>
<p>The equality procedure must be consistent with eq?. That is, it must be the case that:</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">eq?</span> x y) <span class="op">=&gt;</span> (elt= x y)<span class="op">.</span></span></code></pre></div>
<p>Note that this implies that two ilists which are eq? are always ilist=, as well; implementations may exploit this fact to “short-cut” the element-by-element comparisons.</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a>(ilist= <span class="kw">eq?</span>) <span class="op">=&gt;</span> <span class="dv">#t</span>       <span class="co">; Trivial cases</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a>(ilist= <span class="kw">eq?</span> (iq a)) <span class="op">=&gt;</span> <span class="dv">#t</span></span></code></pre></div>
<h2 id="icar-ipair"><code>(icar ipair)</code></h2>
<h2 id="icdr-ipair"><code>(icdr ipair)</code></h2>
<p>These procedures return the contents of the icar and icdr field of their argument, respectively. Note that it is an error to apply them to the empty ilist.</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>(icar (iq a b c))       <span class="op">=&gt;</span>  a        (icdr (iq a b c))     <span class="op">=&gt;</span>  (b c)</span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>(icar (iq (a) b c d))   <span class="op">=&gt;</span>  (a)      (icdr (iq (a) b c d)) <span class="op">=&gt;</span>  (b c d)</span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>(icar (ipair <span class="dv">1</span> <span class="dv">2</span>))      <span class="op">=&gt;</span>  <span class="dv">1</span>        (icdr (ipair <span class="dv">1</span> <span class="dv">2</span>))    <span class="op">=&gt;</span>  <span class="dv">2</span></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a>(icar &#39;())              <span class="op">=&gt;</span>  *error*  (icdr &#39;())            <span class="op">=&gt;</span>  *error*</span></code></pre></div>
<h2 id="icaar-ipair"><code>(icaar ipair)</code></h2>
<h2 id="icadr-ipair"><code>(icadr ipair)</code></h2>
<p>…</p>
<h2 id="icdddar-ipair"><code>(icdddar ipair)</code></h2>
<h2 id="icddddr-ipair">`(icddddr ipair)</h2>
<p>These procedures are compositions of icar and icdr, where for example icaddr could be defined by</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> icaddr </span>(<span class="kw">lambda</span> (x) (icar (icdr (icdr x)))))</span></code></pre></div>
<p>Arbitrary compositions, up to four deep, are provided. There are twenty-eight of these procedures in all.</p>
<h2 id="ilist-ref-ilist-i"><code>(ilist-ref ilist i)</code></h2>
<p>Returns the ith element of ilist. (This is the same as the icar of (idrop ilist i).) It is an error if i &gt;= n, where n is the length of ilist.</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a>(ilist-ref (iq a b c d) <span class="dv">2</span>) <span class="op">=&gt;</span> c</span></code></pre></div>
<h2 id="ifirst-ipair"><code>(ifirst ipair)</code></h2>
<h2 id="isecond-ipair"><code>(isecond ipair)</code></h2>
<h2 id="ithird-ipair"><code>(ithird ipair)</code></h2>
<h2 id="ifourth-ipair"><code>(ifourth ipair)</code></h2>
<h2 id="ififth-ipair"><code>(ififth ipair)</code></h2>
<h2 id="isixth-ipair"><code>(isixth ipair)</code></h2>
<h2 id="iseventh-ipair"><code>(iseventh ipair)</code></h2>
<h2 id="ieighth-ipair"><code>(ieighth ipair)</code></h2>
<h2 id="ininth-ipair"><code>(ininth ipair)</code></h2>
<h2 id="itenth-ipair"><code>(itenth ipair)</code></h2>
<p>Synonyms for car, cadr, caddr, …</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>(ithird &#39;(a b c d e)) <span class="op">=&gt;</span> c</span></code></pre></div>
<h2 id="icaricdr-ipair"><code>(icar+icdr ipair)</code></h2>
<p>The fundamental ipair deconstructor:</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> (p) (<span class="kw">values</span> (icar p) (icdr p)))</span></code></pre></div>
<p>This can, of course, be implemented more efficiently by a compiler.</p>
<h2 id="itake-x-i"><code>(itake x i)</code></h2>
<h2 id="idrop-x-i"><code>(idrop x i)</code></h2>
<h2 id="ilist-tail-x-i"><code>(ilist-tail x i)</code></h2>
<p><code>itake</code> returns the first i elements of ilist x.</p>
<p><code>idrop</code> returns all but the first i elements of ilist x.</p>
<p><code>ilist-tail</code> is either the same procedure as idrop or else a procedure with the same behavior.</p>
<p>``scheme (itake (iq a b c d e) 2) =&gt; (a b) (idrop (iq a b c d e) 2) =&gt; (c d e)</p>
<pre><code>
x may be any value — a proper or dotted ilist:

```scheme
(itake (ipair 1 (ipair 2 (ipair 3 &#39;d)))    =&gt; (1 2)
(idrop (ipair 1 (ipair 2 (ipair 3 &#39;d))) 2) =&gt; (3 . d)
(itake (ipair 1 (ipair 2 (ipair 3 &#39;d))) 3) =&gt; (1 2 3)
(idrop (ipair 1 (ipair 2 (ipair 3 &#39;d))) 3) =&gt; d</code></pre>
<p>For a legal i, itake and idrop partition the ilist in a manner which can be inverted with iappend:</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a>(iappend (itake x i) (idrop x i)) <span class="op">=</span> x</span></code></pre></div>
<p>idrop is exactly equivalent to performing i icdr operations on x; the returned value shares a common tail with x.</p>
<h2 id="itake-right-dilist-i"><code>(itake-right dilist i)</code></h2>
<h2 id="idrop-right-dilist-i"><code>(idrop-right dilist i)</code></h2>
<p>itake-right returns the last i elements of dilist. idrop-right returns all but the last i elements of dilist.</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a>(itake-right (iq a b c d e) <span class="dv">2</span>) <span class="op">=&gt;</span> (d e)</span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>(idrop-right (iq a b c d e) <span class="dv">2</span>) <span class="op">=&gt;</span> (a b c)</span></code></pre></div>
<p>The returned ilist may share a common tail with the argument ilist.</p>
<p>dilist may be any ilist, either proper or dotted:</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a>(itake-right (iq ipair <span class="dv">1</span> (ipair <span class="dv">2</span> (ipair <span class="dv">3</span> &#39;d))) <span class="dv">2</span>) <span class="op">=&gt;</span> (<span class="dv">2</span> <span class="dv">3</span> <span class="op">.</span> d)</span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a>(idrop-right (ipair <span class="dv">1</span> (ipair <span class="dv">2</span> (ipair <span class="dv">3</span> &#39;d))) <span class="dv">2</span>)    <span class="op">=&gt;</span> (<span class="dv">1</span>)</span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>(itake-right (ipair <span class="dv">1</span> (ipair <span class="dv">2</span> (ipair <span class="dv">3</span> &#39;d))) <span class="dv">0</span>)    <span class="op">=&gt;</span> d</span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a>(idrop-right (ipair <span class="dv">1</span> (ipair <span class="dv">2</span> (ipair <span class="dv">3</span> &#39;d))) <span class="dv">0</span>)    <span class="op">=&gt;</span> (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</span></code></pre></div>
<p>For a legal i, itake-right and idrop-right partition the ilist in a manner which can be inverted with iappend:</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a>(iappend (itake dilist i) (idrop dilist i)) <span class="op">=</span> dilist</span></code></pre></div>
<p>itake-right’s return value is guaranteed to share a common tail with dilist.</p>
<h2 id="isplit-at-x-i"><code>(isplit-at  x i)</code></h2>
<p>isplit-at splits the ilist x at index i, returning an ilist of the first i elements, and the remaining tail. It is equivalent to</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">values</span> (itake x i) (idrop x i))</span></code></pre></div>
<h2 id="ilast-ipair"><code>(ilast ipair)</code></h2>
<h2 id="last-ipair-ipair"><code>(last-ipair ipair)</code></h2>
<p>Returns the last element of the non-empty, possibly dotted, ilist ipair. last-ipair returns the last ipair in the non-empty ilist pair.</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a>(ilast (iq a b c))      <span class="op">=&gt;</span> c</span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a>(last-ipair (iq a b c)) <span class="op">=&gt;</span> (c)</span></code></pre></div>
<h2 id="ilength-ilist"><code>(ilength  ilist)</code></h2>
<p>Returns the length of its argument. It is an error to pass a value to ilength which is not a proper ilist (()-terminated).</p>
<p>The length of a proper ilist is a non-negative integer n such that icdr applied n times to the ilist produces the empty list.</p>
<h2 id="iappend-ilist1-..."><code>(iappend  ilist1 ...)</code></h2>
<p>Returns an ilist consisting of the elements of ilist1 followed by the elements of the other ilist parameters.</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a>(iappend (iq x) (iq y))        <span class="op">=&gt;</span>  (x y)</span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a>(iappend (iq a) (iq b c d))    <span class="op">=&gt;</span>  (a b c d)</span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a>(iappend (iq a (b)) (iq (c)))  <span class="op">=&gt;</span>  (a (b) (c))</span></code></pre></div>
<p>The resulting ilist is always newly allocated, except that it shares structure with the final ilisti argument. This last argument may be any value at all; an improper ilist results if it is not a proper ilist. All other arguments must be proper ilists.</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a>(iappend (iq a b) (ipair &#39;c &#39;d))  <span class="op">=&gt;</span>  (a b c <span class="op">.</span> d)</span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a>(iappend &#39;() &#39;a)           <span class="op">=&gt;</span>  a</span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a>(iappend (iq x y))         <span class="op">=&gt;</span>  (x y)</span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a>(iappend)                  <span class="op">=&gt;</span>  ()</span></code></pre></div>
<h2 id="iconcatenate-ilist-of-ilists"><code>(iconcatenate  ilist-of-ilists)</code></h2>
<p>Appends the elements of its argument together. That is, iconcatenate returns</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a>(iapply iappend ilist-of-ilists)</span></code></pre></div>
<p>or, equivalently,</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a>(ireduce-right iappend &#39;() ilist-of-ilists)</span></code></pre></div>
<p>Note that some Scheme implementations do not support passing more than a certain number (e.g., 64) of arguments to an n-ary procedure. In these implementations, the (iapply iappend …) idiom would fail when applied to long lists, but iconcatenate would continue to function properly.</p>
<p>As with iappend, the last element of the input list may be any value at all.</p>
<h2 id="ireverse-ilist"><code>(ireverse  ilist)</code></h2>
<p>Returns a newly allocated ilist consisting of the elements of ilist in reverse order.</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a>(ireverse (iq a b c)) <span class="op">=&gt;</span>  (c b a)</span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a>(ireverse (iq a (b c) d (e (f))))</span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">=&gt;</span>  ((e (f)) d (b c) a)</span></code></pre></div>
<h2 id="iappend-reverse-rev-head-tail"><code>(iappend-reverse  rev-head tail)</code></h2>
<p>iappend-reverse returns (iappend (ireverse rev-head) tail). It is provided because it is a common operation — a common list-processing style calls for this exact operation to transfer values accumulated in reverse order onto the front of another ilist, and because the implementation is significantly more efficient than the simple composition it replaces. (But note that this pattern of iterative computation followed by a reverse can frequently be rewritten as a recursion, dispensing with the reverse and iappend-reverse steps, and shifting temporary, intermediate storage from the heap to the stack, which is typically a win for reasons of cache locality and eager storage reclamation.)</p>
<h2 id="izip-ilist1-ilist2-..."><code>(izip ilist1 ilist2 ...)</code></h2>
<div class="sourceCode" id="cb175"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> ilists (iapply imap ilist ilists))</span></code></pre></div>
<p>If izip is passed n ilists, it returns an ilist as long as the shortest of these ilists, each element of which is an n-element ilist comprised of the corresponding elements from the parameter ilists.</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a>(izip (iq one two three)</span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a>  (iq <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a>  (iq odd even odd even odd even odd even))</span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a>   <span class="co">;; =&gt; ((one 1 odd) (two 2 even) (three 3 odd))</span></span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a>(izip (iq <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)) <span class="op">=&gt;</span> ((<span class="dv">1</span>) (<span class="dv">2</span>) (<span class="dv">3</span>))</span></code></pre></div>
<h2 id="iunzip1-ilist"><code>(iunzip1 ilist)</code></h2>
<h2 id="iunzip2-ilist"><code>(iunzip2 ilist)</code></h2>
<h2 id="iunzip3-ilist"><code>(iunzip3 ilist)</code></h2>
<h2 id="iunzip4-ilist"><code>(iunzip4 ilist)</code></h2>
<h2 id="iunzip5-ilist"><code>(iunzip5 ilist)</code></h2>
<p>iunzip1 takes an ilist of ilists, where every ilist must contain at least one element, and returns an ilist containing the initial element of each such ilist. That is, it returns (imap icar ilists). iunzip2 takes an ilist of ilists, where every ilist must contain at least two elements, and returns two values: an ilist of the first elements, and an ilist of the second elements. iunzip3 does the same for the first three elements of the ilists, and so forth.</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a>(iunzip2 (iq (<span class="dv">1</span> one) (<span class="dv">2</span> two) (<span class="dv">3</span> three))) <span class="op">=&gt;</span></span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a>  (one two three)</span></code></pre></div>
<h2 id="icount-pred-ilist1-ilist2-..."><code>(icount pred ilist1 ilist2 ...)</code></h2>
<p>pred is a procedure taking as many arguments as there are ilists and returning a single value. It is applied element-wise to the elements of the ilists, and a count is tallied of the number of elements that produce a true value. This count is returned. count is “iterative” in that it is guaranteed to apply pred to the ilist elements in a left-to-right order. The counting stops when the shortest ilist expires.</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a>(count <span class="kw">even?</span> (iq <span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>)) <span class="op">=&gt;</span> <span class="dv">3</span></span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a>(count <span class="op">&lt;</span> (iq <span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span> <span class="dv">8</span>) (iq <span class="dv">2</span> <span class="dv">4</span> <span class="dv">6</span> <span class="dv">8</span> <span class="dv">10</span> <span class="dv">12</span> <span class="dv">14</span> <span class="dv">16</span>)) <span class="op">=&gt;</span> <span class="dv">3</span></span></code></pre></div>
<h2 id="ifold-kons-knil-ilist1-ilist2-..."><code>(ifold kons knil ilist1 ilist2 ...)</code></h2>
<p>The fundamental ilist iterator.</p>
<p>First, consider the single ilist-parameter case. If ilist1 = (e1 e2 … en), then this procedure returns</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a>(kons en <span class="op">...</span> (kons e2 (kons e1 knil)) <span class="op">...</span> )</span></code></pre></div>
<p>That is, it obeys the (tail) recursion</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a>(ifold kons knil lis) <span class="op">=</span> (ifold kons (kons (icar lis) knil) (icdr lis))</span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a>(ifold kons knil &#39;()) <span class="op">=</span> knil</span></code></pre></div>
<p>Examples:</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a>(ifold <span class="op">+</span> <span class="dv">0</span> lis)         <span class="co">; Add up the elements of LIS.</span></span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a>(ifold ipair &#39;() lis)       <span class="co">; Reverse LIS.</span></span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-5"><a href="#cb181-5" aria-hidden="true" tabindex="-1"></a>(ifold ipair tail rev-head) <span class="co">; See APPEND-REVERSE.</span></span>
<span id="cb181-6"><a href="#cb181-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-7"><a href="#cb181-7" aria-hidden="true" tabindex="-1"></a><span class="co">;; How many symbols in LIS?</span></span>
<span id="cb181-8"><a href="#cb181-8" aria-hidden="true" tabindex="-1"></a>(ifold (<span class="kw">lambda</span> (x count) (<span class="kw">if</span> (<span class="kw">symbol?</span> x) (<span class="op">+</span> count <span class="dv">1</span>) count))</span>
<span id="cb181-9"><a href="#cb181-9" aria-hidden="true" tabindex="-1"></a>       <span class="dv">0</span></span>
<span id="cb181-10"><a href="#cb181-10" aria-hidden="true" tabindex="-1"></a>       lis)</span>
<span id="cb181-11"><a href="#cb181-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-12"><a href="#cb181-12" aria-hidden="true" tabindex="-1"></a><span class="co">;; Length of the longest string in LIS:</span></span>
<span id="cb181-13"><a href="#cb181-13" aria-hidden="true" tabindex="-1"></a>(ifold (<span class="kw">lambda</span> (s max-len) (<span class="kw">max</span> max-len (<span class="kw">string-length</span> s)))</span>
<span id="cb181-14"><a href="#cb181-14" aria-hidden="true" tabindex="-1"></a>       <span class="dv">0</span></span>
<span id="cb181-15"><a href="#cb181-15" aria-hidden="true" tabindex="-1"></a>       lis)</span></code></pre></div>
<p>If n ilist arguments are provided, then the kons function must take n+1 parameters: one element from each ilist, and the “seed” or fold state, which is initially knil. The fold operation terminates when the shortest ilist runs out of values:</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a>(ifold ipair* &#39;() (iq a b c) (iq <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)) <span class="op">=&gt;</span> (c <span class="dv">3</span> b <span class="dv">2</span> a <span class="dv">1</span>)</span></code></pre></div>
<h2 id="ifold-right-kons-knil-ilist1-ilist2-..."><code>(ifold-right kons knil ilist1 ilist2 ...)</code></h2>
<p>The fundamental ilist recursion operator.</p>
<p>First, consider the single ilist-parameter case. If ilist1 = (e1 e2 … en), then this procedure returns</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a>(kons e1 (kons e2 <span class="op">...</span> (kons en knil)))</span></code></pre></div>
<p>That is, it obeys the recursion</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a>(ifold-right kons knil lis) <span class="op">=</span> (kons (icar lis) (ifold-right kons knil (icdr lis)))</span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a>(ifold-right kons knil &#39;()) <span class="op">=</span> knil</span></code></pre></div>
<p>Examples:</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a>(ifold-right ipair &#39;() lis)     <span class="co">; Copy LIS.</span></span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a><span class="co">;; Filter the even numbers out of LIS.</span></span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a>(ifold-right (<span class="kw">lambda</span> (x l) (<span class="kw">if</span> (<span class="kw">even?</span> x) (ipair x l) l)) &#39;() lis))</span></code></pre></div>
<p>If n ilist arguments are provided, then the kons procedure must take n+1 parameters: one element from each ilist, and the “seed” or fold state, which is initially knil. The fold operation terminates when the shortest ilist runs out of values:</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a>(ifold-right ipair* &#39;() (iq a b c) (iq <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)) <span class="op">=&gt;</span> (a <span class="dv">1</span> b <span class="dv">2</span> c <span class="dv">3</span>)</span></code></pre></div>
<h2 id="ipair-fold-kons-knil-ilist1-ilist2-..."><code>(ipair-fold kons knil ilist1 ilist2 ...)</code></h2>
<p>Analogous to fold, but kons is applied to successive sub-ilists of the ilists, rather than successive elements — that is, kons is applied to the ipairs making up the lists, giving this (tail) recursion:</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a>(ipair-fold kons knil lis) <span class="op">=</span> (<span class="kw">let</span> ((tail (icdr lis)))</span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a>                               (ipair-fold kons (kons lis knil) tail))</span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a>(ipair-fold kons knil &#39;()) <span class="op">=</span> knil</span></code></pre></div>
<p>Example:</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a>(ipair-fold ipair &#39;() (iq a b c)) <span class="op">=&gt;</span> ((c) (b c) (a b c))</span></code></pre></div>
<h2 id="ipair-fold-right-kons-knil-ilist1-ilist2-..."><code>(ipair-fold-right kons knil ilist1 ilist2 ...)</code></h2>
<p>Holds the same relationship with ifold-right that ipair-fold holds with ifold. Obeys the recursion</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a>    (ipair-fold-right kons knil lis) <span class="op">=</span></span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a>        (kons lis (ipair-fold-right kons knil (icdr lis)))</span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a>    (ipair-fold-right kons knil &#39;()) <span class="op">=</span> knil</span></code></pre></div>
<p>Example:</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a>(ipair-fold-right ipair &#39;() (iq a b c)) <span class="op">=&gt;</span> ((a b c) (b c) (c))</span></code></pre></div>
<h2 id="ireduce-f-ridentity-ilist"><code>(ireduce f ridentity ilist)</code></h2>
<p>ireduce is a variant of ifold.</p>
<p>ridentity should be a “right identity” of the procedure f — that is, for any value x acceptable to f,</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a>(f x ridentity) <span class="op">=</span> x</span></code></pre></div>
<p>ireduce has the following definition:</p>
<p>If ilist = (), return ridentity;</p>
<p>Otherwise, return (ifold f (icar ilist) (icdr ilist)).</p>
<p>…in other words, we compute (ifold f ridentity ilist).</p>
<p>Note that ridentity is used only in the empty-list case. You typically use ireduce when applying f is expensive and you’d like to avoid the extra application incurred when ifold applies f to the head of ilist and the identity value, redundantly producing the same value passed in to f. For example, if f involves searching a file directory or performing a database query, this can be significant. In general, however, ifold is useful in many contexts where ireduce is not (consider the examples given in the ifold definition — only one of the five folds uses a function with a right identity. The other four may not be performed with ireduce).</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="co">;; take the max of an ilist of non-negative integers.</span></span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a>(ireduce <span class="kw">max</span> <span class="dv">0</span> nums) <span class="co">; i.e., (iapply max 0 nums)</span></span></code></pre></div>
<h2 id="ireduce-right-f-ridentity-ilist"><code>(ireduce-right f ridentity ilist)</code></h2>
<p>ireduce-right is the fold-right variant of ireduce. It obeys the following definition:</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a>(ireduce-right f ridentity &#39;()) <span class="op">=</span> ridentity</span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a>(ireduce-right f ridentity (iq e1)) <span class="op">=</span> (f e1 ridentity) <span class="op">=</span> e1</span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a>(ireduce-right f ridentity (iq e1 e2 <span class="op">...</span>)) <span class="op">=</span></span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a>  (f e1 (ireduce f ridentity (e2 <span class="op">...</span>)))</span></code></pre></div>
<p>…in other words, we compute (ifold-right f ridentity ilist).</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="co">;; Append a bunch of ilists together.</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a><span class="co">;; I.e., (iapply iappend ilist-of-ilists)</span></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a>(ireduce-right iappend &#39;() ilist-of-ilists)</span></code></pre></div>
<h2 id="iunfold-p-f-g-seed-tail-gen"><code>(iunfold p f g seed [tail-gen])</code></h2>
<p>iunfold is best described by its basic recursion:</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a>    (iunfold p f g seed) <span class="op">=</span></span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">if</span> (p seed) (tail-gen seed)</span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a>            (ipair (f seed)</span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a>                  (iunfold p f g (g seed))))</span></code></pre></div>
<ul>
<li>p, Determines when to stop unfolding.</li>
<li>f, Maps each seed value to the corresponding ilist element.</li>
<li>g, Maps each seed value to next seed value.</li>
<li>seed, The “state” value for the unfold.</li>
<li>tail-gen, Creates the tail of the ilist; defaults to (lambda (x) ’())</li>
</ul>
<p>In other words, we use g to generate a sequence of seed values</p>
<div class="sourceCode" id="cb196"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a>seed, g(seed), g2(seed), g3(seed), <span class="op">...</span></span></code></pre></div>
<p>These seed values are mapped to ilist elements by f, producing the elements of the result ilist in a left-to-right order. P says when to stop.</p>
<p>iunfold is the fundamental recursive ilist constructor, just as ifold-right is the fundamental recursive ilist consumer. While iunfold may seem a bit abstract to novice functional programmers, it can be used in a number of ways:</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; Ilist of squares: 1^2 ... 10^2</span></span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a>    (iunfold (<span class="kw">lambda</span> (x) (<span class="op">&gt;</span> x <span class="dv">10</span>))</span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true" tabindex="-1"></a>            (<span class="kw">lambda</span> (x) (<span class="op">*</span> x x))</span>
<span id="cb197-4"><a href="#cb197-4" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">lambda</span> (x) (<span class="op">+</span> x <span class="dv">1</span>))</span>
<span id="cb197-5"><a href="#cb197-5" aria-hidden="true" tabindex="-1"></a>        <span class="dv">1</span>)</span>
<span id="cb197-6"><a href="#cb197-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-7"><a href="#cb197-7" aria-hidden="true" tabindex="-1"></a>    (iunfold null-ilist? icar icdr lis) <span class="co">; Copy a proper ilist.</span></span>
<span id="cb197-8"><a href="#cb197-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-9"><a href="#cb197-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; Read current input port into an ilist of values.</span></span>
<span id="cb197-10"><a href="#cb197-10" aria-hidden="true" tabindex="-1"></a>    (iunfold <span class="kw">eof-object?</span> <span class="kw">values</span> (<span class="kw">lambda</span> (x) (<span class="kw">read</span>)) (<span class="kw">read</span>))</span>
<span id="cb197-11"><a href="#cb197-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-12"><a href="#cb197-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; Copy a possibly non-proper ilist:</span></span>
<span id="cb197-13"><a href="#cb197-13" aria-hidden="true" tabindex="-1"></a>    (iunfold not-ipair? icar icdr lis</span>
<span id="cb197-14"><a href="#cb197-14" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">values</span>)</span>
<span id="cb197-15"><a href="#cb197-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-16"><a href="#cb197-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; Append HEAD onto TAIL:</span></span>
<span id="cb197-17"><a href="#cb197-17" aria-hidden="true" tabindex="-1"></a>    (iunfold null-ilist? icar icdr head</span>
<span id="cb197-18"><a href="#cb197-18" aria-hidden="true" tabindex="-1"></a>                  (<span class="kw">lambda</span> (x) tail))</span></code></pre></div>
<p>Interested functional programmers may enjoy noting that ifold-right and iunfold are in some sense inverses. That is, given operations knull?, kar, kdr, kons, and knil satisfying</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a>(kons (kar x) (kdr x)) <span class="op">=</span> x <span class="kw">and</span> (knull? knil) <span class="op">=</span> <span class="dv">#t</span></span></code></pre></div>
<p>then</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a>(ifold-right kons knil (iunfold knull? kar kdr x)) <span class="op">=</span> x</span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a>(iunfold knull? kar kdr (ifold-right kons knil x)) <span class="op">=</span> x</span></code></pre></div>
<p>This combinator sometimes is called an “anamorphism;” when an explicit tail-gen procedure is supplied, it is called an “apomorphism.”</p>
<h2 id="iunfold-right-p-f-g-seed-tail"><code>(iunfold-right p f g seed [tail])</code></h2>
<p>iunfold-right constructs an ilist with the following loop:</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">let</span> lp ((seed seed) (lis tail))</span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">if</span> (p seed) lis</span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a>          (lp (g seed)</span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a>              (ipair (f seed) lis))))</span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a>    p</span>
<span id="cb201-7"><a href="#cb201-7" aria-hidden="true" tabindex="-1"></a>        Determines when to stop unfolding.</span>
<span id="cb201-8"><a href="#cb201-8" aria-hidden="true" tabindex="-1"></a>    f</span>
<span id="cb201-9"><a href="#cb201-9" aria-hidden="true" tabindex="-1"></a>        Maps each seed value to the corresponding ilist element.</span>
<span id="cb201-10"><a href="#cb201-10" aria-hidden="true" tabindex="-1"></a>    g</span>
<span id="cb201-11"><a href="#cb201-11" aria-hidden="true" tabindex="-1"></a>        Maps each seed value to next seed value.</span>
<span id="cb201-12"><a href="#cb201-12" aria-hidden="true" tabindex="-1"></a>    seed</span>
<span id="cb201-13"><a href="#cb201-13" aria-hidden="true" tabindex="-1"></a>        The <span class="st">&quot;state&quot;</span> value for the unfold.</span>
<span id="cb201-14"><a href="#cb201-14" aria-hidden="true" tabindex="-1"></a>    tail</span>
<span id="cb201-15"><a href="#cb201-15" aria-hidden="true" tabindex="-1"></a>        ilist terminator<span class="co">; defaults to &#39;().</span></span></code></pre></div>
<p>In other words, we use g to generate a sequence of seed values</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a>    seed, g(seed), g2(seed), g3(seed), <span class="op">...</span></span></code></pre></div>
<p>These seed values are mapped to ilist elements by f, producing the elements of the result ilist in a right-to-left order. P says when to stop.</p>
<p>iunfold-right is the fundamental iterative ilist constructor, just as ifold is the fundamental iterative ilist consumer. While iunfold-right may seem a bit abstract to novice functional programmers, it can be used in a number of ways:</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; Ilist of squares: 1^2 ... 10^2</span></span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a>    (iunfold-right <span class="kw">zero?</span></span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a>                  (<span class="kw">lambda</span> (x) (<span class="op">*</span> x x))</span>
<span id="cb203-4"><a href="#cb203-4" aria-hidden="true" tabindex="-1"></a>                  (<span class="kw">lambda</span> (x) (<span class="op">-</span> x <span class="dv">1</span>))</span>
<span id="cb203-5"><a href="#cb203-5" aria-hidden="true" tabindex="-1"></a>                  <span class="dv">10</span>)</span>
<span id="cb203-6"><a href="#cb203-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb203-7"><a href="#cb203-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; Reverse a proper ilist.</span></span>
<span id="cb203-8"><a href="#cb203-8" aria-hidden="true" tabindex="-1"></a>    (iunfold-right null-ilist? icar icdr lis)</span>
<span id="cb203-9"><a href="#cb203-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb203-10"><a href="#cb203-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; Read current input port into an ilist of values.</span></span>
<span id="cb203-11"><a href="#cb203-11" aria-hidden="true" tabindex="-1"></a>    (iunfold-right <span class="kw">eof-object?</span> <span class="kw">values</span> (<span class="kw">lambda</span> (x) (<span class="kw">read</span>)) (<span class="kw">read</span>))</span>
<span id="cb203-12"><a href="#cb203-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb203-13"><a href="#cb203-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; (iappend-reverse rev-head tail)</span></span>
<span id="cb203-14"><a href="#cb203-14" aria-hidden="true" tabindex="-1"></a>    (iunfold-right null-ilist? icar icdr rev-head tail)</span></code></pre></div>
<p>Interested functional programmers may enjoy noting that ifold and iunfold-right are in some sense inverses. That is, given operations knull?, kar, kdr, kons, and knil satisfying</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a>(kons (kar x) (kdr x)) <span class="op">=</span> x <span class="kw">and</span> (knull? knil) <span class="op">=</span> <span class="dv">#t</span></span></code></pre></div>
<p>then</p>
<div class="sourceCode" id="cb205"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a>(ifold kons knil (iunfold-right knull? kar kdr x)) <span class="op">=</span> x</span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb206"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a>(iunfold-right knull? kar kdr (ifold kons knil x)) <span class="op">=</span> x.</span></code></pre></div>
<p>This combinator presumably has some pretentious mathematical name; interested readers are invited to communicate it to the author.</p>
<h2 id="imap-proc-ilist1-ilist2-..."><code>(imap proc ilist1 ilist2 ...)</code></h2>
<p>proc is a procedure taking as many arguments as there are ilist arguments and returning a single value. imap applies proc element-wise to the elements of the ilists and returns an ilist of the results, in order. The dynamic order in which proc is applied to the elements of the ilists is unspecified.</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a>    (imap icadr (iq (a b) (d e) (g h))) <span class="op">=&gt;</span>  (b e h)</span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a>    (imap (<span class="kw">lambda</span> (n) (<span class="kw">expt</span> n n))</span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a>         (iq <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>))</span>
<span id="cb207-5"><a href="#cb207-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">=&gt;</span>  (<span class="dv">1</span> <span class="dv">4</span> <span class="dv">27</span> <span class="dv">256</span> <span class="dv">3125</span>)</span>
<span id="cb207-6"><a href="#cb207-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-7"><a href="#cb207-7" aria-hidden="true" tabindex="-1"></a>    (imap <span class="op">+</span> (iq <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) (iq <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>)) <span class="op">=&gt;</span>  (<span class="dv">5</span> <span class="dv">7</span> <span class="dv">9</span>)</span>
<span id="cb207-8"><a href="#cb207-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-9"><a href="#cb207-9" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">let</span> ((count <span class="dv">0</span>))</span>
<span id="cb207-10"><a href="#cb207-10" aria-hidden="true" tabindex="-1"></a>      (imap (<span class="kw">lambda</span> (ignored)</span>
<span id="cb207-11"><a href="#cb207-11" aria-hidden="true" tabindex="-1"></a>             (<span class="kw">set!</span> count (<span class="op">+</span> count <span class="dv">1</span>))</span>
<span id="cb207-12"><a href="#cb207-12" aria-hidden="true" tabindex="-1"></a>             count)</span>
<span id="cb207-13"><a href="#cb207-13" aria-hidden="true" tabindex="-1"></a>           (iq a b))) <span class="op">=&gt;</span>  (<span class="dv">1</span> <span class="dv">2</span>) <span class="kw">or</span> (<span class="dv">2</span> <span class="dv">1</span>)</span></code></pre></div>
<h2 id="ifor-each-proc-ilist1-ilist2-..."><code>(ifor-each proc ilist1 ilist2 ...)</code></h2>
<p>The arguments to ifor-each are like the arguments to imap, but ifor-each calls proc for its side effects rather than for its values. Unlike imap, ifor-each is guaranteed to call proc on the elements of the ilists in order from the first element(s) to the last, and the value returned by ifor-each is unspecified.</p>
<div class="sourceCode" id="cb208"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">let</span> ((v (<span class="kw">make-vector</span> <span class="dv">5</span>)))</span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a>      (ifor-each (<span class="kw">lambda</span> (i)</span>
<span id="cb208-3"><a href="#cb208-3" aria-hidden="true" tabindex="-1"></a>                  (<span class="kw">vector-set!</span> v i (<span class="op">*</span> i i)))</span>
<span id="cb208-4"><a href="#cb208-4" aria-hidden="true" tabindex="-1"></a>                (iq <span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))</span>
<span id="cb208-5"><a href="#cb208-5" aria-hidden="true" tabindex="-1"></a>      v)  <span class="op">=&gt;</span>  #(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">9</span> <span class="dv">16</span>)</span></code></pre></div>
<h2 id="iappend-map-f-ilist1-ilist2-..."><code>(iappend-map  f ilist1 ilist2 ...)</code></h2>
<p>Equivalent to</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a>(iapply iappend (imap f ilist1 ilist2 <span class="op">...</span>))</span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb210"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a>(iapply iappend (imap f ilist1 ilist2 <span class="op">...</span>))</span></code></pre></div>
<p>Map f over the elements of the ilists, just as in the imap function. However, the results of the applications are appended together (using iappend) to make the final result.</p>
<p>The dynamic order in which the various applications of f are made is not specified.</p>
<p>Example:</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a>(iappend-map (<span class="kw">lambda</span> (x) (ilist x (<span class="op">-</span> x))) (iq <span class="dv">1</span> <span class="dv">3</span> <span class="dv">8</span>))</span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; =&gt; (1 -1 3 -3 8 -8)</span></span></code></pre></div>
<h2 id="imap-in-order-f-ilist1-ilist2-..."><code>(imap-in-order f ilist1 ilist2 ...)</code></h2>
<p>A variant of the imap procedure that guarantees to apply f across the elements of the ilisti arguments in a left-to-right order. This is useful for mapping procedures that both have side effects and return useful values.</p>
<h2 id="ipair-for-each-f-ilist1-ilist2-..."><code>(ipair-for-each f ilist1 ilist2 ...)</code></h2>
<p>Like ifor-each, but f is applied to successive sub-ilists of the argument ilists. That is, f is applied to the cells of the ilists, rather than the ilists’ elements. These applications occur in left-to-right order.</p>
<div class="sourceCode" id="cb212"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a>    (ipair-for-each (<span class="kw">lambda</span> (ipair) (<span class="kw">display</span> ipair) (<span class="kw">newline</span>)) (iq a b c)) ==&gt;</span>
<span id="cb212-2"><a href="#cb212-2" aria-hidden="true" tabindex="-1"></a>        (a b c)</span>
<span id="cb212-3"><a href="#cb212-3" aria-hidden="true" tabindex="-1"></a>        (b c)</span>
<span id="cb212-4"><a href="#cb212-4" aria-hidden="true" tabindex="-1"></a>        (c)</span></code></pre></div>
<h2 id="ifilter-map-f-ilist1-ilist2-..."><code>(ifilter-map f ilist1 ilist2 ...)</code></h2>
<p>Like imap, but only true values are saved.</p>
<div class="sourceCode" id="cb213"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a>    (ifilter-map (<span class="kw">lambda</span> (x) (<span class="kw">and</span> (<span class="kw">number?</span> x) (<span class="op">*</span> x x))) (iq a <span class="dv">1</span> b <span class="dv">3</span> c <span class="dv">7</span>))</span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a>        <span class="op">=&gt;</span> (<span class="dv">1</span> <span class="dv">9</span> <span class="dv">49</span>)</span></code></pre></div>
<p>The dynamic order in which the various applications of f are made is not specified.</p>
<h2 id="ifilter-pred-ilist"><code>(ifilter pred ilist)</code></h2>
<p>Return all the elements of ilist that satisfy predicate pred. The ilist is not disordered — elements that appear in the result ilist occur in the same order as they occur in the argument ilist. The returned ilist may share a common tail with the argument ilist. The dynamic order in which the various applications of pred are made is not specified.</p>
<div class="sourceCode" id="cb214"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a>(ifilter <span class="kw">even?</span> (iq <span class="dv">0</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">8</span> <span class="dv">43</span> -<span class="dv">4</span>)) <span class="op">=&gt;</span> (<span class="dv">0</span> <span class="dv">8</span> <span class="dv">8</span> -<span class="dv">4</span>)</span></code></pre></div>
<h2 id="ipartition-pred-ilist"><code>(ipartition pred ilist)</code></h2>
<p>Partitions the elements of ilist with predicate pred, and returns two values: the ilist of in-elements and the ilist of out-elements. The ilist is not disordered — elements occur in the result ilists in the same order as they occur in the argument ilist. The dynamic order in which the various applications of pred are made is not specified. One of the returned ilists may share a common tail with the argument ilist.</p>
<div class="sourceCode" id="cb215"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a>    (ipartition <span class="kw">symbol?</span> (iq one <span class="dv">2</span> <span class="dv">3</span> four five <span class="dv">6</span>)) <span class="op">=&gt;</span></span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a>        (one four five)</span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">2</span> <span class="dv">3</span> <span class="dv">6</span>)</span></code></pre></div>
<h2 id="iremove-pred-ilist"><code>(iremove pred ilist)</code></h2>
<p>Returns ilist without the elements that satisfy predicate pred:</p>
<div class="sourceCode" id="cb216"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> (pred ilist) (ifilter (<span class="kw">lambda</span> (x) (<span class="kw">not</span> (pred x))) ilist))</span></code></pre></div>
<p>The ilist is not disordered — elements that appear in the result ilist occur in the same order as they occur in the argument ilist. The returned ilist may share a common tail with the argument ilist. The dynamic order in which the various applications of pred are made is not specified.</p>
<div class="sourceCode" id="cb217"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a>(iremove <span class="kw">even?</span> (iq <span class="dv">0</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">8</span> <span class="dv">43</span> -<span class="dv">4</span>)) <span class="op">=&gt;</span> (<span class="dv">7</span> <span class="dv">43</span>)</span></code></pre></div>
<h2 id="ifind-pred-ilist"><code>(ifind pred ilist)</code></h2>
<p>Return the first element of ilist that satisfies predicate pred; false if no element does.</p>
<div class="sourceCode" id="cb218"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a>(ifind <span class="kw">even?</span> (iq <span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> <span class="dv">4</span></span></code></pre></div>
<p>Note that ifind has an ambiguity in its lookup semantics — if ifind returns #f, you cannot tell (in general) if it found a #f element that satisfied pred, or if it did not find any element at all. In many situations, this ambiguity cannot arise — either the ilist being searched is known not to contain any #f elements, or the ilist is guaranteed to have an element satisfying pred. However, in cases where this ambiguity can arise, you should use ifind-tail instead of ifind — ifind-tail has no such ambiguity:</p>
<div class="sourceCode" id="cb219"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">cond</span> ((ifind-tail pred lis) <span class="op">=&gt;</span> (<span class="kw">lambda</span> (ipair) <span class="op">...</span>)) <span class="co">; Handle (icar ipair)</span></span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a>          (<span class="kw">else</span> <span class="op">...</span>)) <span class="co">; Search failed.</span></span></code></pre></div>
<h2 id="ifind-tail-pred-ilist"><code>(ifind-tail pred ilist)</code></h2>
<p>Return the first ipair of ilist whose icar satisfies pred. If no ipair does, return false.</p>
<p>ifind-tail can be viewed as a general-predicate variant of the imember function.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb220"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a>    (ifind-tail <span class="kw">even?</span> (iq <span class="dv">3</span> <span class="dv">1</span> <span class="dv">37</span> -<span class="dv">8</span> -<span class="dv">5</span> <span class="dv">0</span> <span class="dv">0</span>)) <span class="op">=&gt;</span> (-<span class="dv">8</span> -<span class="dv">5</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true" tabindex="-1"></a>    (ifind-tail <span class="kw">even?</span> (iq <span class="dv">3</span> <span class="dv">1</span> <span class="dv">37</span> -<span class="dv">5</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb220-3"><a href="#cb220-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb220-4"><a href="#cb220-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; IMEMBER X LIS:</span></span>
<span id="cb220-5"><a href="#cb220-5" aria-hidden="true" tabindex="-1"></a>    (ifind-tail (<span class="kw">lambda</span> (elt) (<span class="kw">equal?</span> x elt)) lis)</span></code></pre></div>
<p>iqfind-tail is essentially idrop-while, where the sense of the predicate is inverted: Ifind-tail searches until it finds an element satisfying the predicate; idrop-while searches until it finds an element that doesn’t satisfy the predicate.</p>
<h2 id="itake-while-pred-ilist"><code>(itake-while  pred ilist)</code></h2>
<p>Returns the longest initial prefix of ilist whose elements all satisfy the predicate pred.</p>
<div class="sourceCode" id="cb221"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a>(itake-while <span class="kw">even?</span> (iq <span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> (<span class="dv">2</span> <span class="dv">18</span>)</span></code></pre></div>
<h2 id="idrop-while-pred-ilist"><code>(idrop-while pred ilist)</code></h2>
<p>idrops the longest initial prefix of ilist whose elements all satisfy the predicate pred, and returns the rest of the ilist.</p>
<div class="sourceCode" id="cb222"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a>(idrop-while <span class="kw">even?</span> (iq <span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> (<span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)</span></code></pre></div>
<h2 id="ispan-pred-ilist"><code>(ispan pred ilist)</code></h2>
<h2 id="ibreak-pred-ilist"><code>(ibreak  pred ilist)</code></h2>
<p>ispan splits the ilist into the longest initial prefix whose elements all satisfy pred, and the remaining tail. ibreak inverts the sense of the predicate: the tail commences with the first element of the input ilist that satisfies the predicate.</p>
<p>In other words: ispan finds the initial span of elements satisfying pred, and ibreak breaks the ilist at the first element satisfying pred.</p>
<p>ispan is equivalent to</p>
<div class="sourceCode" id="cb223"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">values</span> (itake-while pred ilist)</span>
<span id="cb223-2"><a href="#cb223-2" aria-hidden="true" tabindex="-1"></a>            (idrop-while pred ilist))</span>
<span id="cb223-3"><a href="#cb223-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-4"><a href="#cb223-4" aria-hidden="true" tabindex="-1"></a>    (ispan <span class="kw">even?</span> (iq <span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span></span>
<span id="cb223-5"><a href="#cb223-5" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">2</span> <span class="dv">18</span>)</span>
<span id="cb223-6"><a href="#cb223-6" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)</span>
<span id="cb223-7"><a href="#cb223-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-8"><a href="#cb223-8" aria-hidden="true" tabindex="-1"></a>    (ibreak <span class="kw">even?</span> (iq <span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="op">=&gt;</span></span>
<span id="cb223-9"><a href="#cb223-9" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">3</span> <span class="dv">1</span>)</span>
<span id="cb223-10"><a href="#cb223-10" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)</span></code></pre></div>
<h2 id="iany-pred-ilist1-ilist2-..."><code>(iany pred ilist1 ilist2 ...)</code></h2>
<p>Applies the predicate across the ilists, returning true if the predicate returns true on any application.</p>
<p>If there are n ilist arguments ilist1 … ilistn, then pred must be a procedure taking n arguments and returning a boolean result.</p>
<p>iany applies pred to the first elements of the ilisti parameters. If this application returns a true value, iany immediately returns that value. Otherwise, it iterates, applying pred to the second elements of the ilisti parameters, then the third, and so forth. The iteration stops when a true value is produced or one of the ilists runs out of values; in the latter case, iany returns #f. The application of pred to the last element of the ilists is a tail call.</p>
<p>Note the difference between ifind and iany — ifind returns the element that satisfied the predicate; iany returns the true value that the predicate produced.</p>
<p>Like ievery, iany’s name does not end with a question mark — this is to indicate that it does not return a simple boolean (#t or #f), but a general value.</p>
<div class="sourceCode" id="cb224"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a>    (iany <span class="kw">integer?</span> (iq a <span class="dv">3</span> b <span class="fl">2.7</span>))   <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a>    (iany <span class="kw">integer?</span> (iq a <span class="fl">3.1</span> b <span class="fl">2.7</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb224-3"><a href="#cb224-3" aria-hidden="true" tabindex="-1"></a>    (iany <span class="op">&lt;</span> (iq <span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span>)</span>
<span id="cb224-4"><a href="#cb224-4" aria-hidden="true" tabindex="-1"></a>           (iq <span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">#t</span></span></code></pre></div>
<h2 id="ievery-pred-ilist1-ilist2-..."><code>(ievery pred ilist1 ilist2 ...)</code></h2>
<p>Applies the predicate across the ilists, returning true if the predicate returns true on every application.</p>
<p>If there are n ilist arguments ilist1 … ilistn, then pred must be a procedure taking n arguments and returning a boolean result.</p>
<p>ievery applies pred to the first elements of the ilisti parameters. If this application returns false, ievery immediately returns false. Otherwise, it iterates, applying pred to the second elements of the ilisti parameters, then the third, and so forth. The iteration stops when a false value is produced or one of the ilists runs out of values. In the latter case, ievery returns the true value produced by its final application of pred. The application of pred to the last element of the ilists is a tail call.</p>
<p>If one of the ilisti has no elements, ievery simply returns #t.</p>
<p>Like iany, ievery’s name does not end with a question mark — this is to indicate that it does not return a simple boolean (#t or #f), but a general value.</p>
<h2 id="ilist-index-pred-ilist1-ilist2-..."><code>(ilist-index pred ilist1 ilist2 ...)</code></h2>
<p>Return the index of the leftmost element that satisfies pred.</p>
<p>If there are n ilist arguments ilist1 … ilistn, then pred must be a function taking n arguments and returning a boolean result.</p>
<p>ilist-index applies pred to the first elements of the ilisti parameters. If this application returns true, ilist-index immediately returns zero. Otherwise, it iterates, applying pred to the second elements of the ilisti parameters, then the third, and so forth. When it finds a tuple of ilist elements that cause pred to return true, it stops and returns the zero-based index of that position in the ilists.</p>
<p>The iteration stops when one of the ilists runs out of values; in this case, ilist-index returns #f.</p>
<div class="sourceCode" id="cb225"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a>    (ilist-index <span class="kw">even?</span> (iq <span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> <span class="dv">2</span></span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true" tabindex="-1"></a>    (ilist-index <span class="op">&lt;</span> (iq <span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) (iq <span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">1</span></span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true" tabindex="-1"></a>    (ilist-index <span class="op">=</span> (iq <span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) (iq <span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="imember-x-ilist"><code>(imember x ilist [=])</code></h2>
<h2 id="imemq-x-ilist"><code>(imemq x ilist)</code></h2>
<h2 id="imemv-x-ilist">`(imemv x ilist)</h2>
<p>These procedures return the first sub-ilist of ilist whose icar is x, where the sub-ilists of ilist are the non-empty ilists returned by (idrop ilist i) for i less than the length of ilist. If x does not occur in ilist, then #f is returned. imemq uses eq? to compare x with the elements of ilist, while imemv uses eqv?, and imember uses equal?.</p>
<pre><code>        (imemq &#39;a (iq a b c))           =&gt;  (a b c)
        (imemq &#39;b (iq a b c))           =&gt;  (b c)
        (imemq &#39;a (iq b c d))           =&gt;  #f
        (imemq (list &#39;a)
                (ilist &#39;b &#39;(a) &#39;c))     =&gt;  #f
        (imember (list &#39;a)
                (ilist &#39;b &#39;(a) &#39;c)))    =&gt;  ((a) c)
        (imemq 101 (iq 100 101 102))    =&gt;  *unspecified*
        (imemv 101 (iq 100 101 102))    =&gt;  (101 102)</code></pre>
<p>The comparison procedure is used to compare the elements ei of ilist to the key x in this way:</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">=</span> x ei) <span class="co">; ilist is (E1 ... En)</span></span></code></pre></div>
<p>That is, the first argument is always x, and the second argument is one of the ilist elements. Thus one can reliably find the first element of ilist that is greater than five with (imember 5 ilist &lt;)</p>
<p>Note that fully general ilist searching may be performed with the ifind-tail and ifind procedures, e.g.</p>
<div class="sourceCode" id="cb228"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a>(ifind-tail <span class="kw">even?</span> ilist) <span class="co">; Find the first elt with an even key.</span></span></code></pre></div>
<h2 id="idelete-x-ilist"><code>(idelete  x ilist [=])</code></h2>
<p>idelete uses the comparison procedure =, which defaults to equal?, to find all elements of ilist that are equal to x, and deletes them from ilist. The dynamic order in which the various applications of = are made is not specified.</p>
<p>The ilist is not disordered — elements that appear in the result ilist occur in the same order as they occur in the argument ilist. The result may share a common tail with the argument ilist.</p>
<p>Note that fully general element deletion can be performed with the iremove procedures, e.g.:</p>
<div class="sourceCode" id="cb229"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a><span class="co">;; idelete all the even elements from LIS:</span></span>
<span id="cb229-2"><a href="#cb229-2" aria-hidden="true" tabindex="-1"></a>(iremove <span class="kw">even?</span> lis)</span></code></pre></div>
<p>The comparison procedure is used in this way: (= x ei). That is, x is always the first argument, and an ilist element is always the second argument. The comparison procedure will be used to compare each element of ilist exactly once; the order in which it is applied to the various ei is not specified. Thus, one can reliably remove all the numbers greater than five from an ilist with (idelete 5 ilist &lt;)</p>
<h2 id="idelete-duplicates-ilist"><code>(idelete-duplicates  ilist [=])</code></h2>
<p>idelete-duplicates removes duplicate elements from the ilist argument. If there are multiple equal elements in the argument ilist, the result ilist only contains the first or leftmost of these elements in the result. The order of these surviving elements is the same as in the original ilist — idelete-duplicates does not disorder the ilist (hence it is useful for “cleaning up” immutable association lists).</p>
<p>The = parameter is used to compare the elements of the ilist; it defaults to equal?. If x comes before y in ilist, then the comparison is performed (= x y). The comparison procedure will be used to compare each pair of elements in ilist no more than once; the order in which it is applied to the various pairs is not specified.</p>
<p>Implementations of idelete-duplicates are allowed to share common tails between argument and result ilists — for example, if the ilist argument contains only unique elements, it may simply return exactly this ilist.</p>
<p>Be aware that, in general, idelete-duplicates runs in time O(n2) for n-element ilists. Uniquifying long ilists can be accomplished in O(n lg n) time by sorting the ilist to bring equal elements together, then using a linear-time algorithm to remove equal elements. Alternatively, one can use algorithms based on element-marking, with linear-time results.</p>
<div class="sourceCode" id="cb230"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a>(idelete-duplicates (iq a b a c a b c z)) <span class="op">=&gt;</span> (a b c z)</span>
<span id="cb230-2"><a href="#cb230-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-3"><a href="#cb230-3" aria-hidden="true" tabindex="-1"></a><span class="co">;; Clean up an ialist:</span></span>
<span id="cb230-4"><a href="#cb230-4" aria-hidden="true" tabindex="-1"></a>(idelete-duplicates (iq (a <span class="op">.</span> <span class="dv">3</span>) (b <span class="op">.</span> <span class="dv">7</span>) (a <span class="op">.</span> <span class="dv">9</span>) (c <span class="op">.</span> <span class="dv">1</span>))</span>
<span id="cb230-5"><a href="#cb230-5" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> (x y) (<span class="kw">eq?</span> (icar x) (icar y))))</span>
<span id="cb230-6"><a href="#cb230-6" aria-hidden="true" tabindex="-1"></a><span class="co">;; =&gt; ((a . 3) (b . 7) (c . 1))</span></span></code></pre></div>
<h2 id="ialist-cons-key-datum-ialist"><code>(ialist-cons key datum ialist)</code></h2>
<div class="sourceCode" id="cb231"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> (key datum ialist) (ipair (ipair key datum) ialist))</span></code></pre></div>
<p>Construct a new ialist entry mapping key -&gt; datum onto ialist.</p>
<h2 id="ialist-delete-key-ialist"><code>(ialist-delete  key ialist [=])</code></h2>
<p>ialist-delete deletes all associations from ialist with the given key, using key-comparison procedure =, which defaults to equal?. The dynamic order in which the various applications of = are made is not specified.</p>
<p>Return values may share common tails with the ialist argument. The ialist is not disordered — elements that appear in the result ialist occur in the same order as they occur in the argument ialist.</p>
<p>The comparison procedure is used to compare the element keys ki of ialist’s entries to the key parameter in this way: (= key ki). Thus, one can reliably remove all entries of ialist whose key is greater than five with (ialist-delete 5 ialist &lt;)</p>
<h2 id="replace-icar-ipair-object"><code>(replace-icar ipair object)</code></h2>
<p>This procedure returns an ipair with object in the icar field and the icdr of ipair in the icdr field.</p>
<h2 id="replace-icdr-ipair-object"><code>(replace-icdr ipair object)</code></h2>
<p>This procedure returns an ipair with object in the icdr field and the icar of ipair in the icar field.</p>
<h2 id="pair-ipair-pair"><code>(pair-&gt;ipair pair)</code></h2>
<h2 id="ipair-pair-ipair"><code>(ipair-&gt;pair ipair)</code></h2>
<p>These procedures, which are inverses, return an ipair and a pair respectively that have the same (i)car and (i)cdr fields as the argument.</p>
<h2 id="list-ilist-flist"><code>(list-&gt;ilist flist)</code></h2>
<h2 id="ilist-list-dilist"><code>(ilist-&gt;list dilist)</code></h2>
<p>These procedures return an ilist and a list respectively that have the same elements as the argument. The tails of dotted (i)lists are preserved in the result, which makes the procedures not inverses when the tail of a dotted ilist is a list or vice versa. The empty list is converted to itself.</p>
<p>It is an error to apply list-&gt;ilist to a circular list.</p>
<h2 id="tree-itree-object"><code>(tree-&gt;itree object)</code></h2>
<h2 id="itree-tree-object"><code>(itree-&gt;tree object)</code></h2>
<p>These procedures walk a tree of pairs or ipairs respectively and make a deep copy of it, returning an isomorphic tree containing ipairs or pairs respectively. The result may share structure with the argument. If the argument is not of the expected type, it is returned.</p>
<p>These procedures are not inverses in the general case. For example, a pair of ipairs would be converted by tree-&gt;itree to an ipair of ipairs, which if converted by itree-&gt;tree would produce a pair of pairs.</p>
<h2 id="gtree-itree-object"><code>(gtree-&gt;itree object)</code></h2>
<h2 id="gtree-tree-object"><code>(gtree-&gt;tree object)</code></h2>
<p>These procedures walk a generalized tree consisting of pairs, ipairs, or a combination of both, and make a deep copy of it, returning an isomorphic tree containing only ipairs or pairs respectively. The result may share structure with the argument. If the argument is neither a pair nor an ipair, it is returned.</p>
<h2 id="iapply-procedure-object-...-ilist"><code>(iapply procedure object ... ilist)</code></h2>
<p>The iapply procedure is an analogue of apply whose last argument is an ilist rather than a list. It is equivalent to (apply procedure object … (ilist-&gt;list ilist)), but may be implemented more efficiently.</p>
<h2 id="ipair-comparator"><code>ipair-comparator</code></h2>
<p>The ipair-comparator object is a SRFI-114 comparator suitable for comparing ipairs. Note that it is not a procedure. It compares pairs using default-comparator on their cars. If the cars are not equal, that value is returned. If they are equal, default-comparator is used on their cdrs and that value is returned.</p>
<h2 id="ilist-comparator"><code>ilist-comparator</code></h2>
<p>The ilist-comparator object is a SRFI-114 comparator suitable for comparing ilists. Note that it is not a procedure. It compares ilists lexicographically, as follows:</p>
<ul>
<li><p>The empty ilist compares equal to itself.</p></li>
<li><p>The empty ilist compares less than any non-empty ilist.</p></li>
<li><p>Two non-empty ilists are compared by comparing their icars. If the icars are not equal when compared using default-comparator, then the result is the result of that comparison. Otherwise, the icdrs are compared using ilist-comparator.</p></li>
</ul>
<h2 id="make-ilist-comparator-comparator"><code>(make-ilist-comparator comparator)</code></h2>
<p>The make-ilist-comparator procedure returns a comparator suitable for comparing ilists using element-comparator to compare the elements.</p>
<h2 id="make-improper-ilist-comparator-comparator"><code>(make-improper-ilist-comparator comparator)</code></h2>
<p>The make-improper-ilist-comparator procedure returns a comparator that compares arbitrary objects as follows: the empty list precedes all ipairs, which precede all other objects. Ipairs are compared as if with (make-ipair-comparator comparator comparator). All other objects are compared using comparator.</p>
<h2 id="make-icar-comparator-comparator"><code>(make-icar-comparator comparator)</code></h2>
<p>The make-icar-comparator procedure returns a comparator that compares ipairs on their icars alone using comparator.</p>
<h2 id="make-icdr-comparator-comparator">`(make-icdr-comparator comparator)</h2>
<p>The make-icdr-comparator procedure returns a comparator that compares ipairs on their icdrs alone using comparator. # <code>(scheme cxr)</code></p>
<p>Exports the following procedure which are the compositions of from three to four <code>car</code> and <code>cdr</code> operations. For example <code>caddar</code> could be defined:</p>
<div class="sourceCode" id="cb232"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> caddar</span></span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> (x) (<span class="kw">car</span> (<span class="kw">cdr</span> (<span class="kw">cdr</span> (<span class="kw">car</span> x))))))</span></code></pre></div>
<p>Here is the full list:</p>
<ul>
<li><code>caaaar</code></li>
<li><code>caaadr</code></li>
<li><code>caaar</code></li>
<li><code>caadar</code></li>
<li><code>caaddr</code></li>
<li><code>caadr</code></li>
<li><code>cadaar</code></li>
<li><code>cadadr</code></li>
<li><code>cadar</code></li>
<li><code>caddar</code></li>
<li><code>cadddr</code></li>
<li><code>caddr</code></li>
<li><code>cdaaar</code></li>
<li><code>cdaadr</code></li>
<li><code>cdaar</code></li>
<li><code>cdadar</code></li>
<li><code>cdaddr</code></li>
<li><code>cdadr</code></li>
<li><code>cddaar</code></li>
<li><code>cddadr</code></li>
<li><code>cddar</code></li>
<li><code>cdddar</code></li>
<li><code>cddddr</code></li>
<li><code>cdddr</code> # <code>(scheme lseq)</code></li>
</ul>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-127/">SRFI-127</a>.</p>
<p>Lazy sequences (or lseqs, pronounced “ell-seeks”) are a generalization of lists. In particular, an lseq is either a proper list or a dotted list whose last cdr is a SRFI 121 generator. A generator is a procedure that can be invoked with no arguments in order to lazily supply additional elements of the lseq. When a generator has no more elements to return, it returns an end-of-file object. Consequently, lazy sequences cannot reliably contain end-of-file objects.</p>
<p>This SRFI provides a set of procedures suitable for operating on lazy sequences based on SRFI 1.</p>
<h2 id="generator-lseq-generator"><code>(generator-&gt;lseq generator)</code></h2>
<p>Returns an lseq whose elements are the values generated by generator. The exact behavior is as follows:</p>
<ul>
<li><p>Generator is invoked with no arguments to produce an object obj.</p></li>
<li><p>If obj is an end-of-file object, the empty list is returned.</p></li>
<li><p>Otherwise, a newly allocated pair whose car is obj and whose cdr is generator is returned.</p></li>
</ul>
<div class="sourceCode" id="cb233"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a>(generator-&gt;lseq (make-iota-generator +inf.0 <span class="dv">1</span>))</span></code></pre></div>
<h2 id="lseq-x"><code>(lseq? x)</code></h2>
<p>Returns #t if x is an lseq. This procedure may also return #t if x is an improper list whose last cdr is a procedure that requires arguments, since there is no portable way to examine a procedure to determine how many arguments it requires. Otherwise it returns #f.</p>
<h2 id="lseq-elt-lseq1-lseq2"><code>(lseq=? elt=? lseq1 lseq2)</code></h2>
<p>Determines lseq equality, given an element-equality procedure. Two lseqs are equal if they are of the same length, and their corresponding elements are equal, as determined by elt=?. When elt=? is called, its first argument is always from lseq1 and its second argument is from lseq2.</p>
<p>The dynamic order in which the elt=? procedure is applied to pairs of elements is not specified.</p>
<p>The elt=? procedure must be consistent with eq?. This implies that two lseqs which are eq? are always lseq=?, as well; implementations may exploit this fact to “short-cut” the element-by-element equality tests.</p>
<h2 id="lseq-car-lseq"><code>(lseq-car lseq)</code></h2>
<h2 id="lseq-first-lseq"><code>(lseq-first lseq)</code></h2>
<p>These procedures are synonymous. They return the first element of lseq. They are included for completeness, as they are the same as car. It is an error to apply them to an empty lseq.</p>
<h2 id="lseq-cdr-lseq"><code>(lseq-cdr lseq)</code></h2>
<h2 id="lseq-rest-lseq"><code>(lseq-rest lseq)</code></h2>
<p>These procedures are synonymous. They return an lseq with the contents of lseq except for the first element. The exact behavior is as follows:</p>
<ul>
<li><p>If lseq is a pair whose cdr is a procedure, then the procedure is invoked with no arguments to produce an object obj.</p></li>
<li><p>If obj is an end-of-file object, then the cdr of lseq is set to the empty list, which is returned.</p></li>
<li><p>If obj is any other object, then a new pair is allocated whose car is obj and whose cdr is the cdr of lseq (i.e. the procedure). The cdr of lseq is set to the newly allocated pair, which is returned.</p></li>
<li><p>If lseq is a pair whose cdr is not a procedure, then the cdr is returned.</p></li>
<li><p>If lseq is not a pair, it is an error.</p></li>
</ul>
<p>Implementations that inline cdr are advised to inline lseq-cdr if possible.</p>
<h2 id="lseq-ref-lseq-i"><code>(lseq-ref lseq i)</code></h2>
<p>Returns the ith element of lseq. (This is the same as (lseq-first (lseq-drop lseq i)).) It is an error if i &gt;= n, where n is the length of lseq.</p>
<div class="sourceCode" id="cb234"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a>(lseq-ref &#39;(a b c d) <span class="dv">2</span>) <span class="op">=&gt;</span> c</span></code></pre></div>
<h2 id="lseq-take-lseq-i"><code>(lseq-take lseq i)</code></h2>
<h2 id="lseq-drop-lseq-i"><code>(lseq-drop lseq i)</code></h2>
<p>lseq-take lazily returns the first i elements of lseq. lseq-drop returns all but the first i elements of lseq.</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a>(lseq-take &#39;(a b c d e)  <span class="dv">2</span>) <span class="op">=&gt;</span> (a b)</span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a>(lseq-drop &#39;(a b c d e)  <span class="dv">2</span>) <span class="op">=&gt;</span> (c d e)</span></code></pre></div>
<p>lseq-drop is exactly equivalent to performing i lseq-rest operations on lseq.</p>
<h2 id="lseq-realize-lseq"><code>(lseq-realize lseq)</code></h2>
<p>Repeatedly applies lseq-cdr to lseq until its generator (if there is one) has been exhausted, and returns lseq, which is now guaranteed to be a proper list. This procedure can be called on an arbitrary lseq before passing it to a procedure which only accepts lists. However, if the generator never returns an end-of-file object, lseq-realize will never return.</p>
<h2 id="lseq-generator-lseq"><code>(lseq-&gt;generator lseq)</code></h2>
<p>Returns a generator which when invoked will return all the elements of lseq, including any that have not yet been realized.</p>
<h2 id="lseq-length-lseq"><code>(lseq-length lseq)</code></h2>
<p>Returns the length of its argument, which is the non-negative integer n such that lseq-rest applied n times to the lseq produces an empty lseq. lseq must be finite, or this procedure will not return.</p>
<h2 id="lseq-append-lseq-..."><code>(lseq-append lseq ...)</code></h2>
<p>Returns an lseq that lazily contains all the elements of all the lseqs in order.</p>
<h2 id="lseq-zip-lseq1-lseq2-..."><code>(lseq-zip lseq1 lseq2 ...)</code></h2>
<p>If lseq-zip is passed n lseqs, it lazily returns an lseq each element of which is an n-element list comprised of the corresponding elements from the lseqs. If any of the lseqs are finite in length, the result is as long as the shortest lseq.</p>
<div class="sourceCode" id="cb236"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a>    (lseq-zip &#39;(one two three)</span>
<span id="cb236-2"><a href="#cb236-2" aria-hidden="true" tabindex="-1"></a>         (generator-&gt;lseq (make-iota-generator +inf.0 <span class="dv">1</span> <span class="dv">1</span>))</span>
<span id="cb236-3"><a href="#cb236-3" aria-hidden="true" tabindex="-1"></a>         (generator-&gt;lseq (make-repeating-generator) &#39;(odd even))))</span>
<span id="cb236-4"><a href="#cb236-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">=&gt;</span> ((one <span class="dv">1</span> odd) (two <span class="dv">2</span> even) (three <span class="dv">3</span> odd))</span>
<span id="cb236-5"><a href="#cb236-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb236-6"><a href="#cb236-6" aria-hidden="true" tabindex="-1"></a>    (lseq-zip &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)) <span class="op">=&gt;</span> ((<span class="dv">1</span>) (<span class="dv">2</span>) (<span class="dv">3</span>))</span></code></pre></div>
<h2 id="lseq-map-proc-lseq1-lseq2-..."><code>(lseq-map proc lseq1 lseq2 ...)</code></h2>
<p>The lseq-map procedure lazily applies proc element-wise to the corresponding elements of the lseqs, where proc is a procedure taking as many arguments as there are lseqs and returning a single value, and returns an lseq of the results in order. The dynamic order in which proc is applied to the elements of the lseqs is unspecified.</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a>    (lseq-map</span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">lambda</span> (x) (lseq-car (lseq-cdr x)))</span>
<span id="cb237-3"><a href="#cb237-3" aria-hidden="true" tabindex="-1"></a>      &#39;((a b) (d e) (g h))) <span class="op">=&gt;</span>  (b e h)</span>
<span id="cb237-4"><a href="#cb237-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-5"><a href="#cb237-5" aria-hidden="true" tabindex="-1"></a>    (lseq-map (<span class="kw">lambda</span> (n) (<span class="kw">expt</span> n n))</span>
<span id="cb237-6"><a href="#cb237-6" aria-hidden="true" tabindex="-1"></a>         (make-iota-generator +inf.0 <span class="dv">1</span> <span class="dv">1</span>)</span>
<span id="cb237-7"><a href="#cb237-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">=&gt;</span>  (<span class="dv">1</span> <span class="dv">4</span> <span class="dv">27</span> <span class="dv">256</span> <span class="dv">3125</span> <span class="op">...</span>)</span>
<span id="cb237-8"><a href="#cb237-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-9"><a href="#cb237-9" aria-hidden="true" tabindex="-1"></a>    (lseq-map <span class="op">+</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) &#39;(<span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>)) <span class="op">=&gt;</span>  (<span class="dv">5</span> <span class="dv">7</span> <span class="dv">9</span>)</span>
<span id="cb237-10"><a href="#cb237-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-11"><a href="#cb237-11" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">let</span> ((count <span class="dv">0</span>))</span>
<span id="cb237-12"><a href="#cb237-12" aria-hidden="true" tabindex="-1"></a>      (lseq-map (<span class="kw">lambda</span> (ignored)</span>
<span id="cb237-13"><a href="#cb237-13" aria-hidden="true" tabindex="-1"></a>             (<span class="kw">set!</span> count (<span class="op">+</span> count <span class="dv">1</span>))</span>
<span id="cb237-14"><a href="#cb237-14" aria-hidden="true" tabindex="-1"></a>             count)</span>
<span id="cb237-15"><a href="#cb237-15" aria-hidden="true" tabindex="-1"></a>           &#39;(a b))) <span class="op">=&gt;</span>  (<span class="dv">1</span> <span class="dv">2</span>) <span class="kw">or</span> (<span class="dv">2</span> <span class="dv">1</span>)</span></code></pre></div>
<h2 id="lseq-for-each-proc-lseq1-lseq2">`(lseq-for-each proc lseq1 lseq2 …)</h2>
<p>The arguments to lseq-for-each are like the arguments to lseq-map, but lseq-for-each calls proc for its side effects rather than for its values. Unlike lseq-map, lseq-for-each is guaranteed to call proc on the elements of the lseqs in order from the first element(s) to the last, and the value returned by lseq-for-each is unspecified.</p>
<p>If none of the lseqs are finite, lseq-for-each never returns.</p>
<div class="sourceCode" id="cb238"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">let</span> ((v (<span class="kw">make-vector</span> <span class="dv">5</span>)))</span>
<span id="cb238-2"><a href="#cb238-2" aria-hidden="true" tabindex="-1"></a>      (lseq-for-each (<span class="kw">let</span> ((count <span class="dv">0</span>))</span>
<span id="cb238-3"><a href="#cb238-3" aria-hidden="true" tabindex="-1"></a>                       (<span class="kw">lambda</span> (i)</span>
<span id="cb238-4"><a href="#cb238-4" aria-hidden="true" tabindex="-1"></a>                         (<span class="kw">vector-set!</span> v count (<span class="op">*</span> i i))</span>
<span id="cb238-5"><a href="#cb238-5" aria-hidden="true" tabindex="-1"></a>                         (<span class="kw">set!</span> count (<span class="op">+</span> count <span class="dv">1</span>))))</span>
<span id="cb238-6"><a href="#cb238-6" aria-hidden="true" tabindex="-1"></a>                     &#39;(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))</span>
<span id="cb238-7"><a href="#cb238-7" aria-hidden="true" tabindex="-1"></a>      v)</span>
<span id="cb238-8"><a href="#cb238-8" aria-hidden="true" tabindex="-1"></a>      <span class="op">=&gt;</span>  (#<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)</span></code></pre></div>
<h2 id="lseq-filter-pred-lseq"><code>(lseq-filter pred lseq)</code></h2>
<h2 id="lseq-remove-pred-lseq"><code>(lseq-remove pred lseq)</code></h2>
<p>The procedure lseq-filter lazily returns an lseq that contains only the elements of lseq that satisfy pred.</p>
<p>The procedure lseq-remove is the same as lseq-filter, except that it returns elements that do not satisfy pred. These procedures are guaranteed to call pred on the elements of the lseqs in sequence order.</p>
<div class="sourceCode" id="cb239"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a>(lseq-filter <span class="kw">odd?</span> (generator-&gt;lseq (make-range-generator <span class="dv">1</span> <span class="dv">5</span>)))</span>
<span id="cb239-2"><a href="#cb239-2" aria-hidden="true" tabindex="-1"></a><span class="co">;; =&gt;  (1 3)</span></span>
<span id="cb239-3"><a href="#cb239-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb239-4"><a href="#cb239-4" aria-hidden="true" tabindex="-1"></a>(lseq-remove <span class="kw">odd?</span> (generator-&gt;lseq (make-range-generator <span class="dv">1</span> <span class="dv">5</span>)))</span>
<span id="cb239-5"><a href="#cb239-5" aria-hidden="true" tabindex="-1"></a><span class="co">;; =&gt;  (2 4)</span></span></code></pre></div>
<h2 id="lseq-find-tail-pred-lseq"><code>(lseq-find-tail pred lseq)</code></h2>
<p>Returns the longest tail of lseq whose first element satisfies pred, or #f if no element does. The predicate is guaranteed to be evaluated on the elements of lseq in sequence order, and only as often as necessary.</p>
<p>lseq-find-tail can be viewed as a general-predicate variant of the lseq-member function.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb240"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true" tabindex="-1"></a>(lseq-find-tail <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">37</span> -<span class="dv">8</span> -<span class="dv">5</span> <span class="dv">0</span> <span class="dv">0</span>)) <span class="op">=&gt;</span> (-<span class="dv">8</span> -<span class="dv">5</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb240-2"><a href="#cb240-2" aria-hidden="true" tabindex="-1"></a>(lseq-find-tail <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">37</span> -<span class="dv">5</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb240-3"><a href="#cb240-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb240-4"><a href="#cb240-4" aria-hidden="true" tabindex="-1"></a><span class="co">;; equivalent to (lseq-member elt lseq)</span></span>
<span id="cb240-5"><a href="#cb240-5" aria-hidden="true" tabindex="-1"></a>(lseq-find-tail (<span class="kw">lambda</span> (elt) (<span class="kw">equal?</span> x elt)) lseq)</span></code></pre></div>
<h2 id="lseq-take-while-pred-lseq"><code>(lseq-take-while pred lseq)</code></h2>
<p>Lazily returns the longest initial prefix of lseq whose elements all satisfy the predicate pred.</p>
<div class="sourceCode" id="cb241"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb241-1"><a href="#cb241-1" aria-hidden="true" tabindex="-1"></a>(lseq-take-while <span class="kw">even?</span> &#39;(<span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> (<span class="dv">2</span> <span class="dv">18</span>)</span></code></pre></div>
<h2 id="lseq-drop-while-pred-lseq"><code>(lseq-drop-while pred lseq)</code></h2>
<p>Drops the longest initial prefix of lseq whose elements all satisfy the predicate pred, and returns the rest of the lseq.</p>
<div class="sourceCode" id="cb242"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true" tabindex="-1"></a>(lseq-drop-while <span class="kw">even?</span> &#39;(<span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> (<span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)</span></code></pre></div>
<p>Note that lseq-drop-while is essentially lseq-find-tail where the sense of the predicate is inverted: lseq-find-tail searches until it finds an element satisfying the predicate; lseq-drop-while searches until it finds an element that doesn’t satisfy the predicate.</p>
<h2 id="lseq-any-pred-lseq1-lseq2-..."><code>(lseq-any pred lseq1 lseq2 ...)</code></h2>
<p>Applies pred to successive elements of the lseqs, returning true if pred returns true on any application. If an application returns a true value, lseq-any immediately returns that value. Otherwise, it iterates until a true value is produced or one of the lseqs runs out of values; in the latter case, lseq-any returns #f. It is an error if pred does not accept the same number of arguments as there are lseqs and return a boolean result.</p>
<p>Note the difference between lseq-find and lseq-any — lseq-find returns the element that satisfied the predicate; lseq-any returns the true value that the predicate produced.</p>
<p>Like lseq-every, lseq-any’s name does not end with a question mark — this is to indicate that it does not return a simple boolean (#t or #f), but a general value.</p>
<div class="sourceCode" id="cb243"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true" tabindex="-1"></a>    (lseq-any <span class="kw">integer?</span> &#39;(a <span class="dv">3</span> b <span class="fl">2.7</span>))   <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb243-2"><a href="#cb243-2" aria-hidden="true" tabindex="-1"></a>    (lseq-any <span class="kw">integer?</span> &#39;(a <span class="fl">3.1</span> b <span class="fl">2.7</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb243-3"><a href="#cb243-3" aria-hidden="true" tabindex="-1"></a>    (lseq-any <span class="op">&lt;</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span>)</span>
<span id="cb243-4"><a href="#cb243-4" aria-hidden="true" tabindex="-1"></a>           &#39;(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb243-5"><a href="#cb243-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-6"><a href="#cb243-6" aria-hidden="true" tabindex="-1"></a>    (<span class="ex">define</span><span class="fu"> </span>(factorial n)</span>
<span id="cb243-7"><a href="#cb243-7" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">cond</span></span>
<span id="cb243-8"><a href="#cb243-8" aria-hidden="true" tabindex="-1"></a>        ((<span class="op">&lt;</span> n <span class="dv">0</span>) <span class="dv">#f</span>)</span>
<span id="cb243-9"><a href="#cb243-9" aria-hidden="true" tabindex="-1"></a>        ((<span class="op">=</span> n <span class="dv">0</span>) <span class="dv">1</span>)</span>
<span id="cb243-10"><a href="#cb243-10" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">else</span> (<span class="op">*</span> n (factorial (<span class="op">-</span> n <span class="dv">1</span>))))))</span>
<span id="cb243-11"><a href="#cb243-11" aria-hidden="true" tabindex="-1"></a>    (lseq-any factorial &#39;(-<span class="dv">1</span> -<span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))</span>
<span id="cb243-12"><a href="#cb243-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">=&gt;</span> <span class="dv">6</span></span></code></pre></div>
<h2 id="lseq-every-pred-lseq1-lseq2-..."><code>(lseq-every pred lseq1 lseq2 ...)</code></h2>
<p>Applies pred to successive elements of the lseqs, returning true if the predicate returns true on every application. If an application returns a false value, lseq-every immediately returns that value. Otherwise, it iterates until a false value is produced or one of the lseqs runs out of values; in the latter case, lseq-every returns the last value returned by pred, or #t if pred was never invoked. It is an error if pred does not accept the same number of arguments as there are lseqs and return a boolean result.</p>
<p>Like lseq-any, lseq-every’s name does not end with a question mark — this is to indicate that it does not return a simple boolean (#t or #f), but a general value.</p>
<div class="sourceCode" id="cb244"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a>    (lseq-every factorial &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))</span>
<span id="cb244-2"><a href="#cb244-2" aria-hidden="true" tabindex="-1"></a>            <span class="op">=&gt;</span> <span class="dv">24</span></span></code></pre></div>
<h2 id="lseq-index-pred-lseq1-lseq2-..."><code>(lseq-index pred lseq1 lseq2 ...)</code></h2>
<p>Return the index of the leftmost element that satisfies pred.</p>
<p>Applies pred to successive elements of the lseqs, returning an index usable with lseq-ref if the predicate returns true. Otherwise, it iterates until one of the lseqs runs out of values, in which case #f is returned.</p>
<p>It is an error if pred does not accept the same number of arguments as there are lseqs and return a boolean result.</p>
<p>The iteration stops when one of the lseqs runs out of values; in this case, lseq-index returns #f.</p>
<div class="sourceCode" id="cb245"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true" tabindex="-1"></a>(lseq-index <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> <span class="dv">2</span></span>
<span id="cb245-2"><a href="#cb245-2" aria-hidden="true" tabindex="-1"></a>(lseq-index <span class="op">&lt;</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) &#39;(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">1</span></span>
<span id="cb245-3"><a href="#cb245-3" aria-hidden="true" tabindex="-1"></a>(lseq-index <span class="op">=</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) &#39;(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="lseq-member-x-lseq-pred"><code>(lseq-member x lseq [ pred ])</code></h2>
<h2 id="lseq-memq-x-lseq"><code>(lseq-memq x lseq)</code></h2>
<h2 id="lseq-memv-x-lseq"><code>(lseq-memv x lseq)</code></h2>
<p>These procedures return the longest tail of lseq whose first element is x, where the tails of lseq are the non-empty lseqs returned by (lseq-drop lseq i) for i less than the length of lseq. If x does not occur in lseq, then #f is returned. lseq-memq uses eq? to compare x with the elements of lseq, while lseq-memv uses eqv?, and lseq-member uses pred, which defaults to equal?.</p>
<div class="sourceCode" id="cb246"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a>(lseq-memq &#39;a &#39;(a b c))           <span class="op">=&gt;</span>  (a b c)</span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true" tabindex="-1"></a>(lseq-memq &#39;b &#39;(a b c))           <span class="op">=&gt;</span>  (b c)</span>
<span id="cb246-3"><a href="#cb246-3" aria-hidden="true" tabindex="-1"></a>(lseq-memq &#39;a &#39;(b c d))           <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb246-4"><a href="#cb246-4" aria-hidden="true" tabindex="-1"></a>(lseq-memq (<span class="kw">list</span> &#39;a) &#39;(b (a) c)) <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb246-5"><a href="#cb246-5" aria-hidden="true" tabindex="-1"></a>(lseq-member (<span class="kw">list</span> &#39;a)</span>
<span id="cb246-6"><a href="#cb246-6" aria-hidden="true" tabindex="-1"></a>&#39;(b (a) c))           <span class="op">=&gt;</span>  ((a) c)</span>
<span id="cb246-7"><a href="#cb246-7" aria-hidden="true" tabindex="-1"></a>(lseq-memq <span class="dv">101</span> &#39;(<span class="dv">100</span> <span class="dv">101</span> <span class="dv">102</span>))    <span class="op">=&gt;</span>  *unspecified*</span>
<span id="cb246-8"><a href="#cb246-8" aria-hidden="true" tabindex="-1"></a>(lseq-memv <span class="dv">101</span> &#39;(<span class="dv">100</span> <span class="dv">101</span> <span class="dv">102</span>))    <span class="op">=&gt;</span>  (<span class="dv">101</span> <span class="dv">102</span>)</span></code></pre></div>
<p>The equality procedure is used to compare the elements ei of lseq to the key x in this way: the first argument is always x, and the second argument is one of the lseq elements. Thus one can reliably find the first element of lseq that is greater than five with (lseq-member 5 lseq &lt;)</p>
<p>Note that fully general lseq searching may be performed with the lseq-find-tail procedure, e.g.</p>
<div class="sourceCode" id="cb247"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true" tabindex="-1"></a>(lseq-find-tail <span class="kw">even?</span> lseq) <span class="co">; Find the first elt with an even key.</span></span></code></pre></div>
<h1 id="scheme-list-queue"><code>(scheme list-queue)</code></h1>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-117/">SRFI-117</a>.</p>
<p>List queues are mutable ordered collections that can contain any Scheme object. Each list queue is based on an ordinary Scheme list containing the elements of the list queue by maintaining pointers to the first and last pairs of the list. It’s cheap to add or remove elements from the front of the list or to add elements to the back, but not to remove elements from the back. List queues are disjoint from other types of Scheme objects.</p>
<h2 id="make-list-queue-list-last"><code>(make-list-queue list [ last ])</code></h2>
<p>Returns a newly allocated list queue containing the elements of list in order. The result shares storage with list. If the last argument is not provided, this operation is O(n) where n is the length of list.</p>
<p>However, if last is provided, make-list-queue returns a newly allocated list queue containing the elements of the list whose first pair is first and whose last pair is last. It is an error if the pairs do not belong to the same list. Alternatively, both first and last can be the empty list. In either case, the operation is O(1).</p>
<p>Note: To apply a non-destructive list procedure to a list queue and return a new list queue, use (make-list-queue (proc (list-queue-list list-queue))).</p>
<h2 id="list-queue-element-..."><code>(list-queue element ...)</code></h2>
<p>Returns a newly allocated list queue containing the elements. This operation is O(n) where n is the number of elements.</p>
<h2 id="list-queue-copy-list-queue"><code>(list-queue-copy list-queue)</code></h2>
<p>Returns a newly allocated list queue containing the elements of list-queue. This operation is O(n) where n is the length of list-queue</p>
<h2 id="list-queue-unfold-stop-mapper-successor-seed-queue"><code>(list-queue-unfold stop? mapper successor seed [ queue ])</code></h2>
<p>Performs the following algorithm:</p>
<p>If the result of applying the predicate stop? to seed is true, return queue. Otherwise, apply the procedure mapper to seed, returning a value which is added to the front of queue. Then get a new seed by applying the procedure successor to seed, and repeat this algorithm.</p>
<p>If queue is omitted, a newly allocated list queue is used.</p>
<h2 id="list-queue-unfold-right-stop-mapper-successor-seed-queue"><code>(list-queue-unfold-right stop? mapper successor seed [ queue ])</code></h2>
<p>Performs the following algorithm:</p>
<p>If the result of applying the predicate stop? to seed is true, return the list queue. Otherwise, apply the procedure mapper to seed, returning a value which is added to the back of the list queue. Then get a new seed by applying the procedure successor to seed, and repeat this algorithm.</p>
<p>If queue is omitted, a newly allocated list queue is used.</p>
<h2 id="list-queue-obj"><code>(list-queue? obj)</code></h2>
<p>Returns #t if obj is a list queue, and #f otherwise. This operation is O(1).</p>
<h2 id="list-queue-empty-list-queue"><code>(list-queue-empty? list-queue)</code></h2>
<p>Returns #t if list-queue has no elements, and #f otherwise. This operation is O(1).</p>
<h2 id="list-queue-front-list-queue"><code>(list-queue-front list-queue)</code></h2>
<p>Returns the first element of list-queue. If the list queue is empty, it is an error. This operation is O(1).</p>
<h2 id="list-queue-back-list-queue"><code>(list-queue-back list-queue)</code></h2>
<p>Returns the last element of list-queue. If the list queue is empty, it is an error. This operation is O(1).</p>
<h2 id="list-queue-list-list-queue"><code>(list-queue-list list-queue)</code></h2>
<p>Returns the list that contains the members of list-queue in order. The result shares storage with list-queue. This operation is O(1).</p>
<h2 id="list-queue-first-last-list-queue"><code>(list-queue-first-last list-queue)</code></h2>
<p>Returns two values, the first and last pairs of the list that contains the members of list-queue in order. If list-queue is empty, returns two empty lists. The results share storage with list-queue. This operation is O(1).</p>
<h2 id="list-queue-add-front-list-queue-element"><code>(list-queue-add-front! list-queue element)</code></h2>
<p>Adds element to the beginning of list-queue. Returns an unspecified value. This operation is O(1).</p>
<h2 id="list-queue-add-back-list-queue-element"><code>(list-queue-add-back! list-queue element)</code></h2>
<p>Adds element to the end of list-queue. Returns an unspecified value. This operation is O(1).</p>
<h2 id="list-queue-remove-front-list-queue"><code>(list-queue-remove-front! list-queue)</code></h2>
<p>Removes the first element of list-queue and returns it. If the list queue is empty, it is an error. This operation is O(1).</p>
<h2 id="list-queue-remove-back-list-queue"><code>(list-queue-remove-back! list-queue)</code></h2>
<p>Removes the last element of list-queue and returns it. If the list queue is empty, it is an error. This operation is O(n) where n is the length of list-queue, because queues do not not have backward links.</p>
<h2 id="list-queue-remove-all-list-queue"><code>(list-queue-remove-all! list-queue)</code></h2>
<p>Removes all the elements of list-queue and returns them in order as a list. This operation is O(1).</p>
<h2 id="list-queue-set-list-list-queue-list-last"><code>(list-queue-set-list! list-queue list [ last ])</code></h2>
<p>Replaces the list associated with list-queue with list, effectively discarding all the elements of list-queue in favor of those in list. Returns an unspecified value. This operation is O(n) where n is the length of list. If last is provided, it is treated in the same way as in make-list-queue, and the operation is O(1).</p>
<p>Note: To apply a destructive list procedure to a list queue, use (list-queue-set-list! (proc (list-queue-list list-queue))).</p>
<h2 id="list-queue-append-list-queue-..."><code>(list-queue-append list-queue ...)</code></h2>
<p>Returns a list queue which contains all the elements in front-to-back order from all the list-queues in front-to-back order. The result does not share storage with any of the arguments. This operation is O(n) in the total number of elements in all queues.</p>
<h2 id="list-queue-append-list-queue-...-1"><code>(list-queue-append! list-queue ...)</code></h2>
<p>Returns a list queue which contains all the elements in front-to-back order from all the list-queues in front-to-back order. It is an error to assume anything about the contents of the list-queues after the procedure returns. This operation is O(n) in the total number of queues, not elements. It is not part of the R7RS-small list API, but is included here for efficiency when pure functional append is not required.</p>
<h2 id="list-queue-concatenate-list-of-list-queues"><code>(list-queue-concatenate list-of-list-queues)</code></h2>
<p>Returns a list queue which contains all the elements in front-to-back order from all the list queues which are members of list-of-list-queues in front-to-back order. The result does not share storage with any of the arguments. This operation is O(n) in the total number of elements in all queues. It is not part of the R7RS-small list API, but is included here to make appending a large number of queues possible in Schemes that limit the number of arguments to apply.</p>
<h2 id="list-queue-map-proc-list-queue"><code>(list-queue-map proc list-queue)</code></h2>
<p>Applies proc to each element of list-queue in unspecified order and returns a newly allocated list queue containing the results. This operation is O(n) where n is the length of list-queue.</p>
<h2 id="list-queue-map-proc-list-queue-1"><code>(list-queue-map! proc list-queue)</code></h2>
<p>Applies proc to each element of list-queue in front-to-back order and modifies list-queue to contain the results. This operation is O(n) in the length of list-queue. It is not part of the R7RS-small list API, but is included here to make transformation of a list queue by mutation more efficient.</p>
<h2 id="list-queue-for-each-proc-list-queue"><code>(list-queue-for-each proc list-queue)</code></h2>
<p>Applies proc to each element of list-queue in front-to-back order, discarding the returned values. Returns an unspecified value. This operation is O(n) where n is the length of list-queue. # <code>(scheme list)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-1/">SRFI-1</a>.</p>
<h2 id="cons-a-d"><code>(cons a d)</code></h2>
<p>The primitive constructor. Returns a newly allocated pair whose <code>car</code> is <code>a</code> and whose <code>cdr</code> is <code>d</code>. The pair is guaranteed to be different (in the sense of <code>eqv?</code>) from every existing object.</p>
<h2 id="list-object-..."><code>(list object ...)</code></h2>
<p>Returns a newly allocated list of its arguments.</p>
<h2 id="xcons-d-a"><code>(xcons d a)</code></h2>
<div class="sourceCode" id="cb248"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> (d a) (<span class="kw">cons</span> a d))</span></code></pre></div>
<p>Of utility only as a value to be conveniently passed to higher-order procedures.</p>
<div class="sourceCode" id="cb249"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb249-1"><a href="#cb249-1" aria-hidden="true" tabindex="-1"></a>(xcons &#39;(b c) &#39;a) <span class="co">;; =&gt; (a b c)</span></span></code></pre></div>
<p>The name stands for “eXchanged CONS.”</p>
<h2 id="cons-obj-...-tail"><code>(cons* obj ... tail)</code></h2>
<p>Like list, but the last argument provides the tail of the constructed list.</p>
<h2 id="make-list-n-fill"><code>(make-list n [fill])</code></h2>
<p>Returns an n-element list, whose elements are all the value fill. If the fill argument is not given, the elements of the list may be arbitrary values.</p>
<div class="sourceCode" id="cb250"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a>(make-list <span class="dv">4</span> &#39;c) <span class="op">=&gt;</span> (c c c c)</span></code></pre></div>
<h2 id="list-tabulate-n-init-proc"><code>(list-tabulate n init-proc)</code></h2>
<p>Returns an n-element list. Element i of the list, where 0 &lt;= i &lt; n, is produced by (init-proc i). No guarantee is made about the dynamic order in which init-proc is applied to these indices.</p>
<div class="sourceCode" id="cb251"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a>(list-tabulate <span class="dv">4</span> <span class="kw">values</span>) <span class="op">=&gt;</span> (<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</span></code></pre></div>
<h2 id="list-copy-flist"><code>(list-copy flist)</code></h2>
<p>Copies the spine of the argument.</p>
<h2 id="circular-list-elt1-elt2-..."><code>(circular-list elt1 elt2 ...)</code></h2>
<p>Constructs a circular list of the elements.</p>
<div class="sourceCode" id="cb252"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true" tabindex="-1"></a>(circular-list &#39;z &#39;q) <span class="op">=&gt;</span> (z q z q z q <span class="op">...</span>)</span></code></pre></div>
<h2 id="iota-count-start-step"><code>(iota count [start step])</code></h2>
<p>Returns a list containing the elements:</p>
<div class="sourceCode" id="cb253"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true" tabindex="-1"></a>(start start+step <span class="op">...</span> start+(count-1)*step)</span></code></pre></div>
<p>The start and step parameters default to 0 and 1, respectively.</p>
<div class="sourceCode" id="cb254"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true" tabindex="-1"></a>(iota <span class="dv">5</span>) <span class="op">=&gt;</span> (<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)</span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true" tabindex="-1"></a>(iota <span class="dv">5</span> <span class="dv">0</span> -<span class="fl">0.1</span>) <span class="op">=&gt;</span> (<span class="dv">0</span> -<span class="fl">0.1</span> -<span class="fl">0.2</span> -<span class="fl">0.3</span> -<span class="fl">0.4</span>)</span></code></pre></div>
<h2 id="proper-list-x"><code>(proper-list? x)</code></h2>
<p>Returns true iff x is a proper list – a finite, nil-terminated list.</p>
<p>More carefully: The empty list is a proper list. A pair whose cdr is a proper list is also a proper list. The opposite of proper is improper.</p>
<h2 id="circular-list-x"><code>(circular-list? x)</code></h2>
<p>True if x is a circular list. A circular list is a value such that for every n &gt;= 0, cdrn(x) is a pair.</p>
<p>Terminology: The opposite of circular is finite.</p>
<h2 id="dotted-list-x"><code>(dotted-list? x)</code></h2>
<p>True if x is a finite, non-nil-terminated list. That is, there exists an n &gt;= 0 such that cdrn(x) is neither a pair nor (). This includes non-pair, non-() values (e.g. symbols, numbers), which are considered to be dotted lists of length 0.</p>
<h2 id="pair-obj-1"><code>(pair? obj)</code></h2>
<p>Returns #t if object is a pair; otherwise, #f.</p>
<h2 id="null-obj-1"><code>(null? obj)</code></h2>
<p>Returns #t if object is the empty list; otherwise, #f.</p>
<h2 id="null-list-list"><code>(null-list? list)</code></h2>
<p>List is a proper or circular list. This procedure returns true if the argument is the empty list (), and false otherwise. It is an error to pass this procedure a value which is not a proper or circular list. This procedure is recommended as the termination condition for list-processing procedures that are not defined on dotted lists.</p>
<h2 id="not-pair-x"><code>(not-pair? x)</code></h2>
<p>Provided as a procedure as it can be useful as the termination condition for list-processing procedures that wish to handle all finite lists, both proper and dotted.</p>
<h2 id="list-elt-list1-..."><code>(list= elt= list1 ...)</code></h2>
<p>Determines list equality, given an element-equality procedure.</p>
<h2 id="car-pair-1"><code>(car pair)</code></h2>
<h2 id="cdr-pair"><code>(cdr pair)</code></h2>
<p>These functions return the contents of the car and cdr field of their argument, respectively. Note that it is an error to apply them to the empty list.</p>
<p>Also the following selectors are defined:</p>
<ul>
<li><code>caar</code></li>
<li><code>cadr</code></li>
<li><code>cdar</code></li>
<li><code>cddr</code></li>
<li><code>caaar</code></li>
<li><code>caadr</code></li>
<li><code>cadar</code></li>
<li><code>caddr</code></li>
<li><code>cdaar</code></li>
<li><code>cdadr</code></li>
<li><code>cddar</code></li>
<li><code>cdddr</code></li>
<li><code>caaaar</code></li>
<li><code>caaadr</code></li>
<li><code>caadar</code></li>
<li><code>caaddr</code></li>
<li><code>cadaar</code></li>
<li><code>cadadr</code></li>
<li><code>caddar</code></li>
<li><code>cadddr</code></li>
<li><code>cdaaar</code></li>
<li><code>cdaadr</code></li>
<li><code>cdadar</code></li>
<li><code>cdaddr</code></li>
<li><code>cddaar</code></li>
<li><code>cddadr</code></li>
<li><code>cdddar</code></li>
<li><code>cddddr</code></li>
</ul>
<h2 id="list-ref-clist-i"><code>(list-ref clist i)</code></h2>
<p>Returns the ith element of clist. (This is the same as the car of (drop clist i).) It is an error if i &gt;= n, where n is the length of clist.</p>
<div class="sourceCode" id="cb255"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">list-ref</span> &#39;(a b c d) <span class="dv">2</span>) <span class="op">=&gt;</span> c</span></code></pre></div>
<h2 id="first-pair"><code>(first pair)</code></h2>
<h2 id="second-pair"><code>(second pair)</code></h2>
<h2 id="third-pair"><code>(third pair)</code></h2>
<h2 id="fourth-pair"><code>(fourth pair)</code></h2>
<h2 id="fifth-pair"><code>(fifth pair)</code></h2>
<h2 id="sixth-pair"><code>(sixth pair)</code></h2>
<h2 id="seventh-pair"><code>(seventh pair)</code></h2>
<h2 id="eighth-pair"><code>(eighth pair)</code></h2>
<h2 id="ninth-pair"><code>(ninth pair)</code></h2>
<h2 id="tenth-pair"><code>(tenth pair)</code></h2>
<p>Synonyms for <code>car</code>, <code>cadr</code>, <code>caddr</code>, …</p>
<h2 id="carcdr-pair"><code>(car+cdr pair)</code></h2>
<p>The fundamental pair deconstructor:</p>
<pre><code>(lambda (p) (values (car p) (cdr p)))</code></pre>
<p>This can, of course, be implemented more efficiently by a compiler.</p>
<h2 id="take-lst-i"><code>(take lst i)</code></h2>
<h2 id="drop-lst-i"><code>(drop lst i)</code></h2>
<p><code>take</code> returns the first <code>I</code> elements of list <code>LST</code>. <code>drop</code> returns all but the first i elements of list <code>LST</code>.</p>
<div class="sourceCode" id="cb257"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true" tabindex="-1"></a>(take &#39;(a b c d e) <span class="dv">2</span>) <span class="co">;; =&gt; (a b)</span></span>
<span id="cb257-2"><a href="#cb257-2" aria-hidden="true" tabindex="-1"></a>(drop &#39;(a b c d e) <span class="dv">2</span>) <span class="co">;; =&gt; (c d e)</span></span></code></pre></div>
<p><code>LST</code> may be any value – a proper, circular, or dotted list:</p>
<div class="sourceCode" id="cb258"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a>(take &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="op">.</span> d) <span class="dv">2</span>) <span class="co">;; =&gt; (1 2)</span></span>
<span id="cb258-2"><a href="#cb258-2" aria-hidden="true" tabindex="-1"></a>(drop &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="op">.</span> d) <span class="dv">2</span>) <span class="co">;; =&gt; (3 . d)</span></span>
<span id="cb258-3"><a href="#cb258-3" aria-hidden="true" tabindex="-1"></a>(take &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="op">.</span> d) <span class="dv">3</span>) <span class="co">;; =&gt; (1 2 3)</span></span>
<span id="cb258-4"><a href="#cb258-4" aria-hidden="true" tabindex="-1"></a>(drop &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="op">.</span> d) <span class="dv">3</span>) <span class="co">;; =&gt; d</span></span></code></pre></div>
<p>For a legal <code>I</code>, <code>take</code> and <code>drop</code> partition the list in a manner which can be inverted with append:</p>
<div class="sourceCode" id="cb259"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">equal?</span> (<span class="kw">append</span> (take lst i) (drop x i)) lst)</span></code></pre></div>
<p><code>drop</code> is exactly equivalent to performing <code>i</code> <code>cdr</code> operations on <code>LST</code>; the returned value shares a common tail with <code>LST</code>. If the argument is a list of non-zero length, <code>take</code> is guaranteed to return a freshly-allocated list, even in the case where the entire list is taken, e.g. <code>(take lst (length lst))</code>.</p>
<h2 id="take-right-flist-i"><code>(take-right flist i)</code></h2>
<h2 id="drop-right-flist-i"><code>(drop-right flist i)</code></h2>
<p><code>take-right</code> returns the last <code>I</code> elements of <code>FLIST</code>. <code>drop-right</code> returns all but the last <code>I</code> elements of <code>FLIST</code>.</p>
<div class="sourceCode" id="cb260"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a>(take-right &#39;(a b c d e) <span class="dv">2</span>) <span class="op">=&gt;</span> (d e)</span>
<span id="cb260-2"><a href="#cb260-2" aria-hidden="true" tabindex="-1"></a>(drop-right &#39;(a b c d e) <span class="dv">2</span>) <span class="op">=&gt;</span> (a b c)</span></code></pre></div>
<p>The returned list may share a common tail with the argument list.</p>
<p><code>FLIST</code> may be any finite list, either proper or dotted:</p>
<div class="sourceCode" id="cb261"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb261-1"><a href="#cb261-1" aria-hidden="true" tabindex="-1"></a>(take-right &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="op">.</span> d) <span class="dv">2</span>) <span class="op">=&gt;</span> (<span class="dv">2</span> <span class="dv">3</span> <span class="op">.</span> d)</span>
<span id="cb261-2"><a href="#cb261-2" aria-hidden="true" tabindex="-1"></a>(drop-right &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="op">.</span> d) <span class="dv">2</span>) <span class="op">=&gt;</span> (<span class="dv">1</span>)</span>
<span id="cb261-3"><a href="#cb261-3" aria-hidden="true" tabindex="-1"></a>(take-right &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="op">.</span> d) <span class="dv">0</span>) <span class="op">=&gt;</span> d</span>
<span id="cb261-4"><a href="#cb261-4" aria-hidden="true" tabindex="-1"></a>(drop-right &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="op">.</span> d) <span class="dv">0</span>) <span class="op">=&gt;</span> (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</span></code></pre></div>
<p>For a legal <code>I</code>, <code>take-right</code> and <code>drop-right</code> partition the list in a manner which can be inverted with <code>append</code>:</p>
<div class="sourceCode" id="cb262"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">equal?</span> (<span class="kw">append</span> (take flist i) (drop flist i)) flist)</span></code></pre></div>
<p><code>take-right</code>’s return value is guaranteed to share a common tail with <code>FLIST</code>. If the argument is a list of non-zero length, <code>drop-right</code> is guaranteed to return a freshly-allocated list, even in the case where nothing is dropped, e.g. <code>(drop-right flist 0)</code>.</p>
<h2 id="take-x-i"><code>(take! x i)</code></h2>
<h2 id="drop-right-flist-i-1"><code>(drop-right! flist i)</code></h2>
<p><code>take!</code> and <code>drop-right!</code> are “linear-update” variants of <code>take</code> and <code>drop-right</code>: the procedure is allowed, but not required, to alter the argument list to produce the result.</p>
<p>If <code>x</code> is circular, <code>take!</code> may return a shorter-than-expected list:</p>
<div class="sourceCode" id="cb263"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true" tabindex="-1"></a>(take! (circular-list <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span>) <span class="dv">8</span>) <span class="op">=&gt;</span> (<span class="dv">1</span> <span class="dv">3</span>)</span>
<span id="cb263-2"><a href="#cb263-2" aria-hidden="true" tabindex="-1"></a>(take! (circular-list <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span>) <span class="dv">8</span>) <span class="op">=&gt;</span> (<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">1</span> <span class="dv">3</span>)</span></code></pre></div>
<h2 id="split-at-x-i"><code>(split-at  x i)</code></h2>
<h2 id="split-at-x-i-1"><code>(split-at! x i)</code></h2>
<p><code>split-at</code> splits the list <code>x</code> at index <code>i</code>, returning a list of the first <code>i</code> elements, and the remaining tail. It is equivalent to:</p>
<div class="sourceCode" id="cb264"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">values</span> (take x i) (drop x i))</span></code></pre></div>
<p><code>split-at!</code> is the linear-update variant. It is allowed, but not required, to alter the argument list to produce the result.</p>
<div class="sourceCode" id="cb265"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb265-1"><a href="#cb265-1" aria-hidden="true" tabindex="-1"></a>(split-at &#39;(a b c d e f g h) <span class="dv">3</span>) <span class="co">;; =&gt; (a b c) and (d e f g h)</span></span></code></pre></div>
<h2 id="last-pair"><code>(last pair)</code></h2>
<h2 id="last-pair-pair"><code>(last-pair pair)</code></h2>
<p><code>last</code> returns the last element of the non-empty, finite list <code>pair</code>. <code>last-pair</code> returns the last pair in the non-empty, finite list <code>pair</code>:</p>
<div class="sourceCode" id="cb266"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb266-1"><a href="#cb266-1" aria-hidden="true" tabindex="-1"></a>(last &#39;(a b c)) <span class="co">;; =&gt; c</span></span>
<span id="cb266-2"><a href="#cb266-2" aria-hidden="true" tabindex="-1"></a>(last-pair &#39;(a b c)) <span class="co">;; =&gt; (c)</span></span></code></pre></div>
<h2 id="length-list-1"><code>(length list)</code></h2>
<h2 id="length-clist"><code>(length+ clist)</code></h2>
<p>Both <code>length</code> and <code>length+</code> return the length of the argument. It is an error to pass a value to length which is not a proper list (finite and nil-terminated). In particular, this means an implementation may diverge or signal an error when length is applied to a circular list.</p>
<p><code>length+</code>, on the other hand, returns <code>#f</code> when applied to a circular list.</p>
<p>The length of a proper list is a non-negative integer <code>n</code> such that <code>cdr</code> applied <code>n</code> times to the list produces the empty list.</p>
<h2 id="append-list1-..."><code>(append  list1 ...)</code></h2>
<h2 id="append-list1-...-1"><code>(append! list1 ...)</code></h2>
<p><code>append</code> returns a list consisting of the elements of <code>list1</code> followed by the elements of the other list parameters.</p>
<div class="sourceCode" id="cb267"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">append</span> &#39;(x) &#39;(y))        <span class="op">=&gt;</span>  (x y)</span>
<span id="cb267-2"><a href="#cb267-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">append</span> &#39;(a) &#39;(b c d))    <span class="op">=&gt;</span>  (a b c d)</span>
<span id="cb267-3"><a href="#cb267-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">append</span> &#39;(a (b)) &#39;((c)))  <span class="op">=&gt;</span>  (a (b) (c))</span></code></pre></div>
<p>The resulting list is always newly allocated, except that it shares structure with the final list argument. This last argument may be any value at all; an improper list results if it is not a proper list. All other arguments must be proper lists.</p>
<div class="sourceCode" id="cb268"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb268-1"><a href="#cb268-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">append</span> &#39;(a b) &#39;(c <span class="op">.</span> d))  <span class="op">=&gt;</span>  (a b c <span class="op">.</span> d)</span>
<span id="cb268-2"><a href="#cb268-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">append</span> &#39;() &#39;a)           <span class="op">=&gt;</span>  a</span>
<span id="cb268-3"><a href="#cb268-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">append</span> &#39;(x y))           <span class="op">=&gt;</span>  (x y)</span>
<span id="cb268-4"><a href="#cb268-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">append</span>)                  <span class="op">=&gt;</span>  ()</span></code></pre></div>
<p><code>append!</code> is the “linear-update” variant of append – it is allowed, but not required, to alter <code>cons</code> cells in the argument lists to construct the result list. The last argument is never altered; the result list shares structure with this parameter.</p>
<h2 id="concatenate-list-of-lists"><code>(concatenate  list-of-lists)</code></h2>
<h2 id="concatenate-list-of-lists-1"><code>(concatenate! list-of-lists)</code></h2>
<p>These functions append the elements of their argument together. That is, <code>concatenate</code> returns:</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb269-1"><a href="#cb269-1" aria-hidden="true" tabindex="-1"></a>(apply <span class="kw">append</span> list-of-lists)</span></code></pre></div>
<p>Or, equivalently,</p>
<div class="sourceCode" id="cb270"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true" tabindex="-1"></a>(reduce-right <span class="kw">append</span> &#39;() list-of-lists)</span></code></pre></div>
<p><code>concatenate!</code> is the linear-update variant, defined in terms of <code>append!</code> instead of <code>append</code>.</p>
<p>As with <code>append</code> and <code>append!</code>, the last element of the input list may be any value at all.</p>
<h2 id="reverse-list-1"><code>(reverse list)</code></h2>
<h2 id="reverse-list-2"><code>(reverse! list)</code></h2>
<p><code>reverse</code> returns a newly allocated list consisting of the elements of list in reverse order.</p>
<div class="sourceCode" id="cb271"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb271-1"><a href="#cb271-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">reverse</span> &#39;(a b c)) <span class="co">;; =&gt;  (c b a)</span></span>
<span id="cb271-2"><a href="#cb271-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">reverse</span> &#39;(a (b c) d (e (f)))) <span class="co">;; =&gt;  ((e (f)) d (b c) a)</span></span></code></pre></div>
<p><code>reverse!</code> is the linear-update variant of reverse. It is permitted, but not required, to alter the argument’s <code>cons</code> cells to produce the reversed list.</p>
<h2 id="append-reverse-rev-head-tail"><code>(append-reverse rev-head tail)</code></h2>
<h2 id="append-reverse-rev-head-tail-1"><code>(append-reverse! rev-head tail)</code></h2>
<p><code>append-reverse</code> returns <code>(append (reverse rev-head) tail)</code>. It is provided because it is a common operation – a common list-processing style calls for this exact operation to transfer values accumulated in reverse order onto the front of another list, and because the implementation is significantly more efficient than the simple composition it replaces. (But note that this pattern of iterative computation followed by a <code>reverse</code> can frequently be rewritten as a recursion, dispensing with the <code>reverse</code> and <code>append-reverse</code> steps, and shifting temporary, intermediate storage from the heap to the stack, which is typically a win for reasons of cache locality and eager storage reclamation.)</p>
<p><code>append-reverse!</code> is just the linear-update variant – it is allowed, but not required, to alter rev-head’s <code>cons</code> cells to construct the result.</p>
<h2 id="zip-clist1-clist2-..."><code>(zip clist1 clist2 ...)</code></h2>
<div class="sourceCode" id="cb272"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb272-1"><a href="#cb272-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> lists (apply map <span class="kw">list</span> lists))</span></code></pre></div>
<p>If <code>zip</code> is passed n lists, it returns a list as long as the shortest of these lists, each element of which is an n-element list comprised of the corresponding elements from the parameter lists.</p>
<div class="sourceCode" id="cb273"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true" tabindex="-1"></a>(zip &#39;(one two three)</span>
<span id="cb273-2"><a href="#cb273-2" aria-hidden="true" tabindex="-1"></a>     &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</span>
<span id="cb273-3"><a href="#cb273-3" aria-hidden="true" tabindex="-1"></a>     &#39;(odd even odd even odd even odd even))</span>
<span id="cb273-4"><a href="#cb273-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">;; =&gt; ((one 1 odd) (two 2 even) (three 3 odd))</span></span>
<span id="cb273-5"><a href="#cb273-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-6"><a href="#cb273-6" aria-hidden="true" tabindex="-1"></a>(zip &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)) <span class="op">=&gt;</span> ((<span class="dv">1</span>) (<span class="dv">2</span>) (<span class="dv">3</span>))</span></code></pre></div>
<h2 id="unzip1-list"><code>(unzip1 list)</code></h2>
<h2 id="unzip2-list"><code>(unzip2 list)</code></h2>
<h2 id="unzip3-list"><code>(unzip3 list)</code></h2>
<h2 id="unzip4-list"><code>(unzip4 list)</code></h2>
<h2 id="unzip5-list"><code>(unzip5 list)</code></h2>
<p><code>unzip1</code> takes a list of lists, where every list must contain at least one element, and returns a list containing the initial element of each such list. That is, it returns <code>(map car lists)</code>. <code>unzip2</code> takes a list of lists, where every list must contain at least two elements, and returns two values: a list of the first elements, and a list of the second elements. <code>unzip3</code> does the same for the first three elements of the lists, and so forth.</p>
<div class="sourceCode" id="cb274"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb274-1"><a href="#cb274-1" aria-hidden="true" tabindex="-1"></a>(unzip2 &#39;((<span class="dv">1</span> one) (<span class="dv">2</span> two) (<span class="dv">3</span> three))) <span class="co">;; =&gt; &#39;((1 2 3) (one two three))</span></span></code></pre></div>
<h2 id="count-pred-clist1-..."><code>(count pred clist1 ...)</code></h2>
<p><code>pred</code> is a procedure taking as many arguments as there are lists and returning a single value. It is applied element-wise to the elements of the lists, and a count is tallied of the number of elements that produce a true value. This count is returned. <code>count</code> is “iterative” in that it is guaranteed to apply <code>pred</code> to the list elements in a left-to-right order. The counting stops when the shortest list expires.</p>
<div class="sourceCode" id="cb275"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb275-1"><a href="#cb275-1" aria-hidden="true" tabindex="-1"></a>(count <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>)) <span class="op">=&gt;</span> <span class="dv">3</span></span>
<span id="cb275-2"><a href="#cb275-2" aria-hidden="true" tabindex="-1"></a>(count <span class="op">&lt;</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span> <span class="dv">8</span>) &#39;(<span class="dv">2</span> <span class="dv">4</span> <span class="dv">6</span> <span class="dv">8</span> <span class="dv">10</span> <span class="dv">12</span> <span class="dv">14</span> <span class="dv">16</span>)) <span class="op">=&gt;</span> <span class="dv">3</span></span></code></pre></div>
<p>At least one of the argument lists must be finite:</p>
<pre><code>(count &lt; &#39;(3 1 4 1) (circular-list 1 10)) =&gt; 2</code></pre>
<h2 id="fold-kons-knil-list1-..."><code>(fold kons knil list1 ...)</code></h2>
<p>TODO</p>
<h2 id="fold-right-kons-knil-list1-..."><code>(fold-right kons knil list1 ...)</code></h2>
<p>TODO</p>
<h2 id="pair-fold-kons-knil-list1-..."><code>(pair-fold kons knil list1 ...)</code></h2>
<p>TODO</p>
<h2 id="pair-fold-right-kons-knil-list1-..."><code>(pair-fold-right kons knil list1 ...)</code></h2>
<p>TODO</p>
<h2 id="reduce-f-ridentity-list"><code>(reduce f ridentity list)</code></h2>
<p><code>reduce</code> is a variant of <code>fold</code>.</p>
<p><code>ridentity</code> should be a “right identity” of the procedure <code>f</code> – that is, for any value <code>x</code> acceptable to <code>f</code>:</p>
<div class="sourceCode" id="cb277"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb277-1"><a href="#cb277-1" aria-hidden="true" tabindex="-1"></a>(f x ridentity) <span class="co">;; =&gt; x</span></span></code></pre></div>
<p>Note: that <code>ridentity</code> is used only in the empty-list case. You typically use reduce when applying <code>f</code> is expensive and you’d like to avoid the extra application incurred when fold applies <code>f</code> to the head of list and the identity value, redundantly producing the same value passed in to <code>f</code>. For example, if <code>f</code> involves searching a file directory or performing a database query, this can be significant. In general, however, <code>fold</code> is useful in many contexts where <code>reduce</code> is not (consider the examples given in the <code>fold</code> definition – only one of the five folds uses a function with a right identity. The other four may not be performed with reduce).</p>
<h2 id="reducse-right-f-ridentity-list"><code>(reducse-right f ridentity list)</code></h2>
<p><code>reduce-right</code> is the <code>fold-right</code> variant of reduce. It obeys the following definition:</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb278-1"><a href="#cb278-1" aria-hidden="true" tabindex="-1"></a>(reduce-right f ridentity &#39;()) <span class="op">=</span> ridentity</span>
<span id="cb278-2"><a href="#cb278-2" aria-hidden="true" tabindex="-1"></a>(reduce-right f ridentity &#39;(e1)) <span class="op">=</span> (f e1 ridentity) <span class="op">=</span> e1</span>
<span id="cb278-3"><a href="#cb278-3" aria-hidden="true" tabindex="-1"></a>(reduce-right f ridentity &#39;(e1 e2 <span class="op">...</span>)) <span class="op">=</span></span>
<span id="cb278-4"><a href="#cb278-4" aria-hidden="true" tabindex="-1"></a>    (f e1 (reduce f ridentity (e2 <span class="op">...</span>)))</span></code></pre></div>
<p>… in other words, we compute <code>(fold-right f ridentity list)</code>.</p>
<div class="sourceCode" id="cb279"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb279-1"><a href="#cb279-1" aria-hidden="true" tabindex="-1"></a><span class="co">;; Append a bunch of lists together.</span></span>
<span id="cb279-2"><a href="#cb279-2" aria-hidden="true" tabindex="-1"></a><span class="co">;; I.e., (apply append list-of-lists)</span></span>
<span id="cb279-3"><a href="#cb279-3" aria-hidden="true" tabindex="-1"></a>(reduce-right <span class="kw">append</span> &#39;() list-of-lists)</span></code></pre></div>
<h2 id="unfold-p-f-g-seed-tail-gen"><code>(unfold p f g seed [tail-gen])</code></h2>
<p>TODO</p>
<h2 id="unfold-right-p-f-g-seed-tail-gen"><code>(unfold-right p f g seed [tail-gen])</code></h2>
<p>TODO</p>
<h2 id="map-proc-list1-...-1"><code>(map proc list1 ...)</code></h2>
<p><code>proc</code> is a procedure taking as many arguments as there are list arguments and returning a single value. map applies <code>proc</code> element-wise to the elements of the lists and returns a list of the results, in order. The dynamic order in which proc is applied to the elements of the lists is unspecified.</p>
<div class="sourceCode" id="cb280"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb280-1"><a href="#cb280-1" aria-hidden="true" tabindex="-1"></a>(map <span class="kw">cadr</span> &#39;((a b) (d e) (g h))) <span class="op">=&gt;</span>  (b e h)</span>
<span id="cb280-2"><a href="#cb280-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb280-3"><a href="#cb280-3" aria-hidden="true" tabindex="-1"></a>(map (<span class="kw">lambda</span> (n) (<span class="kw">expt</span> n n))</span>
<span id="cb280-4"><a href="#cb280-4" aria-hidden="true" tabindex="-1"></a>     &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>))</span>
<span id="cb280-5"><a href="#cb280-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">=&gt;</span>  (<span class="dv">1</span> <span class="dv">4</span> <span class="dv">27</span> <span class="dv">256</span> <span class="dv">3125</span>)</span>
<span id="cb280-6"><a href="#cb280-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb280-7"><a href="#cb280-7" aria-hidden="true" tabindex="-1"></a>(map <span class="op">+</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) &#39;(<span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>)) <span class="op">=&gt;</span>  (<span class="dv">5</span> <span class="dv">7</span> <span class="dv">9</span>)</span>
<span id="cb280-8"><a href="#cb280-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb280-9"><a href="#cb280-9" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> ((count <span class="dv">0</span>))</span>
<span id="cb280-10"><a href="#cb280-10" aria-hidden="true" tabindex="-1"></a>  (map (<span class="kw">lambda</span> (ignored)</span>
<span id="cb280-11"><a href="#cb280-11" aria-hidden="true" tabindex="-1"></a>         (<span class="kw">set!</span> count (<span class="op">+</span> count <span class="dv">1</span>))</span>
<span id="cb280-12"><a href="#cb280-12" aria-hidden="true" tabindex="-1"></a>         count)</span>
<span id="cb280-13"><a href="#cb280-13" aria-hidden="true" tabindex="-1"></a>       &#39;(a b))) <span class="op">=&gt;</span>  (<span class="dv">1</span> <span class="dv">2</span>) <span class="kw">or</span> (<span class="dv">2</span> <span class="dv">1</span>)</span></code></pre></div>
<p>At least one of the argument lists must be finite:</p>
<div class="sourceCode" id="cb281"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb281-1"><a href="#cb281-1" aria-hidden="true" tabindex="-1"></a>(map <span class="op">+</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span>) (circular-list <span class="dv">1</span> <span class="dv">0</span>)) <span class="co">;; =&gt; (4 1 5 1)</span></span></code></pre></div>
<h2 id="for-each-proc-clist1-..."><code>(for-each proc clist1 ...)</code></h2>
<p>The arguments to <code>for-each</code> are like the arguments to <code>map</code>, but <code>for-each</code> calls <code>proc</code> for its side effects rather than for its values. Unlike <code>map</code>, <code>for-each</code> is guaranteed to call <code>proc</code> on the elements of the lists in order from the first element(s) to the last, and the value returned by for-each is unspecified.</p>
<div class="sourceCode" id="cb282"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb282-1"><a href="#cb282-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> ((v (<span class="kw">make-vector</span> <span class="dv">5</span>)))</span>
<span id="cb282-2"><a href="#cb282-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">for-each</span> (<span class="kw">lambda</span> (i)</span>
<span id="cb282-3"><a href="#cb282-3" aria-hidden="true" tabindex="-1"></a>              (<span class="kw">vector-set!</span> v i (<span class="op">*</span> i i)))</span>
<span id="cb282-4"><a href="#cb282-4" aria-hidden="true" tabindex="-1"></a>            &#39;(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))</span>
<span id="cb282-5"><a href="#cb282-5" aria-hidden="true" tabindex="-1"></a>  v)  <span class="op">=&gt;</span>  #(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">9</span> <span class="dv">16</span>)</span></code></pre></div>
<p>At least one of the argument lists must be finite.</p>
<h2 id="append-map-f-list-..."><code>(append-map f list ...)</code></h2>
<h2 id="append-map-f-list-...-1"><code>(append-map! f list ...)</code></h2>
<p>Equivalent to:</p>
<div class="sourceCode" id="cb283"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb283-1"><a href="#cb283-1" aria-hidden="true" tabindex="-1"></a>(apply <span class="kw">append</span> (map f clist1 clist2 <span class="op">...</span>))</span></code></pre></div>
<p>And:</p>
<div class="sourceCode" id="cb284"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb284-1"><a href="#cb284-1" aria-hidden="true" tabindex="-1"></a>(apply append! (map f clist1 clist2 <span class="op">...</span>))</span></code></pre></div>
<p>Map <code>f</code> over the elements of the lists, just as in the <code>map</code> function. However, the results of the applications are appended together to make the final result. <code>append-map</code> uses <code>append</code> to append the results together; <code>append-map!</code> uses <code>append!</code>.</p>
<p>The dynamic order in which the various applications of <code>f</code> are made is not specified.</p>
<p>Example:</p>
<div class="sourceCode" id="cb285"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb285-1"><a href="#cb285-1" aria-hidden="true" tabindex="-1"></a>(append-map! (<span class="kw">lambda</span> (x) (<span class="kw">list</span> x (<span class="op">-</span> x))) &#39;(<span class="dv">1</span> <span class="dv">3</span> <span class="dv">8</span>)) <span class="co">;; =&gt; (1 -1 3 -3 8 -8)</span></span></code></pre></div>
<p>At least one of the list arguments must be finite.</p>
<h2 id="map-f-list1-..."><code>(map! f list1 ...)</code></h2>
<p>Linear-update variant of <code>map</code> – <code>map!</code> is allowed, but not required, to alter the cons cells of <code>list1</code> to construct the result list.</p>
<p>The dynamic order in which the various applications of <code>f</code> are made is not specified. In the n-ary case, <code>clist2</code>, <code>clist3</code>, … must have at least as many elements as <code>list1</code>.</p>
<h2 id="map-in-order-f-clist1-..."><code>(map-in-order f clist1 ...)</code></h2>
<p>A variant of the map procedure that guarantees to apply <code>f</code> across the elements of the <code>clisti</code> arguments in a left-to-right order. This is useful for mapping procedures that both have side effects and return useful values.</p>
<p>At least one of the list arguments must be finite.</p>
<h2 id="pair-for-each-f-clist1-..."><code>(pair-for-each f clist1 ...)</code></h2>
<p>Like for-each, but <code>f</code> is applied to successive sublists of the argument lists. That is, <code>f</code> is applied to the <code>cons</code> cells of the lists, rather than the lists’ elements. These applications occur in left-to-right order.</p>
<p>The f procedure may reliably apply <code>set-cdr!</code> to the pairs it is given without altering the sequence of execution.</p>
<div class="sourceCode" id="cb286"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb286-1"><a href="#cb286-1" aria-hidden="true" tabindex="-1"></a>(pair-for-each (<span class="kw">lambda</span> (pair) (<span class="kw">display</span> pair) (<span class="kw">newline</span>)) &#39;(a b c))</span>
<span id="cb286-2"><a href="#cb286-2" aria-hidden="true" tabindex="-1"></a> <span class="co">;; =&gt; (a b c)</span></span>
<span id="cb286-3"><a href="#cb286-3" aria-hidden="true" tabindex="-1"></a> <span class="co">;; =&gt; (b c)</span></span>
<span id="cb286-4"><a href="#cb286-4" aria-hidden="true" tabindex="-1"></a> <span class="co">;; =&gt; (c)</span></span></code></pre></div>
<p>At least one of the list arguments must be finite.</p>
<h2 id="filter-map-f-clist1-..."><code>(filter-map f clist1 ...)</code></h2>
<p>Like <code>map</code>, but only true values are saved.</p>
<div class="sourceCode" id="cb287"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb287-1"><a href="#cb287-1" aria-hidden="true" tabindex="-1"></a>(filter-map (<span class="kw">lambda</span> (x) (<span class="kw">and</span> (<span class="kw">number?</span> x) (<span class="op">*</span> x x))) &#39;(a <span class="dv">1</span> b <span class="dv">3</span> c <span class="dv">7</span>))</span>
<span id="cb287-2"><a href="#cb287-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; =&gt; (1 9 49)</span></span></code></pre></div>
<p>The dynamic order in which the various applications of <code>f</code> are made is not specified.</p>
<p>At least one of the list arguments must be finite.</p>
<h2 id="filter-pred-list"><code>(filter pred list)</code></h2>
<p>Return all the elements of list that satisfy predicate <code>pred</code>. The list is not disordered – elements that appear in the result list occur in the same order as they occur in the argument list. The returned list may share a common tail with the argument list. The dynamic order in which the various applications of <code>pred</code> are made is not specified.</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb288-1"><a href="#cb288-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">filter</span> <span class="kw">even?</span> &#39;(<span class="dv">0</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">8</span> <span class="dv">43</span> -<span class="dv">4</span>)) <span class="op">=&gt;</span> (<span class="dv">0</span> <span class="dv">8</span> <span class="dv">8</span> -<span class="dv">4</span>)</span></code></pre></div>
<h2 id="partition-pred-list"><code>(partition pred list)</code></h2>
<p>Partitions the elements of list with predicate <code>pred</code>, and returns two values: the list of in-elements and the list of out-elements. The list is not disordered – elements occur in the result lists in the same order as they occur in the argument list. The dynamic order in which the various applications of pred are made is not specified. One of the returned lists may share a common tail with the argument list.</p>
<div class="sourceCode" id="cb289"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb289-1"><a href="#cb289-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">partition</span> <span class="kw">symbol?</span> &#39;(one <span class="dv">2</span> <span class="dv">3</span> four five <span class="dv">6</span>)) <span class="op">=&gt;</span></span>
<span id="cb289-2"><a href="#cb289-2" aria-hidden="true" tabindex="-1"></a>    (one four five)</span>
<span id="cb289-3"><a href="#cb289-3" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">2</span> <span class="dv">3</span> <span class="dv">6</span>)</span></code></pre></div>
<h2 id="remove-pred-list"><code>(remove pred list)</code></h2>
<p>Returns <code>list</code> without the elements that satisfy predicate <code>pred</code>:</p>
<div class="sourceCode" id="cb290"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb290-1"><a href="#cb290-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> (pred <span class="kw">list</span>) (<span class="kw">filter</span> (<span class="kw">lambda</span> (x) (<span class="kw">not</span> (pred x))) <span class="kw">list</span>))</span></code></pre></div>
<p>The <code>list</code> is not disordered – elements that appear in the result list occur in the same order as they occur in the argument list. The returned list may share a common tail with the argument list. The dynamic order in which the various applications of <code>pred</code> are made is not specified.</p>
<div class="sourceCode" id="cb291"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb291-1"><a href="#cb291-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">remove</span> <span class="kw">even?</span> &#39;(<span class="dv">0</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">8</span> <span class="dv">43</span> -<span class="dv">4</span>)) <span class="op">=&gt;</span> (<span class="dv">7</span> <span class="dv">43</span>)</span></code></pre></div>
<h2 id="filter-pred-list-1"><code>(filter! pred list)</code></h2>
<h2 id="partition-pred-list-1"><code>(partition! pred list)</code></h2>
<h2 id="remove-pred-list-1"><code>(remove! pred list)</code></h2>
<p>Linear-update variants of <code>filter</code>, <code>partition</code> and <code>remove</code>. These procedures are allowed, but not required, to alter the cons cells in the argument list to construct the result lists.</p>
<h2 id="find-pred-clist"><code>(find pred clist)</code></h2>
<p>Return the first element of clist that satisfies predicate <code>pred</code>; false if no element does.</p>
<div class="sourceCode" id="cb292"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">find</span> <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> <span class="dv">4</span></span></code></pre></div>
<p>Note that <code>find</code> has an ambiguity in its lookup semantics – if <code>find</code> returns <code>#f</code>, you cannot tell (in general) if it found a #f element that satisfied <code>pred</code>, or if it did not find any element at all. In many situations, this ambiguity cannot arise – either the list being searched is known not to contain any <code>#f</code> elements, or the list is guaranteed to have an element satisfying <code>pred</code>. However, in cases where this ambiguity can arise, you should use <code>find-tail</code> instead of find – <code>find-tail</code> has no such ambiguity.</p>
<h2 id="find-tail-pred-clist"><code>(find-tail pred clist)</code></h2>
<p>Return the first pair of <code>clist</code> whose <code>car</code> satisfies <code>pred</code>. If no pair does, return false.</p>
<p><code>find-tail</code> can be viewed as a general-predicate variant of the member function.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb293"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb293-1"><a href="#cb293-1" aria-hidden="true" tabindex="-1"></a>(find-tail <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">37</span> -<span class="dv">8</span> -<span class="dv">5</span> <span class="dv">0</span> <span class="dv">0</span>)) <span class="op">=&gt;</span> (-<span class="dv">8</span> -<span class="dv">5</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb293-2"><a href="#cb293-2" aria-hidden="true" tabindex="-1"></a>(find-tail <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">37</span> -<span class="dv">5</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb293-3"><a href="#cb293-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-4"><a href="#cb293-4" aria-hidden="true" tabindex="-1"></a><span class="co">;; MEMBER X LIS:</span></span>
<span id="cb293-5"><a href="#cb293-5" aria-hidden="true" tabindex="-1"></a>(find-tail (<span class="kw">lambda</span> (elt) (<span class="kw">equal?</span> x elt)) lis)</span></code></pre></div>
<p>In the circular-list case, this procedure “rotates” the list.</p>
<p><code>find-tail</code> is essentially drop-while, where the sense of the predicate is inverted: <code>find-tail</code> searches until it finds an element satisfying the predicate; drop-while searches until it finds an element that doesn’t satisfy the predicate.</p>
<h2 id="take-while-pred-clist"><code>(take-while  pred clist)</code></h2>
<h2 id="take-while-pred-clist-1"><code>(take-while! pred clist)</code></h2>
<p>Returns the longest initial prefix of <code>clist</code> whose elements all satisfy the predicate <code>pred</code>.</p>
<p><code>take-while!</code> is the linear-update variant. It is allowed, but not required, to alter the argument list to produce the result.</p>
<div class="sourceCode" id="cb294"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb294-1"><a href="#cb294-1" aria-hidden="true" tabindex="-1"></a>(take-while <span class="kw">even?</span> &#39;(<span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> (<span class="dv">2</span> <span class="dv">18</span>)</span></code></pre></div>
<h2 id="drop-while-pred-clist"><code>(drop-while pred clist)</code></h2>
<p>Drops the longest initial prefix of <code>clist</code> whose elements all satisfy the predicate <code>pred</code>, and returns the rest of the list.</p>
<div class="sourceCode" id="cb295"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb295-1"><a href="#cb295-1" aria-hidden="true" tabindex="-1"></a>(drop-while <span class="kw">even?</span> &#39;(<span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> (<span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)</span></code></pre></div>
<p>The circular-list case may be viewed as “rotating” the list.</p>
<h2 id="span-pred-clist"><code>(span pred clist)</code></h2>
<h2 id="span-pred-list"><code>(span!  pred list)</code></h2>
<h2 id="break-pred-clist"><code>(break  pred clist)</code></h2>
<h2 id="break-pred-list">`(break! pred list)</h2>
<p>Span splits the list into the longest initial prefix whose elements all satisfy <code>pred</code>, and the remaining tail. Break inverts the sense of the predicate: the tail commences with the first element of the input list that satisfies the predicate.</p>
<p>In other words: <code>span</code> finds the intial span of elements satisfying <code>pred</code>, and break breaks the list at the first element satisfying <code>pred</code>.</p>
<p>Span is equivalent to:</p>
<div class="sourceCode" id="cb296"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb296-1"><a href="#cb296-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">values</span> (take-while pred clist)</span>
<span id="cb296-2"><a href="#cb296-2" aria-hidden="true" tabindex="-1"></a>        (drop-while pred clist))</span></code></pre></div>
<p><code>span!</code> and <code>break!</code> are the linear-update variants. They are allowed, but not required, to alter the argument list to produce the result.</p>
<div class="sourceCode" id="cb297"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb297-1"><a href="#cb297-1" aria-hidden="true" tabindex="-1"></a>(span <span class="kw">even?</span> &#39;(<span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span></span>
<span id="cb297-2"><a href="#cb297-2" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">2</span> <span class="dv">18</span>)</span>
<span id="cb297-3"><a href="#cb297-3" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)</span>
<span id="cb297-4"><a href="#cb297-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-5"><a href="#cb297-5" aria-hidden="true" tabindex="-1"></a>(<span class="kw">break</span> <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="op">=&gt;</span></span>
<span id="cb297-6"><a href="#cb297-6" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">3</span> <span class="dv">1</span>)</span>
<span id="cb297-7"><a href="#cb297-7" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)</span></code></pre></div>
<h2 id="any-pred-clist1-..."><code>(any pred clist1 ...)</code></h2>
<p>Applies the predicate across the lists, returning true if the predicate returns true on any application.</p>
<p>If there are n list arguments <code>clist1 ... clistn</code>, then <code>pred</code> must be a procedure taking n arguments and returning a single value, interpreted as a boolean (that is, <code>#f</code> means false, and any other value means true).</p>
<p><code>any</code> applies <code>pred</code> to the first elements of the <code>clisti</code> parameters. If this application returns a true value, any immediately returns that value. Otherwise, it iterates, applying <code>pred</code> to the second elements of the <code>clisti</code> parameters, then the third, and so forth. The iteration stops when a true value is produced or one of the lists runs out of values; in the latter case, any returns <code>#f</code>. The application of pred to the last element of the lists is a tail call.</p>
<p>Note the difference between <code>find</code> and <code>any</code> – <code>find</code> returns the element that satisfied the predicate; <code>any</code> returns the true value that the predicate produced.</p>
<p>Like <code>every</code>, <code>any</code>’s name does not end with a question mark – this is to indicate that it does not return a simple boolean (#t or #f), but a general value.</p>
<div class="sourceCode" id="cb298"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb298-1"><a href="#cb298-1" aria-hidden="true" tabindex="-1"></a>(any <span class="kw">integer?</span> &#39;(a <span class="dv">3</span> b <span class="fl">2.7</span>))   <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb298-2"><a href="#cb298-2" aria-hidden="true" tabindex="-1"></a>(any <span class="kw">integer?</span> &#39;(a <span class="fl">3.1</span> b <span class="fl">2.7</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb298-3"><a href="#cb298-3" aria-hidden="true" tabindex="-1"></a>(any <span class="op">&lt;</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span>)</span>
<span id="cb298-4"><a href="#cb298-4" aria-hidden="true" tabindex="-1"></a>           &#39;(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">#t</span></span></code></pre></div>
<h2 id="every-pred-clist1-..."><code>(every pred clist1 ...)</code></h2>
<p>Applies the predicate across the lists, returning true if the predicate returns true on every application.</p>
<p>If there are n list arguments <code>clist1 ... clistn</code>, then <code>pred</code> must be a procedure taking n arguments and returning a single value, interpreted as a boolean (that is, #f means false, and any other value means true).</p>
<p><code>every</code> applies <code>pred</code> to the first elements of the <code>clisti</code> parameters. If this application returns false, every immediately returns false. Otherwise, it iterates, applying <code>pred</code> to the second elements of the <code>clisti</code> parameters, then the third, and so forth. The iteration stops when a false value is produced or one of the lists runs out of values. In the latter case, <code>every</code> returns the true value produced by its final application of pred. The application of <code>pred</code> to the last element of the lists is a tail call.</p>
<p>If one of the <code>clisti</code> has no elements, <code>every</code> simply returns #t.</p>
<p>Like <code>any</code>, <code>every</code>’s name does not end with a question mark – this is to indicate that it does not return a simple boolean (<code>#t</code> or <code>#f</code>), but a general value.</p>
<h2 id="list-index-pred-clist1-..."><code>(list-index pred clist1 ...)</code></h2>
<p>Return the index of the leftmost element that satisfies <code>pred</code>.</p>
<p>If there are n list arguments <code>clist1 ... clistn</code>, then <code>pred</code> must be a function taking n arguments and returning a single value, interpreted as a boolean (that is, <code>#f</code> means false, and any other value means true).</p>
<p><code>list-index</code> applies <code>pred</code> to the first elements of the <code>clisti</code> parameters. If this application returns true, <code>list-index</code> immediately returns zero. Otherwise, it iterates, applying <code>pred</code> to the second elements of the <code>clisti</code> parameters, then the third, and so forth. When it finds a tuple of list elements that cause <code>pred</code> to return true, it stops and returns the zero-based index of that position in the lists.</p>
<p>The iteration stops when one of the lists runs out of values; in this case, <code>list-index</code> returns <code>#f</code>.</p>
<div class="sourceCode" id="cb299"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb299-1"><a href="#cb299-1" aria-hidden="true" tabindex="-1"></a>(list-index <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> <span class="dv">2</span></span>
<span id="cb299-2"><a href="#cb299-2" aria-hidden="true" tabindex="-1"></a>(list-index <span class="op">&lt;</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) &#39;(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">1</span></span>
<span id="cb299-3"><a href="#cb299-3" aria-hidden="true" tabindex="-1"></a>(list-index <span class="op">=</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) &#39;(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="member-x-list"><code>(member x list [=])</code></h2>
<h2 id="memq-x-list"><code>(memq x list)</code></h2>
<h2 id="memv-x-list"><code>(memv x list)</code></h2>
<p>These procedures return the first sublist of <code>list</code> whose <code>car</code> is <code>x</code>, where the sublists of <code>list</code> are the non-empty lists returned by <code>(drop list i)</code> for <code>i</code> less than the length of list. If <code>x</code> does not occur in list, then <code>#f</code> is returned. <code>memq</code> uses <code>eq?</code> to compare <code>x</code> with the elements of list, while <code>memv</code> uses <code>eqv?</code>, and <code>member</code> uses <code>equal?</code>.</p>
<div class="sourceCode" id="cb300"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb300-1"><a href="#cb300-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">memq</span> &#39;a &#39;(a b c))          <span class="op">=&gt;</span>  (a b c)</span>
<span id="cb300-2"><a href="#cb300-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">memq</span> &#39;b &#39;(a b c))          <span class="op">=&gt;</span>  (b c)</span>
<span id="cb300-3"><a href="#cb300-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">memq</span> &#39;a &#39;(b c d))          <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb300-4"><a href="#cb300-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">memq</span> (<span class="kw">list</span> &#39;a) &#39;(b (a) c)) <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb300-5"><a href="#cb300-5" aria-hidden="true" tabindex="-1"></a>(<span class="kw">member</span> (<span class="kw">list</span> &#39;a) &#39;(b (a) c))         <span class="op">=&gt;</span>  ((a) c)</span>
<span id="cb300-6"><a href="#cb300-6" aria-hidden="true" tabindex="-1"></a>(<span class="kw">memq</span> <span class="dv">101</span> &#39;(<span class="dv">100</span> <span class="dv">101</span> <span class="dv">102</span>))   <span class="op">=&gt;</span>  *unspecified*</span>
<span id="cb300-7"><a href="#cb300-7" aria-hidden="true" tabindex="-1"></a>(<span class="kw">memv</span> <span class="dv">101</span> &#39;(<span class="dv">100</span> <span class="dv">101</span> <span class="dv">102</span>))   <span class="op">=&gt;</span>  (<span class="dv">101</span> <span class="dv">102</span>)</span></code></pre></div>
<p>The comparison procedure is used to compare the elements <code>ei</code> of list to the key <code>x</code> in this way:</p>
<div class="sourceCode" id="cb301"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb301-1"><a href="#cb301-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">=</span> x ei) <span class="co">; list is (e1 ... en)</span></span></code></pre></div>
<p>That is, the first argument is always <code>x</code>, and the second argument is one of the list elements. Thus one can reliably find the first element of list that is greater than five with <code>(member 5 list &lt;)</code></p>
<p>Note that fully general list searching may be performed with the <code>find-tail</code> and <code>find</code> procedures, e.g.</p>
<div class="sourceCode" id="cb302"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb302-1"><a href="#cb302-1" aria-hidden="true" tabindex="-1"></a>(find-tail <span class="kw">even?</span> <span class="kw">list</span>) <span class="co">; Find the first elt with an even key.</span></span></code></pre></div>
<h2 id="delete-x-list"><code>(delete x list)</code></h2>
<h2 id="delete-x-list-1"><code>(delete! x list)</code></h2>
<p><code>delete</code> uses the comparison procedure <code>=</code>, which defaults to <code>equal?</code>, to find all elements of list that are equal to <code>x</code>, and deletes them from list. The dynamic order in which the various applications of <code>=</code> are made is not specified.</p>
<p>The list is not disordered – elements that appear in the result list occur in the same order as they occur in the argument list. The result may share a common tail with the argument list.</p>
<p>Note that fully general element deletion can be performed with the <code>remove</code> and <code>remove!</code> procedures, e.g.:</p>
<div class="sourceCode" id="cb303"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb303-1"><a href="#cb303-1" aria-hidden="true" tabindex="-1"></a><span class="co">;; Delete all the even elements from LIS:</span></span>
<span id="cb303-2"><a href="#cb303-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">remove</span> <span class="kw">even?</span> lis)</span></code></pre></div>
<p>The comparison procedure is used in this way: <code>(= x ei)</code>. That is, <code>x</code> is always the first argument, and a list element is always the second argument. The comparison procedure will be used to compare each element of list exactly once; the order in which it is applied to the various <code>ei</code> is not specified. Thus, one can reliably remove all the numbers greater than five from a list with <code>(delete 5 list &lt;)</code>.</p>
<p><code>delete!</code> is the linear-update variant of <code>delete</code>. It is allowed, but not required, to alter the cons cells in its argument list to construct the result.</p>
<h2 id="delete-duplicates-list"><code>(delete-duplicates  list [=])</code></h2>
<h2 id="delete-duplicates-list-1"><code>(delete-duplicates! list [=])</code></h2>
<p><code>delete-duplicates</code> removes duplicate elements from the list argument. If there are multiple equal elements in the argument list, the result list only contains the first or leftmost of these elements in the result. The order of these surviving elements is the same as in the original list – delete-duplicates does not disorder the list (hence it is useful for “cleaning up” association lists).</p>
<p>The <code>=</code> parameter is used to compare the elements of the list; it defaults to equal?. If x comes before y in list, then the comparison is performed (= x y). The comparison procedure will be used to compare each pair of elements in list no more than once; the order in which it is applied to the various pairs is not specified.</p>
<p>Implementations of <code>delete-duplicates</code> are allowed to share common tails between argument and result lists – for example, if the list argument contains only unique elements, it may simply return exactly this list.</p>
<p>Be aware that, in general, delete-duplicates runs in time O(n2) for n-element lists. Uniquifying long lists can be accomplished in O(n lg n) time by sorting the list to bring equal elements together, then using a linear-time algorithm to remove equal elements. Alternatively, one can use algorithms based on element-marking, with linear-time results.</p>
<p><code>delete-duplicates!</code> is the linear-update variant of <code>delete-duplicates</code>; it is allowed, but not required, to alter the cons cells in its argument list to construct the result.</p>
<div class="sourceCode" id="cb304"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb304-1"><a href="#cb304-1" aria-hidden="true" tabindex="-1"></a>(delete-duplicates &#39;(a b a c a b c z)) <span class="op">=&gt;</span> (a b c z)</span>
<span id="cb304-2"><a href="#cb304-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-3"><a href="#cb304-3" aria-hidden="true" tabindex="-1"></a><span class="co">;; Clean up an alist:</span></span>
<span id="cb304-4"><a href="#cb304-4" aria-hidden="true" tabindex="-1"></a>(delete-duplicates &#39;((a <span class="op">.</span> <span class="dv">3</span>) (b <span class="op">.</span> <span class="dv">7</span>) (a <span class="op">.</span> <span class="dv">9</span>) (c <span class="op">.</span> <span class="dv">1</span>))</span>
<span id="cb304-5"><a href="#cb304-5" aria-hidden="true" tabindex="-1"></a>                   (<span class="kw">lambda</span> (x y) (<span class="kw">eq?</span> (<span class="kw">car</span> x) (<span class="kw">car</span> y))))</span>
<span id="cb304-6"><a href="#cb304-6" aria-hidden="true" tabindex="-1"></a><span class="co">;;  =&gt; ((a . 3) (b . 7) (c . 1))</span></span></code></pre></div>
<h2 id="assoc-key-alist"><code>(assoc key alist [=])</code></h2>
<h2 id="assq-key-alist"><code>(assq key alist)</code></h2>
<h2 id="assv-key-alist"><code>(assv key alist)</code></h2>
<p><code>alist</code> must be an association list – a list of pairs. These procedures find the first pair in <code>alist</code> whose <code>car</code> field is <code>key</code>, and returns that pair. If no pair in <code>alist</code> has <code>key</code> as its <code>car</code>, then <code>#f</code> is returned. <code>assq</code> uses <code>eq?</code> to compare <code>key</code> with the <code>car</code> fields of the pairs in <code>alist</code>, while <code>assv</code> uses <code>eqv?</code> and <code>assoc</code> uses <code>equal?</code>.</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb305-1"><a href="#cb305-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> e </span>&#39;((a <span class="dv">1</span>) (b <span class="dv">2</span>) (c <span class="dv">3</span>)))</span>
<span id="cb305-2"><a href="#cb305-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">assq</span> &#39;a e)                            <span class="op">=&gt;</span>  (a <span class="dv">1</span>)</span>
<span id="cb305-3"><a href="#cb305-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">assq</span> &#39;b e)                            <span class="op">=&gt;</span>  (b <span class="dv">2</span>)</span>
<span id="cb305-4"><a href="#cb305-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">assq</span> &#39;d e)                            <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb305-5"><a href="#cb305-5" aria-hidden="true" tabindex="-1"></a>(<span class="kw">assq</span> (<span class="kw">list</span> &#39;a) &#39;(((a)) ((b)) ((c))))  <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb305-6"><a href="#cb305-6" aria-hidden="true" tabindex="-1"></a>(<span class="kw">assoc</span> (<span class="kw">list</span> &#39;a) &#39;(((a)) ((b)) ((c)))) <span class="op">=&gt;</span>  ((a))</span>
<span id="cb305-7"><a href="#cb305-7" aria-hidden="true" tabindex="-1"></a>(<span class="kw">assq</span> <span class="dv">5</span> &#39;((<span class="dv">2</span> <span class="dv">3</span>) (<span class="dv">5</span> <span class="dv">7</span>) (<span class="dv">11</span> <span class="dv">13</span>)))    <span class="op">=&gt;</span>  *unspecified*</span>
<span id="cb305-8"><a href="#cb305-8" aria-hidden="true" tabindex="-1"></a>(<span class="kw">assv</span> <span class="dv">5</span> &#39;((<span class="dv">2</span> <span class="dv">3</span>) (<span class="dv">5</span> <span class="dv">7</span>) (<span class="dv">11</span> <span class="dv">13</span>)))    <span class="op">=&gt;</span>  (<span class="dv">5</span> <span class="dv">7</span>)</span></code></pre></div>
<p>The comparison procedure is used to compare the elements <code>ei</code> of list to the <code>key</code> parameter in this way:</p>
<div class="sourceCode" id="cb306"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb306-1"><a href="#cb306-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">=</span> key (<span class="kw">car</span> ei)) <span class="co">; list is (E1 ... En)</span></span></code></pre></div>
<p>That is, the first argument is always <code>key</code>, and the second argument is one of the list elements. Thus one can reliably find the first entry of alist whose key is greater than five with <code>(assoc 5 alist &lt;)</code></p>
<p>Note that fully general <code>alist</code> searching may be performed with the <code>find-tail</code> and <code>find</code> procedures, e.g.</p>
<div class="sourceCode" id="cb307"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb307-1"><a href="#cb307-1" aria-hidden="true" tabindex="-1"></a><span class="co">;; Look up the first association in alist with an even key:</span></span>
<span id="cb307-2"><a href="#cb307-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">find</span> (<span class="kw">lambda</span> (a) (<span class="kw">even?</span> (<span class="kw">car</span> a))) alist)</span></code></pre></div>
<h2 id="alist-cons-key-datum-alist"><code>(alist-cons key datum alist)</code></h2>
<div class="sourceCode" id="cb308"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb308-1"><a href="#cb308-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> (key datum alist) (<span class="kw">cons</span> (<span class="kw">cons</span> key datum) alist))</span></code></pre></div>
<p><code>cons</code> a new entry mapping <code>key</code> to <code>datum</code> onto <code>alist</code>.</p>
<h2 id="alist-copy-alist"><code>(alist-copy alist)</code></h2>
<p>Make a fresh copy of <code>alist</code>. This means copying each pair that forms an association as well as the spine of the list, i.e.</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb309-1"><a href="#cb309-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> (a) (map (<span class="kw">lambda</span> (elt) (<span class="kw">cons</span> (<span class="kw">car</span> elt) (<span class="kw">cdr</span> elt))) a))</span></code></pre></div>
<h2 id="alist-delete-key-alist"><code>(alist-delete  key alist [=])</code></h2>
<h2 id="alist-delete-key-alist-1"><code>(alist-delete! key alist [=])</code></h2>
<p><code>alist-delete</code> deletes all associations from alist with the given key, using key-comparison procedure <code>=</code>, which defaults to equal?. The dynamic order in which the various applications of = are made is not specified.</p>
<p>Return values may share common tails with the alist argument. The alist is not disordered – elements that appear in the result alist occur in the same order as they occur in the argument alist.</p>
<p>The comparison procedure is used to compare the element keys ki of alist’s entries to the key parameter in this way: (= key ki). Thus, one can reliably remove all entries of alist whose key is greater than five with (alist-delete 5 alist &lt;)</p>
<p>alist-delete! is the linear-update variant of alist-delete. It is allowed, but not required, to alter cons cells from the alist parameter to construct the result.</p>
<h2 id="lset-list1-..."><code>(lset&lt;= = list1 ...)</code></h2>
<p>Returns true iff every listi is a subset of listi+1, using = for the element-equality procedure. List A is a subset of list B if every element in A is equal to some element of B. When performing an element comparison, the = procedure’s first argument is an element of A; its second, an element of B.</p>
<div class="sourceCode" id="cb310"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb310-1"><a href="#cb310-1" aria-hidden="true" tabindex="-1"></a>(lset&lt;= <span class="kw">eq?</span> &#39;(a) &#39;(a b a) &#39;(a b c c)) <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb310-2"><a href="#cb310-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-3"><a href="#cb310-3" aria-hidden="true" tabindex="-1"></a>(lset&lt;= <span class="kw">eq?</span>) <span class="op">=&gt;</span> <span class="dv">#t</span>             <span class="co">; Trivial cases</span></span>
<span id="cb310-4"><a href="#cb310-4" aria-hidden="true" tabindex="-1"></a>(lset&lt;= <span class="kw">eq?</span> &#39;(a)) <span class="op">=&gt;</span> <span class="dv">#t</span></span></code></pre></div>
<h2 id="lset-list1-...-1"><code>(lset= = list1 ...)</code></h2>
<p>Returns true iff every listi is set-equal to listi+1, using = for the element-equality procedure. “Set-equal” simply means that listi is a subset of listi+1, and listi+1 is a subset of listi. The = procedure’s first argument is an element of listi; its second is an element of listi+1.</p>
<div class="sourceCode" id="cb311"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb311-1"><a href="#cb311-1" aria-hidden="true" tabindex="-1"></a>(lset= <span class="kw">eq?</span> &#39;(b e a) &#39;(a e b) &#39;(e e b a)) <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb311-2"><a href="#cb311-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb311-3"><a href="#cb311-3" aria-hidden="true" tabindex="-1"></a>(lset= <span class="kw">eq?</span>) <span class="op">=&gt;</span> <span class="dv">#t</span>               <span class="co">; Trivial cases</span></span>
<span id="cb311-4"><a href="#cb311-4" aria-hidden="true" tabindex="-1"></a>(lset= <span class="kw">eq?</span> &#39;(a)) <span class="op">=&gt;</span> <span class="dv">#t</span></span></code></pre></div>
<h2 id="lset-adjoin-list-elt1-..."><code>(lset-adjoin = list elt1 ...)</code></h2>
<p>Adds the elti elements not already in the list parameter to the result list. The result shares a common tail with the list parameter. The new elements are added to the front of the list, but no guarantees are made about their order. The = parameter is an equality procedure used to determine if an elti is already a member of list. Its first argument is an element of list; its second is one of the elti.</p>
<p>The list parameter is always a suffix of the result – even if the list parameter contains repeated elements, these are not reduced.</p>
<div class="sourceCode" id="cb312"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb312-1"><a href="#cb312-1" aria-hidden="true" tabindex="-1"></a>(lset-adjoin <span class="kw">eq?</span> &#39;(a b c d c e) &#39;a &#39;e &#39;i &#39;o &#39;u) <span class="op">=&gt;</span> (u o i a b c d c e)</span></code></pre></div>
<h2 id="lset-union-list1-..."><code>(lset-union = list1 ...)</code></h2>
<p>Returns the union of the lists, using = for the element-equality procedure.</p>
<p>The union of lists A and B is constructed as follows:</p>
<ul>
<li>If A is the empty list, the answer is B (or a copy of B).</li>
<li>Otherwise, the result is initialised to be list A (or a copy of A).</li>
<li>Proceed through the elements of list B in a left-to-right order. If b is such an element of B, compare every element r of the current result list to b: (= r b). If all comparisons fail, b is consed onto the front of the result.</li>
</ul>
<p>However, there is no guarantee that = will be applied to every pair of arguments from A and B. In particular, if A is eq? to B, the operation may immediately terminate.</p>
<p>In the n-ary case, the two-argument list-union operation is simply folded across the argument lists.</p>
<div class="sourceCode" id="cb313"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb313-1"><a href="#cb313-1" aria-hidden="true" tabindex="-1"></a>(lset-union <span class="kw">eq?</span> &#39;(a b c d e) &#39;(a e i o u)) <span class="op">=&gt;</span></span>
<span id="cb313-2"><a href="#cb313-2" aria-hidden="true" tabindex="-1"></a>        (u o i a b c d e)</span>
<span id="cb313-3"><a href="#cb313-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-4"><a href="#cb313-4" aria-hidden="true" tabindex="-1"></a><span class="co">;; Repeated elements in LIST1 are preserved.</span></span>
<span id="cb313-5"><a href="#cb313-5" aria-hidden="true" tabindex="-1"></a>(lset-union <span class="kw">eq?</span> &#39;(a a c) &#39;(x a x)) <span class="op">=&gt;</span> (x a a c)</span>
<span id="cb313-6"><a href="#cb313-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-7"><a href="#cb313-7" aria-hidden="true" tabindex="-1"></a><span class="co">;; Trivial cases</span></span>
<span id="cb313-8"><a href="#cb313-8" aria-hidden="true" tabindex="-1"></a>(lset-union <span class="kw">eq?</span>) <span class="op">=&gt;</span> ()</span>
<span id="cb313-9"><a href="#cb313-9" aria-hidden="true" tabindex="-1"></a>(lset-union <span class="kw">eq?</span> &#39;(a b c)) <span class="op">=&gt;</span> (a b c)</span></code></pre></div>
<h2 id="lset-intersection-list1-list2-..."><code>(lset-intersection = list1 list2 ...)</code></h2>
<p>Returns the intersection of the lists, using = for the element-equality procedure.</p>
<p>The intersection of lists A and B is comprised of every element of A that is = to some element of B: (= a b), for a in A, and b in B. Note this implies that an element which appears in B and multiple times in list A will also appear multiple times in the result.</p>
<p>The order in which elements appear in the result is the same as they appear in list1 – that is, lset-intersection essentially filters list1, without disarranging element order. The result may share a common tail with list1.</p>
<p>In the n-ary case, the two-argument list-intersection operation is simply folded across the argument lists. However, the dynamic order in which the applications of = are made is not specified. The procedure may check an element of list1 for membership in every other list before proceeding to consider the next element of list1, or it may completely intersect list1 and list2 before proceeding to list3, or it may go about its work in some third order.</p>
<div class="sourceCode" id="cb314"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb314-1"><a href="#cb314-1" aria-hidden="true" tabindex="-1"></a>(lset-intersection <span class="kw">eq?</span> &#39;(a b c d e) &#39;(a e i o u)) <span class="op">=&gt;</span> (a e)</span>
<span id="cb314-2"><a href="#cb314-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-3"><a href="#cb314-3" aria-hidden="true" tabindex="-1"></a><span class="co">;; Repeated elements in LIST1 are preserved.</span></span>
<span id="cb314-4"><a href="#cb314-4" aria-hidden="true" tabindex="-1"></a>(lset-intersection <span class="kw">eq?</span> &#39;(a x y a) &#39;(x a x z)) <span class="op">=&gt;</span> &#39;(a x a)</span>
<span id="cb314-5"><a href="#cb314-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-6"><a href="#cb314-6" aria-hidden="true" tabindex="-1"></a>(lset-intersection <span class="kw">eq?</span> &#39;(a b c)) <span class="op">=&gt;</span> (a b c)     <span class="co">; Trivial case</span></span></code></pre></div>
<h2 id="lset-difference-list1-list2-..."><code>(lset-difference = list1 list2 ...)</code></h2>
<p>Returns the difference of the lists, using = for the element-equality procedure – all the elements of list1 that are not = to any element from one of the other listi parameters.</p>
<p>The = procedure’s first argument is always an element of list1; its second is an element of one of the other listi. Elements that are repeated multiple times in the list1 parameter will occur multiple times in the result. The order in which elements appear in the result is the same as they appear in list1 – that is, lset-difference essentially filters list1, without disarranging element order. The result may share a common tail with list1. The dynamic order in which the applications of = are made is not specified. The procedure may check an element of list1 for membership in every other list before proceeding to consider the next element of list1, or it may completely compute the difference of list1 and list2 before proceeding to list3, or it may go about its work in some third order.</p>
<div class="sourceCode" id="cb315"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb315-1"><a href="#cb315-1" aria-hidden="true" tabindex="-1"></a>(lset-difference <span class="kw">eq?</span> &#39;(a b c d e) &#39;(a e i o u)) <span class="op">=&gt;</span> (b c d)</span>
<span id="cb315-2"><a href="#cb315-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-3"><a href="#cb315-3" aria-hidden="true" tabindex="-1"></a>(lset-difference <span class="kw">eq?</span> &#39;(a b c)) <span class="op">=&gt;</span> (a b c) <span class="co">; Trivial case</span></span></code></pre></div>
<h2 id="lset-xor-list1">`(lset-xor = list1 …)</h2>
<p>Returns the exclusive-or of the sets, using = for the element-equality procedure. If there are exactly two lists, this is all the elements that appear in exactly one of the two lists. The operation is associative, and thus extends to the n-ary case – the elements that appear in an odd number of the lists. The result may share a common tail with any of the listi parameters.</p>
<p>More precisely, for two lists A and B, A xor B is a list of:</p>
<ul>
<li>every element a of A such that there is no element b of B such that (= a b), and</li>
<li>every element b of B such that there is no element a of A such that (= b a).</li>
</ul>
<p>However, an implementation is allowed to assume that = is symmetric – that is, that</p>
<div class="sourceCode" id="cb316"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb316-1"><a href="#cb316-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">=</span> a b) <span class="op">=&gt;</span> (<span class="op">=</span> b a)<span class="op">.</span></span></code></pre></div>
<p>This means, for example, that if a comparison (= a b) produces true for some a in A and b in B, both a and b may be removed from inclusion in the result.</p>
<p>In the n-ary case, the binary-xor operation is simply folded across the lists.</p>
<div class="sourceCode" id="cb317"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb317-1"><a href="#cb317-1" aria-hidden="true" tabindex="-1"></a>(lset-xor <span class="kw">eq?</span> &#39;(a b c d e) &#39;(a e i o u)) <span class="op">=&gt;</span> (d c b i o u)</span>
<span id="cb317-2"><a href="#cb317-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-3"><a href="#cb317-3" aria-hidden="true" tabindex="-1"></a><span class="co">;; Trivial cases.</span></span>
<span id="cb317-4"><a href="#cb317-4" aria-hidden="true" tabindex="-1"></a>(lset-xor <span class="kw">eq?</span>) <span class="op">=&gt;</span> ()</span>
<span id="cb317-5"><a href="#cb317-5" aria-hidden="true" tabindex="-1"></a>(lset-xor <span class="kw">eq?</span> &#39;(a b c d e)) <span class="op">=&gt;</span> (a b c d e)</span></code></pre></div>
<h2 id="lset-diffintersection-list1-list2-..."><code>(lset-diff+intersection = list1 list2 ...)</code></h2>
<p>Returns two values – the difference and the intersection of the lists. Is equivalent to:</p>
<pre><code>(values (lset-difference = list1 list2 ...)
        (lset-intersection = list1
                             (lset-union = list2 ...)))</code></pre>
<p>But can be implemented more efficiently.</p>
<p>The = procedure’s first argument is an element of list1; its second is an element of one of the other listi.</p>
<p>Either of the answer lists may share a common tail with list1. This operation essentially partitions list1.</p>
<h2 id="lset-union-list1-...-1"><code>(lset-union! list1 ...)</code></h2>
<h2 id="lset-intersection-list1-..."><code>(lset-intersection! list1 ...)</code></h2>
<h2 id="lset-difference-list1-..."><code>(lset-difference! list1 ...)</code></h2>
<h2 id="lset-xor-list1-..."><code>(lset-xor! list1 ...)</code></h2>
<h2 id="lset-diffintersection-list1-..."><code>(lset-diff+intersection! list1 ...)</code></h2>
<p>These are linear-update variants. They are allowed, but not required, to use the cons cells in their first list parameter to construct their answer. lset-union! is permitted to recycle cons cells from any of its list arguments.</p>
<h2 id="set-car-pair-object"><code>(set-car! pair object)</code></h2>
<h2 id="set-cdr-pair-object"><code>(set-cdr! pair object)</code></h2>
<p>These procedures store object in the car and cdr field of pair, respectively. The value returned is unspecified.</p>
<div class="sourceCode" id="cb319"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb319-1"><a href="#cb319-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(f) (<span class="kw">list</span> &#39;not-a-constant-list))</span>
<span id="cb319-2"><a href="#cb319-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(g) &#39;(constant-list))</span>
<span id="cb319-3"><a href="#cb319-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">set-car!</span> (f) <span class="dv">3</span>) <span class="op">=&gt;</span>  *unspecified*</span>
<span id="cb319-4"><a href="#cb319-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">set-car!</span> (g) <span class="dv">3</span>) <span class="op">=&gt;</span>  *error*</span></code></pre></div>
<h1 id="scheme-hash-table"><code>(scheme hash-table)</code></h1>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-125/">srfi-125</a>.</p>
<p>The library doesn’t implement deprecated features. Application must rely on <code>(scheme comparator)</code> to specify equal predicate and hash function.</p>
<p>This SRFI defines an interface to hash tables, which are widely recognized as a fundamental data structure for a wide variety of applications. A hash table is a data structure that:</p>
<ul>
<li><p>Is disjoint from all other types.</p></li>
<li><p>Provides a mapping from objects known as keys to corresponding objects known as values.</p>
<ul>
<li><p>Keys may be any Scheme objects in some kinds of hash tables, but are restricted in other kinds.</p></li>
<li><p>Values may be any Scheme objects.</p></li>
</ul></li>
<li><p>Has no intrinsic order for the key-value associations it contains.</p></li>
<li><p>Provides an equality predicate which defines when a proposed key is the same as an existing key. No table may contain more than one value for a given key.</p></li>
<li><p>Provides a hash function which maps a candidate key into a non-negative exact integer.</p></li>
<li><p>Supports mutation as the primary means of setting the contents of a able.</p></li>
<li><p>Provides key lookup and destructive update in (expected) amortized constant time, provided a satisfactory hash function is available.</p></li>
<li><p>Does not guarantee that whole-table operations work in the presence of concurrent mutation of the whole hash table (values may be safely mutated).</p></li>
</ul>
<h2 id="make-hash-table-comparator-.-args"><code>(make-hash-table comparator . args)</code></h2>
<p>Returns a newly allocated hash table using <code>(scheme comparator)</code> object <code>COMPARATOR</code>. For the time being, <code>ARGS</code> is ignored.</p>
<h2 id="hash-table-comparator-key-value-..."><code>(hash-table comparator [key value] ...)</code></h2>
<p>Returns a newly allocated hash table using <code>(scheme comparator)</code> object <code>COMPARATOR</code>. For each pair of arguments, an association is added to the new hash table with key as its key and value as its value. If the same key (in the sense of the equality predicate) is specified more than once, it is an error.</p>
<h2 id="hash-table-unfold-stop-mapper-successor-seed-comparator-args-..."><code>(hash-table-unfold stop? mapper successor seed comparator args ...)</code></h2>
<p>Create a new hash table as if by <code>make-hash-table</code> using <code>comparator</code> and the <code>args</code>. If the result of applying the predicate <code>stop?</code> to <code>seed</code> is true, return the hash table. Otherwise, apply the procedure <code>mapper</code> to <code>seed</code>. <code>mapper</code> returns two values, which are inserted into the hash table as the key and the value respectively. Then get a new <code>seed</code> by applying the procedure <code>successor</code> to <code>seed</code>, and repeat this algorithm.</p>
<h2 id="alist-hash-table-alist-comparator-arg-..."><code>(alist-&gt;hash-table alist comparator arg ...)</code></h2>
<p>Returns a newly allocated hash-table as if by <code>make-hash-table</code> using <code>comparator</code> and the <code>args</code>. It is then initialized from the associations of <code>alist</code>. Associations earlier in the list take precedence over those that come later.</p>
<h2 id="hash-table-obj"><code>(hash-table? obj)</code></h2>
<p>Returns #t if obj is a hash table, and #f otherwise</p>
<h2 id="hash-table-contains-hash-table-key"><code>(hash-table-contains? hash-table key)</code></h2>
<p>Returns #t if there is any association to key in hash-table, and #f otherwise.</p>
<h2 id="hash-table-empty-hash-table"><code>(hash-table-empty? hash-table)</code></h2>
<p>Returns #t if hash-table contains no associations, and #f otherwise.</p>
<h2 id="hash-table-value-comparator-hash-table1-hash-table2"><code>(hash-table=? value-comparator hash-table1 hash-table2)</code></h2>
<p>Returns #t if hash-table1 and hash-table2 have the same keys (in the sense of their common equality predicate) and each key has the same value (in the sense of value-comparator), and #f otherwise.</p>
<h2 id="hash-table-mutable-hash-table"><code>(hash-table-mutable? hash-table)</code></h2>
<p>Returns #t if the hash table is mutable.</p>
<h2 id="hash-table-ref-hash-table-key-failure-success"><code>(hash-table-ref hash-table key [failure [success]])</code></h2>
<p>Extracts the value associated to key in hash-table, invokes the procedure success on it, and returns its result; if success is not provided, then the value itself is returned. If key is not contained in hash-table and failure is supplied, then failure is invoked on no arguments and its result is returned.</p>
<h2 id="hash-table-refdefault-hash-table-key-default"><code>(hash-table-ref/default hash-table key default)</code></h2>
<p>TODO</p>
<h2 id="hash-table-set-hash-table-key-value-..."><code>(hash-table-set! hash-table key value ...)</code></h2>
<p>Repeatedly mutates hash-table, creating new associations in it by processing the arguments from left to right. The args alternate between keys and values. Whenever there is a previous association for a key, it is deleted. It is an error if the type check procedure of the comparator of hash-table, when invoked on a key, does not return #t. Likewise, it is an error if a key is not a valid argument to the equality predicate of hash-table. Returns an unspecified value.</p>
<h2 id="hash-table-delete-hash-table-key-..."><code>(hash-table-delete! hash-table key ...)</code></h2>
<p>Deletes any association to each key in hash-table and returns the number of keys that had associations.</p>
<h2 id="hash-table-intern-hash-table-key-failure"><code>(hash-table-intern! hash-table key failure)</code></h2>
<p>Effectively invokes hash-table-ref with the given arguments and returns what it returns. If key was not found in hash-table, its value is set to the result of calling failure.</p>
<h2 id="hash-table-update-hash-table-key-updater-failure-success"><code>(hash-table-update! hash-table key updater [failure [success]])</code></h2>
<p>TODO:</p>
<h2 id="hash-table-pop-hash-table"><code>(hash-table-pop! hash-table)</code></h2>
<p>Chooses an arbitrary association from hash-table and removes it, returning the key and value as two values. It is an error if hash-table is empty.</p>
<h2 id="hash-table-clear-hash-table"><code>(hash-table-clear! hash-table)</code></h2>
<p>Delete all the associations from hash-table.</p>
<h2 id="hash-table-size-hash-table"><code>(hash-table-size hash-table)</code></h2>
<p>Returns the number of associations in hash-table as an exact integer.</p>
<h2 id="hash-table-keys-hash-table"><code>(hash-table-keys hash-table)</code></h2>
<p>Returns a newly allocated list of all the keys in hash-table.</p>
<h2 id="hash-table-values-hash-table"><code>(hash-table-values hash-table)</code></h2>
<p>Returns a newly allocated list of all the keys in hash-table.</p>
<h2 id="hash-table-entries-hash-table"><code>(hash-table-entries hash-table)</code></h2>
<p>Returns two values, a newly allocated list of all the keys in hash-table and a newly allocated list of all the values in hash-table in the corresponding order.</p>
<h2 id="hash-table-find-proc-hash-table-failure"><code>(hash-table-find proc hash-table failure)</code></h2>
<p>For each association of hash-table, invoke proc on its key and value. If proc returns true, then hash-table-find returns what proc returns. If all the calls to proc return #f, return the result of invoking the thunk failure.</p>
<h2 id="hash-table-count-pred-hash-table"><code>(hash-table-count pred hash-table)</code></h2>
<p>For each association of hash-table, invoke pred on its key and value. Return the number of calls to pred which returned true.</p>
<h2 id="hash-table-map-proc-comparator-hash-table"><code>(hash-table-map proc comparator hash-table)</code></h2>
<p>Returns a newly allocated hash table as if by <code>(make-hash-table comparator)</code>. Calls <code>PROC</code> for every association in <code>hash-table</code> with the value of the association. The key of the association and the result of invoking <code>proc</code> are entered into the new hash table. Note that this is not the result of lifting mapping over the domain of hash tables, but it is considered more useful.</p>
<p>If comparator recognizes multiple keys in the hash-table as equivalent, any one of such associations is taken.</p>
<h2 id="hash-table-for-each-proc-hash-table"><code>(hash-table-for-each proc hash-table)</code></h2>
<p>Calls proc for every association in hash-table with two arguments: the key of the association and the value of the association. The value returned by proc is discarded. Returns an unspecified value.</p>
<h2 id="hash-table-map-proc-hash-table"><code>(hash-table-map! proc hash-table)</code></h2>
<p>Calls proc for every association in hash-table with two arguments: the key of the association and the value of the association. The value returned by proc is used to update the value of the association. Returns an unspecified value.</p>
<h2 id="hash-table-map-list-proc-hash-table"><code>(hash-table-map-&gt;list proc hash-table)</code></h2>
<p>Calls proc for every association in hash-table with two arguments: the key of the association and the value of the association. The values returned by the invocations of proc are accumulated into a list, which is returned.</p>
<h2 id="hash-table-fold-proc-seed-hash-table"><code>(hash-table-fold proc seed hash-table)</code></h2>
<p>Calls proc for every association in hash-table with three arguments: the key of the association, the value of the association, and an accumulated value val. Val is seed for the first invocation of procedure, and for subsequent invocations of proc, the returned value of the previous invocation. The value returned by hash-table-fold is the return value of the last invocation of proc.</p>
<h2 id="hash-table-prune-proc-hash-table"><code>(hash-table-prune! proc hash-table)</code></h2>
<p>Calls proc for every association in hash-table with two arguments, the key and the value of the association, and removes all associations from hash-table for which proc returns true. Returns an unspecified value.</p>
<h2 id="hash-table-copy-hash-table-mutable"><code>(hash-table-copy hash-table [mutable?])</code></h2>
<p>Returns a newly allocated hash table with the same properties and associations as hash-table. If the second argument is present and is true, the new hash table is mutable. Otherwise it is immutable provided that the implementation supports immutable hash tables.</p>
<h2 id="hash-table-empty-copy-hash-table"><code>(hash-table-empty-copy hash-table)</code></h2>
<p>Returns a newly allocated mutable hash table with the same properties as hash-table, but with no associations.</p>
<h2 id="hash-table-alist-hash-table"><code>(hash-table-&gt;alist hash-table)</code></h2>
<p>Returns an alist with the same associations as hash-table in an unspecified order.</p>
<h2 id="hash-table-union-hash-table1-hash-table2"><code>(hash-table-union! hash-table1 hash-table2)</code></h2>
<p>Adds the associations of hash-table2 to hash-table1 and returns hash-table1. If a key appears in both hash tables, its value is set to the value appearing in hash-table1. Returns hash-table1.</p>
<h2 id="hash-table-intersection-hash-table1-hash-table2"><code>(hash-table-intersection! hash-table1 hash-table2)</code></h2>
<p>Deletes the associations from hash-table1 whose keys don’t also appear in hash-table2 and returns hash-table1.</p>
<h2 id="hash-table-difference-hash-table1-hash-table2"><code>(hash-table-difference! hash-table1 hash-table2)</code></h2>
<p>Deletes the associations of hash-table1 whose keys are also present in hash-table2 and returns hash-table1.</p>
<h2 id="hash-table-xor-hash-table1-hash-table2"><code>(hash-table-xor! hash-table1 hash-table2)</code></h2>
<p>Deletes the associations of hash-table1 whose keys are also present in hash-table2, and then adds the associations of hash-table2 whose keys are not present in hash-table1 to hash-table1. Returns hash-table1. # <code>(scheme load)</code></p>
<h2 id="load-filename-environment"><code>(load filename [environment])</code></h2>
<p>It is an error if <code>filename</code> is not a string.</p>
<p>An implementation-dependent operation is used to transform <code>filename</code> into the name of an existing file containing Scheme source code. The <code>load</code> procedure reads expressions and definitions from the file and evaluates them sequentially in the environment specified by <code>environment</code>. If <code>environment</code> is omitted, <code>(interaction-environment)</code> is assumed.</p>
<p>qIt is unspecified whether the results of the expressions are printed. The <code>load</code> procedure does not affect the values returned by <code>current-input-port</code> and <code>current-output-port</code>. It returns an unspecified value. # <code>(scheme inexact)</code></p>
<h2 id="acos-z"><code>(acos z)</code></h2>
<p>TODO</p>
<h2 id="asin-z"><code>(asin z)</code></h2>
<p>TODO</p>
<h2 id="atan-z"><code>(atan z)</code></h2>
<p>TODO</p>
<h2 id="cos-z"><code>(cos z)</code></h2>
<p>TODO</p>
<h2 id="exp-z-t"><code>(exp z t)</code></h2>
<p>TODO</p>
<h2 id="finite-z"><code>(finite? z)</code></h2>
<p>TODO</p>
<h2 id="infinite-z"><code>(infinite? z)</code></h2>
<p>TODO</p>
<h2 id="log-z"><code>(log z)</code></h2>
<p>TODO</p>
<h2 id="nan-z"><code>(nan? z)</code></h2>
<p>TODO</p>
<h2 id="sin">sin</h2>
<p>TODO</p>
<h2 id="sqrt">sqrt</h2>
<p>TODO</p>
<h2 id="tan">tan</h2>
<p>TODO # <code>(scheme write)</code></p>
<h2 id="display-obj-port"><code>(display obj [port])</code></h2>
<p>Writes a representation of obj to the given textual output port. Strings that appear in the written representation are output as if by write-string instead of by write. Symbols are not escaped. Character objects appear in the representation as if written by write-char instead of by write.</p>
<h2 id="write-obj-port"><code>(write obj [port])</code></h2>
<p>Writes a representation of obj to the given textual output port. Strings that appear in the written representation are enclosed in quotation marks, and within those strings backslash and quotation mark characters are escaped by backslashes. Symbols that contain non-ASCII characters are escaped with vertical lines. Character objects are written using the <code>#\</code> notation.</p>
<p>If obj contains cycles which would cause an infinite loop using the normal written representation, then at least the objects that form part of the cycle must be represented using datum labels as described in section 2.4. Datum labels must not be used if there are no cycles.</p>
<h2 id="write-simple-obj-port"><code>(write-simple obj [port])</code></h2>
<p>The write-simple procedure is the same as write, except that shared structure is never represented using datum labels. This can cause write-simple not to terminate if obj contains circular structure.</p>
<h2 id="write-shared-obj-port"><code>(write-shared obj [port])</code></h2>
<p>The write-shared procedure is the same as write, except that shared structure must be represented using datum labels for all pairs and vectors that appear more than once in the output. # <code>(scheme show)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-159/">SRFI-159</a>.</p>
<p>A library of procedures for formatting Scheme objects to text in various ways, and for easily concatenating, composing and extending these formatters efficiently without resorting to capturing and manipulating intermediate strings.</p>
<h2 id="show-output-dest-fmt-..."><code>(show output-dest fmt ...)</code></h2>
<p>The entry point for all formatting. Applies the fmt formatters in sequence, accumulating the output to output-dest. As with SRFI 28 format, output-dest can be an output port, #t to indicate the current output port, or #f to accumulate the output into a string and return that as the result of show.</p>
<p>Each fmt should be a formatter as discussed below. As a convenience, non-formatter arguments are also allowed and are formatted as if wrapped with displayed, described below, so that</p>
<div class="sourceCode" id="cb320"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb320-1"><a href="#cb320-1" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> <span class="st">&quot;π = &quot;</span> (with ((precision <span class="dv">2</span>)) (<span class="kw">acos</span> -<span class="dv">1</span>)) nl)</span></code></pre></div>
<p>would return the string “π = 3.14”.</p>
<p>As mentioned, formatters are an opaque type and cannot directly be applied outside of show. Custom formatters are built on the existing formatters, and as first class objects may be named or computed dynamically, so that:</p>
<div class="sourceCode" id="cb321"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb321-1"><a href="#cb321-1" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">let</span> ((~.2f (<span class="kw">lambda</span> (x) (with ((precision <span class="dv">2</span>)) x))))</span>
<span id="cb321-2"><a href="#cb321-2" aria-hidden="true" tabindex="-1"></a>        (show <span class="dv">#f</span> <span class="st">&quot;π = &quot;</span> (~.2f (<span class="kw">acos</span> -<span class="dv">1</span>)) nl))</span></code></pre></div>
<p>produces the same result. For typical uses you only need to combine the existing high level formatters described in the succeeding sections, but see the section Higher Order Formatters and State for control flow and state manipulation primitives.</p>
<p>The return value of show is the accumulated string if output-dest is #f and unspecified otherwise.</p>
<h2 id="displayed-obj"><code>(displayed obj)</code></h2>
<p>If obj is a formatter, returns obj as is. Otherwise, outputs obj using display semantics. Specifically, strings are output as if by write-string and characters are written as if by write-char. Other objects are output as with written (including nested strings and chars inside obj). This is the default behavior for top-level formats in show, each and most other high-level formatters.</p>
<h2 id="written-obj"><code>(written obj)</code></h2>
<p>Outputs obj using write semantics. Uses the current numeric formatting settings to the extent that the written result can still be passed to read, possibly with loss of precision. Specifically, the current radix is used if set to any of 2, 8, 10 or 16, and the fixed point precision is used if specified and the radix is 10.</p>
<div class="sourceCode" id="cb322"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb322-1"><a href="#cb322-1" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (written (<span class="kw">cons</span> <span class="dv">0</span> <span class="dv">1</span>)))</span>
<span id="cb322-2"><a href="#cb322-2" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;(0 . 1)&quot;</span></span>
<span id="cb322-3"><a href="#cb322-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb322-4"><a href="#cb322-4" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> <span class="fl">1.5</span> <span class="st">&quot; &quot;</span> (with ((precision <span class="dv">0</span>)) <span class="fl">1.5</span>))</span>
<span id="cb322-5"><a href="#cb322-5" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;1.5 2&quot;</span></span>
<span id="cb322-6"><a href="#cb322-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb322-7"><a href="#cb322-7" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> <span class="dv">1</span>/7 <span class="st">&quot; &quot;</span> (with ((precision <span class="dv">3</span>)) <span class="dv">1</span>/7)</span>
<span id="cb322-8"><a href="#cb322-8" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot; &quot;</span> (with ((precision <span class="dv">20</span>)) <span class="dv">1</span>/7))</span>
<span id="cb322-9"><a href="#cb322-9" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;1/7 0.143 0.14285714285714285714&quot;</span></span></code></pre></div>
<p>Implementations should allow arbitrary precision for exact rational numbers, for example, using string-segment from SRFI 152, the following code returns the first 100 Fibonacci numbers:</p>
<div class="sourceCode" id="cb323"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb323-1"><a href="#cb323-1" aria-hidden="true" tabindex="-1"></a>    (map <span class="kw">string-&gt;number</span></span>
<span id="cb323-2"><a href="#cb323-2" aria-hidden="true" tabindex="-1"></a>         (string-segment</span>
<span id="cb323-3"><a href="#cb323-3" aria-hidden="true" tabindex="-1"></a>          (show <span class="dv">#f</span> (with ((precision <span class="dv">2500</span>))</span>
<span id="cb323-4"><a href="#cb323-4" aria-hidden="true" tabindex="-1"></a>                     (<span class="op">/</span> <span class="dv">1000</span> (<span class="op">-</span> <span class="sc">#e</span><span class="fl">1e50</span> <span class="sc">#e</span><span class="fl">1e25</span> <span class="dv">1</span>))))</span>
<span id="cb323-5"><a href="#cb323-5" aria-hidden="true" tabindex="-1"></a>          <span class="dv">25</span>))</span></code></pre></div>
<h2 id="written-simply-obj"><code>(written-simply obj)</code></h2>
<p>As above, but doesn’t handle shared structures. Infinite loops can still be avoided if used inside a formatter that truncates data (see trimmed and fitted below).</p>
<h2 id="pretty-obj"><code>(pretty obj)</code></h2>
<p>Pretty-prints obj. The result should be identical to written except possibly for differences in whitespace to make the output resemble formatted source code. Implementations should print vectors and data lists (lists that don’t begin with a (nested) symbol) in a tabular format when possible to reduce vertical space.</p>
<h2 id="pretty-simply-obj"><code>(pretty-simply obj)</code></h2>
<p>As above but without sharing.</p>
<h2 id="escaped-str-quote-ch-esc-ch-renamer"><code>(escaped str [quote-ch esc-ch renamer])</code></h2>
<p>Outputs the string str, escaping any quote or escape characters. If esc-ch, which defaults to #\, is #f, escapes only the quote-ch, which defaults to #", by doubling it, as in SQL strings and CSV values. If renamer is provided, it should be a procedure of one character which maps that character to its escape value, e.g. #=&gt; #, or #f if there is no escape value.</p>
<div class="sourceCode" id="cb324"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb324-1"><a href="#cb324-1" aria-hidden="true" tabindex="-1"></a>    (show <span class="dv">#f</span> (escaped <span class="st">&quot;hi, bob!&quot;</span>))</span>
<span id="cb324-2"><a href="#cb324-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">=&gt;</span> <span class="st">&quot;hi, bob!&quot;</span></span>
<span id="cb324-3"><a href="#cb324-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-4"><a href="#cb324-4" aria-hidden="true" tabindex="-1"></a>    (show <span class="dv">#f</span> (escaped <span class="st">&quot;hi, </span><span class="ch">\&quot;</span><span class="st">bob!</span><span class="ch">\&quot;</span><span class="st">&quot;</span>))</span>
<span id="cb324-5"><a href="#cb324-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">=&gt;</span> <span class="st">&quot;hi, </span><span class="ch">\&quot;</span><span class="st">bob!</span><span class="ch">\&quot;</span><span class="st">&quot;</span></span></code></pre></div>
<h2 id="maybe-escaped-str-pred-quote-ch-esc-ch-renamer"><code>(maybe-escaped str pred [quote-ch esc-ch renamer])</code></h2>
<p>Like escaped, but first checks if any quoting is required (by the existence of either any quote or escape characters, or any character matching pred), and if so outputs the string in quotes and with escapes. Otherwise outputs the string as is. This is useful for quoting symbols and CSV output, etc.</p>
<div class="sourceCode" id="cb325"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb325-1"><a href="#cb325-1" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (maybe-escaped <span class="st">&quot;foo&quot;</span> <span class="kw">char-whitespace?</span> <span class="ch">#\&quot;</span>))</span>
<span id="cb325-2"><a href="#cb325-2" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;foo&quot;</span></span>
<span id="cb325-3"><a href="#cb325-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb325-4"><a href="#cb325-4" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (maybe-escaped <span class="st">&quot;foo bar&quot;</span> <span class="kw">char-whitespace?</span> <span class="ch">#\&quot;</span>))</span>
<span id="cb325-5"><a href="#cb325-5" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">foo bar</span><span class="ch">\&quot;</span><span class="st">&quot;</span></span>
<span id="cb325-6"><a href="#cb325-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb325-7"><a href="#cb325-7" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (maybe-escaped <span class="st">&quot;foo</span><span class="ch">\&quot;</span><span class="st">bar</span><span class="ch">\&quot;</span><span class="st">baz&quot;</span> <span class="kw">char-whitespace?</span> <span class="ch">#\&quot;</span>))</span>
<span id="cb325-8"><a href="#cb325-8" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">foo</span><span class="ch">\&quot;</span><span class="st">bar</span><span class="ch">\&quot;</span><span class="st">baz</span><span class="ch">\&quot;</span><span class="st">&quot;</span></span></code></pre></div>
<h2 id="numeric-num-radix-precision-sign-comma-comma-sep-decimal-sep"><code>(numeric num [radix precision sign comma comma-sep decimal-sep])</code></h2>
<p>Formats a single number num. You can optionally specify any radix from 2 to 36 (even if num isn’t an integer). precision forces a fixed-point format.</p>
<p>A sign of #t indicates to output a plus sign (+) for positive integers. However, if sign is a pair of two strings, it means to wrap negative numbers with the two strings. For example, (“(” . “)”) prints negative numbers in parentheses, financial style: -1.99 =&gt; (1.99).</p>
<ul>
<li><p>comma is an integer specifying the number of digits between commas.</p></li>
<li><p>comma-sep is the character to use for commas, defaulting to #,.</p></li>
<li><p>decimal-sep is the character to use for decimals, defaulting to #., or to #, (European style) if comma-sep is already #..</p></li>
</ul>
<p>These parameters may seem unwieldy, but they can also take their defaults from state variables, described below.</p>
<h2 id="numericcomma-num-base-precision-sign"><code>(numeric/comma num [base precision sign])</code></h2>
<p>Shortcut for numeric to print with commas.</p>
<div class="sourceCode" id="cb326"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb326-1"><a href="#cb326-1" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (numeric/comma <span class="dv">1234567</span>))</span>
<span id="cb326-2"><a href="#cb326-2" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;1,234,567&quot;</span></span></code></pre></div>
<h2 id="numericsi-num-base-separator"><code>(numeric/si num [base separator])</code></h2>
<p>Abbreviates num with an SI suffix as in the -h or –si option to many GNU commands. The base defaults to 1024, using suffix names like Ki, Mi, Gi, etc. Other bases (e.g. the standard 1000) have the suffixes k, M, G, etc. If separator is provided, it is inserted after the number, before any suffix.</p>
<div class="sourceCode" id="cb327"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb327-1"><a href="#cb327-1" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (numeric/si <span class="dv">608</span>))</span>
<span id="cb327-2"><a href="#cb327-2" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;608&quot;</span></span>
<span id="cb327-3"><a href="#cb327-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-4"><a href="#cb327-4" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (numeric/si <span class="dv">608</span>) <span class="st">&quot;B&quot;</span>)</span>
<span id="cb327-5"><a href="#cb327-5" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;608B&quot;</span></span>
<span id="cb327-6"><a href="#cb327-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-7"><a href="#cb327-7" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (numeric/si <span class="dv">608</span> <span class="dv">1000</span> <span class="st">&quot; &quot;</span>) <span class="st">&quot;B&quot;</span>)</span>
<span id="cb327-8"><a href="#cb327-8" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;608 B&quot;</span></span>
<span id="cb327-9"><a href="#cb327-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-10"><a href="#cb327-10" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (numeric/si <span class="dv">3986</span>))</span>
<span id="cb327-11"><a href="#cb327-11" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;3.9Ki&quot;</span></span>
<span id="cb327-12"><a href="#cb327-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-13"><a href="#cb327-13" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (numeric/si <span class="dv">3986</span> <span class="dv">1000</span>) <span class="st">&quot;B&quot;</span>)</span>
<span id="cb327-14"><a href="#cb327-14" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;4kB&quot;</span></span>
<span id="cb327-15"><a href="#cb327-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-16"><a href="#cb327-16" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (numeric/si <span class="fl">1.23e-6</span> <span class="dv">1000</span>) <span class="st">&quot;m&quot;</span>)</span>
<span id="cb327-17"><a href="#cb327-17" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;1.2µm&quot;</span></span>
<span id="cb327-18"><a href="#cb327-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-19"><a href="#cb327-19" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (numeric/si <span class="fl">1.23e-6</span> <span class="dv">1000</span> <span class="st">&quot; &quot;</span>) <span class="st">&quot;m&quot;</span>)</span>
<span id="cb327-20"><a href="#cb327-20" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;1.2 µm&quot;</span></span>
<span id="cb327-21"><a href="#cb327-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-22"><a href="#cb327-22" aria-hidden="true" tabindex="-1"></a>See https://en.wikipedia.org/wiki/Metric_prefix for the complete <span class="kw">list</span> of abbreviations.</span>
<span id="cb327-23"><a href="#cb327-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-24"><a href="#cb327-24" aria-hidden="true" tabindex="-1"></a>    (numeric/fitted width n <span class="op">.</span> args)</span>
<span id="cb327-25"><a href="#cb327-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-26"><a href="#cb327-26" aria-hidden="true" tabindex="-1"></a>Like numeric, but <span class="kw">if</span> the result doesn&#39;t fit in width using the current precision, output instead a <span class="kw">string</span> of hashes rather than showing an incorrectly truncated number. For example</span>
<span id="cb327-27"><a href="#cb327-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-28"><a href="#cb327-28" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (with ((precision <span class="dv">2</span>)) (numeric/fitted <span class="dv">4</span> <span class="fl">1.25</span>)))</span>
<span id="cb327-29"><a href="#cb327-29" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;1.25&quot;</span></span>
<span id="cb327-30"><a href="#cb327-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-31"><a href="#cb327-31" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (with ((precision <span class="dv">2</span>)) (numeric/fitted <span class="dv">4</span> <span class="fl">12.345</span>)))</span>
<span id="cb327-32"><a href="#cb327-32" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;#.##&quot;</span></span></code></pre></div>
<h2 id="nl"><code>nl</code></h2>
<p>Outputs a newline.</p>
<div class="sourceCode" id="cb328"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb328-1"><a href="#cb328-1" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> nl)</span>
<span id="cb328-2"><a href="#cb328-2" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span></span></code></pre></div>
<h2 id="fl"><code>fl</code></h2>
<p>Short for “fresh line,” outputs a newline only if we’re not already at the start of a line.</p>
<div class="sourceCode" id="cb329"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb329-1"><a href="#cb329-1" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> fl)</span>
<span id="cb329-2"><a href="#cb329-2" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;&quot;</span></span>
<span id="cb329-3"><a href="#cb329-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb329-4"><a href="#cb329-4" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> <span class="st">&quot;hi&quot;</span> fl)</span>
<span id="cb329-5"><a href="#cb329-5" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;hi</span><span class="ch">\n</span><span class="st">&quot;</span></span>
<span id="cb329-6"><a href="#cb329-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb329-7"><a href="#cb329-7" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> <span class="st">&quot;hi&quot;</span> nl fl)</span>
<span id="cb329-8"><a href="#cb329-8" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;hi</span><span class="ch">\n</span><span class="st">&quot;</span></span></code></pre></div>
<h2 id="space-to-column"><code>(space-to column)</code></h2>
<p>Outputs spaces up to the given column. If the current column is already &gt;= column, does nothing. The character used for spacing is the current value of pad-char, described below, which defaults to space. Columns are zero-based.</p>
<div class="sourceCode" id="cb330"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb330-1"><a href="#cb330-1" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> <span class="st">&quot;a&quot;</span> (space-to <span class="dv">5</span>) <span class="st">&quot;b&quot;</span>)</span>
<span id="cb330-2"><a href="#cb330-2" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;a    b&quot;</span></span>
<span id="cb330-3"><a href="#cb330-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb330-4"><a href="#cb330-4" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> <span class="st">&quot;a&quot;</span> (space-to <span class="dv">0</span>) <span class="st">&quot;b&quot;</span>)</span>
<span id="cb330-5"><a href="#cb330-5" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;ab&quot;</span></span></code></pre></div>
<h2 id="tab-to-tab-width"><code>(tab-to [tab-width])</code></h2>
<p>Outputs spaces up to the next tab stop, using tab stops of width tab-width, which defaults to 8. If already on a tab stop, does nothing. If you want to ensure you always tab at least one space, you can use (each ” ” (tab-to width)). Columns are zero-based.</p>
<pre><code>(show #f (tab-to 5) &quot;b&quot;)
=&gt; &quot;b&quot;

(show #f &quot;a&quot; (tab-to 5) &quot;b&quot;)
=&gt; &quot;a    b&quot;

(show #f &quot;abcdefghi&quot; (tab-to 5) &quot;b&quot;)
=&gt; &quot;abcdefghi b&quot;</code></pre>
<h2 id="nothing"><code>nothing</code></h2>
<p>Outputs nothing (useful in combinators and as a default noop in conditionals).</p>
<pre><code>(show #f &quot;a&quot; nothing &quot;b&quot;)
=&gt; &quot;ab&quot;</code></pre>
<h2 id="each-fmt-..."><code>(each fmt ...)</code></h2>
<p>Applies each fmt in sequence, as in the top-level of show.</p>
<div class="sourceCode" id="cb333"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb333-1"><a href="#cb333-1" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (each <span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span>))</span>
<span id="cb333-2"><a href="#cb333-2" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;ab&quot;</span></span></code></pre></div>
<h2 id="each-in-list-list-of-fmts"><code>(each-in-list list-of-fmts)</code></h2>
<p>Equivalent to (apply each list-of-fmts) but may be more efficient.</p>
<h2 id="joined-mapper-list-sep"><code>(joined mapper list [sep])</code></h2>
<p>Formats each element elt of list with (mapper elt), inserting sep in between. sep defaults to the empty string, but can be any format or string.</p>
<div class="sourceCode" id="cb334"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb334-1"><a href="#cb334-1" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (joined displayed &#39;(a b c) <span class="st">&quot;, &quot;</span>))</span>
<span id="cb334-2"><a href="#cb334-2" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;a, b, c&quot;</span></span></code></pre></div>
<h2 id="joinedprefix-mapper-list-sep"><code>(joined/prefix mapper list [sep])</code></h2>
<h2 id="joinedsuffix-mapper-list-sep"><code>(joined/suffix mapper list [sep])</code></h2>
<div class="sourceCode" id="cb335"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb335-1"><a href="#cb335-1" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (joined/prefix displayed &#39;(usr local bin) <span class="st">&quot;/&quot;</span>))</span>
<span id="cb335-2"><a href="#cb335-2" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;/usr/local/bin&quot;</span></span>
<span id="cb335-3"><a href="#cb335-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb335-4"><a href="#cb335-4" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (joined/suffix displayed &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) nl))</span>
<span id="cb335-5"><a href="#cb335-5" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;1</span><span class="ch">\n</span><span class="st">2</span><span class="ch">\n</span><span class="st">3</span><span class="ch">\n</span><span class="st">&quot;</span></span></code></pre></div>
<p>As joined, but inserts sep before/after every element.</p>
<h2 id="joinedlast-mapper-last-mapper-list-sep"><code>(joined/last mapper last-mapper list [sep])</code></h2>
<p>As joined, but the last element of the list is formatted with last-mapper instead.</p>
<pre><code>    (show #f (joined/last displayed
                          (lambda (last) (each &quot;and &quot; last))
                          &#39;(lions tigers bears)
                          &quot;, &quot;))
    =&gt; &quot;lions, tigers, and bears&quot;</code></pre>
<h2 id="joineddot-mapper-dot-mapper-list-sep"><code>(joined/dot mapper dot-mapper list [sep])</code></h2>
<p>As joined, but if the list is a dotted list, then formats the dotted value with dot-mapper instead.</p>
<pre><code>    (show #f
          &quot;(&quot;
          (joined/dot displayed
              (lambda (dot) (each &quot;. &quot; dot))
              &#39;(1 2 . 3)
              &quot; &quot;)
          &quot;)&quot;)
    =&gt; &quot;(1 2 . 3)&quot;</code></pre>
<h2 id="joinedrange-mapper-start-end-sep"><code>(joined/range mapper start [end sep])</code></h2>
<p>As joined, but counts from start (inclusive) to end (exclusive), formatting each integer in the range with mapper. If end is #f or unspecified, produces an infinite stream of output.</p>
<div class="sourceCode" id="cb338"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb338-1"><a href="#cb338-1" aria-hidden="true" tabindex="-1"></a>    (show <span class="dv">#f</span> (joined/range displayed <span class="dv">0</span> <span class="dv">5</span> <span class="st">&quot; &quot;</span>))</span>
<span id="cb338-2"><a href="#cb338-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">=&gt;</span> <span class="st">&quot;0 1 2 3 4&quot;</span></span></code></pre></div>
<h2 id="padded-width-fmt-..."><code>(padded width fmt ...)</code></h2>
<h2 id="paddedright-width-fmt-..."><code>(padded/right width fmt ...)</code></h2>
<h2 id="paddedboth-width-fmt-..."><code>(padded/both width fmt ...)</code></h2>
<p>Analogs of SRFI 13 string-pad, these add extra space to the left, right or both sides of the output generated by the fmts to pad it to width. If width is exceeded, has no effect. padded/both will include one more extra space on the right side of the output if the difference is odd.</p>
<p>padded/right is guaranteed not to accumulate any intermediate data.</p>
<p>Note these are column-oriented padders, so won’t necessarily work with multi-line output (padding doesn’t seem a likely operation for multi-line output).</p>
<div class="sourceCode" id="cb339"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb339-1"><a href="#cb339-1" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (padded <span class="dv">5</span> <span class="st">&quot;abc&quot;</span>))</span>
<span id="cb339-2"><a href="#cb339-2" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;  abc&quot;</span></span>
<span id="cb339-3"><a href="#cb339-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb339-4"><a href="#cb339-4" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (padded/right <span class="dv">5</span> <span class="st">&quot;abc&quot;</span>))</span>
<span id="cb339-5"><a href="#cb339-5" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;abc  &quot;</span></span>
<span id="cb339-6"><a href="#cb339-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb339-7"><a href="#cb339-7" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (padded/both <span class="dv">5</span> <span class="st">&quot;abc&quot;</span>))</span>
<span id="cb339-8"><a href="#cb339-8" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot; abc &quot;</span></span></code></pre></div>
<h2 id="trimmed-width-fmt-..."><code>(trimmed width fmt ...)</code></h2>
<h2 id="trimmedright-width-fmt-..."><code>(trimmed/right width fmt ...)</code></h2>
<h2 id="trimmedboth-width-fmt-..."><code>(trimmed/both width fmt ...)</code></h2>
<p>Analogs of SRFI 13 string-trim, these truncate the output of the fmts to force it in under width columns. As soon as any of the fmts exceeds width, stop formatting and truncate the result, returning control to whoever called trimmed. If width is not exceeded, is equivalent to each.</p>
<p>If a truncation ellipsis is set, then when any truncation occurs trimmed and trimmed/right will prepend and append the ellipsis, respectively. trimmed/both will both prepend and append. The length of the ellipsis will be considered when truncating the original string, so that the total width will never be longer than width. It is an error if width is less than the length of ellipsis, or double the length for /both.</p>
<div class="sourceCode" id="cb340"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb340-1"><a href="#cb340-1" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (with ((ellipsis <span class="st">&quot;...&quot;</span>)) (trimmed <span class="dv">5</span> <span class="st">&quot;abcde&quot;</span>)))</span>
<span id="cb340-2"><a href="#cb340-2" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span>  <span class="st">&quot;abcde&quot;</span></span>
<span id="cb340-3"><a href="#cb340-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb340-4"><a href="#cb340-4" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (with ((ellipses <span class="st">&quot;...&quot;</span>)) (trimmed <span class="dv">5</span> <span class="st">&quot;abcdef&quot;</span>)))</span>
<span id="cb340-5"><a href="#cb340-5" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span>  <span class="st">&quot;ab...&quot;</span></span></code></pre></div>
<p>It is an error if width is shorter than the width of the ellipsis.</p>
<h2 id="trimmedlazy-width-fmt-..."><code>(trimmed/lazy width fmt ...)</code></h2>
<p>A variant of trimmed which generates each fmt in left to right order, and truncates and terminates immediately if more than width characters are generated. Thus this is safe to use with an infinite amount of output, e.g. from written-simply on an infinite list.</p>
<h2 id="fitted-width-fmt-..."><code>(fitted width fmt ...)</code></h2>
<h2 id="fittedright-width-fmt-..."><code>(fitted/right width fmt ...)</code></h2>
<h2 id="fittedboth-width-fmt-..."><code>(fitted/both width fmt ...)</code></h2>
<p>A combination of padded and trimmed that ensures that the output width is exactly width, truncating if it goes over and padding if it goes under.</p>
<h2 id="columnar-column-..."><code>(columnar column ...)</code></h2>
<p>Formats each column side-by-side, i.e. as though each were formatted separately and then the individual lines concatenated together. The current line width (from the width state variable) is divided evenly among the columns, and all but the last column are right-padded. For example</p>
<div class="sourceCode" id="cb341"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb341-1"><a href="#cb341-1" aria-hidden="true" tabindex="-1"></a>    (show <span class="dv">#t</span> (columnar (displayed <span class="st">&quot;abc</span><span class="ch">\n</span><span class="st">def</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb341-2"><a href="#cb341-2" aria-hidden="true" tabindex="-1"></a>                       (displayed <span class="st">&quot;123</span><span class="ch">\n</span><span class="st">456</span><span class="ch">\n</span><span class="st">&quot;</span>)))</span></code></pre></div>
<p>outputs</p>
<div class="sourceCode" id="cb342"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb342-1"><a href="#cb342-1" aria-hidden="true" tabindex="-1"></a>    abc     <span class="dv">123</span></span>
<span id="cb342-2"><a href="#cb342-2" aria-hidden="true" tabindex="-1"></a>    def     <span class="dv">456</span></span></code></pre></div>
<p>assuming a 16-char width (the left side gets half the width, or 8 spaces, and is left aligned). Note that we explicitly use displayed instead of the strings directly. This is because columnar treats raw strings as literals inserted into the given location on every line, to be used as borders, for example:</p>
<div class="sourceCode" id="cb343"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb343-1"><a href="#cb343-1" aria-hidden="true" tabindex="-1"></a>    (show <span class="dv">#t</span> (columnar <span class="st">&quot;/* &quot;</span> (displayed <span class="st">&quot;abc</span><span class="ch">\n</span><span class="st">def</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb343-2"><a href="#cb343-2" aria-hidden="true" tabindex="-1"></a>                       <span class="st">&quot; | &quot;</span> (displayed <span class="st">&quot;123</span><span class="ch">\n</span><span class="st">456</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb343-3"><a href="#cb343-3" aria-hidden="true" tabindex="-1"></a>                       <span class="st">&quot; */&quot;</span>))</span></code></pre></div>
<p>would output</p>
<pre><code>    /* abc | 123 */
    /* def | 456 */</code></pre>
<p>You may also prefix any column with any of the symbols ’left, ’right or ’center to control the justification. The symbol ’infinite can be used to indicate the column generates an infinite stream of output.</p>
<p>You can further prefix any column with a width modifier. Any positive integer is treated as a fixed width, ignoring the available width. Any real number between 0 and 1 indicates a fraction of the available width (after subtracting out any fixed widths). Columns with unspecified width divide up the remaining width evenly. If the extra space does not divide evenly, it is allocated column-wise left to right, e.g. if the width of 78 is divided among 5 columns, the column widths become 16, 16, 16, 15, 15 in order.</p>
<p>Note that columnar builds its output incrementally, interleaving calls to the generators until each has produced a line, then concatenating that line together and outputting it. This is important because as noted above, some columns may produce an infinite stream of output, and in general you may want to format data larger than can fit into memory. Thus columnar would be suitable for line numbering a file of arbitrary size, or implementing the Unix yes(1) command, etc.</p>
<h2 id="tabular-column-..."><code>(tabular column ...)</code></h2>
<p>Equivalent to columnar except that each column is padded at least to the minimum width required on any of its lines. Thus</p>
<div class="sourceCode" id="cb345"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb345-1"><a href="#cb345-1" aria-hidden="true" tabindex="-1"></a>    (show <span class="dv">#t</span> (tabular <span class="st">&quot;|&quot;</span> (each <span class="st">&quot;a</span><span class="ch">\n</span><span class="st">bc</span><span class="ch">\n</span><span class="st">def</span><span class="ch">\n</span><span class="st">&quot;</span>) <span class="st">&quot;|&quot;</span></span>
<span id="cb345-2"><a href="#cb345-2" aria-hidden="true" tabindex="-1"></a>                          (each <span class="st">&quot;123</span><span class="ch">\n</span><span class="st">45</span><span class="ch">\n</span><span class="st">6</span><span class="ch">\n</span><span class="st">&quot;</span>) <span class="st">&quot;|&quot;</span>))</span></code></pre></div>
<p>outputs</p>
<pre><code>    |a  |123|
    |bc |45 |
    |def|6  |</code></pre>
<p>This makes it easier to generate tables without knowing widths in advance. However, because it requires generating the entire output in advance to determine the correct column widths, tabular cannot format a table larger than would fit in memory. (wrapped fmt …)</p>
<p>Behaves like each, except text is accumulated and lines are wrapped to fit in the current width as in the Unix fmt(1) command. Specifically, words are tokenized by splitting on all characters which satisfy the predicate in the parameter word-separator?, which defaults to char-whitespace?. Words are grouped into lines separating them by space, and line breaks are introduced to minimize the sum of the cube of trailing whitespace on every line.</p>
<h2 id="wrappedlist-list-of-strings"><code>(wrapped/list list-of-strings)</code></h2>
<p>Like wrapped, but taking a pre-tokenized list of strings.</p>
<h2 id="wrappedchar-fmt-..."><code>(wrapped/char fmt ...)</code></h2>
<p>As wrapped, but splits simply on individual characters exactly as the current width is reached on each line. Thus there is nothing to optimize and this formatter doesn’t buffer output.</p>
<h2 id="justified-format-..."><code>(justified &lt;format&gt; ...)</code></h2>
<p>Like wrapped except the lines are full-justified.</p>
<div class="sourceCode" id="cb347"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb347-1"><a href="#cb347-1" aria-hidden="true" tabindex="-1"></a>    (<span class="ex">define</span><span class="fu"> func</span></span>
<span id="cb347-2"><a href="#cb347-2" aria-hidden="true" tabindex="-1"></a>      &#39;(<span class="ex">define</span><span class="fu"> </span>(fold kons knil ls)</span>
<span id="cb347-3"><a href="#cb347-3" aria-hidden="true" tabindex="-1"></a>         (<span class="kw">let</span> lp ((ls ls) (acc knil))</span>
<span id="cb347-4"><a href="#cb347-4" aria-hidden="true" tabindex="-1"></a>           (<span class="kw">if</span> (<span class="kw">null?</span> ls) acc (lp (<span class="kw">cdr</span> ls) (kons (<span class="kw">car</span> ls) acc))))))</span>
<span id="cb347-5"><a href="#cb347-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb347-6"><a href="#cb347-6" aria-hidden="true" tabindex="-1"></a>    (<span class="ex">define</span><span class="fu"> doc</span></span>
<span id="cb347-7"><a href="#cb347-7" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">string-append</span></span>
<span id="cb347-8"><a href="#cb347-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;The fundamental list iterator.  Applies KONS to each &quot;</span></span>
<span id="cb347-9"><a href="#cb347-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;element of LS and the result of the previous application, &quot;</span></span>
<span id="cb347-10"><a href="#cb347-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;beginning with KNIL.  With KONS as CONS and KNIL as &#39;(), &quot;</span></span>
<span id="cb347-11"><a href="#cb347-11" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;equivalent to REVERSE.&quot;</span>))</span>
<span id="cb347-12"><a href="#cb347-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb347-13"><a href="#cb347-13" aria-hidden="true" tabindex="-1"></a>    (show <span class="dv">#t</span> (columnar (pretty func) <span class="st">&quot; ; &quot;</span> (justified doc)))</span></code></pre></div>
<p>outputs</p>
<div class="sourceCode" id="cb348"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb348-1"><a href="#cb348-1" aria-hidden="true" tabindex="-1"></a>    (<span class="ex">define</span><span class="fu"> </span>(fold kons knil ls)          <span class="co">; The   fundamental   list   iterator.</span></span>
<span id="cb348-2"><a href="#cb348-2" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">let</span> lp ((ls ls) (acc knil))       <span class="co">; Applies  KONS  to  each  element  of</span></span>
<span id="cb348-3"><a href="#cb348-3" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">if</span> (<span class="kw">null?</span> ls)                   <span class="co">; LS  and  the  result of the previous</span></span>
<span id="cb348-4"><a href="#cb348-4" aria-hidden="true" tabindex="-1"></a>            acc                          <span class="co">; application,  beginning  with  KNIL.</span></span>
<span id="cb348-5"><a href="#cb348-5" aria-hidden="true" tabindex="-1"></a>            (lp (<span class="kw">cdr</span> ls)                 <span class="co">; With  KONS  as CONS and KNIL as &#39;(),</span></span>
<span id="cb348-6"><a href="#cb348-6" aria-hidden="true" tabindex="-1"></a>                (kons (<span class="kw">car</span> ls) acc)))))  <span class="co">; equivalent to REVERSE.</span></span></code></pre></div>
<h2 id="from-file-pathname"><code>(from-file pathname)</code></h2>
<p>Displays the contents of the file pathname one line at a time, so that in typical formatters such as columnar only constant memory is consumed, making this suitable for formatting files of arbitrary size.</p>
<h2 id="line-numbers-start"><code>(line-numbers [start])</code></h2>
<p>A convenience utility, just formats an infinite stream of numbers (in the current radix) beginning with start, which defaults to 1.</p>
<p>The Unix nl(1) utility could be implemented as:</p>
<div class="sourceCode" id="cb349"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb349-1"><a href="#cb349-1" aria-hidden="true" tabindex="-1"></a>    (show <span class="dv">#t</span> (columnar <span class="dv">4</span> &#39;right &#39;infinite (line-numbers)</span>
<span id="cb349-2"><a href="#cb349-2" aria-hidden="true" tabindex="-1"></a>                       <span class="st">&quot; &quot;</span> (from-file <span class="st">&quot;read-line.scm&quot;</span>)))</span></code></pre></div>
<p>which might output:</p>
<div class="sourceCode" id="cb350"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb350-1"><a href="#cb350-1" aria-hidden="true" tabindex="-1"></a>       <span class="dv">1</span></span>
<span id="cb350-2"><a href="#cb350-2" aria-hidden="true" tabindex="-1"></a>       <span class="dv">2</span> (<span class="ex">define</span><span class="fu"> </span>(read-line <span class="op">.</span> o)</span>
<span id="cb350-3"><a href="#cb350-3" aria-hidden="true" tabindex="-1"></a>       <span class="dv">3</span>   (<span class="kw">let</span> ((port (<span class="kw">if</span> (<span class="kw">pair?</span> o) (<span class="kw">car</span> o) (<span class="kw">current-input-port</span>))))</span>
<span id="cb350-4"><a href="#cb350-4" aria-hidden="true" tabindex="-1"></a>       <span class="dv">4</span>     (<span class="kw">let</span> lp ((res &#39;()))</span>
<span id="cb350-5"><a href="#cb350-5" aria-hidden="true" tabindex="-1"></a>       <span class="dv">5</span>       (<span class="kw">let</span> ((c (<span class="kw">read-char</span> port)))</span>
<span id="cb350-6"><a href="#cb350-6" aria-hidden="true" tabindex="-1"></a>       <span class="dv">6</span>         (<span class="kw">if</span> (<span class="kw">or</span> (<span class="kw">eof-object?</span> c) (<span class="kw">eqv?</span> c <span class="ch">#\</span><span class="er">newline</span>))</span>
<span id="cb350-7"><a href="#cb350-7" aria-hidden="true" tabindex="-1"></a>       <span class="dv">7</span>             (<span class="kw">list-&gt;string</span> (<span class="kw">reverse</span> res))</span>
<span id="cb350-8"><a href="#cb350-8" aria-hidden="true" tabindex="-1"></a>       <span class="dv">8</span>             (lp (<span class="kw">cons</span> c res)))))))</span></code></pre></div>
<h2 id="as-red-fmt-..."><code>(as-red fmt ...)</code></h2>
<h2 id="as-blue-fmt-..."><code>(as-blue fmt ...)</code></h2>
<h2 id="as-green-fmt-..."><code>(as-green fmt ...)</code></h2>
<h2 id="as-cyan-fmt-..."><code>(as-cyan fmt ...)</code></h2>
<h2 id="as-yellow-fmt-..."><code>(as-yellow fmt ...)</code></h2>
<h2 id="as-magenta-fmt-..."><code>(as-magenta fmt ...)</code></h2>
<h2 id="as-white-fmt-..."><code>(as-white fmt ...)</code></h2>
<h2 id="as-black-fmt-..."><code>(as-black fmt ...)</code></h2>
<h2 id="as-bold-fmt-..."><code>(as-bold fmt ...)</code></h2>
<h2 id="as-underline-fmt-..."><code>(as-underline fmt ...)</code></h2>
<p>Outputs the formatters colored or (boldened or underline) with ANSI escapes, for use when formatting to a terminal.</p>
<h2 id="as-unicode-fmt-..."><code>(as-unicode fmt ...)</code></h2>
<p>Equivalent to</p>
<div class="sourceCode" id="cb351"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb351-1"><a href="#cb351-1" aria-hidden="true" tabindex="-1"></a>(with ((string-width unicode-terminal-width)) fmt <span class="op">...</span>)</span></code></pre></div>
<p>Padding, trimming and tabbing, etc. will generally not do the right thing in the presence of zero-width and double-width Unicode characters. This formatter overrides the string-width state var used in column tracking to do the right thing in such cases, considering Unicode double or full width characters as 2 characters wide (as they typically are in fixed-width terminals), while treating combining and non-spacing characters as 0 characters wide.</p>
<div class="sourceCode" id="cb352"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb352-1"><a href="#cb352-1" aria-hidden="true" tabindex="-1"></a><span class="co">;; 3 characters padded to 5</span></span>
<span id="cb352-2"><a href="#cb352-2" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (with ((pad-char <span class="ch">#\〜</span>)) (padded/both <span class="dv">5</span> <span class="st">&quot;日本語&quot;</span>)))</span>
<span id="cb352-3"><a href="#cb352-3" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;〜日本語〜&quot;</span></span>
<span id="cb352-4"><a href="#cb352-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb352-5"><a href="#cb352-5" aria-hidden="true" tabindex="-1"></a><span class="co">;; the 3 characters have a terminal width of 6 so are not padded</span></span>
<span id="cb352-6"><a href="#cb352-6" aria-hidden="true" tabindex="-1"></a>(show <span class="dv">#f</span> (as-unicode (with ((pad-char <span class="ch">#\〜</span>)) (padded/both <span class="dv">5</span> <span class="st">&quot;日本語&quot;</span>))))</span>
<span id="cb352-7"><a href="#cb352-7" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;日本語&quot;</span></span></code></pre></div>
<h2 id="unicode-terminal-width-str"><code>(unicode-terminal-width str)</code></h2>
<p>A utility function which returns the integer number of columns str would require in a terminal, according to the following rules:</p>
<ul>
<li><p>non-spacing characters (format control characters with the property Cf, or non-spacing marks with the property Mn) count as 0 columns</p></li>
<li><p>characters with the East Asian Wide (W) or East Asian Fullwidth (F) properties, according to Unicode TR #11, count as 2 columns</p></li>
<li><p>characters with the Halfwidth (H) or Narrow (Na) should count as 1 column</p></li>
<li><p>characters with the Neutral (N) non-East Asian also count as 1 column</p></li>
<li><p>characters with the Ambiguous (A) property are implementation defined</p></li>
<li><p>ANSI terminal escapes, as output by the color formatters above, count as 0 columns</p></li>
<li><p>the tab character is implementation defined</p></li>
<li><p>Implementations should support the properties from at least the current Unicode specification at time of writing this SRFI, 10.0.0. Higher Order Formatters and State</p></li>
</ul>
<p>Formatters up to this point have been simple accumulators of output, with no control flow or handling of state. Both of these are provided by fn and with for getting and setting state, respectively.</p>
<p>A formatter is essentially an environment monad, although the underlying implementation is unspecified.</p>
<h2 id="fn-id-state-var-...-expr-...-fmt"><code>(fn ((id state-var) ...) expr ... fmt)</code></h2>
<p>Short for “function,” this is the analog to lambda. Returns a formatter which on application evaluates each expr and fmt in left-to-right order, in a lexical environment extended with each identifier id bound to the current value of the state variable named by the symbol state-var. The result of the fmt is then applied as a formatter.</p>
<p>As a convenience, any (id state-var) list may be abbreviated as simply id, indicating id is bound to the state variable of the same (symbol) name.</p>
<div class="sourceCode" id="cb353"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb353-1"><a href="#cb353-1" aria-hidden="true" tabindex="-1"></a>    (show <span class="dv">#f</span> <span class="st">&quot;column: &quot;</span> (fn (col) col))</span>
<span id="cb353-2"><a href="#cb353-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">=&gt;</span> <span class="st">&quot;column: 8&quot;</span></span>
<span id="cb353-3"><a href="#cb353-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb353-4"><a href="#cb353-4" aria-hidden="true" tabindex="-1"></a>    (show <span class="dv">#f</span> <span class="st">&quot;column: &quot;</span> (fn ((col1 col))</span>
<span id="cb353-5"><a href="#cb353-5" aria-hidden="true" tabindex="-1"></a>                         (each col1 <span class="st">&quot;, &quot;</span> (fn ((col2 col)) col2))))</span>
<span id="cb353-6"><a href="#cb353-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">=&gt;</span> <span class="st">&quot;column: 8, 11&quot;</span></span></code></pre></div>
<p>The trivial case of no state variables is often useful to allow for lazy applications of formatters, needed for conditional formatting and loops. For example:</p>
<div class="sourceCode" id="cb354"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb354-1"><a href="#cb354-1" aria-hidden="true" tabindex="-1"></a>    (show <span class="dv">#t</span> (<span class="kw">let</span> lp ((ls ls))</span>
<span id="cb354-2"><a href="#cb354-2" aria-hidden="true" tabindex="-1"></a>               (<span class="kw">if</span> (<span class="kw">pair?</span> ls)</span>
<span id="cb354-3"><a href="#cb354-3" aria-hidden="true" tabindex="-1"></a>                   (each (<span class="kw">car</span> ls) (lp (<span class="kw">cdr</span> ls)))</span>
<span id="cb354-4"><a href="#cb354-4" aria-hidden="true" tabindex="-1"></a>                   nothing)))</span></code></pre></div>
<p>would eagerly create a formatter concatenating every element of ls before starting to accumulate any output, whereas</p>
<div class="sourceCode" id="cb355"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb355-1"><a href="#cb355-1" aria-hidden="true" tabindex="-1"></a>    (show <span class="dv">#t</span> (<span class="kw">let</span> lp ((ls ls))</span>
<span id="cb355-2"><a href="#cb355-2" aria-hidden="true" tabindex="-1"></a>               (<span class="kw">if</span> (<span class="kw">pair?</span> ls)</span>
<span id="cb355-3"><a href="#cb355-3" aria-hidden="true" tabindex="-1"></a>                   (each (<span class="kw">car</span> ls) (fn () (lp (<span class="kw">cdr</span> ls))))</span>
<span id="cb355-4"><a href="#cb355-4" aria-hidden="true" tabindex="-1"></a>                   nothing)))</span></code></pre></div>
<p>would lazily apply the formatters one at a time.</p>
<h2 id="with-state-var-value-...-fmt-..."><code>(with ((state-var value) ...) fmt ...)</code></h2>
<p>Conceptually the formatting equivalent of parameterize, temporarily altering state variables. Applies each of the formatters fmt with each state-var bound to the corresponding value. The resulting state is then updated to restore each state-var to its original value.</p>
<div class="sourceCode" id="cb356"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb356-1"><a href="#cb356-1" aria-hidden="true" tabindex="-1"></a>(with! (state-var value) <span class="op">...</span>)</span></code></pre></div>
<p>Similar to with but does not restore the original values, changing the value of each state-var for any remaining formatters in a sequence.</p>
<h2 id="forked-fmt1-fmt2"><code>(forked fmt1 fmt2)</code></h2>
<p>Calls fmt1 on (a conceptual copy of) the current state, then fmt2 on the same original state as though fmt1 had not been called.</p>
<h2 id="call-with-output-formatter-mapper"><code>(call-with-output formatter mapper)</code></h2>
<p>A utility, calls formatter on a copy of the current state (as with forked), accumulating the results into a string. Then calls the formatter resulting from (mapper result-string) on the original state.</p>
<h2 id="port"><code>port</code></h2>
<p>The textual port output is written to, this can be overridden to capture intermediate output.</p>
<h2 id="row"><code>row</code></h2>
<p>The current row of output.</p>
<h2 id="col"><code>col</code></h2>
<p>The current column of output, used for padding and spacing, etc.</p>
<h2 id="width"><code>width</code></h2>
<p>The current line width, used for wrapping, pretty-printing, and columnar formatting. The default is implementation-defined.</p>
<h2 id="output"><code>output</code></h2>
<p>The underlying standard formatter for writing a single string. The default value outputs the string while tracking the current row and col. This can be overridden both to capture intermediate output and perform transformations on strings before outputting, but should generally wrap the existing output to preserve expected behavior.</p>
<h2 id="writer"><code>writer</code></h2>
<p>The mapper for automatic formatting of non-string/char values in top-level show, each and other formatters. Default value is implementation-defined.</p>
<h2 id="string-width"><code>string-width</code></h2>
<p>A function of a single string, it returns the length in columns of that string, used by the default output.</p>
<h2 id="pad-char"><code>pad-char</code></h2>
<p>The character used by space-to, tab-to and other padding formatters.</p>
<div class="sourceCode" id="cb357"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb357-1"><a href="#cb357-1" aria-hidden="true" tabindex="-1"></a>    (<span class="ex">define</span><span class="fu"> </span>(print-table-of-contents alist)</span>
<span id="cb357-2"><a href="#cb357-2" aria-hidden="true" tabindex="-1"></a>      (<span class="ex">define</span><span class="fu"> </span>(print-line x)</span>
<span id="cb357-3"><a href="#cb357-3" aria-hidden="true" tabindex="-1"></a>        (each (<span class="kw">car</span> x) (space-to <span class="dv">72</span>) (padded <span class="dv">3</span> (<span class="kw">cdr</span> x))))</span>
<span id="cb357-4"><a href="#cb357-4" aria-hidden="true" tabindex="-1"></a>      (show <span class="dv">#t</span> (with ((pad-char <span class="ch">#\.</span>))</span>
<span id="cb357-5"><a href="#cb357-5" aria-hidden="true" tabindex="-1"></a>                 (joined/suffix print-line alist nl))))</span>
<span id="cb357-6"><a href="#cb357-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb357-7"><a href="#cb357-7" aria-hidden="true" tabindex="-1"></a>    (print-table-of-contents</span>
<span id="cb357-8"><a href="#cb357-8" aria-hidden="true" tabindex="-1"></a>     &#39;((<span class="st">&quot;An Unexpected Party&quot;</span> <span class="op">.</span> <span class="dv">29</span>)</span>
<span id="cb357-9"><a href="#cb357-9" aria-hidden="true" tabindex="-1"></a>       (<span class="st">&quot;Roast Mutton&quot;</span> <span class="op">.</span> <span class="dv">60</span>)</span>
<span id="cb357-10"><a href="#cb357-10" aria-hidden="true" tabindex="-1"></a>       (<span class="st">&quot;A Short Rest&quot;</span> <span class="op">.</span> <span class="dv">87</span>)</span>
<span id="cb357-11"><a href="#cb357-11" aria-hidden="true" tabindex="-1"></a>       (<span class="st">&quot;Over Hill and Under Hill&quot;</span> <span class="op">.</span> <span class="dv">100</span>)</span>
<span id="cb357-12"><a href="#cb357-12" aria-hidden="true" tabindex="-1"></a>       (<span class="st">&quot;Riddles in the Dark&quot;</span> <span class="op">.</span> <span class="dv">115</span>)))</span></code></pre></div>
<p>would output</p>
<pre><code>    An Unexpected Party.....................................................29
    Roast Mutton............................................................60
    A Short Rest............................................................87
    Over Hill and Under Hill...............................................100
    Riddles in the Dark....................................................115</code></pre>
<h2 id="eellipsis"><code>eellipsis</code></h2>
<p>The string used when truncating as described in trimmed.</p>
<h2 id="radix"><code>radix</code></h2>
<p>The radix for numeric output, defaulting to 10, as used in numeric and written.</p>
<h2 id="precision"><code>precision</code></h2>
<p>The precision for numeric output, as described in numeric and written. The precision specifies the number of digits written after the decimal point. If the numeric value to be written out requires more digits to represent it than precision, the written representation is chosen which is closest to the numeric value and representable with the specified precision. If the numeric value falls on the midpoint of two such representations, it is implementation dependent which representation is chosen.</p>
<p>When the numeric value is an inexact floating-point number, there is more than one interpretation of this “rounding”. One is to take the effective value the floating-point number represents (e.g. if we use binary floating-point numbers, we take the value of (* sign mantissa (expt 2 exponent))), and compare it to the two closest numeric representations of the given precision. Another way is to obtain the default notation of the floating-point number and apply rounding to it. The former (we call it effective rounding) is consistent with most floating-point number operations, but may lead to a more non-intuitive result than the latter (we call it notational rounding). For example, 5.015 can’t be represented exactly in binary floating-point numbers. With IEEE754 floating-point numbers, the floating point number closest to 5.015 is smaller than exact 5.015, i.e. (&lt; 5.015 5015/1000) =&gt; #t. With effective rounding with precision 2, it should result in “5.01”. However, users who look at the notation may be confused by “5.015” not being rounded up as they usually expect. With notational rounding the implementation chooses “5.02” (if it also adopts round-half-to-infinity or round-half-up rule). It is up to the implementation to choose which interpretation to adopt.</p>
<h2 id="decimal-sep"><code>decimal-sep</code></h2>
<p>The decimal separator for floating point output, default “.”.</p>
<h2 id="decimal-align"><code>decimal-align</code></h2>
<p>Specifies an alignment for the decimal place when formatting numbers, and is useful for outputting tables of numbers.</p>
<div class="sourceCode" id="cb359"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb359-1"><a href="#cb359-1" aria-hidden="true" tabindex="-1"></a>    (<span class="ex">define</span><span class="fu"> </span>(print-angles x)</span>
<span id="cb359-2"><a href="#cb359-2" aria-hidden="true" tabindex="-1"></a>      (joined numeric (<span class="kw">list</span> x (<span class="kw">sin</span> x) (<span class="kw">cos</span> x) (<span class="kw">tan</span> x)) <span class="st">&quot; &quot;</span>))</span>
<span id="cb359-3"><a href="#cb359-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb359-4"><a href="#cb359-4" aria-hidden="true" tabindex="-1"></a>    (show <span class="dv">#t</span> (with ((decimal-align <span class="dv">5</span>) (precision <span class="dv">3</span>))</span>
<span id="cb359-5"><a href="#cb359-5" aria-hidden="true" tabindex="-1"></a>               (joined/suffix print-angles (iota <span class="dv">5</span>) nl)))</span></code></pre></div>
<p>would output</p>
<div class="sourceCode" id="cb360"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb360-1"><a href="#cb360-1" aria-hidden="true" tabindex="-1"></a>     <span class="fl">0.000</span>    <span class="fl">0.000</span>    <span class="fl">1.000</span>    <span class="fl">0.000</span></span>
<span id="cb360-2"><a href="#cb360-2" aria-hidden="true" tabindex="-1"></a>     <span class="fl">1.000</span>    <span class="fl">0.842</span>    <span class="fl">0.540</span>    <span class="fl">1.557</span></span>
<span id="cb360-3"><a href="#cb360-3" aria-hidden="true" tabindex="-1"></a>     <span class="fl">2.000</span>    <span class="fl">0.909</span>   -<span class="fl">0.416</span>   -<span class="fl">2.185</span></span>
<span id="cb360-4"><a href="#cb360-4" aria-hidden="true" tabindex="-1"></a>     <span class="fl">3.000</span>    <span class="fl">0.141</span>   -<span class="fl">0.990</span>   -<span class="fl">0.142</span></span>
<span id="cb360-5"><a href="#cb360-5" aria-hidden="true" tabindex="-1"></a>     <span class="fl">4.000</span>   -<span class="fl">0.757</span>   -<span class="fl">0.654</span>    <span class="fl">1.158</span></span></code></pre></div>
<h2 id="word-separator"><code>word-separator?</code></h2>
<p>A character predicate used to tokenize words for wrapped and justify. Defaults to char-whitespace?. More flexibility is available with wrapped/list. # <code>(scheme vector)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-133/">SRFI-133</a>.</p>
<h2 id="make-vector-size-fill"><code>(make-vector size [fill])</code></h2>
<p>[R7RS-small] Creates and returns a vector of size size. If fill is specified, all the elements of the vector are initialized to fill. Otherwise, their contents are indeterminate.</p>
<p>Example:</p>
<div class="sourceCode" id="cb361"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb361-1"><a href="#cb361-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">make-vector</span> <span class="dv">5</span> <span class="dv">3</span>)</span>
<span id="cb361-2"><a href="#cb361-2" aria-hidden="true" tabindex="-1"></a>#(<span class="dv">3</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">3</span>)</span></code></pre></div>
<h2 id="vector-x-..."><code>(vector x ...)</code></h2>
<p>[R7RS-small] Creates and returns a vector whose elements are x ….</p>
<p>Example:</p>
<div class="sourceCode" id="cb362"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb362-1"><a href="#cb362-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">vector</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)</span>
<span id="cb362-2"><a href="#cb362-2" aria-hidden="true" tabindex="-1"></a>#(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)</span></code></pre></div>
<h2 id="vector-unfold-f-length-initial-seed-..."><code>(vector-unfold f length initial-seed ...)</code></h2>
<p>The fundamental vector constructor. Creates a vector whose length is length and iterates across each index k between 0 and length, applying f at each iteration to the current index and current seeds, in that order, to receive n + 1 values: first, the element to put in the kth slot of the new vector and n new seeds for the next iteration. It is an error for the number of seeds to vary between iterations. Note that the termination condition is different from the unfold procedure of SRFI 1.</p>
<p>Examples:</p>
<p>``scheme (vector-unfold (λ (i x) (values x (- x 1))) 10 0) #(0 -1 -2 -3 -4 -5 -6 -7 -8 -9)</p>
<pre><code>
Construct a vector of the sequence of integers in the range [0,n).

```scheme
(vector-unfold values n)
#(0 1 2 ... n-2 n-1)</code></pre>
<p>Copy vector.</p>
<div class="sourceCode" id="cb364"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb364-1"><a href="#cb364-1" aria-hidden="true" tabindex="-1"></a>    (vector-unfold (λ (i) (<span class="kw">vector-ref</span> <span class="kw">vector</span> i))</span>
<span id="cb364-2"><a href="#cb364-2" aria-hidden="true" tabindex="-1"></a>                     (<span class="kw">vector-length</span> <span class="kw">vector</span>))</span></code></pre></div>
<h2 id="vector-unfold-right-f-length-initial-seed-..."><code>(vector-unfold-right f length initial-seed ...)</code></h2>
<p>Like vector-unfold, but it uses f to generate elements from right-to-left, rather than left-to-right. The first index used is length - 1. Note that the termination condition is different from the unfold-right procedure of SRFI 1.</p>
<p>Examples:</p>
<p>Construct a vector of pairs of non-negative integers whose values sum to 4.</p>
<div class="sourceCode" id="cb365"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb365-1"><a href="#cb365-1" aria-hidden="true" tabindex="-1"></a>(vector-unfold-right (λ (i x) (<span class="kw">values</span> (<span class="kw">cons</span> i x) (<span class="op">+</span> x <span class="dv">1</span>))) <span class="dv">5</span> <span class="dv">0</span>)</span>
<span id="cb365-2"><a href="#cb365-2" aria-hidden="true" tabindex="-1"></a>#((<span class="dv">0</span> <span class="op">.</span> <span class="dv">4</span>) (<span class="dv">1</span> <span class="op">.</span> <span class="dv">3</span>) (<span class="dv">2</span> <span class="op">.</span> <span class="dv">2</span>) (<span class="dv">3</span> <span class="op">.</span> <span class="dv">1</span>) (<span class="dv">4</span> <span class="op">.</span> <span class="dv">0</span>))</span></code></pre></div>
<p>Reverse vector.</p>
<div class="sourceCode" id="cb366"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb366-1"><a href="#cb366-1" aria-hidden="true" tabindex="-1"></a>    (vector-unfold-right (λ (i x) (<span class="kw">values</span> (<span class="kw">vector-ref</span> <span class="kw">vector</span> x) (<span class="op">+</span> x <span class="dv">1</span>)))</span>
<span id="cb366-2"><a href="#cb366-2" aria-hidden="true" tabindex="-1"></a>                           (<span class="kw">vector-length</span> <span class="kw">vector</span>)</span>
<span id="cb366-3"><a href="#cb366-3" aria-hidden="true" tabindex="-1"></a>                           <span class="dv">0</span>)</span></code></pre></div>
<h2 id="vector-copy-vec-start-end"><code>(vector-copy vec [start [end]])</code></h2>
<p>[R7RS-small] Allocates a new vector whose length is end - start and fills it with elements from vec, taking elements from vec starting at index start and stopping at index end. Start defaults to 0 and end defaults to the value of (vector-length vec). SRFI 43 provides an optional fill argument to supply values if end is greater than the length of vec. Neither R7RS-small nor this SRFI requires support for this argument.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb367"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb367-1"><a href="#cb367-1" aria-hidden="true" tabindex="-1"></a>    (vector-copy &#39;#(a b c d e f g h i))</span>
<span id="cb367-2"><a href="#cb367-2" aria-hidden="true" tabindex="-1"></a>    #(a b c d e f g h i)</span>
<span id="cb367-3"><a href="#cb367-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb367-4"><a href="#cb367-4" aria-hidden="true" tabindex="-1"></a>    (vector-copy &#39;#(a b c d e f g h i) <span class="dv">6</span>)</span>
<span id="cb367-5"><a href="#cb367-5" aria-hidden="true" tabindex="-1"></a>    #(g h i)</span>
<span id="cb367-6"><a href="#cb367-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb367-7"><a href="#cb367-7" aria-hidden="true" tabindex="-1"></a>    (vector-copy &#39;#(a b c d e f g h i) <span class="dv">3</span> <span class="dv">6</span>)</span>
<span id="cb367-8"><a href="#cb367-8" aria-hidden="true" tabindex="-1"></a>    #(d e f)</span></code></pre></div>
<h2 id="vector-reverse-copy-vec-start-end"><code>(vector-reverse-copy vec [start [end]])</code></h2>
<p>Like vector-copy, but it copies the elements in the reverse order from vec.</p>
<p>Example:</p>
<div class="sourceCode" id="cb368"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb368-1"><a href="#cb368-1" aria-hidden="true" tabindex="-1"></a>(vector-reverse-copy &#39;#(<span class="dv">5</span> <span class="dv">4</span> <span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span> <span class="dv">0</span>) <span class="dv">1</span> <span class="dv">5</span>)</span>
<span id="cb368-2"><a href="#cb368-2" aria-hidden="true" tabindex="-1"></a>#(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)</span></code></pre></div>
<h2 id="vector-append-vec-..."><code>(vector-append vec ...)</code></h2>
<p>[R7RS-small] Returns a newly allocated vector that contains all elements in order from the subsequent locations in vec ….</p>
<p>Examples:</p>
<div class="sourceCode" id="cb369"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb369-1"><a href="#cb369-1" aria-hidden="true" tabindex="-1"></a>(vector-append &#39;#(x) &#39;#(y))</span>
<span id="cb369-2"><a href="#cb369-2" aria-hidden="true" tabindex="-1"></a>#(x y)</span>
<span id="cb369-3"><a href="#cb369-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb369-4"><a href="#cb369-4" aria-hidden="true" tabindex="-1"></a>(vector-append &#39;#(a) &#39;#(b c d))</span>
<span id="cb369-5"><a href="#cb369-5" aria-hidden="true" tabindex="-1"></a>#(a b c d)</span>
<span id="cb369-6"><a href="#cb369-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb369-7"><a href="#cb369-7" aria-hidden="true" tabindex="-1"></a>(vector-append &#39;#(a #(b)) &#39;#(#(c)))</span>
<span id="cb369-8"><a href="#cb369-8" aria-hidden="true" tabindex="-1"></a>#(a #(b) #(c))</span></code></pre></div>
<h2 id="vector-concatenate-list-of-vectors"><code>(vector-concatenate list-of-vectors)</code></h2>
<p>Appends each vector in list-of-vectors. This is equivalent to:</p>
<div class="sourceCode" id="cb370"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb370-1"><a href="#cb370-1" aria-hidden="true" tabindex="-1"></a>(apply vector-append list-of-vectors)</span></code></pre></div>
<p>However, it may be implemented better.</p>
<p>Example:</p>
<div class="sourceCode" id="cb371"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb371-1"><a href="#cb371-1" aria-hidden="true" tabindex="-1"></a>(vector-concatenate &#39;(#(a b) #(c d)))</span>
<span id="cb371-2"><a href="#cb371-2" aria-hidden="true" tabindex="-1"></a>#(a b c d)</span></code></pre></div>
<h2 id="vector-append-subvectors-vec-start-end-..."><code>(vector-append-subvectors [vec start end] ...)</code></h2>
<p>Returns a vector that contains every element of each vec from start to end in the specified order. This procedure is a generalization of vector-append.</p>
<p>Example:</p>
<div class="sourceCode" id="cb372"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb372-1"><a href="#cb372-1" aria-hidden="true" tabindex="-1"></a>(vector-append-subvectors &#39;#(a b c d e) <span class="dv">0</span> <span class="dv">2</span> &#39;#(f g h i j) <span class="dv">2</span> <span class="dv">4</span>)</span>
<span id="cb372-2"><a href="#cb372-2" aria-hidden="true" tabindex="-1"></a>#(a b h i)</span></code></pre></div>
<h2 id="vector-x"><code>(vector? x)</code></h2>
<p>[R7RS-small] Disjoint type predicate for vectors: this returns #t if x is a vector, and #f if otherwise.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb373"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb373-1"><a href="#cb373-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">vector?</span> &#39;#(a b c))</span>
<span id="cb373-2"><a href="#cb373-2" aria-hidden="true" tabindex="-1"></a><span class="dv">#t</span></span>
<span id="cb373-3"><a href="#cb373-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb373-4"><a href="#cb373-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">vector?</span> &#39;(a b c))</span>
<span id="cb373-5"><a href="#cb373-5" aria-hidden="true" tabindex="-1"></a><span class="dv">#f</span></span>
<span id="cb373-6"><a href="#cb373-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb373-7"><a href="#cb373-7" aria-hidden="true" tabindex="-1"></a>(<span class="kw">vector?</span> <span class="dv">#t</span>)</span>
<span id="cb373-8"><a href="#cb373-8" aria-hidden="true" tabindex="-1"></a><span class="dv">#f</span></span>
<span id="cb373-9"><a href="#cb373-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb373-10"><a href="#cb373-10" aria-hidden="true" tabindex="-1"></a>(<span class="kw">vector?</span> &#39;#())</span>
<span id="cb373-11"><a href="#cb373-11" aria-hidden="true" tabindex="-1"></a><span class="dv">#t</span></span>
<span id="cb373-12"><a href="#cb373-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb373-13"><a href="#cb373-13" aria-hidden="true" tabindex="-1"></a>(<span class="kw">vector?</span> &#39;())</span>
<span id="cb373-14"><a href="#cb373-14" aria-hidden="true" tabindex="-1"></a><span class="dv">#f</span></span></code></pre></div>
<h2 id="vector-empty-vec"><code>(vector-empty? vec)</code></h2>
<p>Returns #t if vec is empty, i.e. its length is 0, and #f if not.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb374"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb374-1"><a href="#cb374-1" aria-hidden="true" tabindex="-1"></a>(vector-empty? &#39;#(a))</span>
<span id="cb374-2"><a href="#cb374-2" aria-hidden="true" tabindex="-1"></a><span class="dv">#f</span></span>
<span id="cb374-3"><a href="#cb374-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb374-4"><a href="#cb374-4" aria-hidden="true" tabindex="-1"></a>(vector-empty? &#39;#(()))</span>
<span id="cb374-5"><a href="#cb374-5" aria-hidden="true" tabindex="-1"></a><span class="dv">#f</span></span>
<span id="cb374-6"><a href="#cb374-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb374-7"><a href="#cb374-7" aria-hidden="true" tabindex="-1"></a>(vector-empty? &#39;#(#()))</span>
<span id="cb374-8"><a href="#cb374-8" aria-hidden="true" tabindex="-1"></a><span class="dv">#f</span></span>
<span id="cb374-9"><a href="#cb374-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb374-10"><a href="#cb374-10" aria-hidden="true" tabindex="-1"></a>(vector-empty? &#39;#())</span>
<span id="cb374-11"><a href="#cb374-11" aria-hidden="true" tabindex="-1"></a><span class="dv">#t</span></span></code></pre></div>
<h2 id="vector-elt-vec-..."><code>(vector= elt=? vec ...)</code></h2>
<p>Vector structure comparator, generalized across user-specified element comparators. Vectors a and b are considered equal by vector= iff their lengths are the same, and for each respective element Ea and Eb, (elt=? Ea Eb) returns a true value. Elt=? is always applied to two arguments.</p>
<p>If there are only zero or one vector arguments, #t is automatically returned. The dynamic order in which comparisons of elements and of vectors are performed is left completely unspecified; do not rely on a particular order.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb375"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb375-1"><a href="#cb375-1" aria-hidden="true" tabindex="-1"></a>(vector= <span class="kw">eq?</span> &#39;#(a b c d) &#39;#(a b c d))</span>
<span id="cb375-2"><a href="#cb375-2" aria-hidden="true" tabindex="-1"></a><span class="dv">#t</span></span>
<span id="cb375-3"><a href="#cb375-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb375-4"><a href="#cb375-4" aria-hidden="true" tabindex="-1"></a>(vector= <span class="kw">eq?</span> &#39;#(a b c d) &#39;#(a b d c))</span>
<span id="cb375-5"><a href="#cb375-5" aria-hidden="true" tabindex="-1"></a><span class="dv">#f</span></span>
<span id="cb375-6"><a href="#cb375-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb375-7"><a href="#cb375-7" aria-hidden="true" tabindex="-1"></a>(vector= <span class="op">=</span> &#39;#(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>) &#39;#(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))</span>
<span id="cb375-8"><a href="#cb375-8" aria-hidden="true" tabindex="-1"></a><span class="dv">#f</span></span>
<span id="cb375-9"><a href="#cb375-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb375-10"><a href="#cb375-10" aria-hidden="true" tabindex="-1"></a>(vector= <span class="op">=</span> &#39;#(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>) &#39;#(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))</span>
<span id="cb375-11"><a href="#cb375-11" aria-hidden="true" tabindex="-1"></a><span class="dv">#t</span></span>
<span id="cb375-12"><a href="#cb375-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb375-13"><a href="#cb375-13" aria-hidden="true" tabindex="-1"></a>The two trivial cases.</span>
<span id="cb375-14"><a href="#cb375-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb375-15"><a href="#cb375-15" aria-hidden="true" tabindex="-1"></a>(vector= <span class="kw">eq?</span>)</span>
<span id="cb375-16"><a href="#cb375-16" aria-hidden="true" tabindex="-1"></a><span class="dv">#t</span></span>
<span id="cb375-17"><a href="#cb375-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb375-18"><a href="#cb375-18" aria-hidden="true" tabindex="-1"></a>(vector= <span class="kw">eq?</span> &#39;#(a))</span>
<span id="cb375-19"><a href="#cb375-19" aria-hidden="true" tabindex="-1"></a><span class="dv">#t</span></span>
<span id="cb375-20"><a href="#cb375-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb375-21"><a href="#cb375-21" aria-hidden="true" tabindex="-1"></a>Note the fact that we don&#39;t use <span class="kw">vector</span> literals in the next two — it is unspecified whether <span class="kw">or</span> <span class="kw">not</span> literal vectors with the same external representation are eq?.</span>
<span id="cb375-22"><a href="#cb375-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb375-23"><a href="#cb375-23" aria-hidden="true" tabindex="-1"></a>(vector= <span class="kw">eq?</span> (<span class="kw">vector</span> (<span class="kw">vector</span> &#39;a)) (<span class="kw">vector</span> (<span class="kw">vector</span> &#39;a)))</span>
<span id="cb375-24"><a href="#cb375-24" aria-hidden="true" tabindex="-1"></a><span class="dv">#f</span></span>
<span id="cb375-25"><a href="#cb375-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb375-26"><a href="#cb375-26" aria-hidden="true" tabindex="-1"></a>(vector= <span class="kw">equal?</span> (<span class="kw">vector</span> (<span class="kw">vector</span> &#39;a)) (<span class="kw">vector</span> (<span class="kw">vector</span> &#39;a)))</span>
<span id="cb375-27"><a href="#cb375-27" aria-hidden="true" tabindex="-1"></a><span class="dv">#t</span></span></code></pre></div>
<h2 id="vector-ref-vec-i"><code>(vector-ref vec i)</code></h2>
<p>[R7RS-small] Vector element dereferencing: returns the value that the location in vec at i is mapped to in the store. Indexing is based on zero. I must be within the range [0, (vector-length vec)).</p>
<p>Example:</p>
<div class="sourceCode" id="cb376"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb376-1"><a href="#cb376-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">vector-ref</span> &#39;#(a b c d) <span class="dv">2</span>)</span>
<span id="cb376-2"><a href="#cb376-2" aria-hidden="true" tabindex="-1"></a>c</span></code></pre></div>
<h2 id="vector-length-vec"><code>(vector-length vec)</code></h2>
<p>[R7RS-small] Returns the length of vec, the number of locations reachable from vec. (The careful word ‘reachable’ is used to allow for ‘vector slices,’ whereby vec refers to a larger vector that contains more locations that are unreachable from vec. This SRFI does not define vector slices, but later SRFIs may.)</p>
<p>Example:</p>
<div class="sourceCode" id="cb377"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb377-1"><a href="#cb377-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">vector-length</span> &#39;#(a b c))</span>
<span id="cb377-2"><a href="#cb377-2" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span></span></code></pre></div>
<h2 id="vector-fold-kons-knil-vec1-vec2-..."><code>(vector-fold kons knil vec1 vec2 ...)</code></h2>
<p>The fundamental vector iterator. Kons is iterated over each value in all of the vectors, stopping at the end of the shortest; kons is applied as (kons state (vector-ref vec1 i) (vector-ref vec2 i) …) where state is the current state value — the current state value begins with knil, and becomes whatever kons returned on the previous iteration —, and i is the current index.</p>
<p>The iteration is strictly left-to-right.</p>
<p>Examples:</p>
<p>Find the longest string’s length in vector-of-strings.</p>
<div class="sourceCode" id="cb378"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb378-1"><a href="#cb378-1" aria-hidden="true" tabindex="-1"></a>    (vector-fold (λ (len str) (<span class="kw">max</span> (<span class="kw">string-length</span> str) len))</span>
<span id="cb378-2"><a href="#cb378-2" aria-hidden="true" tabindex="-1"></a>                   <span class="dv">0</span> vector-of-strings)</span></code></pre></div>
<p>Produce a list of the reversed elements of vec.</p>
<pre><code>    (vector-fold (λ (tail elt) (cons elt tail))
                   &#39;() vec)</code></pre>
<p>Count the number of even numbers in vec.</p>
<div class="sourceCode" id="cb380"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb380-1"><a href="#cb380-1" aria-hidden="true" tabindex="-1"></a>    (vector-fold (λ (counter n)</span>
<span id="cb380-2"><a href="#cb380-2" aria-hidden="true" tabindex="-1"></a>                     (<span class="kw">if</span> (<span class="kw">even?</span> n) (<span class="op">+</span> counter <span class="dv">1</span>) counter))</span>
<span id="cb380-3"><a href="#cb380-3" aria-hidden="true" tabindex="-1"></a>                   <span class="dv">0</span> vec)</span></code></pre></div>
<h2 id="vector-fold-right-kons-knil-vec1-vec2-..."><code>(vector-fold-right kons knil vec1 vec2 ...)</code></h2>
<p>Similar to vector-fold, but it iterates right to left instead of left to right.</p>
<p>Example:</p>
<p>Convert a vector to a list.</p>
<div class="sourceCode" id="cb381"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb381-1"><a href="#cb381-1" aria-hidden="true" tabindex="-1"></a>    (vector-fold-right (λ (tail elt) (<span class="kw">cons</span> elt tail))</span>
<span id="cb381-2"><a href="#cb381-2" aria-hidden="true" tabindex="-1"></a>                         &#39;() &#39;#(a b c d))</span>
<span id="cb381-3"><a href="#cb381-3" aria-hidden="true" tabindex="-1"></a>    (a b c d)</span></code></pre></div>
<h2 id="vector-map-f-vec1-vec2-..."><code>(vector-map f vec1 vec2 ...)</code></h2>
<p>[R7RS-small] Constructs a new vector of the shortest size of the vector arguments. Each element at index i of the new vector is mapped from the old vectors by (f (vector-ref vec1 i) (vector-ref vec2 i) …). The dynamic order of application of f is unspecified.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb382"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb382-1"><a href="#cb382-1" aria-hidden="true" tabindex="-1"></a>    (vector-map (λ (x) (<span class="op">*</span> x x))</span>
<span id="cb382-2"><a href="#cb382-2" aria-hidden="true" tabindex="-1"></a>                  (vector-unfold (λ (i x) (<span class="kw">values</span> x (<span class="op">+</span> x <span class="dv">1</span>))) <span class="dv">4</span> <span class="dv">1</span>))</span>
<span id="cb382-3"><a href="#cb382-3" aria-hidden="true" tabindex="-1"></a>    #(<span class="dv">1</span> <span class="dv">4</span> <span class="dv">9</span> <span class="dv">16</span>)</span>
<span id="cb382-4"><a href="#cb382-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb382-5"><a href="#cb382-5" aria-hidden="true" tabindex="-1"></a>    (vector-map (λ (x y) (<span class="op">*</span> x y))</span>
<span id="cb382-6"><a href="#cb382-6" aria-hidden="true" tabindex="-1"></a>                  (vector-unfold (λ (x) (<span class="kw">values</span> x (<span class="op">+</span> x <span class="dv">1</span>))) <span class="dv">5</span> <span class="dv">1</span>)</span>
<span id="cb382-7"><a href="#cb382-7" aria-hidden="true" tabindex="-1"></a>                  (vector-unfold (λ (x) (<span class="kw">values</span> x (<span class="op">-</span> x <span class="dv">1</span>))) <span class="dv">5</span> <span class="dv">5</span>))</span>
<span id="cb382-8"><a href="#cb382-8" aria-hidden="true" tabindex="-1"></a>    #(<span class="dv">5</span> <span class="dv">8</span> <span class="dv">9</span> <span class="dv">8</span> <span class="dv">5</span>)</span>
<span id="cb382-9"><a href="#cb382-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb382-10"><a href="#cb382-10" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">let</span> ((count <span class="dv">0</span>))</span>
<span id="cb382-11"><a href="#cb382-11" aria-hidden="true" tabindex="-1"></a>       (vector-map (λ (ignored-elt)</span>
<span id="cb382-12"><a href="#cb382-12" aria-hidden="true" tabindex="-1"></a>                     (<span class="kw">set!</span> count (<span class="op">+</span> count <span class="dv">1</span>))</span>
<span id="cb382-13"><a href="#cb382-13" aria-hidden="true" tabindex="-1"></a>                     count)</span>
<span id="cb382-14"><a href="#cb382-14" aria-hidden="true" tabindex="-1"></a>                   &#39;#(a b)))</span>
<span id="cb382-15"><a href="#cb382-15" aria-hidden="true" tabindex="-1"></a>    #(<span class="dv">1</span> <span class="dv">2</span>) OR #(<span class="dv">2</span> <span class="dv">1</span>)</span></code></pre></div>
<h2 id="vector-map-f-vec1-vec2-...-1"><code>(vector-map! f vec1 vec2 ...)</code></h2>
<p>Similar to vector-map, but rather than mapping the new elements into a new vector, the new mapped elements are destructively inserted into vec1. Again, the dynamic order of application of f unspecified, so it is dangerous for f to apply either vector-ref or vector-set! to vec1 in f.</p>
<h2 id="vector-for-each-f-vec1-vec2-..."><code>(vector-for-each f vec1 vec2 ...)</code></h2>
<p>[R7RS-small] Simple vector iterator: applies f to the corresponding list of parallel elements from vec1 vec2 … in the range [0, length), where length is the length of the smallest vector argument passed, In contrast with vector-map, f is reliably applied to each subsequent element, starting at index 0, in the vectors.</p>
<p>Example:</p>
<div class="sourceCode" id="cb383"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb383-1"><a href="#cb383-1" aria-hidden="true" tabindex="-1"></a>    (vector-for-each (λ (x) (<span class="kw">display</span> x) (<span class="kw">newline</span>))</span>
<span id="cb383-2"><a href="#cb383-2" aria-hidden="true" tabindex="-1"></a>                     &#39;#(<span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span> <span class="st">&quot;baz&quot;</span> <span class="st">&quot;quux&quot;</span> <span class="st">&quot;zot&quot;</span>))</span></code></pre></div>
<p>Displays:</p>
<pre><code>foo
bar
baz
quux
zot</code></pre>
<h2 id="vector-count-pred-vec1-vec2-..."><code>(vector-count pred? vec1 vec2 ...)</code></h2>
<p>Counts the number of parallel elements in the vectors that satisfy pred?, which is applied, for each index i in the range [0, length) where length is the length of the smallest vector argument, to each parallel element in the vectors, in order.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb385"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb385-1"><a href="#cb385-1" aria-hidden="true" tabindex="-1"></a>(vector-count <span class="kw">even?</span> &#39;#(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>))</span>
<span id="cb385-2"><a href="#cb385-2" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span></span>
<span id="cb385-3"><a href="#cb385-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb385-4"><a href="#cb385-4" aria-hidden="true" tabindex="-1"></a>(vector-count <span class="op">&lt;</span> &#39;#(<span class="dv">1</span> <span class="dv">3</span> <span class="dv">6</span> <span class="dv">9</span>) &#39;#(<span class="dv">2</span> <span class="dv">4</span> <span class="dv">6</span> <span class="dv">8</span> <span class="dv">10</span> <span class="dv">12</span>))</span>
<span id="cb385-5"><a href="#cb385-5" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span></code></pre></div>
<h2 id="vector-cumulate-f-knil-vec"><code>(vector-cumulate f knil vec)</code></h2>
<p>Returns a newly allocated vector new with the same length as vec. Each element i of new is set to the result of invoking f on newi-1 and veci, except that for the first call on f, the first argument is knil. The new vector is returned.</p>
<p>Note that the order of arguments to vector-cumulate was changed by errata-3 on 2016-09-02.</p>
<p>Example:</p>
<div class="sourceCode" id="cb386"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb386-1"><a href="#cb386-1" aria-hidden="true" tabindex="-1"></a>(vector-cumulate <span class="op">+</span> <span class="dv">0</span> &#39;#(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>))</span>
<span id="cb386-2"><a href="#cb386-2" aria-hidden="true" tabindex="-1"></a>#(<span class="dv">3</span> <span class="dv">4</span> <span class="dv">8</span> <span class="dv">9</span> <span class="dv">14</span> <span class="dv">23</span> <span class="dv">25</span> <span class="dv">30</span> <span class="dv">36</span>)</span></code></pre></div>
<h2 id="vector-index-pred-vec1-vec2-..."><code>(vector-index pred? vec1 vec2 ...)</code></h2>
<p>Finds &amp; returns the index of the first elements in vec1 vec2 … that satisfy pred?. If no matching element is found by the end of the shortest vector, #f is returned.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb387"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb387-1"><a href="#cb387-1" aria-hidden="true" tabindex="-1"></a>(vector-index <span class="kw">even?</span> &#39;#(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>))</span>
<span id="cb387-2"><a href="#cb387-2" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb387-3"><a href="#cb387-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb387-4"><a href="#cb387-4" aria-hidden="true" tabindex="-1"></a>(vector-index <span class="op">&lt;</span> &#39;#(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) &#39;#(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>))</span>
<span id="cb387-5"><a href="#cb387-5" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span>
<span id="cb387-6"><a href="#cb387-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb387-7"><a href="#cb387-7" aria-hidden="true" tabindex="-1"></a>(vector-index <span class="op">=</span> &#39;#(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) &#39;#(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>))</span>
<span id="cb387-8"><a href="#cb387-8" aria-hidden="true" tabindex="-1"></a><span class="dv">#f</span></span></code></pre></div>
<h2 id="vector-index-right-pred-vec1-vec2-..."><code>(vector-index-right pred? vec1 vec2 ...)</code></h2>
<p>Like vector-index, but it searches right-to-left, rather than left-to-right, and all of the vectors must have the same length.</p>
<h2 id="vector-skip-pred-vec1-vec2-..."><code>(vector-skip pred? vec1 vec2 ...)</code></h2>
<p>Finds &amp; returns the index of the first elements in vec1 vec2 … that do not satisfy pred?. If all the values in the vectors satisfy pred? until the end of the shortest vector, this returns #f. This is equivalent to:</p>
<p>``scheme (vector-index (λ (x1 x2 …) (not (pred? x1 x1 …))) vec1 vec2 …)</p>
<pre><code>
Example:

```scheme
(vector-skip number? &#39;#(1 2 a b 3 4 c d))
2</code></pre>
<h2 id="vector-skip-right-pred-vec1-vec2-..."><code>(vector-skip-right pred? vec1 vec2 ...)</code></h2>
<p>Like vector-skip, but it searches for a non-matching element right-to-left, rather than left-to-right, and it is an error if all of the vectors do not have the same length. This is equivalent to:</p>
<div class="sourceCode" id="cb389"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb389-1"><a href="#cb389-1" aria-hidden="true" tabindex="-1"></a>    (vector-index-right (λ (x1 x2 <span class="op">...</span>) (<span class="kw">not</span> (pred? x1 x1 <span class="op">...</span>)))</span>
<span id="cb389-2"><a href="#cb389-2" aria-hidden="true" tabindex="-1"></a>                              vec1 vec2 <span class="op">...</span>)</span></code></pre></div>
<h2 id="vector-binary-search-vec-value-cmp"><code>(vector-binary-search vec value cmp)</code></h2>
<p>Similar to vector-index and vector-index-right, but instead of searching left to right or right to left, this performs a binary search. If there is more than one element of vec that matches value in the sense of cmp, vector-binary-search may return the index of any of them.</p>
<p>cmp should be a procedure of two arguments and return a negative integer, which indicates that its first argument is less than its second, zero, which indicates that they are equal, or a positive integer, which indicates that the first argument is greater than the second argument. An example cmp might be:</p>
<div class="sourceCode" id="cb390"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb390-1"><a href="#cb390-1" aria-hidden="true" tabindex="-1"></a>    (λ (char1 char2)</span>
<span id="cb390-2"><a href="#cb390-2" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">cond</span> ((<span class="kw">char&lt;?</span> char1 char2) -<span class="dv">1</span>)</span>
<span id="cb390-3"><a href="#cb390-3" aria-hidden="true" tabindex="-1"></a>            ((<span class="kw">char=?</span> char1 char2) <span class="dv">0</span>)</span>
<span id="cb390-4"><a href="#cb390-4" aria-hidden="true" tabindex="-1"></a>            (<span class="kw">else</span> <span class="dv">1</span>)))</span></code></pre></div>
<h2 id="vector-any-pred-vec1-vec2-..."><code>(vector-any pred? vec1 vec2 ...)</code></h2>
<p>Finds the first set of elements in parallel from vec1 vec2 … for which pred? returns a true value. If such a parallel set of elements exists, vector-any returns the value that pred? returned for that set of elements. The iteration is strictly left-to-right.</p>
<h2 id="vector-every-pred-vec1-vec2-..."><code>(vector-every pred? vec1 vec2 ...)</code></h2>
<p>If, for every index i between 0 and the length of the shortest vector argument, the set of elements (vector-ref vec1 i) (vector-ref vec2 i) … satisfies pred?, vector-every returns the value that pred? returned for the last set of elements, at the last index of the shortest vector. The iteration is strictly left-to-right.</p>
<h2 id="vector-partition-pred-vec"><code>(vector-partition pred? vec)</code></h2>
<p>A vector the same size as vec is newly allocated and filled with all the elements of vec that satisfy pred? in their original order followed by all the elements that do not satisfy pred?, also in their original order.</p>
<p>Two values are returned, the newly allocated vector and the index of the leftmost element that does not satisfy pred?.</p>
<h2 id="vector-set-vec-i-value"><code>(vector-set! vec i value)</code></h2>
<p>[R7RS-small] Assigns the contents of the location at i in vec to value.</p>
<h2 id="vector-swap-vec-i-j"><code>(vector-swap! vec i j)</code></h2>
<p>Swaps or exchanges the values of the locations in vec at i &amp; j.</p>
<h2 id="vector-fill-vec-fill-start-end"><code>(vector-fill! vec fill [start [end]])</code></h2>
<p>[R7RS-small] Assigns the value of every location in vec between start, which defaults to 0 and end, which defaults to the length of vec, to fill.</p>
<h2 id="vector-reverse-vec-start-end"><code>(vector-reverse! vec [start [end]])</code></h2>
<p>Destructively reverses the contents of the sequence of locations in vec between start and end. Start defaults to 0 and end defaults to the length of vec. Note that this does not deeply reverse.</p>
<h2 id="vector-copy-to-at-from-start-end-1"><code>(vector-copy! to at from [start [end]])</code></h2>
<p>[R7RS-small] Copies the elements of vector from between start and end to vector to, starting at at. The order in which elements are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary vector and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances.</p>
<h2 id="vector-reverse-copy-to-at-from-start-end"><code>(vector-reverse-copy! to at from [start [end]])</code></h2>
<p>Like vector-copy!, but the elements appear in to in reverse order.</p>
<h2 id="vector-unfold-f-vec-start-end-initial-seed-..."><code>(vector-unfold! f vec start end initial-seed ...)</code></h2>
<p>Like vector-unfold, but the elements are copied into the vector vec starting at element start rather than into a newly allocated vector. Terminates when end-start elements have been generated.</p>
<h2 id="vector-unfold-right-f-vec-start-end-initial-seed-..."><code>(vector-unfold-right! f vec start end initial-seed ...)</code></h2>
<p>Like vector-unfold!, but the elements are copied in reverse order into the vector vec starting at the index preceding end.</p>
<h2 id="vector-list-vec-start-end"><code>(vector-&gt;list vec [start [end]])</code></h2>
<p>[R7RS-small] Creates a list containing the elements in vec between start, which defaults to 0, and end, which defaults to the length of vec.</p>
<h2 id="reverse-vector-list-vec-start-end"><code>(reverse-vector-&gt;list vec [start [end]])</code></h2>
<p>Like vector-&gt;list, but the resulting list contains the elements in reverse of vec.</p>
<h2 id="list-vector-proper-list"><code>(list-&gt;vector proper-list)</code></h2>
<p>[R7RS-small] Creates a vector of elements from proper-list.</p>
<h2 id="reverse-list-vector-proper-list"><code>(reverse-list-&gt;vector proper-list)</code></h2>
<p>Like list-&gt;vector, but the resulting vector contains the elements in reverse of proper-list.</p>
<h2 id="string-vector-string-start-end-1"><code>(string-&gt;vector string [start [end]])</code></h2>
<p>[R7RS-small] Creates a vector containing the elements in string between start, which defaults to 0, and end, which defaults to the length of string.</p>
<h2 id="vector-string-vec-start-end"><code>(vector-&gt;string vec [start [end]])</code></h2>
<p>[R7RS-small] Creates a string containing the elements in vec between start, which defaults to 0, and end, which defaults to the length of vec. It is an error if the elements are not characters. # <code>(scheme r5rs)</code></p>
<p>Thie library export<a href="https://bitbucket.org/cowan/r7rs/src/draft-10/rnrs/">R5RS</a> forms. It is based on the following libraries:</p>
<ul>
<li><code>(scheme base)</code></li>
<li><code>(scheme inexact)</code></li>
<li><code>(scheme complex)</code></li>
<li><code>(scheme cxr)</code></li>
<li><code>(scheme file)</code></li>
<li><code>(scheme char)</code></li>
<li><code>(scheme read)</code></li>
<li><code>(scheme write)</code></li>
<li><code>(scheme eval)</code></li>
<li><code>(scheme repl)</code></li>
<li><code>(scheme load)</code></li>
<li><code>(scheme lazy)</code>t</li>
</ul>
<p>It exports the following forms:</p>
<ul>
<li><code>*</code></li>
<li><code>+</code></li>
<li><code>-</code></li>
<li><code>/</code></li>
<li><code>&lt;</code></li>
<li><code>&lt;=</code></li>
<li><code>=</code></li>
<li><code>&gt;</code></li>
<li><code>&gt;=</code></li>
<li><code>abs</code></li>
<li><code>acos</code></li>
<li><code>and</code></li>
<li><code>angle</code></li>
<li><code>append</code></li>
<li><code>apply</code></li>
<li><code>asin</code></li>
<li><code>assoc</code></li>
<li><code>assq</code></li>
<li><code>assv</code></li>
<li><code>atan</code></li>
<li><code>begin</code></li>
<li><code>boolean?</code></li>
<li><code>caaaar</code></li>
<li><code>caaadr</code></li>
<li><code>caaar</code></li>
<li><code>caadar</code></li>
<li><code>caaddr</code></li>
<li><code>caadr</code></li>
<li><code>caar</code></li>
<li><code>cadaar</code></li>
<li><code>cadadr</code></li>
<li><code>cadar</code></li>
<li><code>caddar</code></li>
<li><code>cadddr</code></li>
<li><code>caddr</code></li>
<li><code>cadr</code></li>
<li><code>call-with-current-continuation</code></li>
<li><code>call-with-input-file</code></li>
<li><code>call-with-output-file</code></li>
<li><code>call-with-values</code></li>
<li><code>car</code></li>
<li><code>case</code></li>
<li><code>cdaaar</code></li>
<li><code>cdaadr</code></li>
<li><code>cdaar</code></li>
<li><code>cdadar</code></li>
<li><code>cdaddr</code></li>
<li><code>cdadr</code></li>
<li><code>cdar</code></li>
<li><code>cddaar</code></li>
<li><code>cddadr</code></li>
<li><code>cddar</code></li>
<li><code>cdddar</code></li>
<li><code>cddddr</code></li>
<li><code>cdddr</code></li>
<li><code>cddr</code></li>
<li><code>cdr</code></li>
<li><code>ceiling</code></li>
<li><code>char-&gt;integer</code></li>
<li><code>char-alphabetic?</code></li>
<li><code>char-ci&lt;=?</code></li>
<li><code>char-ci&lt;?</code></li>
<li><code>char-ci=?</code></li>
<li><code>char-ci&gt;=?</code></li>
<li><code>char-ci&gt;?</code></li>
<li><code>char-downcase</code></li>
<li><code>char-lower-case?</code></li>
<li><code>char-numeric?</code></li>
<li><code>char-ready?</code></li>
<li><code>char-upcase</code></li>
<li><code>char-upper-case?</code></li>
<li><code>char-whitespace?</code></li>
<li><code>char&lt;=?</code></li>
<li><code>char&lt;?</code></li>
<li><code>char=?</code></li>
<li><code>char&gt;=?</code></li>
<li><code>char&gt;?</code></li>
<li><code>char?</code></li>
<li><code>close-input-port</code></li>
<li><code>close-output-port</code></li>
<li><code>complex?</code></li>
<li><code>cond</code></li>
<li><code>cons</code></li>
<li><code>cos</code></li>
<li><code>current-input-port</code></li>
<li><code>current-output-port</code></li>
<li><code>define</code></li>
<li><code>define-syntax</code></li>
<li><code>delay</code></li>
<li><code>denominator</code></li>
<li><code>display</code></li>
<li><code>do</code></li>
<li><code>dynamic-wind</code></li>
<li><code>eof-object?</code></li>
<li><code>eq?</code></li>
<li><code>equal?</code></li>
<li><code>eqv?</code></li>
<li><code>eval</code></li>
<li><code>even?</code></li>
<li><code>exact-&gt;inexact</code></li>
<li><code>exact?</code></li>
<li><code>exp</code></li>
<li><code>expt</code></li>
<li><code>floor</code></li>
<li><code>for-each</code></li>
<li><code>force</code></li>
<li><code>gcd</code></li>
<li><code>if</code></li>
<li><code>imag-part</code></li>
<li><code>inexact-&gt;exact</code></li>
<li><code>inexact?</code></li>
<li><code>input-port?</code></li>
<li><code>integer-&gt;char</code></li>
<li><code>integer?</code></li>
<li><code>interaction-environment</code></li>
<li><code>lambda</code></li>
<li><code>lcm</code></li>
<li><code>length</code></li>
<li><code>let</code></li>
<li><code>let*</code></li>
<li><code>let-syntax</code></li>
<li><code>letrec</code></li>
<li><code>letrec-syntax</code></li>
<li><code>list</code></li>
<li><code>list-&gt;string</code></li>
<li><code>list-&gt;vector</code></li>
<li><code>list-ref</code></li>
<li><code>list-tail</code></li>
<li><code>list?</code></li>
<li><code>load</code></li>
<li><code>log</code></li>
<li><code>magnitude</code></li>
<li><code>make-polar</code></li>
<li><code>make-rectangular</code></li>
<li><code>make-string</code></li>
<li><code>make-vector</code></li>
<li><code>map</code></li>
<li><code>max</code></li>
<li><code>member</code></li>
<li><code>memq</code></li>
<li><code>memv</code></li>
<li><code>min</code></li>
<li><code>modulo</code></li>
<li><code>negative?</code></li>
<li><code>newline</code></li>
<li><code>not</code></li>
<li><code>null-environment</code></li>
<li><code>null?</code></li>
<li><code>number-&gt;string</code></li>
<li><code>number?</code></li>
<li><code>numerator</code></li>
<li><code>odd?</code></li>
<li><code>open-input-file</code></li>
<li><code>open-output-file</code></li>
<li><code>or</code></li>
<li><code>output-port?</code></li>
<li><code>pair?</code></li>
<li><code>peek-char</code></li>
<li><code>positive?</code></li>
<li><code>procedure?</code></li>
<li><code>quasiquote</code></li>
<li><code>quote</code></li>
<li><code>quotient</code></li>
<li><code>rational?</code></li>
<li><code>rationalize</code></li>
<li><code>read</code></li>
<li><code>read-char</code></li>
<li><code>real-part</code></li>
<li><code>real?</code></li>
<li><code>remainder</code></li>
<li><code>reverse</code></li>
<li><code>round</code></li>
<li><code>scheme-report-environment</code></li>
<li><code>set!</code></li>
<li><code>set-car!</code></li>
<li><code>set-cdr!</code></li>
<li><code>sin</code></li>
<li><code>sqrt</code></li>
<li><code>string</code></li>
<li><code>string-&gt;list</code></li>
<li><code>string-&gt;number</code></li>
<li><code>string-&gt;symbol</code></li>
<li><code>string-append</code></li>
<li><code>string-ci&lt;=?</code></li>
<li><code>string-ci&lt;?</code></li>
<li><code>string-ci=?</code></li>
<li><code>string-ci&gt;=?</code></li>
<li><code>string-ci&gt;?</code></li>
<li><code>string-copy</code></li>
<li><code>string-fill!</code></li>
<li><code>string-length</code></li>
<li><code>string-ref</code></li>
<li><code>string-set!</code></li>
<li><code>string&lt;=?</code></li>
<li><code>string&lt;?</code></li>
<li><code>string=?</code></li>
<li><code>string&gt;=?</code></li>
<li><code>string&gt;?</code></li>
<li><code>string?</code></li>
<li><code>substring</code></li>
<li><code>symbol-&gt;string</code></li>
<li><code>symbol?</code></li>
<li><code>syntax-rules</code></li>
<li><code>tan</code></li>
<li><code>truncate</code></li>
<li><code>values</code></li>
<li><code>vector</code></li>
<li><code>vector-&gt;list</code></li>
<li><code>vector-fill!</code></li>
<li><code>vector-length</code></li>
<li><code>vector-ref</code></li>
<li><code>vector-set!</code></li>
<li><code>vector?</code></li>
<li><code>with-input-from-file</code></li>
<li><code>with-output-to-file</code></li>
<li><code>write</code></li>
<li><code>write-char</code></li>
<li><code>zero?</code> # <code>(scheme bitwise)</code></li>
</ul>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-151/">SRFI-151</a>.</p>
<p>This library offers a coherent and comprehensive set of procedures for performing bitwise logical operations on integers.</p>
<h2 id="bitwise-not-i"><code>(bitwise-not i)</code></h2>
<p>Returns the bitwise complement of i; that is, all 1 bits are changed to 0 bits and all 0 bits to 1 bits.</p>
<div class="sourceCode" id="cb391"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb391-1"><a href="#cb391-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">bitwise-not</span> <span class="dv">10</span>) <span class="co">;; =&gt; -11</span></span>
<span id="cb391-2"><a href="#cb391-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">bitwise-not</span> -<span class="dv">37</span>) <span class="co">;; =&gt; 36</span></span></code></pre></div>
<p>The following ten procedures correspond to the useful set of non-trivial two-argument boolean functions. For each such function, the corresponding bitwise operator maps that function across a pair of bitstrings in a bit-wise fashion. The core idea of this group of functions is this bitwise “lifting” of the set of dyadic boolean functions to bitstring parameters.</p>
<h2 id="bitwise-and-i-..."><code>(bitwise-and i ...)</code></h2>
<h2 id="bitwise-ior-i-..."><code>(bitwise-ior i ...)</code></h2>
<h2 id="bitwise-xor-i-..."><code>(bitwise-xor i ...)</code></h2>
<h2 id="bitwise-eqv-i-..."><code>(bitwise-eqv i ...)</code></h2>
<p>These operations are associative. When passed no arguments, the procedures return the identity values -1, 0, 0, and -1 respectively.</p>
<p>The bitwise-eqv procedure produces the complement of the bitwise-xor procedure. When applied to three arguments, it does not produce a 1 bit everywhere that a, b and c all agree. That is, it does not produce</p>
<div class="sourceCode" id="cb392"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb392-1"><a href="#cb392-1" aria-hidden="true" tabindex="-1"></a>     (<span class="kw">bitwise-ior</span> (<span class="kw">bitwise-and</span> a b c)</span>
<span id="cb392-2"><a href="#cb392-2" aria-hidden="true" tabindex="-1"></a>                  (<span class="kw">bitwise-and</span> (<span class="kw">bitwise-not</span> a)</span>
<span id="cb392-3"><a href="#cb392-3" aria-hidden="true" tabindex="-1"></a>                               (<span class="kw">bitwise-not</span> b)</span>
<span id="cb392-4"><a href="#cb392-4" aria-hidden="true" tabindex="-1"></a>                               (<span class="kw">bitwise-not</span> c)))</span></code></pre></div>
<p>Rather, it produces (bitwise-eqv a (bitwise-eqv b c)) or the equivalent (bitwise-eqv (bitwise-eqv a b) c).</p>
<div class="sourceCode" id="cb393"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb393-1"><a href="#cb393-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">bitwise-ior</span> <span class="dv">3</span>  <span class="dv">10</span>)     <span class="op">=&gt;</span>  <span class="dv">11</span></span>
<span id="cb393-2"><a href="#cb393-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">bitwise-and</span> <span class="dv">11</span> <span class="dv">26</span>)     <span class="op">=&gt;</span>  <span class="dv">10</span></span>
<span id="cb393-3"><a href="#cb393-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">bitwise-xor</span> <span class="dv">3</span> <span class="dv">10</span>)      <span class="op">=&gt;</span>   <span class="dv">9</span></span>
<span id="cb393-4"><a href="#cb393-4" aria-hidden="true" tabindex="-1"></a>(bitwise-eqv <span class="dv">37</span> <span class="dv">12</span>)     <span class="op">=&gt;</span> -<span class="dv">42</span></span>
<span id="cb393-5"><a href="#cb393-5" aria-hidden="true" tabindex="-1"></a>(<span class="kw">bitwise-and</span> <span class="dv">37</span> <span class="dv">12</span>)     <span class="op">=&gt;</span>   <span class="dv">4</span></span></code></pre></div>
<h2 id="bitwise-nand-i-j"><code>(bitwise-nand i j)</code></h2>
<h2 id="bitwise-nor-i-j"><code>(bitwise-nor i j)</code></h2>
<h2 id="bitwise-andc1-i-j"><code>(bitwise-andc1 i j)</code></h2>
<h2 id="bitwise-andc2-i-j"><code>(bitwise-andc2 i j)</code></h2>
<h2 id="bitwise-orc1-i-j"><code>(bitwise-orc1 i j)</code></h2>
<h2 id="bitwise-orc2-i-j"><code>(bitwise-orc2 i j)</code></h2>
<p>These operations are not associative.</p>
<div class="sourceCode" id="cb394"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb394-1"><a href="#cb394-1" aria-hidden="true" tabindex="-1"></a>(bitwise-nand <span class="dv">11</span> <span class="dv">26</span>) <span class="op">=&gt;</span>  -<span class="dv">11</span></span>
<span id="cb394-2"><a href="#cb394-2" aria-hidden="true" tabindex="-1"></a>(bitwise-nor  <span class="dv">11</span> <span class="dv">26</span>) <span class="op">=&gt;</span> -<span class="dv">28</span></span>
<span id="cb394-3"><a href="#cb394-3" aria-hidden="true" tabindex="-1"></a>(bitwise-andc1 <span class="dv">11</span> <span class="dv">26</span>) <span class="op">=&gt;</span> <span class="dv">16</span></span>
<span id="cb394-4"><a href="#cb394-4" aria-hidden="true" tabindex="-1"></a>(bitwise-andc2 <span class="dv">11</span> <span class="dv">26</span>) <span class="op">=&gt;</span> <span class="dv">1</span></span>
<span id="cb394-5"><a href="#cb394-5" aria-hidden="true" tabindex="-1"></a>(bitwise-orc1 <span class="dv">11</span> <span class="dv">26</span>) <span class="op">=&gt;</span> -<span class="dv">2</span></span>
<span id="cb394-6"><a href="#cb394-6" aria-hidden="true" tabindex="-1"></a>(bitwise-orc2 <span class="dv">11</span> <span class="dv">26</span>) <span class="op">=&gt;</span> -<span class="dv">17</span></span></code></pre></div>
<h2 id="arithmetic-shift-i-count"><code>(arithmetic-shift i count)</code></h2>
<p>Returns the arithmetic left shift when count&gt;0; right shift when count &lt; 0.</p>
<div class="sourceCode" id="cb395"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb395-1"><a href="#cb395-1" aria-hidden="true" tabindex="-1"></a>(arithmetic-shift <span class="dv">8</span> <span class="dv">2</span>) <span class="op">=&gt;</span> <span class="dv">32</span></span>
<span id="cb395-2"><a href="#cb395-2" aria-hidden="true" tabindex="-1"></a>(arithmetic-shift <span class="dv">4</span> <span class="dv">0</span>) <span class="op">=&gt;</span> <span class="dv">4</span></span>
<span id="cb395-3"><a href="#cb395-3" aria-hidden="true" tabindex="-1"></a>(arithmetic-shift <span class="dv">8</span> -<span class="dv">1</span>) <span class="op">=&gt;</span> <span class="dv">4</span></span>
<span id="cb395-4"><a href="#cb395-4" aria-hidden="true" tabindex="-1"></a>(arithmetic-shift -<span class="dv">100000000000000000000000000000000</span> -<span class="dv">100</span>) <span class="op">=&gt;</span> -<span class="dv">79</span></span></code></pre></div>
<h2 id="bit-count-i"><code>(bit-count i)</code></h2>
<p>Returns the population count of 1’s (i &gt;= 0) or 0’s (i &lt; 0). The result is always non-negative.</p>
<p>Compatibility note: The R6RS analogue bitwise-bit-count applies bitwise-not to the population count before returning it if i is negative.</p>
<div class="sourceCode" id="cb396"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb396-1"><a href="#cb396-1" aria-hidden="true" tabindex="-1"></a>(bit-count <span class="dv">0</span>) <span class="op">=&gt;</span>  <span class="dv">0</span></span>
<span id="cb396-2"><a href="#cb396-2" aria-hidden="true" tabindex="-1"></a>(bit-count -<span class="dv">1</span>) <span class="op">=&gt;</span>  <span class="dv">0</span></span>
<span id="cb396-3"><a href="#cb396-3" aria-hidden="true" tabindex="-1"></a>(bit-count <span class="dv">7</span>) <span class="op">=&gt;</span>  <span class="dv">3</span></span>
<span id="cb396-4"><a href="#cb396-4" aria-hidden="true" tabindex="-1"></a>(bit-count  <span class="dv">13</span>) <span class="op">=&gt;</span>  <span class="dv">3</span> <span class="co">;Two&#39;s-complement binary: ...0001101</span></span>
<span id="cb396-5"><a href="#cb396-5" aria-hidden="true" tabindex="-1"></a>(bit-count -<span class="dv">13</span>) <span class="op">=&gt;</span>  <span class="dv">2</span> <span class="co">;Two&#39;s-complement binary: ...1110011</span></span>
<span id="cb396-6"><a href="#cb396-6" aria-hidden="true" tabindex="-1"></a>(bit-count  <span class="dv">30</span>) <span class="op">=&gt;</span>  <span class="dv">4</span> <span class="co">;Two&#39;s-complement binary: ...0011110</span></span>
<span id="cb396-7"><a href="#cb396-7" aria-hidden="true" tabindex="-1"></a>(bit-count -<span class="dv">30</span>) <span class="op">=&gt;</span>  <span class="dv">4</span> <span class="co">;Two&#39;s-complement binary: ...1100010</span></span>
<span id="cb396-8"><a href="#cb396-8" aria-hidden="true" tabindex="-1"></a>(bit-count (<span class="kw">expt</span> <span class="dv">2</span> <span class="dv">100</span>)) <span class="op">=&gt;</span>  <span class="dv">1</span></span>
<span id="cb396-9"><a href="#cb396-9" aria-hidden="true" tabindex="-1"></a>(bit-count (<span class="op">-</span> (<span class="kw">expt</span> <span class="dv">2</span> <span class="dv">100</span>))) <span class="op">=&gt;</span>  <span class="dv">100</span></span>
<span id="cb396-10"><a href="#cb396-10" aria-hidden="true" tabindex="-1"></a>(bit-count (<span class="op">-</span> (<span class="dv">1</span>+ (<span class="kw">expt</span> <span class="dv">2</span> <span class="dv">100</span>)))) <span class="op">=&gt;</span>  <span class="dv">1</span></span></code></pre></div>
<h2 id="integer-length-i"><code>(integer-length i)</code></h2>
<p>The number of bits needed to represent i, i.e.</p>
<div class="sourceCode" id="cb397"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb397-1"><a href="#cb397-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">ceiling</span> (<span class="op">/</span> (<span class="kw">log</span> (<span class="kw">if</span> (<span class="kw">negative?</span> integer)</span>
<span id="cb397-2"><a href="#cb397-2" aria-hidden="true" tabindex="-1"></a>                     (<span class="op">-</span> integer)</span>
<span id="cb397-3"><a href="#cb397-3" aria-hidden="true" tabindex="-1"></a>                     (<span class="op">+</span> <span class="dv">1</span> integer)))</span>
<span id="cb397-4"><a href="#cb397-4" aria-hidden="true" tabindex="-1"></a>            (<span class="kw">log</span> <span class="dv">2</span>)))</span></code></pre></div>
<p>The result is always non-negative. For non-negative i, this is the number of bits needed to represent i in an unsigned binary representation. For all i, (+ 1 (integer-length i)) is the number of bits needed to represent i in a signed twos-complement representation.</p>
<div class="sourceCode" id="cb398"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb398-1"><a href="#cb398-1" aria-hidden="true" tabindex="-1"></a>(integer-length  <span class="dv">0</span>) <span class="op">=&gt;</span> <span class="dv">0</span></span>
<span id="cb398-2"><a href="#cb398-2" aria-hidden="true" tabindex="-1"></a>(integer-length  <span class="dv">1</span>) <span class="op">=&gt;</span> <span class="dv">1</span></span>
<span id="cb398-3"><a href="#cb398-3" aria-hidden="true" tabindex="-1"></a>(integer-length -<span class="dv">1</span>) <span class="op">=&gt;</span> <span class="dv">0</span></span>
<span id="cb398-4"><a href="#cb398-4" aria-hidden="true" tabindex="-1"></a>(integer-length  <span class="dv">7</span>) <span class="op">=&gt;</span> <span class="dv">3</span></span>
<span id="cb398-5"><a href="#cb398-5" aria-hidden="true" tabindex="-1"></a>(integer-length -<span class="dv">7</span>) <span class="op">=&gt;</span> <span class="dv">3</span></span>
<span id="cb398-6"><a href="#cb398-6" aria-hidden="true" tabindex="-1"></a>(integer-length  <span class="dv">8</span>) <span class="op">=&gt;</span> <span class="dv">4</span></span>
<span id="cb398-7"><a href="#cb398-7" aria-hidden="true" tabindex="-1"></a>(integer-length -<span class="dv">8</span>) <span class="op">=&gt;</span> <span class="dv">3</span></span></code></pre></div>
<h2 id="bitwise-if-mask-i-j"><code>(bitwise-if mask i j)</code></h2>
<p>Merge the bitstrings i and j, with bitstring mask determining from which string to take each bit. That is, if the kth bit of mask is 1, then the kth bit of the result is the kth bit of i, otherwise the kth bit of j.</p>
<div class="sourceCode" id="cb399"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb399-1"><a href="#cb399-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">bitwise-if</span> <span class="dv">3</span> <span class="dv">1</span> <span class="dv">8</span>) <span class="op">=&gt;</span> <span class="dv">9</span></span>
<span id="cb399-2"><a href="#cb399-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">bitwise-if</span> <span class="dv">3</span> <span class="dv">8</span> <span class="dv">1</span>) <span class="op">=&gt;</span> <span class="dv">0</span></span>
<span id="cb399-3"><a href="#cb399-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">bitwise-if</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="op">=&gt;</span> <span class="dv">3</span></span>
<span id="cb399-4"><a href="#cb399-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">bitwise-if</span> <span class="sc">#b</span><span class="dv">00111100</span> <span class="sc">#b</span><span class="dv">11110000</span> <span class="sc">#b</span><span class="dv">00001111</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">00110011</span></span></code></pre></div>
<h2 id="bit-set-index-i"><code>(bit-set? index i)</code></h2>
<p>Is bit index set in bitstring i (where index is a non-negative exact integer)?</p>
<p>Compatibility note: The R6RS analogue bitwise-bit-set? accepts its arguments in the opposite order.</p>
<div class="sourceCode" id="cb400"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb400-1"><a href="#cb400-1" aria-hidden="true" tabindex="-1"></a>(bit-set? <span class="dv">1</span> <span class="dv">1</span>) <span class="op">=&gt;</span>  false</span>
<span id="cb400-2"><a href="#cb400-2" aria-hidden="true" tabindex="-1"></a>(bit-set? <span class="dv">0</span> <span class="dv">1</span>) <span class="op">=&gt;</span>  true</span>
<span id="cb400-3"><a href="#cb400-3" aria-hidden="true" tabindex="-1"></a>(bit-set? <span class="dv">3</span> <span class="dv">10</span>) <span class="op">=&gt;</span>  true</span>
<span id="cb400-4"><a href="#cb400-4" aria-hidden="true" tabindex="-1"></a>(bit-set? <span class="dv">1000000</span> -<span class="dv">1</span>) <span class="op">=&gt;</span>  true</span>
<span id="cb400-5"><a href="#cb400-5" aria-hidden="true" tabindex="-1"></a>(bit-set? <span class="dv">2</span> <span class="dv">6</span>) <span class="op">=&gt;</span>  true</span>
<span id="cb400-6"><a href="#cb400-6" aria-hidden="true" tabindex="-1"></a>(bit-set? <span class="dv">0</span> <span class="dv">6</span>) <span class="op">=&gt;</span>  false</span></code></pre></div>
<h2 id="copy-bit-index-i-boolean"><code>(copy-bit index i boolean)</code></h2>
<p>Returns an integer the same as i except in the indexth bit, which is 1 if boolean is #t and 0 if boolean is #f.</p>
<p>Compatibility note: The R6RS analogue bitwise-copy-bit as originally documented has a completely different interface. (bitwise-copy-bit dest index source) replaces the index’th bit of dest with the index’th bit of source. It is equivalent to (bit-field-replace-same dest source index (+ index 1)). However, an erratum made a silent breaking change to interpret the third argument as 0 for a false bit and 1 for a true bit. Some R6RS implementations applied this erratum but others did not.</p>
<div class="sourceCode" id="cb401"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb401-1"><a href="#cb401-1" aria-hidden="true" tabindex="-1"></a>(copy-bit <span class="dv">0</span> <span class="dv">0</span> <span class="dv">#t</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">1</span></span>
<span id="cb401-2"><a href="#cb401-2" aria-hidden="true" tabindex="-1"></a>(copy-bit <span class="dv">2</span> <span class="dv">0</span> <span class="dv">#t</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">100</span></span>
<span id="cb401-3"><a href="#cb401-3" aria-hidden="true" tabindex="-1"></a>(copy-bit <span class="dv">2</span> <span class="sc">#b</span><span class="dv">1111</span> <span class="dv">#f</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">1011</span></span></code></pre></div>
<h2 id="bit-swap-index1-index2-i"><code>(bit-swap index1 index2 i)</code></h2>
<p>Returns an integer the same as i except that the index1th bit and the index2th bit have been exchanged.</p>
<div class="sourceCode" id="cb402"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb402-1"><a href="#cb402-1" aria-hidden="true" tabindex="-1"></a>(bit-swap <span class="dv">0</span> <span class="dv">2</span> <span class="dv">4</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">1</span></span></code></pre></div>
<h2 id="any-bit-set-test-bits-i"><code>(any-bit-set? test-bits i)</code></h2>
<h2 id="every-bit-set-test-bits-i"><code>(every-bit-set? test-bits i)</code></h2>
<p>Determines if any/all of the bits set in bitstring test-bits are set in bitstring i. I.e., returns (not (zero? (bitwise-and test-bits i))) and (= test-bits (bitwise-and test-bits i))) respectively.</p>
<div class="sourceCode" id="cb403"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb403-1"><a href="#cb403-1" aria-hidden="true" tabindex="-1"></a>(any-bit-set? <span class="dv">3</span> <span class="dv">6</span>) <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb403-2"><a href="#cb403-2" aria-hidden="true" tabindex="-1"></a>(any-bit-set? <span class="dv">3</span> <span class="dv">12</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb403-3"><a href="#cb403-3" aria-hidden="true" tabindex="-1"></a>(every-bit-set? <span class="dv">4</span> <span class="dv">6</span>) <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb403-4"><a href="#cb403-4" aria-hidden="true" tabindex="-1"></a>(every-bit-set? <span class="dv">7</span> <span class="dv">6</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="first-set-bit-i"><code>(first-set-bit i)</code></h2>
<p>Return the index of the first (smallest index) 1 bit in bitstring i. Return -1 if i contains no 1 bits (i.e., if i is zero).</p>
<div class="sourceCode" id="cb404"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb404-1"><a href="#cb404-1" aria-hidden="true" tabindex="-1"></a>(first-set-bit <span class="dv">1</span>) <span class="op">=&gt;</span> <span class="dv">0</span></span>
<span id="cb404-2"><a href="#cb404-2" aria-hidden="true" tabindex="-1"></a>(first-set-bit <span class="dv">2</span>) <span class="op">=&gt;</span> <span class="dv">1</span></span>
<span id="cb404-3"><a href="#cb404-3" aria-hidden="true" tabindex="-1"></a>(first-set-bit <span class="dv">0</span>) <span class="op">=&gt;</span> -<span class="dv">1</span></span>
<span id="cb404-4"><a href="#cb404-4" aria-hidden="true" tabindex="-1"></a>(first-set-bit <span class="dv">40</span>) <span class="op">=&gt;</span> <span class="dv">3</span></span>
<span id="cb404-5"><a href="#cb404-5" aria-hidden="true" tabindex="-1"></a>(first-set-bit -<span class="dv">28</span>) <span class="op">=&gt;</span> <span class="dv">2</span></span>
<span id="cb404-6"><a href="#cb404-6" aria-hidden="true" tabindex="-1"></a>(first-set-bit (<span class="kw">expt</span>  <span class="dv">2</span> <span class="dv">99</span>)) <span class="op">=&gt;</span> <span class="dv">99</span></span>
<span id="cb404-7"><a href="#cb404-7" aria-hidden="true" tabindex="-1"></a>(first-set-bit (<span class="kw">expt</span> -<span class="dv">2</span> <span class="dv">99</span>)) <span class="op">=&gt;</span> <span class="dv">99</span></span></code></pre></div>
<h2 id="bit-field-i-start-end"><code>(bit-field i start end)</code></h2>
<p>Returns the field from i, shifted down to the least-significant position in the result.</p>
<div class="sourceCode" id="cb405"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb405-1"><a href="#cb405-1" aria-hidden="true" tabindex="-1"></a>(bit-field <span class="sc">#b</span><span class="dv">1101101010</span> <span class="dv">0</span> <span class="dv">4</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">1010</span></span>
<span id="cb405-2"><a href="#cb405-2" aria-hidden="true" tabindex="-1"></a>(bit-field <span class="sc">#b</span><span class="dv">1101101010</span> <span class="dv">3</span> <span class="dv">9</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">101101</span></span>
<span id="cb405-3"><a href="#cb405-3" aria-hidden="true" tabindex="-1"></a>(bit-field <span class="sc">#b</span><span class="dv">1101101010</span> <span class="dv">4</span> <span class="dv">9</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">10110</span></span>
<span id="cb405-4"><a href="#cb405-4" aria-hidden="true" tabindex="-1"></a>(bit-field <span class="sc">#b</span><span class="dv">1101101010</span> <span class="dv">4</span> <span class="dv">10</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">110110</span></span>
<span id="cb405-5"><a href="#cb405-5" aria-hidden="true" tabindex="-1"></a>(bit-field <span class="dv">6</span> <span class="dv">0</span> <span class="dv">1</span>) <span class="op">=&gt;</span> <span class="dv">0</span></span>
<span id="cb405-6"><a href="#cb405-6" aria-hidden="true" tabindex="-1"></a>(bit-field <span class="dv">6</span> <span class="dv">1</span> <span class="dv">3</span>) <span class="op">=&gt;</span> <span class="dv">3</span></span>
<span id="cb405-7"><a href="#cb405-7" aria-hidden="true" tabindex="-1"></a>(bit-field <span class="dv">6</span> <span class="dv">2</span> <span class="dv">999</span>) <span class="op">=&gt;</span> <span class="dv">1</span></span>
<span id="cb405-8"><a href="#cb405-8" aria-hidden="true" tabindex="-1"></a>(bit-field <span class="sc">#x</span><span class="dv">100000000000000000000000000000000</span> <span class="dv">128</span> <span class="dv">129</span>) <span class="op">=&gt;</span> <span class="dv">1</span></span></code></pre></div>
<h2 id="bit-field-any-i-start-end"><code>(bit-field-any? i start end)</code></h2>
<p>Returns true if any of the field’s bits are set in bitstring i, and false otherwise.</p>
<div class="sourceCode" id="cb406"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb406-1"><a href="#cb406-1" aria-hidden="true" tabindex="-1"></a>(bit-field-any? <span class="sc">#b</span><span class="dv">1001001</span> <span class="dv">1</span> <span class="dv">6</span>) <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb406-2"><a href="#cb406-2" aria-hidden="true" tabindex="-1"></a>(bit-field-any? <span class="sc">#b</span><span class="dv">1000001</span> <span class="dv">1</span> <span class="dv">6</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="bit-field-every-i-start-end"><code>(bit-field-every? i start end)</code></h2>
<p>Returns false if any of the field’s bits are not set in bitstring i, and true otherwise.</p>
<div class="sourceCode" id="cb407"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb407-1"><a href="#cb407-1" aria-hidden="true" tabindex="-1"></a>(bit-field-every? <span class="sc">#b</span><span class="dv">1011110</span> <span class="dv">1</span> <span class="dv">5</span>) <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb407-2"><a href="#cb407-2" aria-hidden="true" tabindex="-1"></a>(bit-field-every? <span class="sc">#b</span><span class="dv">1011010</span> <span class="dv">1</span> <span class="dv">5</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="bit-field-clear-i-start-end"><code>(bit-field-clear i start end)</code></h2>
<h2 id="bit-field-set-i-start-end"><code>(bit-field-set i start end)</code></h2>
<p>Returns i with the field’s bits set to all 0s/1s.</p>
<div class="sourceCode" id="cb408"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb408-1"><a href="#cb408-1" aria-hidden="true" tabindex="-1"></a>(bit-field-clear <span class="sc">#b</span><span class="dv">101010</span> <span class="dv">1</span> <span class="dv">4</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">100000</span></span>
<span id="cb408-2"><a href="#cb408-2" aria-hidden="true" tabindex="-1"></a>(bit-field-set <span class="sc">#b</span><span class="dv">101010</span> <span class="dv">1</span> <span class="dv">4</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">101110</span></span></code></pre></div>
<h2 id="bit-field-replace-dest-source-start-end"><code>(bit-field-replace dest source start end)</code></h2>
<p>Returns dest with the field replaced by the least-significant end-start bits in source.</p>
<div class="sourceCode" id="cb409"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb409-1"><a href="#cb409-1" aria-hidden="true" tabindex="-1"></a>(bit-field-replace <span class="sc">#b</span><span class="dv">101010</span> <span class="sc">#b</span><span class="dv">010</span> <span class="dv">1</span> <span class="dv">4</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">100100</span></span>
<span id="cb409-2"><a href="#cb409-2" aria-hidden="true" tabindex="-1"></a>(bit-field-replace <span class="sc">#b</span><span class="dv">110</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">1</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">111</span></span>
<span id="cb409-3"><a href="#cb409-3" aria-hidden="true" tabindex="-1"></a>(bit-field-replace <span class="sc">#b</span><span class="dv">110</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">110</span></span></code></pre></div>
<h2 id="bit-field-replace-same-dest-source-start-end"><code>(bit-field-replace-same dest source start end)</code></h2>
<p>Returns dest with its field replaced by the corresponding field in source.</p>
<div class="sourceCode" id="cb410"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb410-1"><a href="#cb410-1" aria-hidden="true" tabindex="-1"></a>(bit-field-replace-same <span class="sc">#b</span><span class="dv">1111</span> <span class="sc">#b</span><span class="dv">0000</span> <span class="dv">1</span> <span class="dv">3</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">1001</span></span></code></pre></div>
<h2 id="bit-field-rotate-i-count-start-end"><code>(bit-field-rotate i count start end)</code></h2>
<p>Returns i with the field cyclically permuted by count bits towards high-order.</p>
<p>Compatibility note: The R6RS analogue bitwise-rotate-bit-field uses the argument ordering i start end count.</p>
<div class="sourceCode" id="cb411"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb411-1"><a href="#cb411-1" aria-hidden="true" tabindex="-1"></a>(bit-field-rotate <span class="sc">#b</span><span class="dv">110</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">10</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">110</span></span>
<span id="cb411-2"><a href="#cb411-2" aria-hidden="true" tabindex="-1"></a>(bit-field-rotate <span class="sc">#b</span><span class="dv">110</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">256</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">110</span></span>
<span id="cb411-3"><a href="#cb411-3" aria-hidden="true" tabindex="-1"></a>(bit-field-rotate <span class="sc">#x</span><span class="dv">100000000000000000000000000000000</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">129</span>) <span class="op">=&gt;</span> <span class="dv">1</span></span>
<span id="cb411-4"><a href="#cb411-4" aria-hidden="true" tabindex="-1"></a>(bit-field-rotate <span class="sc">#b</span><span class="dv">110</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">110</span></span>
<span id="cb411-5"><a href="#cb411-5" aria-hidden="true" tabindex="-1"></a>(bit-field-rotate <span class="sc">#b</span><span class="dv">110</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">1010</span></span>
<span id="cb411-6"><a href="#cb411-6" aria-hidden="true" tabindex="-1"></a>(bit-field-rotate <span class="sc">#b</span><span class="dv">0111</span> -<span class="dv">1</span> <span class="dv">1</span> <span class="dv">4</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">1011</span></span></code></pre></div>
<h2 id="bit-field-reverse-i-start-end"><code>(bit-field-reverse i start end)</code></h2>
<p>Returns i with the order of the bits in the field reversed.</p>
<div class="sourceCode" id="cb412"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb412-1"><a href="#cb412-1" aria-hidden="true" tabindex="-1"></a>(bit-field-reverse <span class="dv">6</span> <span class="dv">1</span> <span class="dv">3</span>) <span class="op">=&gt;</span> <span class="dv">6</span></span>
<span id="cb412-2"><a href="#cb412-2" aria-hidden="true" tabindex="-1"></a>(bit-field-reverse <span class="dv">6</span> <span class="dv">1</span> <span class="dv">4</span>) <span class="op">=&gt;</span> <span class="dv">12</span></span>
<span id="cb412-3"><a href="#cb412-3" aria-hidden="true" tabindex="-1"></a>(bit-field-reverse <span class="dv">1</span> <span class="dv">0</span> <span class="dv">32</span>) <span class="op">=&gt;</span> <span class="sc">#x</span><span class="dv">80000000</span></span>
<span id="cb412-4"><a href="#cb412-4" aria-hidden="true" tabindex="-1"></a>(bit-field-reverse <span class="dv">1</span> <span class="dv">0</span> <span class="dv">31</span>) <span class="op">=&gt;</span> <span class="sc">#x</span><span class="dv">40000000</span></span>
<span id="cb412-5"><a href="#cb412-5" aria-hidden="true" tabindex="-1"></a>(bit-field-reverse <span class="dv">1</span> <span class="dv">0</span> <span class="dv">30</span>) <span class="op">=&gt;</span> <span class="sc">#x</span><span class="dv">20000000</span></span>
<span id="cb412-6"><a href="#cb412-6" aria-hidden="true" tabindex="-1"></a>(bit-field-reverse <span class="sc">#x</span><span class="dv">140000000000000000000000000000000</span> <span class="dv">0</span> <span class="dv">129</span>) <span class="op">=&gt;</span> <span class="dv">5</span></span></code></pre></div>
<h2 id="bits-list-i-len"><code>(bits-&gt;list i [ len ])</code></h2>
<h2 id="bits-vector-i-len"><code>(bits-&gt;vector i [ len ])</code></h2>
<p>Returns a list/vector of len booleans corresponding to each bit of the non-negative integer i, returning bit #0 as the first element, bit #1 as the second, and so on. #t is returned for each 1; #f for 0.</p>
<div class="sourceCode" id="cb413"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb413-1"><a href="#cb413-1" aria-hidden="true" tabindex="-1"></a>(bits-&gt;list <span class="sc">#b</span><span class="dv">1110101</span>)) <span class="op">=&gt;</span> (<span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)</span>
<span id="cb413-2"><a href="#cb413-2" aria-hidden="true" tabindex="-1"></a>(bits-&gt;list <span class="dv">3</span> <span class="dv">5</span>)) <span class="op">=&gt;</span> (<span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#f</span>)</span>
<span id="cb413-3"><a href="#cb413-3" aria-hidden="true" tabindex="-1"></a>(bits-&gt;list <span class="dv">6</span> <span class="dv">4</span>)) <span class="op">=&gt;</span> (<span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#f</span>)</span>
<span id="cb413-4"><a href="#cb413-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-5"><a href="#cb413-5" aria-hidden="true" tabindex="-1"></a>(bits-&gt;vector <span class="sc">#b</span><span class="dv">1110101</span>)) <span class="op">=&gt;</span> #(<span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)</span></code></pre></div>
<h2 id="list-bits-list"><code>(list-&gt;bits list)</code></h2>
<h2 id="vector-bits-vector"><code>(vector-&gt;bits vector)</code></h2>
<p>Returns an integer formed from the booleans in list/vector, using the first element as bit #0, the second element as bit #1, and so on. It is an error if list/vector contains non-booleans. A 1 bit is coded for each #t; a 0 bit for #f. Note that the result is never a negative integer.</p>
<div class="sourceCode" id="cb414"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb414-1"><a href="#cb414-1" aria-hidden="true" tabindex="-1"></a>(list-&gt;bits &#39;(<span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">1110101</span></span>
<span id="cb414-2"><a href="#cb414-2" aria-hidden="true" tabindex="-1"></a>(list-&gt;bits &#39;(<span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">111010100</span></span>
<span id="cb414-3"><a href="#cb414-3" aria-hidden="true" tabindex="-1"></a>(list-&gt;bits &#39;(<span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="op">=&gt;</span> <span class="dv">6</span></span>
<span id="cb414-4"><a href="#cb414-4" aria-hidden="true" tabindex="-1"></a>(list-&gt;bits &#39;(<span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#f</span>)) <span class="op">=&gt;</span> <span class="dv">6</span></span>
<span id="cb414-5"><a href="#cb414-5" aria-hidden="true" tabindex="-1"></a>(list-&gt;bits &#39;(<span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="op">=&gt;</span> <span class="dv">12</span></span>
<span id="cb414-6"><a href="#cb414-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb414-7"><a href="#cb414-7" aria-hidden="true" tabindex="-1"></a>(vector-&gt;bits &#39;#(<span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">1110101</span></span>
<span id="cb414-8"><a href="#cb414-8" aria-hidden="true" tabindex="-1"></a>(vector-&gt;bits &#39;#(<span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">111010100</span></span>
<span id="cb414-9"><a href="#cb414-9" aria-hidden="true" tabindex="-1"></a>(vector-&gt;bits &#39;#(<span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="op">=&gt;</span> <span class="dv">6</span></span>
<span id="cb414-10"><a href="#cb414-10" aria-hidden="true" tabindex="-1"></a>(vector-&gt;bits &#39;#(<span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#f</span>)) <span class="op">=&gt;</span> <span class="dv">6</span></span>
<span id="cb414-11"><a href="#cb414-11" aria-hidden="true" tabindex="-1"></a>(vector-&gt;bits &#39;#(<span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="op">=&gt;</span> <span class="dv">12</span></span></code></pre></div>
<p>For positive integers, bits-&gt;list and list-&gt;bits are inverses in the sense of equal?, and so are bits-&gt;vector and vector-&gt;bits.</p>
<h2 id="bits-bool-..."><code>(bits bool ...)</code></h2>
<p>Returns the integer coded by the bool arguments. The first argument is bit #0, the second argument is bit #1, and so on. Note that the result is never a negative integer.</p>
<div class="sourceCode" id="cb415"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb415-1"><a href="#cb415-1" aria-hidden="true" tabindex="-1"></a>(bits <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">1110101</span></span>
<span id="cb415-2"><a href="#cb415-2" aria-hidden="true" tabindex="-1"></a>(bits <span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">111010100</span></span></code></pre></div>
<h2 id="bitwise-fold-proc-seed-i"><code>(bitwise-fold proc seed i)</code></h2>
<p>For each bit b of i from bit #0 (inclusive) to bit (integer-length i) (exclusive), proc is called as (proc b r), where r is the current accumulated result. The initial value of r is seed, and the value returned by proc becomes the next accumulated result. When the last bit has been processed, the final accumulated result becomes the result of bitwise-fold.</p>
<div class="sourceCode" id="cb416"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb416-1"><a href="#cb416-1" aria-hidden="true" tabindex="-1"></a>(bitwise-fold <span class="kw">cons</span> &#39;() <span class="sc">#b</span><span class="dv">1010111</span>) <span class="op">=&gt;</span> (<span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)</span></code></pre></div>
<h2 id="bitwise-for-each-proc-i"><code>(bitwise-for-each proc i)</code></h2>
<p>Repeatedly applies proc to the bits of i starting with bit #0 (inclusive) and ending with bit (integer-length i) (exclusive). The values returned by proc are discarded. Returns an unspecified value.</p>
<div class="sourceCode" id="cb417"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb417-1"><a href="#cb417-1" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">let</span> ((count <span class="dv">0</span>))</span>
<span id="cb417-2"><a href="#cb417-2" aria-hidden="true" tabindex="-1"></a>        (bitwise-for-each (<span class="kw">lambda</span> (b) (<span class="kw">if</span> b (<span class="kw">set!</span> count (<span class="op">+</span> count <span class="dv">1</span>))))</span>
<span id="cb417-3"><a href="#cb417-3" aria-hidden="true" tabindex="-1"></a>                          <span class="sc">#b</span><span class="dv">1010111</span>)</span>
<span id="cb417-4"><a href="#cb417-4" aria-hidden="true" tabindex="-1"></a>       count)</span></code></pre></div>
<h2 id="bitwise-unfold-stop-mapper-successor-seed"><code>(bitwise-unfold stop? mapper successor seed)</code></h2>
<p>Generates a non-negative integer bit by bit, starting with bit 0. If the result of applying stop? to the current state (whose initial value is seed) is true, return the currently accumulated bits as an integer. Otherwise, apply mapper to the current state to obtain the next bit of the result by interpreting a true value as a 1 bit and a false value as a 0 bit. Then get a new state by applying successor to the current state, and repeat this algorithm.</p>
<div class="sourceCode" id="cb418"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb418-1"><a href="#cb418-1" aria-hidden="true" tabindex="-1"></a>  (bitwise-unfold (<span class="kw">lambda</span> (i) (<span class="op">=</span> i <span class="dv">10</span>))</span>
<span id="cb418-2"><a href="#cb418-2" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">even?</span></span>
<span id="cb418-3"><a href="#cb418-3" aria-hidden="true" tabindex="-1"></a>                  (<span class="kw">lambda</span> (i) (<span class="op">+</span> i <span class="dv">1</span>))</span>
<span id="cb418-4"><a href="#cb418-4" aria-hidden="true" tabindex="-1"></a>                  <span class="dv">0</span>)) <span class="op">=&gt;</span> <span class="sc">#b</span><span class="dv">101010101</span></span></code></pre></div>
<h2 id="make-bitwise-generator-i"><code>(make-bitwise-generator i)</code></h2>
<p>Returns a SRFI 121 generator that generates all the bits of i starting with bit #0. Note that the generator is infinite.</p>
<div class="sourceCode" id="cb419"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb419-1"><a href="#cb419-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> ((g (make-bitwise-generator <span class="sc">#b</span><span class="dv">110</span>)))</span>
<span id="cb419-2"><a href="#cb419-2" aria-hidden="true" tabindex="-1"></a>  (test <span class="dv">#f</span> (g))</span>
<span id="cb419-3"><a href="#cb419-3" aria-hidden="true" tabindex="-1"></a>  (test <span class="dv">#t</span> (g))</span>
<span id="cb419-4"><a href="#cb419-4" aria-hidden="true" tabindex="-1"></a>  (test <span class="dv">#t</span> (g))</span>
<span id="cb419-5"><a href="#cb419-5" aria-hidden="true" tabindex="-1"></a>  (test <span class="dv">#f</span> (g)))</span></code></pre></div>
<h1 id="scheme-file"><code>(scheme file)</code></h1>
<h2 id="call-with-input-file"><code>(call-with-input-file)</code></h2>
<p>TODO</p>
<h2 id="call-with-output-file"><code>(call-with-output-file)</code></h2>
<p>TODO</p>
<h2 id="delete-file"><code>(delete-file)</code></h2>
<p>TODO</p>
<h2 id="file-exists"><code>(file-exists?)</code></h2>
<p>TODO</p>
<h2 id="open-input-file"><code>(open-input-file)</code></h2>
<p>TODO</p>
<h2 id="open-output-file"><code>(open-output-file)</code></h2>
<p>TODO</p>
<h2 id="with-input-from-file"><code>(with-input-from-file)</code></h2>
<p>TODO</p>
<h2 id="with-output-to-file"><code>(with-output-to-file)</code></h2>
<p>TODO</p>
<h2 id="open-binary-input-file"><code>(open-binary-input-file)</code></h2>
<p>TODO</p>
<h2 id="open-binary-output-file"><code>(open-binary-output-file)</code></h2>
<p>TODO # <code>(scheme rlist)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-101/">SRFI-101</a>.</p>
<p>Random-access lists [1] are a purely functional data structure for representing lists of values. A random-access list may act as a drop in replacement for the usual linear-access pair and list data structures (pair?, cons, car, cdr), which additionally supports fast index-based addressing and updating (list-ref, list-set). The impact is a whole class of purely-functional algorithms expressed in terms of index-based list addressing become feasible compared with their linear-access list counterparts.</p>
<p>This document proposes a library API for purely functional random-access lists consistent with the R6RS [2] base library and list utility standard library [3]. # <code>(scheme repl)</code></p>
<h2 id="interaction-environment"><code>(interaction-environment)</code></h2>
<p>This procedure returns a specifier for a mutable environment that contains an implementation-defined set of bindings, typically a superset of those exported by <code>(arew scheme base)</code>. The intent is that this procedure will return the environment in which the implementation would evaluate expressions entered by the user into a REPL.</p>
<h1 id="scheme-box"><code>(scheme box)</code></h1>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-111/">SRFI-111</a>.</p>
<p>Boxes are objects with a single mutable state. Several Schemes have them, sometimes called cells. A constructor, predicate, accessor, and mutator are provided.</p>
<h2 id="box-value"><code>(box value)</code></h2>
<p>Constructor. Returns a newly allocated box initialized to value.</p>
<h2 id="box-object"><code>(box? object)</code></h2>
<p>Predicate. Returns <code>#t</code> if object is a box, and <code>#f</code> otherwise.</p>
<h2 id="unbox-box"><code>(unbox box)</code></h2>
<p>Accessor. Returns the current value of box.</p>
<h2 id="set-box-box-value"><code>(set-box! box value)</code></h2>
<p>Mutator. Changes box to hold value.</p>
<h1 id="scheme-lazy"><code>(scheme lazy)</code></h1>
<h2 id="delay-exp"><code>(delay exp)</code></h2>
<p>TODO</p>
<h2 id="force-promise"><code>(force promise)</code></h2>
<p>TODO</p>
<h2 id="delay-force-exp"><code>(delay-force exp)</code></h2>
<p>TODO</p>
<h2 id="promise-obj"><code>(promise? obj)</code></h2>
<p>TODO</p>
<h2 id="make-promise-exp"><code>(make-promise exp)</code></h2>
<p>TODO # <code>(scheme regex)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-115/">SRFI-115</a>.</p>
<p>This library provides a library for matching strings with regular expressions described using the SRE “Scheme Regular Expression” notation first introduced by SCSH, and extended heavily by IrRegex.</p>
<h2 id="regexp-re"><code>(regexp re)</code></h2>
<p>Compiles a regexp if given an object whose structure matches the SRE syntax. This may be written as a literal or partial literal with quote or quasiquote, or may be generated entirely programmatically. Returns re unmodified if it is already a regexp. Raises an error if re is neither a regexp nor a valid representation of an SRE.</p>
<p>Mutating re may invalidate the resulting regexp, causing unspecified results if subsequently used for matching.</p>
<h2 id="rx-sre-..."><code>(rx sre ...)</code></h2>
<p>Macro shorthand for (regexp `(: sre …)). May be able to perform some or all computation at compile time if sre is not unquoted. Note because of this equivalence with the procedural constructor regexp, the semantics of unquote differs from the original SCSH implementation in that unquoted expressions can expand into any object matching the SRE syntax, but not a compiled regexp object. Further, unquote and unquote-splicing both expand all matches.</p>
<p>Rationale: Providing a procedural interface provides for greater flexibility, and without loss of potential compile-time optimizations by preserving the syntactic shorthand. The alternative is to rely on eval to dynamically generate regular expressions. However regexps in many cases come from untrusted sources, such as search parameters to a server, or from serialized sources such as config files or command-line arguments. Moreover many applications may want to keep many thousands of regexps in memory at once. Given the relatively heavy cost and insecurity of eval, and the frequency with which SREs are read and written as text, we prefer the procedural interface.</p>
<h2 id="regexp-sre-re"><code>(regexp-&gt;sre re)</code></h2>
<p>Returns an SRE corresponding to the given regexp re. The SRE will be equivalent to (will match the same strings) but not necessarily equal? to the SRE originally used to compile re. Mutating the result may invalidate re, causing unspecified results if subsequently used for matching.</p>
<h2 id="char-set-sre-char-set"><code>(char-set-&gt;sre char-set)</code></h2>
<p>Returns an SRE corresponding to the given SRFI 14 character set. The resulting SRE expands the character set into notation which does not make use of embedded SRFI 14 character sets, and so is suitable for writing portably.</p>
<h2 id="valid-sre-obj"><code>(valid-sre? obj)</code></h2>
<p>Returns true iff obj can be safely passed to regexp.</p>
<h2 id="regexp-obj"><code>(regexp? obj)</code></h2>
<p>Returns true iff obj is a regexp.</p>
<h2 id="regexp-matches-re-str-start-end"><code>(regexp-matches re str [start [end]])</code></h2>
<p>Returns an regexp-match object if re successfully matches the entire string str from start (inclusive) to end (exclusive), or #f is the match fails. The regexp-match object will contain information needed to extract any submatches.</p>
<h2 id="regexp-matches-re-str-start-end-1"><code>(regexp-matches? re str [start [end]])</code></h2>
<p>Returns #t if re matches str as in regexp-matches, or #f otherwise. May be faster than regexp-matches since it doesn’t need to return submatch data.</p>
<h2 id="regexp-search-re-str-start-end"><code>(regexp-search re str [start [end]])</code></h2>
<p>Returns a regexp-match object if re successfully matches a substring of str between start (inclusive) and end (exclusive), or #f if the match fails. The regexp-match object will contain information needed to extract any submatches.</p>
<h2 id="regexp-fold-re-kons-knil-str-finish-start-end"><code>(regexp-fold re kons knil str [finish [start [end]]])</code></h2>
<p>The fundamental regexp matching iterator. Repeatedly searches str for the regexp re so long as a match can be found. On each successful match, applies (kons i regexp-match str acc) where i is the index since the last match (beginning with start), regexp-match is the resulting match, and acc is the result of the previous kons application, beginning with knil. When no more matches can be found, calls finish with the same arguments, except that regexp-match is #f.</p>
<p>By default finish just returns acc.</p>
<div class="sourceCode" id="cb420"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb420-1"><a href="#cb420-1" aria-hidden="true" tabindex="-1"></a>   (regexp-fold &#39;word</span>
<span id="cb420-2"><a href="#cb420-2" aria-hidden="true" tabindex="-1"></a>                (<span class="kw">lambda</span> (i m str acc)</span>
<span id="cb420-3"><a href="#cb420-3" aria-hidden="true" tabindex="-1"></a>                  (<span class="kw">let</span> ((s (regexp-match-submatch m <span class="dv">0</span>)))</span>
<span id="cb420-4"><a href="#cb420-4" aria-hidden="true" tabindex="-1"></a>                   (<span class="kw">cond</span> ((<span class="kw">assoc</span> s acc)</span>
<span id="cb420-5"><a href="#cb420-5" aria-hidden="true" tabindex="-1"></a>                          <span class="op">=&gt;</span> (<span class="kw">lambda</span> (x) (<span class="kw">set-cdr!</span> x (<span class="op">+</span> <span class="dv">1</span> (<span class="kw">cdr</span> x))) acc))</span>
<span id="cb420-6"><a href="#cb420-6" aria-hidden="true" tabindex="-1"></a>                         (<span class="kw">else</span> `((,s <span class="op">.</span> <span class="dv">1</span>) ,@acc)))))</span>
<span id="cb420-7"><a href="#cb420-7" aria-hidden="true" tabindex="-1"></a>                &#39;()</span>
<span id="cb420-8"><a href="#cb420-8" aria-hidden="true" tabindex="-1"></a>                <span class="st">&quot;to be or not to be&quot;</span>)</span>
<span id="cb420-9"><a href="#cb420-9" aria-hidden="true" tabindex="-1"></a>   <span class="op">=&gt;</span> &#39;((<span class="st">&quot;not&quot;</span> <span class="op">.</span> <span class="dv">1</span>) (<span class="st">&quot;or&quot;</span> <span class="op">.</span> <span class="dv">1</span>) (<span class="st">&quot;be&quot;</span> <span class="op">.</span> <span class="dv">2</span>) (<span class="st">&quot;to&quot;</span> <span class="op">.</span> <span class="dv">2</span>))</span></code></pre></div>
<h2 id="regexp-extract-re-str-start-end"><code>(regexp-extract re str [start [end]])</code></h2>
<p>Extracts all non-empty substrings of str which match re between start and end as a list of strings.</p>
<div class="sourceCode" id="cb421"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb421-1"><a href="#cb421-1" aria-hidden="true" tabindex="-1"></a>   (regexp-extract &#39;(<span class="op">+</span> numeric) <span class="st">&quot;192.168.0.1&quot;</span>)</span>
<span id="cb421-2"><a href="#cb421-2" aria-hidden="true" tabindex="-1"></a>   <span class="op">=&gt;</span> (<span class="st">&quot;192&quot;</span> <span class="st">&quot;168&quot;</span> <span class="st">&quot;0&quot;</span> <span class="st">&quot;1&quot;</span>)</span></code></pre></div>
<h2 id="regexp-split-re-str-start-end"><code>(regexp-split re str [start [end]])</code></h2>
<p>Splits str into a list of (possibly empty) strings separated by non-empty matches of re.</p>
<div class="sourceCode" id="cb422"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb422-1"><a href="#cb422-1" aria-hidden="true" tabindex="-1"></a>(regexp-split &#39;(<span class="op">+</span> space) <span class="st">&quot; fee fi  fo</span><span class="ch">\t</span><span class="st">fum</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb422-2"><a href="#cb422-2" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> (<span class="st">&quot;&quot;</span> <span class="st">&quot;fee&quot;</span> <span class="st">&quot;fi&quot;</span> <span class="st">&quot;fo&quot;</span> <span class="st">&quot;fum&quot;</span> <span class="st">&quot;&quot;</span>)</span>
<span id="cb422-3"><a href="#cb422-3" aria-hidden="true" tabindex="-1"></a>(regexp-split &#39;(<span class="st">&quot;,;&quot;</span>) <span class="st">&quot;a,,b,&quot;</span>)</span>
<span id="cb422-4"><a href="#cb422-4" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> (<span class="st">&quot;a&quot;</span> <span class="st">&quot;&quot;</span> <span class="st">&quot;b&quot;</span> <span class="st">&quot;&quot;</span>)</span>
<span id="cb422-5"><a href="#cb422-5" aria-hidden="true" tabindex="-1"></a>(regexp-split &#39;(<span class="op">*</span> digit) <span class="st">&quot;abc123def456ghi789&quot;</span>)</span>
<span id="cb422-6"><a href="#cb422-6" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> (<span class="st">&quot;abc&quot;</span> <span class="st">&quot;def&quot;</span> <span class="st">&quot;ghi&quot;</span> <span class="st">&quot;&quot;</span>)</span></code></pre></div>
<h2 id="regexp-partition-re-str-start-end"><code>(regexp-partition re str [start [end]])</code></h2>
<p>Partitions str into a list of non-empty strings matching re, interspersed with the unmatched portions of the string. The first and every odd element is an unmatched substring, which will be the empty string if re matches at the beginning of the string or end of the previous match. The second and every even element will be a substring matching re. If the final match ends at the end of the string, no trailing empty string will be included. Thus, in the degenerate case where str is the empty string, the result is (““).</p>
<p>Note that regexp-partition is equivalent to interleaving the results of regexp-split and regexp-extract, starting with the former.</p>
<div class="sourceCode" id="cb423"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb423-1"><a href="#cb423-1" aria-hidden="true" tabindex="-1"></a>(regexp-partition &#39;(<span class="op">+</span> (<span class="kw">or</span> space punct)) <span class="st">&quot;&quot;</span>)</span>
<span id="cb423-2"><a href="#cb423-2" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> (<span class="st">&quot;&quot;</span>)</span>
<span id="cb423-3"><a href="#cb423-3" aria-hidden="true" tabindex="-1"></a>(regexp-partition &#39;(<span class="op">+</span> (<span class="kw">or</span> space punct)) <span class="st">&quot;Hello, world!</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb423-4"><a href="#cb423-4" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> (<span class="st">&quot;Hello&quot;</span> <span class="st">&quot;, &quot;</span> <span class="st">&quot;world&quot;</span> <span class="st">&quot;!</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb423-5"><a href="#cb423-5" aria-hidden="true" tabindex="-1"></a>(regexp-partition &#39;(<span class="op">+</span> (<span class="kw">or</span> space punct)) <span class="st">&quot;¿Dónde Estás?&quot;</span>)</span>
<span id="cb423-6"><a href="#cb423-6" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> (<span class="st">&quot;&quot;</span> <span class="st">&quot;¿&quot;</span> <span class="st">&quot;Dónde&quot;</span> <span class="st">&quot; &quot;</span> <span class="st">&quot;Estás&quot;</span> <span class="st">&quot;?&quot;</span>)</span>
<span id="cb423-7"><a href="#cb423-7" aria-hidden="true" tabindex="-1"></a>(regexp-partition &#39;(<span class="op">*</span> digit) <span class="st">&quot;abc123def456ghi789&quot;</span>)</span>
<span id="cb423-8"><a href="#cb423-8" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> (<span class="st">&quot;abc&quot;</span> <span class="st">&quot;123&quot;</span> <span class="st">&quot;def&quot;</span> <span class="st">&quot;456&quot;</span> <span class="st">&quot;ghi&quot;</span> <span class="st">&quot;789&quot;</span>)</span></code></pre></div>
<h2 id="regexp-replace-re-str-subst-start-end-count"><code>(regexp-replace re str subst [start [end [count]])</code></h2>
<p>Returns a new string replacing the countth match of re in str the subst, where the zero-indexed count defaults to zero (i.e. the first match). If there are not count matches, returns the selected substring unmodified.</p>
<p>subst can be a string, an integer or symbol indicating the contents of a numbered or named submatch of re, ’pre for the substring to the left of the match, or ’post for the substring to the right of the match.</p>
<p>The optional parameters start and end restrict both the matching and the substitution, to the given indices, such that the result is equivalent to omitting these parameters and replacing on (substring str start end). As a convenience, a value of #f for end is equivalent to (string-length str).</p>
<div class="sourceCode" id="cb424"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb424-1"><a href="#cb424-1" aria-hidden="true" tabindex="-1"></a>(regexp-replace &#39;(<span class="op">+</span> space) <span class="st">&quot;one two three&quot;</span> <span class="st">&quot;_&quot;</span>)</span>
<span id="cb424-2"><a href="#cb424-2" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;one_two three&quot;</span></span>
<span id="cb424-3"><a href="#cb424-3" aria-hidden="true" tabindex="-1"></a>(regexp-replace &#39;(<span class="op">+</span> space) <span class="st">&quot;one two three&quot;</span> <span class="st">&quot;_&quot;</span> <span class="dv">0</span> <span class="dv">#f</span> <span class="dv">0</span>)</span>
<span id="cb424-4"><a href="#cb424-4" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;one_two three&quot;</span></span>
<span id="cb424-5"><a href="#cb424-5" aria-hidden="true" tabindex="-1"></a>(regexp-replace &#39;(<span class="op">+</span> space) <span class="st">&quot;one two three&quot;</span> <span class="st">&quot;_&quot;</span> <span class="dv">0</span> <span class="dv">#f</span> <span class="dv">1</span>)</span>
<span id="cb424-6"><a href="#cb424-6" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;one two_three&quot;</span></span>
<span id="cb424-7"><a href="#cb424-7" aria-hidden="true" tabindex="-1"></a>(regexp-replace &#39;(<span class="op">+</span> space) <span class="st">&quot;one two three&quot;</span> <span class="st">&quot;_&quot;</span> <span class="dv">0</span> <span class="dv">#f</span> <span class="dv">2</span>)</span>
<span id="cb424-8"><a href="#cb424-8" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span> <span class="st">&quot;one two three&quot;</span></span></code></pre></div>
<h2 id="regexp-replace-all-re-str-subst-start-end"><code>(regexp-replace-all re str subst [start [end]])</code></h2>
<p>Equivalent to regexp-replace, but replaces all occurrences of re in str.</p>
<pre><code>(regexp-replace-all &#39;(+ space) &quot;one two three&quot; &quot;_&quot;)
=&gt; &quot;one_two_three&quot;</code></pre>
<h2 id="regexp-match-obj"><code>(regexp-match? obj)</code></h2>
<p>Returns true iff obj is a successful match from regexp-matches or regexp-search.</p>
<div class="sourceCode" id="cb426"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb426-1"><a href="#cb426-1" aria-hidden="true" tabindex="-1"></a>(regexp-match? (regexp-matches <span class="st">&quot;x&quot;</span> <span class="st">&quot;x&quot;</span>))  <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb426-2"><a href="#cb426-2" aria-hidden="true" tabindex="-1"></a>(regexp-match? (regexp-matches <span class="st">&quot;x&quot;</span> <span class="st">&quot;y&quot;</span>))  <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="regexp-match-count-regexp-match"><code>(regexp-match-count regexp-match)</code></h2>
<p>Returns the number of submatches of regexp-match, regardless of whether they matched or not. Does not include the implicit zero full match in the count.</p>
<div class="sourceCode" id="cb427"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb427-1"><a href="#cb427-1" aria-hidden="true" tabindex="-1"></a>(regexp-match-count (regexp-matches <span class="st">&quot;x&quot;</span> <span class="st">&quot;x&quot;</span>))  <span class="op">=&gt;</span> <span class="dv">0</span></span>
<span id="cb427-2"><a href="#cb427-2" aria-hidden="true" tabindex="-1"></a>(regexp-match-count (regexp-matches &#39;(<span class="op">$</span> <span class="st">&quot;x&quot;</span>) <span class="st">&quot;x&quot;</span>))  <span class="op">=&gt;</span> <span class="dv">1</span></span></code></pre></div>
<h2 id="regexp-match-submatch-regexp-match-field"><code>(regexp-match-submatch regexp-match field)</code></h2>
<p>Returns the substring matched in regexp-match corresponding to field, either an integer or a symbol for a named submatch. Index 0 refers to the entire match, index 1 to the first lexicographic submatch, and so on. If there are multiple submatches with the same name, the first which matched is returned. If passed an integer outside the range of matches, or a symbol which does not correspond to a named submatch of the pattern, it is an error. If the corresponding submatch did not match, returns false.</p>
<p>The result of extracting a submatch after the original matched string has been mutated is unspecified.</p>
<div class="sourceCode" id="cb428"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb428-1"><a href="#cb428-1" aria-hidden="true" tabindex="-1"></a>(regexp-match-submatch (regexp-search &#39;word <span class="st">&quot;**foo**&quot;</span>) <span class="dv">0</span>)  <span class="op">=&gt;</span> <span class="st">&quot;foo&quot;</span></span>
<span id="cb428-2"><a href="#cb428-2" aria-hidden="true" tabindex="-1"></a>(regexp-match-submatch</span>
<span id="cb428-3"><a href="#cb428-3" aria-hidden="true" tabindex="-1"></a>  (regexp-search &#39;(: <span class="st">&quot;*&quot;</span> (<span class="op">$</span> word) <span class="st">&quot;*&quot;</span>) <span class="st">&quot;**foo**&quot;</span>) <span class="dv">0</span>)  <span class="op">=&gt;</span> <span class="st">&quot;*foo*&quot;</span></span>
<span id="cb428-4"><a href="#cb428-4" aria-hidden="true" tabindex="-1"></a>(regexp-match-submatch</span>
<span id="cb428-5"><a href="#cb428-5" aria-hidden="true" tabindex="-1"></a>  (regexp-search &#39;(: <span class="st">&quot;*&quot;</span> (<span class="op">$</span> word) <span class="st">&quot;*&quot;</span>) <span class="st">&quot;**foo**&quot;</span>) <span class="dv">1</span>)  <span class="op">=&gt;</span> <span class="st">&quot;foo&quot;</span></span></code></pre></div>
<h2 id="regexp-match-submatch-start-regexp-match-field"><code>(regexp-match-submatch-start regexp-match field)</code></h2>
<p>Returns the start index regexp-match corresponding to field, as in regexp-match-submatch.</p>
<div class="sourceCode" id="cb429"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb429-1"><a href="#cb429-1" aria-hidden="true" tabindex="-1"></a>   (regexp-match-submatch-start</span>
<span id="cb429-2"><a href="#cb429-2" aria-hidden="true" tabindex="-1"></a>    (regexp-search &#39;word <span class="st">&quot;**foo**&quot;</span>) <span class="dv">0</span>)  <span class="op">=&gt;</span> <span class="dv">2</span></span>
<span id="cb429-3"><a href="#cb429-3" aria-hidden="true" tabindex="-1"></a>   (regexp-match-submatch-start</span>
<span id="cb429-4"><a href="#cb429-4" aria-hidden="true" tabindex="-1"></a>    (regexp-search &#39;(: <span class="st">&quot;*&quot;</span> (<span class="op">$</span> word) <span class="st">&quot;*&quot;</span>) <span class="st">&quot;**foo**&quot;</span>) <span class="dv">0</span>)  <span class="op">=&gt;</span> <span class="dv">1</span></span>
<span id="cb429-5"><a href="#cb429-5" aria-hidden="true" tabindex="-1"></a>   (regexp-match-submatch-start</span>
<span id="cb429-6"><a href="#cb429-6" aria-hidden="true" tabindex="-1"></a>    (regexp-search &#39;(: <span class="st">&quot;*&quot;</span> (<span class="op">$</span> word) <span class="st">&quot;*&quot;</span>) <span class="st">&quot;**foo**&quot;</span>) <span class="dv">1</span>)  <span class="op">=&gt;</span> <span class="dv">2</span></span></code></pre></div>
<h2 id="regexp-match-submatch-end-regexp-match-field"><code>(regexp-match-submatch-end regexp-match field)</code></h2>
<p>Returns the end index in regexp-match corresponding to field, as in regexp-match-submatch.</p>
<div class="sourceCode" id="cb430"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb430-1"><a href="#cb430-1" aria-hidden="true" tabindex="-1"></a>   (regexp-match-submatch-end</span>
<span id="cb430-2"><a href="#cb430-2" aria-hidden="true" tabindex="-1"></a>    (regexp-search &#39;word <span class="st">&quot;**foo**&quot;</span>) <span class="dv">0</span>)  <span class="op">=&gt;</span> <span class="dv">5</span></span>
<span id="cb430-3"><a href="#cb430-3" aria-hidden="true" tabindex="-1"></a>   (regexp-match-submatch-end</span>
<span id="cb430-4"><a href="#cb430-4" aria-hidden="true" tabindex="-1"></a>    (regexp-search &#39;(: <span class="st">&quot;*&quot;</span> (<span class="op">$</span> word) <span class="st">&quot;*&quot;</span>) <span class="st">&quot;**foo**&quot;</span>) <span class="dv">0</span>)  <span class="op">=&gt;</span> <span class="dv">6</span></span>
<span id="cb430-5"><a href="#cb430-5" aria-hidden="true" tabindex="-1"></a>   (regexp-match-submatch-end</span>
<span id="cb430-6"><a href="#cb430-6" aria-hidden="true" tabindex="-1"></a>    (regexp-search &#39;(: <span class="st">&quot;*&quot;</span> (<span class="op">$</span> word) <span class="st">&quot;*&quot;</span>) <span class="st">&quot;**foo**&quot;</span>) <span class="dv">1</span>)  <span class="op">=&gt;</span> <span class="dv">5</span></span></code></pre></div>
<h2 id="regexp-match-list-regexp-match"><code>(regexp-match-&gt;list regexp-match)</code></h2>
<p>Returns a list of all submatches in regexp-match as string or false, beginning with the entire match 0.</p>
<div class="sourceCode" id="cb431"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb431-1"><a href="#cb431-1" aria-hidden="true" tabindex="-1"></a>   (regexp-match-&gt;list</span>
<span id="cb431-2"><a href="#cb431-2" aria-hidden="true" tabindex="-1"></a>    (regexp-search &#39;(: (<span class="op">$</span> word) (<span class="op">+</span> (<span class="kw">or</span> space punct)) (<span class="op">$</span> word)) <span class="st">&quot;cats &amp; dogs&quot;</span>))</span>
<span id="cb431-3"><a href="#cb431-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">=&gt;</span> &#39;(<span class="st">&quot;cats &amp; dogs&quot;</span> <span class="st">&quot;cats&quot;</span> <span class="st">&quot;dogs&quot;</span>)</span></code></pre></div>
<h2 id="sre-syntax">SRE Syntax</h2>
<p>The grammar for SREs is summarized below. Note that an SRE is a first-class object consisting of nested lists of strings, chars, char-sets, symbols and numbers. Where the syntax is described as (foo bar), this can be constructed equivalently as ’(foo bar) or (list ’foo ’bar), etc. The following sections explain the semantics in greater detail.</p>
<p>```scheme <sre> ::= | <string> ; A literal string match. | <cset-sre> ; A character set match. | (* <sre> …) ; 0 or more matches. | (zero-or-more <sre> …) | (+ <sre> …) ; 1 or more matches. | (one-or-more <sre> …) | (? <sre> …) ; 0 or 1 matches. | (optional <sre> …) | (= <n> <sre> …) ; <n> matches. | (exactly <n> <sre> …) | (&gt;= <n> <sre> …) ; <n> or more matches. | (at-least <n> <sre> …) | (** <n> <m> <sre> …) ; <n> to <m> matches. | (repeated <n> <m> <sre> …)</p>
<pre><code> | (|  &lt;sre&gt; ...)              ; Alternation.
 | (or &lt;sre&gt; ...)

 | (:   &lt;sre&gt; ...)             ; Sequence.
 | (seq &lt;sre&gt; ...)
 | ($ &lt;sre&gt; ...)               ; Numbered submatch.
 | (submatch &lt;sre&gt; ...)
 | (-&gt; &lt;name&gt; &lt;sre&gt; ...)               ;  Named submatch.  &lt;name&gt; is
 | (submatch-named &lt;name&gt; &lt;sre&gt; ...)   ;  a symbol.

 | (w/case   &lt;sre&gt; ...)        ; Introduce a case-sensitive context.
 | (w/nocase &lt;sre&gt; ...)        ; Introduce a case-insensitive context.

 | (w/unicode   &lt;sre&gt; ...)     ; Introduce a unicode context.
 | (w/ascii &lt;sre&gt; ...)         ; Introduce an ascii context.

 | (w/nocapture &lt;sre&gt; ...)     ; Ignore all enclosed submatches.

 | bos                         ; Beginning of string.
 | eos                         ; End of string.

 | bol                         ; Beginning of line.
 | eol                         ; End of line.

 | bog                         ; Beginning of grapheme cluster.
 | eog                         ; End of grapheme cluster.
 | grapheme                    ; A single grapheme cluster.

 | bow                         ; Beginning of word.
 | eow                         ; End of word.
 | nwb                         ; A non-word boundary.
 | (word &lt;sre&gt; ...)            ; An SRE wrapped in word boundaries.
 | (word+ &lt;cset-sre&gt; ...)      ; A single word restricted to a cset.
 | word                        ; A single word.

 | (?? &lt;sre&gt; ...)              ; A non-greedy pattern, 0 or 1 match.
 | (non-greedy-optional &lt;sre&gt; ...)
 | (*? &lt;sre&gt; ...)              ; Non-greedy 0 or more matches.
 | (non-greedy-zero-or-more &lt;sre&gt; ...)
 | (**? &lt;m&gt; &lt;n&gt; &lt;sre&gt; ...)     ; Non-greedy &lt;m&gt; to &lt;n&gt; matches.
 | (non-greedy-repeated &lt;sre&gt; ...)
 | (look-ahead &lt;sre&gt; ...)      ; Zero-width look-ahead assertion.
 | (look-behind &lt;sre&gt; ...)     ; Zero-width look-behind assertion.
 | (neg-look-ahead &lt;sre&gt; ...)  ; Zero-width negative look-ahead assertion.
 | (neg-look-behind &lt;sre&gt; ...) ; Zero-width negative look-behind assertion.

 | (backref &lt;n-or-name&gt;)       ; Match a previous submatch.</code></pre>
<pre><code>
The grammar for cset-sre is as follows.

```scheme
    &lt;cset-sre&gt; ::=
     | &lt;char&gt;                      ; literal char
     | &quot;&lt;char&gt;&quot;                    ; string of one char
     | &lt;char-set&gt;                  ; embedded SRFI 14 char set
     | (&lt;string&gt;)                  ; literal char set
     | (char-set &lt;string&gt;)
     | (/ &lt;range-spec&gt; ...)        ; ranges
     | (char-range &lt;range-spec&gt; ...)
     | (or &lt;cset-sre&gt; ...)         ; union
     | (|\|| &lt;cset-sre&gt; ...)
     | (and &lt;cset-sre&gt; ...)        ; intersection
     | (&amp; &lt;cset-sre&gt; ...)
     | (- &lt;cset-sre&gt; ...)          ; difference
     | (- &lt;difference&gt; ...)
     | (~ &lt;cset-sre&gt; ...)          ; complement of union
     | (complement &lt;cset-sre&gt; ...)
     | (w/case &lt;cset-sre&gt; ...)     ; case and unicode toggling
     | (w/nocase &lt;cset-sre&gt; ...)
     | (w/ascii &lt;cset-sre&gt; ...)
     | (w/unicode &lt;cset-sre&gt; ...)
     | any | nonl | ascii | lower-case | lower
     | upper-case | upper | title-case | title
     | alphabetic | alpha | alphanumeric | alphanum | alnum
     | numeric | num | punctuation | punct | symbol
     | graphic | graph | whitespace | white | space
     | printing | print | control | cntrl | hex-digit | xdigit

    &lt;range-spec&gt; ::= &lt;string&gt; | &lt;char&gt;</code></pre>
<h2 id="string-5"><code>&lt;string&gt;</code></h2>
<p>A literal string.</p>
<div class="sourceCode" id="cb434"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb434-1"><a href="#cb434-1" aria-hidden="true" tabindex="-1"></a>   (regexp-search <span class="st">&quot;needle&quot;</span> <span class="st">&quot;hayneedlehay&quot;</span>) <span class="op">=&gt;</span> <span class="st">#&lt;regexp-match&gt;</span></span>
<span id="cb434-2"><a href="#cb434-2" aria-hidden="true" tabindex="-1"></a><span class="st">   (regexp-search &quot;needle&quot; &quot;haynEEdlehay&quot;) =&gt; #f</span></span></code></pre></div>
<h2 id="seq-sre-..."><code>(seq sre ...)</code></h2>
<h2 id="sre-..."><code>(: sre ...)</code></h2>
<p>Sequencing. Matches if each of sre matches adjacently in order.</p>
<div class="sourceCode" id="cb435"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb435-1"><a href="#cb435-1" aria-hidden="true" tabindex="-1"></a>(regexp-search &#39;(: <span class="st">&quot;one&quot;</span> space <span class="st">&quot;two&quot;</span> space <span class="st">&quot;three&quot;</span>) <span class="st">&quot;one two three&quot;</span>) <span class="op">=&gt;</span> <span class="st">#&lt;regexp-match&gt;</span></span></code></pre></div>
<h2 id="or-sre-..."><code>(or sre ...)</code></h2>
<h2 id="sre-...-1"><code>(|\|| sre ...)</code></h2>
<p>Alternation. Matches if any of sre match.</p>
<div class="sourceCode" id="cb436"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb436-1"><a href="#cb436-1" aria-hidden="true" tabindex="-1"></a>(regexp-search &#39;(<span class="kw">or</span> <span class="st">&quot;eeney&quot;</span> <span class="st">&quot;meeney&quot;</span> <span class="st">&quot;miney&quot;</span>) <span class="st">&quot;meeney&quot;</span>) <span class="op">=&gt;</span> <span class="st">#&lt;regexp-match&gt;</span></span>
<span id="cb436-2"><a href="#cb436-2" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(or &quot;eeney&quot; &quot;meeney&quot; &quot;miney&quot;) &quot;moe&quot;) =&gt; #f</span></span></code></pre></div>
<h2 id="wnocase-sre-..."><code>(w/nocase sre ...)</code></h2>
<p>Enclosed sres are case-insensitive. In a Unicode context character and string literals match with the default simple Unicode case-insensitive matching. Implementations may, but are not required to, handle variable length case conversions, such as #00DF “ß” matching the two characters “SS”.</p>
<p>Character sets match if any character in the set matches case-insensitively to the input. Conceptually each cset-sre is expanded to contain all case variants for all of its characters. In a compound cset-sre the expansion is applied at the terminals consisting of characters, strings, embedded SRFI 14 char-sets, and named character sets. For simple unions this would be equivalent to computing the full union first and then expanding case variants, but the semantics can differ when differences and intersections are applied. For example, (w/nocase (~ (“Aab”))) is equivalent to (~ (“AaBb”)), for which “B” is clearly not a member. However if you were to compute (~ (“Aab”)) first then you would have a char-set containing “B”, and after expanding case variants both “B” and “b” would be members.</p>
<p>In an ASCII context only the 52 ASCII letters (/ “a-zA-Z”) match case-insensitively to each other.</p>
<p>In a Unicode context the only named cset-sre which are affected by w/nocase are upper and lower. Note that the case insensitive versions of these are not equivalent to alpha as there are characters with the letter property but no case.</p>
<div class="sourceCode" id="cb437"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb437-1"><a href="#cb437-1" aria-hidden="true" tabindex="-1"></a>(regexp-search <span class="st">&quot;needle&quot;</span> <span class="st">&quot;haynEEdlehay&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb437-2"><a href="#cb437-2" aria-hidden="true" tabindex="-1"></a>(regexp-search &#39;(w/nocase <span class="st">&quot;needle&quot;</span>) <span class="st">&quot;haynEEdlehay&quot;</span>) <span class="op">=&gt;</span> <span class="st">#&lt;regexp-match&gt;</span></span>
<span id="cb437-3"><a href="#cb437-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb437-4"><a href="#cb437-4" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(~ (&quot;Aab&quot;)) &quot;B&quot;) =&gt; #&lt;regexp-match&gt;</span></span>
<span id="cb437-5"><a href="#cb437-5" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(~ (&quot;Aab&quot;)) &quot;b&quot;) =&gt; #f</span></span>
<span id="cb437-6"><a href="#cb437-6" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(w/nocase (~ (&quot;Aab&quot;))) &quot;B&quot;) =&gt; #f</span></span>
<span id="cb437-7"><a href="#cb437-7" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(w/nocase (~ (&quot;Aab&quot;))) &quot;b&quot;) =&gt; #f</span></span>
<span id="cb437-8"><a href="#cb437-8" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(~ (w/nocase (&quot;Aab&quot;))) &quot;B&quot;) =&gt; #f</span></span>
<span id="cb437-9"><a href="#cb437-9" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(~ (w/nocase (&quot;Aab&quot;))) &quot;b&quot;) =&gt; #f</span></span></code></pre></div>
<h2 id="wcase-sre-..."><code>(w/case sre ...)</code></h2>
<p>Enclosed sres are case-sensitive. This is the default, and overrides any enclosing w/nocase setting.</p>
<div class="sourceCode" id="cb438"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb438-1"><a href="#cb438-1" aria-hidden="true" tabindex="-1"></a>(regexp-search &#39;(w/nocase <span class="st">&quot;SMALL&quot;</span> (w/case <span class="st">&quot;BIG&quot;</span>)) <span class="st">&quot;smallBIGsmall&quot;</span>) <span class="op">=&gt;</span> <span class="st">#&lt;regexp-match&gt;</span></span>
<span id="cb438-2"><a href="#cb438-2" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(w/nocase (~ (w/case (&quot;Aab&quot;)))) &quot;b&quot;) =&gt; #f</span></span></code></pre></div>
<h2 id="wascii-sre-..."><code>(w/ascii sre ...)</code></h2>
<p>Enclosed sres are interpreted in an ASCII context. In practice many regular expressions are used for simple parsing and only ASCII characters are relevant. Switching to ASCII mode can improve performance in some implementations.</p>
<div class="sourceCode" id="cb439"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb439-1"><a href="#cb439-1" aria-hidden="true" tabindex="-1"></a>(regexp-search &#39;(w/ascii bos (<span class="op">*</span> alpha) eos) <span class="st">&quot;English&quot;</span>) <span class="op">=&gt;</span> <span class="st">#&lt;regexp-match&gt;</span></span>
<span id="cb439-2"><a href="#cb439-2" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(w/ascii bos (* alpha) eos) &quot;Ελληνική&quot;) =&gt; #f</span></span></code></pre></div>
<h2 id="wunicode-sre-..."><code>(w/unicode sre ...)</code></h2>
<p>Enclosed sres are interpreted in a Unicode context - character sets with both an ASCII and Unicode definition take the latter. Has no effect if the regexp-unicode feature is not provided. This is the default.</p>
<pre><code>(regexp-search &#39;(w/unicode bos (* alpha) eos) &quot;English&quot;) =&gt; #&lt;regexp-match&gt;
(regexp-search &#39;(w/unicode bos (* alpha) eos) &quot;Ελληνική&quot;) =&gt; #&lt;regexp-match&gt;</code></pre>
<h2 id="wnocapture-sre-..."><code>(w/nocapture sre ...)</code></h2>
<p>Disables capturing for all submatches ($, submatch, -&gt; and submatch-named) in the enclosed sres. The resulting SRE matches exactly the same strings, but without any associated submatch info. Useful for utility SREs which you want to incorporate without affecting your submatch positions.</p>
<div class="sourceCode" id="cb441"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb441-1"><a href="#cb441-1" aria-hidden="true" tabindex="-1"></a>   (<span class="kw">let</span> ((number &#39;(<span class="op">$</span> (<span class="op">+</span> digit))))</span>
<span id="cb441-2"><a href="#cb441-2" aria-hidden="true" tabindex="-1"></a>     (<span class="kw">cdr</span></span>
<span id="cb441-3"><a href="#cb441-3" aria-hidden="true" tabindex="-1"></a>      (regexp-match-&gt;list</span>
<span id="cb441-4"><a href="#cb441-4" aria-hidden="true" tabindex="-1"></a>       (regexp-search `(: ,number <span class="st">&quot;-&quot;</span> ,number <span class="st">&quot;-&quot;</span> ,number)</span>
<span id="cb441-5"><a href="#cb441-5" aria-hidden="true" tabindex="-1"></a>                      <span class="st">&quot;555-867-5309&quot;</span>)))  <span class="co">; =&gt; &#39;(&quot;555&quot; &quot;867&quot; &quot;5309&quot;)</span></span>
<span id="cb441-6"><a href="#cb441-6" aria-hidden="true" tabindex="-1"></a>     (<span class="kw">cdr</span></span>
<span id="cb441-7"><a href="#cb441-7" aria-hidden="true" tabindex="-1"></a>      (regexp-match-&gt;list</span>
<span id="cb441-8"><a href="#cb441-8" aria-hidden="true" tabindex="-1"></a>       (regexp-search `(: ,number <span class="st">&quot;-&quot;</span> (w/nocapture ,number) <span class="st">&quot;-&quot;</span> ,number)</span>
<span id="cb441-9"><a href="#cb441-9" aria-hidden="true" tabindex="-1"></a>                      <span class="st">&quot;555-867-5309&quot;</span>))))   <span class="op">=&gt;</span> &#39;(<span class="st">&quot;555&quot;</span> <span class="st">&quot;5309&quot;</span>)</span></code></pre></div>
<h2 id="optional-sre-..."><code>(optional sre ...)</code></h2>
<h2 id="sre-...-2"><code>(? sre ...)</code></h2>
<p>An optional pattern - matches 1 or 0 times.</p>
<div class="sourceCode" id="cb442"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb442-1"><a href="#cb442-1" aria-hidden="true" tabindex="-1"></a>(regexp-search &#39;(: <span class="st">&quot;match&quot;</span> (<span class="op">?</span> <span class="st">&quot;es&quot;</span>) <span class="st">&quot;!&quot;</span>) <span class="st">&quot;matches!&quot;</span>) <span class="op">=&gt;</span> <span class="st">#&lt;regexp-match&gt;</span></span>
<span id="cb442-2"><a href="#cb442-2" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(: &quot;match&quot; (? &quot;es&quot;) &quot;!&quot;) &quot;match!&quot;) =&gt; #&lt;regexp-match&gt;</span></span>
<span id="cb442-3"><a href="#cb442-3" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(: &quot;match&quot; (? &quot;es&quot;) &quot;!&quot;) &quot;matche!&quot;) =&gt; #f</span></span></code></pre></div>
<h2 id="zero-or-more-sre-..."><code>(zero-or-more sre ...)</code></h2>
<h2 id="sre-...-3"><code>(* sre ...)</code></h2>
<p>Kleene star, matches 0 or more times.</p>
<div class="sourceCode" id="cb443"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb443-1"><a href="#cb443-1" aria-hidden="true" tabindex="-1"></a>(regexp-search &#39;(: <span class="st">&quot;&lt;&quot;</span> (<span class="op">*</span> (~ <span class="ch">#\&gt;</span>)) <span class="st">&quot;&gt;&quot;</span>) <span class="st">&quot;&lt;html&gt;&quot;</span>) <span class="op">=&gt;</span> <span class="st">#&lt;regexp-match&gt;</span></span>
<span id="cb443-2"><a href="#cb443-2" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(: &quot;&lt;&quot;</span><span class="ot"> (* (~ #\</span><span class="st">&gt;)) &quot;&gt;&quot;) &quot;</span><span class="er">&lt;</span><span class="st">&gt;&quot;) =&gt; #&lt;regexp-match&gt;</span></span>
<span id="cb443-3"><a href="#cb443-3" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(: &quot;&lt;&quot;</span><span class="ot"> (* (~ #\</span><span class="st">&gt;)) &quot;&gt;&quot;) &quot;&lt;html&quot;)</span><span class="ot"> =</span><span class="st">&gt; #f</span></span></code></pre></div>
<h2 id="one-or-more-sre-..."><code>(one-or-more sre ...)</code></h2>
<h2 id="sre-...-4"><code>(+ sre ...)</code></h2>
<p>1 or more matches. Like * but requires at least a single match.</p>
<div class="sourceCode" id="cb444"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb444-1"><a href="#cb444-1" aria-hidden="true" tabindex="-1"></a>(regexp-search &#39;(: <span class="st">&quot;&lt;&quot;</span> (<span class="op">+</span> (~ <span class="ch">#\&gt;</span>)) <span class="st">&quot;&gt;&quot;</span>) <span class="st">&quot;&lt;html&gt;&quot;</span>) <span class="op">=&gt;</span> <span class="st">#&lt;regexp-match&gt;</span></span>
<span id="cb444-2"><a href="#cb444-2" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(: &quot;&lt;&quot;</span><span class="ot"> (+ (~ #\</span><span class="st">&gt;)) &quot;&gt;&quot;) &quot;&lt;a&gt;&quot;) =&gt; #&lt;regexp-match&gt;</span></span>
<span id="cb444-3"><a href="#cb444-3" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(: &quot;&lt;&quot;</span><span class="ot"> (+ (~ #\</span><span class="st">&gt;)) &quot;&gt;&quot;) &quot;</span><span class="er">&lt;</span><span class="st">&gt;&quot;) =&gt; #f</span></span></code></pre></div>
<h2 id="at-least-n-sre-..."><code>(at-least n sre ...)</code></h2>
<h2 id="n-sre-..."><code>(&gt;= n sre ...)</code></h2>
<p>More generally, n or more matches.</p>
<div class="sourceCode" id="cb445"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb445-1"><a href="#cb445-1" aria-hidden="true" tabindex="-1"></a>(regexp-search &#39;(: <span class="st">&quot;&lt;&quot;</span> (<span class="op">&gt;=</span> <span class="dv">3</span> (~ <span class="ch">#\&gt;</span>)) <span class="st">&quot;&gt;&quot;</span>) <span class="st">&quot;&lt;table&gt;&quot;</span>) <span class="op">=&gt;</span> <span class="st">#&lt;regexp-match&gt;</span></span>
<span id="cb445-2"><a href="#cb445-2" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(: &quot;&lt;&quot;</span><span class="ot"> (</span><span class="st">&gt;= 3 (~ #\&gt;)) &quot;&gt;&quot;) &quot;&lt;pre&gt;&quot;) =&gt; #&lt;regexp-match&gt;</span></span>
<span id="cb445-3"><a href="#cb445-3" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(: &quot;&lt;&quot;</span><span class="ot"> (</span><span class="st">&gt;= 3 (~ #\&gt;)) &quot;&gt;&quot;) &quot;&lt;tr&gt;&quot;) =&gt; #f</span></span></code></pre></div>
<h2 id="exactly-n-sre-..."><code>(exactly n sre ...)</code></h2>
<h2 id="n-sre-...-1"><code>(= n sre ...)</code></h2>
<p>Exactly n matches.</p>
<div class="sourceCode" id="cb446"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb446-1"><a href="#cb446-1" aria-hidden="true" tabindex="-1"></a>(regexp-search &#39;(: <span class="st">&quot;&lt;&quot;</span> (<span class="op">=</span> <span class="dv">4</span> (~ <span class="ch">#\&gt;</span>)) <span class="st">&quot;&gt;&quot;</span>) <span class="st">&quot;&lt;html&gt;&quot;</span>) <span class="op">=&gt;</span> <span class="st">#&lt;regexp-match&gt;</span></span>
<span id="cb446-2"><a href="#cb446-2" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(: &quot;&lt;&quot;</span><span class="ot"> (= 4 (~ #\</span><span class="st">&gt;)) &quot;&gt;&quot;) &quot;&lt;table&gt;&quot;) =&gt; #f</span></span></code></pre></div>
<h2 id="repeated-from-to-sre-..."><code>(repeated from to sre ...)</code></h2>
<h2 id="from-to-sre-..."><code>(** from to sre ...)</code></h2>
<p>The most general form, from n to m matches, inclusive.</p>
<div class="sourceCode" id="cb447"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb447-1"><a href="#cb447-1" aria-hidden="true" tabindex="-1"></a>(regexp-search &#39;(: (<span class="op">=</span> <span class="dv">3</span> (** <span class="dv">1</span> <span class="dv">3</span> numeric) <span class="st">&quot;.&quot;</span>) (** <span class="dv">1</span> <span class="dv">3</span> numeric)) <span class="st">&quot;192.168.1.10&quot;</span>) <span class="op">=&gt;</span> <span class="st">#&lt;regexp-match&gt;</span></span>
<span id="cb447-2"><a href="#cb447-2" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-search &#39;(: (= 3 (** 1 3 numeric) &quot;.&quot;) (** 1 3 numeric)) &quot;192.0168.1.10&quot;) =&gt; #f</span></span></code></pre></div>
<h2 id="submatch-sre-..."><code>(submatch sre ...)</code></h2>
<h2 id="sre-...-5"><code>($ sre ...)</code></h2>
<p>A numbered submatch. The contents matching the pattern will be available in the resulting regexp-match.</p>
<h2 id="submatch-named-name-sre-..."><code>(submatch-named name sre ...)</code></h2>
<h2 id="name-sre-..."><code>(-&gt; name sre ...)</code></h2>
<p>A named submatch. Behaves just like submatch, but the field may also be referred to by name.</p>
<h2 id="backref-n-or-name"><code>(backref n-or-name)</code></h2>
<p>Optional: Match a previously matched submatch. The feature regexp-backrefs will be provided if this pattern is supported. Backreferences are expensive, and can trivially be shown to be NP-hard, so one should avoid their use even in implementations which support them.</p>
<h2 id="char-6"><code>&lt;char&gt;</code></h2>
<p>A singleton char set.</p>
<div class="sourceCode" id="cb448"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb448-1"><a href="#cb448-1" aria-hidden="true" tabindex="-1"></a>   (regexp-matches &#39;(<span class="op">*</span> <span class="ch">#\-</span>) <span class="st">&quot;---&quot;</span>) <span class="op">=&gt;</span> <span class="st">#&lt;regexp-match&gt;</span></span>
<span id="cb448-2"><a href="#cb448-2" aria-hidden="true" tabindex="-1"></a><span class="st">   (regexp-matches &#39;(* #\-) &quot;-_-&quot;) =&gt; #f</span></span></code></pre></div>
<h2 id="char-7"><code>"&lt;char&gt;"</code></h2>
<p>A singleton char set written as a string of length one rather than a character. Equivalent to its interpretation as a literal string match, but included to clarify it can be composed in cset-sres.</p>
<h2 id="char-set"><code>&lt;char-set&gt;</code></h2>
<p>A SRFI 14 character set, which matches any character in the set. Note that currently there is no portable written representation of SRFI 14 character sets, which means that this pattern is typically generated programmatically, such as with a quasiquoted expression.</p>
<pre><code>(regexp-partition `(+ ,char-set:vowels) &quot;vowels&quot;)
   =&gt; (&quot;v&quot; &quot;o&quot; &quot;w&quot; &quot;e&quot; &quot;ls&quot;)</code></pre>
<p>Rationale: Many useful character sets are likely to be available as SRFI 14 char-sets, so it is desirable to reuse them in regular expressions. Since many Unicode character sets are extremely large, converting back and forth between an internal and external representation can be expensive, so the option of direct embedding is necessary. When a readable external representation is needed, char-set-&gt;sre can be used.</p>
<h2 id="char-set-string"><code>(char-set &lt;string&gt;)</code></h2>
<h2 id="string-6"><code>(&lt;string&gt;)</code></h2>
<p>The set of chars as formed by SRFI 14 (string-&gt;char-set <string>).</p>
<p>Note that char-sets contain code points, not grapheme clusters, so any combining characters in <string> will be inserted separately from any preceding base characters by string-&gt;char-set.</p>
<div class="sourceCode" id="cb450"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb450-1"><a href="#cb450-1" aria-hidden="true" tabindex="-1"></a>   (regexp-matches &#39;(<span class="op">*</span> (<span class="st">&quot;aeiou&quot;</span>)) <span class="st">&quot;oui&quot;</span>) <span class="op">=&gt;</span> <span class="st">#&lt;regexp-match&gt;</span></span>
<span id="cb450-2"><a href="#cb450-2" aria-hidden="true" tabindex="-1"></a><span class="st">   (regexp-matches &#39;(* (&quot;aeiou&quot;)) &quot;ouais&quot;) =&gt; #f</span></span>
<span id="cb450-3"><a href="#cb450-3" aria-hidden="true" tabindex="-1"></a><span class="st">   (regexp-matches &#39;(* (&quot;e\x0301&quot;)) &quot;e\x0301&quot;) =&gt; #&lt;regexp-match&gt;</span></span>
<span id="cb450-4"><a href="#cb450-4" aria-hidden="true" tabindex="-1"></a><span class="st">   (regexp-matches &#39;(&quot;e\x0301&quot;) &quot;e\x0301&quot;) =&gt; #f</span></span>
<span id="cb450-5"><a href="#cb450-5" aria-hidden="true" tabindex="-1"></a><span class="st">   (regexp-matches &#39;(&quot;e\x0301&quot;) &quot;e&quot;) =&gt; #&lt;regexp-match&gt;</span></span>
<span id="cb450-6"><a href="#cb450-6" aria-hidden="true" tabindex="-1"></a><span class="st">   (regexp-matches &#39;(&quot;e\x0301&quot;) &quot;\x0301&quot;) =&gt; #&lt;regexp-match&gt;</span></span>
<span id="cb450-7"><a href="#cb450-7" aria-hidden="true" tabindex="-1"></a><span class="st">   (regexp-matches &#39;(&quot;e\x0301&quot;) &quot;\x00E9&quot;) =&gt; #f</span></span></code></pre></div>
<h2 id="char-range-range-spec-..."><code>(char-range &lt;range-spec&gt; ...)</code></h2>
<h2 id="range-spec-..."><code>(/ &lt;range-spec&gt; ...)</code></h2>
<p>Ranged char set. The <range-spec> is a list of strings and characters. These are flattened and grouped into pairs of characters, and all ranges formed by the pairs are included in the char set.</p>
<div class="sourceCode" id="cb451"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb451-1"><a href="#cb451-1" aria-hidden="true" tabindex="-1"></a>(regexp-matches &#39;(<span class="op">*</span> (<span class="op">/</span> <span class="st">&quot;AZ09&quot;</span>)) <span class="st">&quot;R2D2&quot;</span>) <span class="op">=&gt;</span> <span class="st">#&lt;regexp-match&gt;</span></span>
<span id="cb451-2"><a href="#cb451-2" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-matches &#39;(* (/ &quot;AZ09&quot;)) &quot;C-3PO&quot;) =&gt; #f</span></span></code></pre></div>
<h2 id="or-cset-sre-..."><code>(or &lt;cset-sre&gt; ...)</code></h2>
<h2 id="cset-sre-..."><code>(|\|| &lt;cset-sre&gt; ...)</code></h2>
<p>Char set union. The single vertical bar form is provided for consistency and compatibility with SCSH, although it needs to be escaped in R7RS.</p>
<h2 id="complement-cset-sre-..."><code>(complement &lt;cset-sre&gt; ...)</code></h2>
<h2 id="cset-sre-...-1"><code>(~ &lt;cset-sre&gt; ...)</code></h2>
<p>Char set complement (i.e. [^...] in PCRE notation). (~ x) is equivalent to (- any x), thus in an ASCII context the complement is always ASCII.</p>
<h2 id="difference-cset-sre-..."><code>(difference &lt;cset-sre&gt; ...)</code></h2>
<h2 id="cset-sre-...-2"><code>(- &lt;cset-sre&gt; ...)</code></h2>
<p>Char set difference.</p>
<div class="sourceCode" id="cb452"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb452-1"><a href="#cb452-1" aria-hidden="true" tabindex="-1"></a>(regexp-matches &#39;(<span class="op">*</span> (<span class="op">-</span> (<span class="op">/</span> <span class="st">&quot;az&quot;</span>) (<span class="st">&quot;aeiou&quot;</span>))) <span class="st">&quot;xyzzy&quot;</span>) <span class="op">=&gt;</span> <span class="st">#&lt;regexp-match&gt;</span></span>
<span id="cb452-2"><a href="#cb452-2" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-matches &#39;(* (- (/ &quot;az&quot;) (&quot;aeiou&quot;))) &quot;vowels&quot;) =&gt; #f</span></span></code></pre></div>
<h2 id="and-cset-sre-..."><code>(and &lt;cset-sre&gt; ...)</code></h2>
<h2 id="cset-sre-...-3"><code>(&amp; &lt;cset-sre&gt; ...)</code></h2>
<p>Char set intersection.</p>
<pre><code>(regexp-matches &#39;(* (&amp; (/ &quot;az&quot;) (~ (&quot;aeiou&quot;)))) &quot;xyzzy&quot;) =&gt; #&lt;regexp-match&gt;
(regexp-matches &#39;(* (&amp; (/ &quot;az&quot;) (~ (&quot;aeiou&quot;)))) &quot;vowels&quot;) =&gt; #f</code></pre>
<h2 id="any"><code>any</code></h2>
<p>Match any character. Equivalent to ascii in an ASCII context.</p>
<h2 id="nonl"><code>nonl</code></h2>
<p>Match any character other than #or #.</p>
<h2 id="ascii"><code>ascii</code></h2>
<p>Match any ASCII character [0..127].</p>
<h2 id="lower-case"><code>lower-case</code></h2>
<h2 id="lower"><code>lower</code></h2>
<p>Matches any character for which char-lower-case? returns true. In a Unicode context this corresponds to the Lowercase (Ll + Other_Lowercase) property. In an ASCII context corresponds to (/ “az”).</p>
<h2 id="upper-case"><code>upper-case</code></h2>
<h2 id="upper"><code>upper</code></h2>
<p>Matches any character for which char-upper-case? returns true. In a Unicode context this corresponds to the Uppercase (Lu + Other_Uppercase) property. In an ASCII context corresponds to (/ “AZ”).</p>
<h2 id="title-case"><code>title-case</code></h2>
<h2 id="title"><code>title</code></h2>
<p>Matches any character with the Unicode Titlecase (Lt) property. This property only exists for the sake of ligature characters, of which only 31 exist at time of writing. In an ASCII context this is empty.</p>
<h2 id="alphabetic"><code>alphabetic</code></h2>
<h2 id="alpha"><code>alpha</code></h2>
<p>Matches any character for which char-alphabetic? returns true. In a Unicode context this corresponds to the Alphabetic (L + Nl + Other_Alphabetic) property. In an ASCII context corresponds to (w/nocase (/ “az”)).</p>
<h2 id="numeric"><code>numeric</code></h2>
<h2 id="num"><code>num</code></h2>
<p>Matches any character for which char-numeric? returns true. For In a Unicode context this corresponds to the Numeric_Digit (Nd) property. In an ASCII context corresponds to (/ “09”).</p>
<h2 id="alphanumeric"><code>alphanumeric</code></h2>
<h2 id="alphanum"><code>alphanum</code></h2>
<h2 id="alnum"><code>alnum</code></h2>
<p>Matches any character which is either a letter or number. Equivalent to:</p>
<div class="sourceCode" id="cb454"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb454-1"><a href="#cb454-1" aria-hidden="true" tabindex="-1"></a>   (<span class="kw">or</span> alphabetic numeric)</span></code></pre></div>
<h2 id="punctuation"><code>punctuation</code></h2>
<h2 id="punct"><code>punct</code></h2>
<p>Matches any punctuation character. In a Unicode context this corresponds to the Punctuation property (P). In an ASCII context this corresponds to “!"#%&amp;’()*,-./:;?@[]_{}“.</p>
<h2 id="symbol-1"><code>symbol</code></h2>
<p>Matches any symbol character. In a Unicode context this corresponds to the Symbol property (Sm, Sc, Sk, or So). In an ASCII this corresponds to “$+&lt;=&gt;^`|~”.</p>
<h2 id="graphic"><code>graphic</code></h2>
<h2 id="graph"><code>graph</code></h2>
<p>Matches any graphic character. Equivalent to:</p>
<div class="sourceCode" id="cb455"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb455-1"><a href="#cb455-1" aria-hidden="true" tabindex="-1"></a>   (<span class="kw">or</span> alphanumeric punctuation symbol)</span></code></pre></div>
<h2 id="whitespace"><code>whitespace</code></h2>
<h2 id="white"><code>white</code></h2>
<h2 id="space"><code>space</code></h2>
<p>Matches any whitespace character. In a Unicode context this corresponds to the Separator property (Zs, Zl or Zp). In an ASCII context this corresponds to space, tab, line feed, form feed, and carriage return.</p>
<h2 id="printing"><code>printing</code></h2>
<h2 id="print"><code>print</code></h2>
<p>Matches any printing character. Equivalent to:</p>
<div class="sourceCode" id="cb456"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb456-1"><a href="#cb456-1" aria-hidden="true" tabindex="-1"></a>   (<span class="kw">or</span> graphic whitespace)</span></code></pre></div>
<h2 id="control"><code>control</code></h2>
<h2 id="cntrl"><code>cntrl</code></h2>
<p>Matches any control or other character. In a Unicode context this corresponds to the Other property (Cc, Cf, Co, Cs or Cn). In an ASCII context this corresponds to:</p>
<div class="sourceCode" id="cb457"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb457-1"><a href="#cb457-1" aria-hidden="true" tabindex="-1"></a>   `(<span class="op">/</span> ,(<span class="kw">integer-&gt;char</span> <span class="dv">0</span>) ,(integer-char <span class="dv">31</span>))</span></code></pre></div>
<h2 id="hex-digit"><code>hex-digit</code></h2>
<h2 id="xdigit"><code>xdigit</code></h2>
<p>Matches any valid digit in hexadecimal notation. Always ASCII-only. Equivalent to:</p>
<div class="sourceCode" id="cb458"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb458-1"><a href="#cb458-1" aria-hidden="true" tabindex="-1"></a>(w/ascii (w/nocase (<span class="kw">or</span> numeric <span class="st">&quot;abcdef&quot;</span>)))</span></code></pre></div>
<h2 id="bos"><code>bos</code></h2>
<h2 id="eos"><code>eos</code></h2>
<p>Matches at the beginning/end of string without consuming any characters (a zero-width assertion). If the search was initiated with start/end parameters, these are considered the end points, rather than the full string.</p>
<h2 id="bol"><code>bol</code></h2>
<h2 id="eol"><code>eol</code></h2>
<p>Matches at the beginning/end of a line without consuming any characters (a zero-width assertion). A line is a possibly empty sequence of characters followed by an end of line sequence as understood by the R7RS read-line procedure, specifically any of a linefeed character, carriage return character, or a carriage return followed by a linefeed character. The string is assumed to contain end of line sequences before the start and after the end of the string, even if the search was made on a substring and the actual surrounding characters differ.</p>
<h2 id="bow"><code>bow</code></h2>
<h2 id="eow"><code>eow</code></h2>
<p>Matches at the beginning/end of a word without consuming any characters (a zero-width assertion). A word is a contiguous sequence of characters that are either alphanumeric or the underscore character, i.e. (or alphanumeric “_“), with the definition of alphanumeric depending on the Unicode or ASCII context. The string is assumed to contain non-word characters immediately before the start and after the end, even if the search was made on a substring and word constituent characters appear immediately before the beginning or after the end.</p>
<div class="sourceCode" id="cb459"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb459-1"><a href="#cb459-1" aria-hidden="true" tabindex="-1"></a>  (regexp-search &#39;(: bow <span class="st">&quot;foo&quot;</span>) <span class="st">&quot;foo&quot;</span>) <span class="op">=&gt;</span> <span class="st">#&lt;regexp-match&gt;</span></span>
<span id="cb459-2"><a href="#cb459-2" aria-hidden="true" tabindex="-1"></a><span class="st">  (regexp-search &#39;(: bow &quot;foo&quot;) &quot;&lt;foo&gt;&gt;&quot;) =&gt; #&lt;regexp-match&gt;</span></span>
<span id="cb459-3"><a href="#cb459-3" aria-hidden="true" tabindex="-1"></a><span class="st">  (regexp-search &#39;(: bow &quot;foo&quot;) &quot;snafoo&quot;) =&gt; #f</span></span>
<span id="cb459-4"><a href="#cb459-4" aria-hidden="true" tabindex="-1"></a><span class="st">  (regexp-search &#39;(: &quot;foo&quot; eow) &quot;foo&quot;) =&gt; #&lt;regexp-match&gt;</span></span>
<span id="cb459-5"><a href="#cb459-5" aria-hidden="true" tabindex="-1"></a><span class="st">  (regexp-search &#39;(: &quot;foo&quot; eow) &quot;foo!&quot;) =&gt; #&lt;regexp-match&gt;</span></span>
<span id="cb459-6"><a href="#cb459-6" aria-hidden="true" tabindex="-1"></a><span class="st">  (regexp-search &#39;(: &quot;foo&quot; eow) &quot;foobar&quot;) =&gt; #f</span></span></code></pre></div>
<h2 id="nwb"><code>nwb</code></h2>
<p>Matches a non-word-boundary (i.e. in PCRE). Equivalent to (neg-look-ahead (or bow eow)).</p>
<h2 id="word-sre-..."><code>(word sre ...)</code></h2>
<p>Anchors a sequence to word boundaries. Equivalent to:</p>
<div class="sourceCode" id="cb460"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb460-1"><a href="#cb460-1" aria-hidden="true" tabindex="-1"></a>   (: bow sre <span class="op">...</span> eow)</span></code></pre></div>
<h2 id="word-cset-sre-..."><code>(word+ cset-sre ...)</code></h2>
<p>Matches a single word composed of characters in the intersection of the given cset-sre and the word constituent characters. Equivalent to:</p>
<div class="sourceCode" id="cb461"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb461-1"><a href="#cb461-1" aria-hidden="true" tabindex="-1"></a>   (word (<span class="op">+</span> (<span class="kw">and</span> (<span class="kw">or</span> alphanumeric <span class="st">&quot;_&quot;</span>) (<span class="kw">or</span> cset-sre <span class="op">...</span>))))</span></code></pre></div>
<h2 id="word"><code>word</code></h2>
<p>A shorthand for (word+ any).</p>
<h2 id="bog"><code>bog</code></h2>
<h2 id="eog"><code>eog</code></h2>
<p>Matches at the beginning/end of a single extended grapheme cluster without consuming any characters (a zero-width assertion). Grapheme cluster boundaries are defined in Unicode TR29. The string is assumed to contain non-combining codepoints immediately before the start and after the end. These always succeed in an ASCII context.</p>
<h2 id="grapheme"><code>grapheme</code></h2>
<p>Matches a single grapheme cluster (i.e. in PCRE). This is what the end-user typically thinks of as a single character, comprised of a base non-combining codepoint followed by zero or more combining marks. In an ASCII context this is equivalent to any.</p>
<p>Assuming char-set:mark contains all characters with the Extend or SpacingMark properties defined in TR29, and char-set:control, char-set:regional-indicator and char-set:hangul-* are defined similarly, then the following SRE can be used with regexp-extract to define grapheme:</p>
<div class="sourceCode" id="cb462"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb462-1"><a href="#cb462-1" aria-hidden="true" tabindex="-1"></a>   `(<span class="kw">or</span> (: (<span class="op">*</span> ,char-set:hangul-l) (<span class="op">+</span> ,char-set:hangul-v)</span>
<span id="cb462-2"><a href="#cb462-2" aria-hidden="true" tabindex="-1"></a>           (<span class="op">*</span> ,char-set:hangul-t))</span>
<span id="cb462-3"><a href="#cb462-3" aria-hidden="true" tabindex="-1"></a>        (: (<span class="op">*</span> ,char-set:hangul-l) ,char-set:hangul-v</span>
<span id="cb462-4"><a href="#cb462-4" aria-hidden="true" tabindex="-1"></a>           (<span class="op">*</span> ,char-set:hangul-v) (<span class="op">*</span> ,char-set:hangul-t))</span>
<span id="cb462-5"><a href="#cb462-5" aria-hidden="true" tabindex="-1"></a>        (: (<span class="op">*</span> ,char-set:hangul-l) ,char-set:hangul-lvt</span>
<span id="cb462-6"><a href="#cb462-6" aria-hidden="true" tabindex="-1"></a>           (<span class="op">*</span> ,char-set:hangul-t))</span>
<span id="cb462-7"><a href="#cb462-7" aria-hidden="true" tabindex="-1"></a>        (<span class="op">+</span> ,char-set:hangul-l)</span>
<span id="cb462-8"><a href="#cb462-8" aria-hidden="true" tabindex="-1"></a>        (<span class="op">+</span> ,char-set:hangul-t)</span>
<span id="cb462-9"><a href="#cb462-9" aria-hidden="true" tabindex="-1"></a>        (<span class="op">+</span> ,char-set:regional-indicator)</span>
<span id="cb462-10"><a href="#cb462-10" aria-hidden="true" tabindex="-1"></a>        (: <span class="st">&quot;</span><span class="ch">\r\n</span><span class="st">&quot;</span>)</span>
<span id="cb462-11"><a href="#cb462-11" aria-hidden="true" tabindex="-1"></a>        (: (~ control (<span class="st">&quot;</span><span class="ch">\r\n</span><span class="st">&quot;</span>))</span>
<span id="cb462-12"><a href="#cb462-12" aria-hidden="true" tabindex="-1"></a>           (<span class="op">*</span> ,char-set:mark))</span>
<span id="cb462-13"><a href="#cb462-13" aria-hidden="true" tabindex="-1"></a>        control)</span></code></pre></div>
<h2 id="non-greedy-optional-sre-..."><code>(non-greedy-optional sre ...)</code></h2>
<h2 id="sre-...-6"><code>(?? sre ...)</code></h2>
<p>Non-greedy pattern, matches 0 or 1 times, preferring the shorter match.</p>
<h2 id="non-greedy-zero-or-more-sre-..."><code>(non-greedy-zero-or-more&lt; sre ...)</code></h2>
<h2 id="sre-...-7"><code>(*? sre ...)</code></h2>
<p>Non-greedy Kleene star, matches 0 or more times, preferring the shorter match.</p>
<h2 id="non-greedy-repeated-m-n-sre-..."><code>(non-greedy-repeated m n sre ...)</code></h2>
<h2 id="m-n-sre-..."><code>(**? m n sre ...)</code></h2>
<p>Non-greedy Kleene star, matches m to n times, preferring the shorter match.</p>
<h2 id="look-ahead-sre-..."><code>(look-ahead sre ...)</code></h2>
<p>Zero-width look-ahead assertion. Asserts the sequence matches from the current position, without advancing the position.</p>
<div class="sourceCode" id="cb463"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb463-1"><a href="#cb463-1" aria-hidden="true" tabindex="-1"></a>(regexp-matches &#39;(: <span class="st">&quot;regular&quot;</span> (look-ahead <span class="st">&quot; expression&quot;</span>) <span class="st">&quot; expression&quot;</span>) <span class="st">&quot;regular expression&quot;</span>)<span class="op">=&gt;</span> <span class="st">#&lt;regexp-match&gt;</span></span>
<span id="cb463-2"><a href="#cb463-2" aria-hidden="true" tabindex="-1"></a><span class="st">(regexp-matches &#39;(: &quot;regular&quot; (look-ahead &quot; &quot;) &quot;expression&quot;) &quot;regular expression&quot;)=&gt; #f</span></span></code></pre></div>
<h2 id="look-behind-sre-..."><code>(look-behind sre ...)</code></h2>
<p>Zero-width look-behind assertion. Asserts the sequence matches behind the current position, without advancing the position. It is an error if the sequence does not have a fixed length.</p>
<h2 id="neg-look-ahead-sre-..."><code>(neg-look-ahead sre ...)</code></h2>
<p>Zero-width negative look-ahead assertion.</p>
<h2 id="neg-look-behind-sre-..."><code>(neg-look-behind sre ...)</code></h2>
<p>Zero-width negative look-behind assertion. # <code>(scheme mapping hash)</code></p>
<h2 id="hashmap-comparator-key-value-..."><code>(hashmap comparator [key value] ...)</code></h2>
<p>Returns a newly allocated hashmap. The comparator argument is used to control and distinguish the keys of the hashmap. The args alternate between keys and values and are used to initialize the hashmap. In particular, the number of args has to be even. Earlier associations with equal keys take precedence over later arguments.</p>
<h2 id="hashmap-unfold-stop-mapper-successor-seed-comparator"><code>(hashmap-unfold stop? mapper successor seed comparator)</code></h2>
<p>Create a newly allocated hashmap as if by hashmap using comparator. If the result of applying the predicate stop? to seed is true, return the hashmap. Otherwise, apply the procedure mapper to seed. Mapper returns two values which are added to the hashmap as the key and the value, respectively. Then get a new seed by applying the procedure successor to seed, and repeat this algorithm. Associations earlier in the list take precedence over those that come later.</p>
<h2 id="hashmap-obj"><code>(hashmap? obj)</code></h2>
<p>Returns #t if obj is a hashmap, and #f otherwise.</p>
<h2 id="hashmap-contains-hashmap-key"><code>(hashmap-contains? hashmap key)</code></h2>
<p>Returns #t if key is the key of an association of hashmap and #f otherwise.</p>
<h2 id="hashmap-empty-hashmap"><code>(hashmap-empty? hashmap)</code></h2>
<p>Returns #t if hashmap has no associations and #f otherwise.</p>
<h2 id="hashmap-disjoint-hashmap1-hashmap2"><code>(hashmap-disjoint? hashmap1 hashmap2)</code></h2>
<p>Returns #t if hashmap1 and hashmap2 have no keys in common and #f otherwise.</p>
<h2 id="hashmap-ref-hashmap-key-failure-success"><code>(hashmap-ref hashmap key [failure [success]])</code></h2>
<p>Extracts the value associated to key in the hashmap hashmap, invokes the procedure success in tail context on it, and returns its result; if success is not provided, then the value itself is returned. If key is not contained in hashmap and failure is supplied, then failure is invoked in tail context on no arguments and its values are returned. Otherwise, it is an error.</p>
<h2 id="hashmap-refdefault-hashmap-key-default"><code>(hashmap-ref/default hashmap key default)</code></h2>
<h2 id="hashmap-key-comparator-hashmap"><code>(hashmap-key-comparator hashmap)</code></h2>
<p>Returns the comparator used to compare the keys of the hashmap hashmap.</p>
<h2 id="hashmap-adjoin-hashmap-arg-..."><code>(hashmap-adjoin hashmap arg ...)</code></h2>
<p>The hashmap-adjoin procedure returns a newly allocated hashmap that uses the same comparator as the hashmap hashmap and contains all the associations of hashmap, and in addition new associations by processing the arguments from left to right. The args alternate between keys and values. Whenever there is a previous association for a key, the previous association prevails and the new association is skipped. It is an error to add an association to hashmap whose key that does not return #t when passed to the type test procedure of the comparator.</p>
<h2 id="hashmap-adjoin-hashmap-arg-...-1"><code>(hashmap-adjoin! hashmap arg ...)</code></h2>
<p>The hashmap-adjoin! procedure is the same as hashmap-adjoin, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h2 id="hashmap-set-hashmap-arg-..."><code>(hashmap-set hashmap arg ...)</code></h2>
<p>The hashmap-set procedure returns a newly allocated hashmap that uses the same comparator as the hashmap hashmap and contains all the associations of hashmap, and in addition new associations by processing the arguments from left to right. The args alternate between keys and values. Whenever there is a previous association for a key, it is deleted. It is an error to add an association to hashmap whose key that does not return #t when passed to the type test procedure of the comparator.</p>
<h2 id="hashmap-set-hashmap-arg-...-1"><code>(hashmap-set! hashmap arg ...)</code></h2>
<p>The hashmap-set! procedure is the same as hashmap-set, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h2 id="hashmap-replace-hashmap-key-value"><code>(hashmap-replace hashmap key value)</code></h2>
<p>The hashmap-replace procedure returns a newly allocated hashmap that uses the same comparator as the hashmap hashmap and contains all the associations of hashmap except as follows: If key is equal (in the sense of hashmap’s comparator) to an existing key of hashmap, then the association for that key is omitted and replaced the association defined by the pair key and value. If there is no such key in hashmap, then hashmap is returned unchanged.</p>
<h2 id="hashmap-replace-hashmap-key-value-1"><code>(hashmap-replace! hashmap key value)</code></h2>
<p>The hashmap-replace! procedure is the same as hashmap-replace, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h2 id="hashmap-delete-hashmap-key-..."><code>(hashmap-delete hashmap key ...)</code></h2>
<h2 id="hashmap-delete-hashmap-key-...-1"><code>(hashmap-delete! hashmap key ...)</code></h2>
<h2 id="hashmap-delete-all-hashmap-key-list"><code>(hashmap-delete-all hashmap key-list)</code></h2>
<h2 id="hashmap-delete-all-hashmap-key-list-1"><code>(hashmap-delete-all! hashmap key-list)</code></h2>
<p>The hashmap-delete procedure returns a newly allocated hashmap containing all the associations of the hashmap hashmap except for any whose keys are equal (in the sense of hashmap’s comparator) to one or more of the keys. Any key that is not equal to some key of the hashmap is ignored.</p>
<p>The hashmap-delete! procedure is the same as hashmap-delete, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<p>The hashmap-delete-all and hashmap-delete-all! procedures are the same as hashmap-delete and hashmap-delete!, respectively, except that they accept a single argument which is a list of keys whose associations are to be deleted.</p>
<h2 id="hashmap-intern-hashmap-key-failure"><code>(hashmap-intern hashmap key failure)</code></h2>
<p>Extracts the value associated to key in the hashmap hashmap, and returns hashmap and the value as two values. If key is not contained in hashmap, failure is invoked on no arguments. The procedure then returns two values, a newly allocated hashmap that uses the same comparator as the hashmap and contains all the associations of hashmap, and in addition a new association hashmap key to the result of invoking failure, and the result of invoking failure.</p>
<h2 id="hashmap-intern-hashmap-key-failure-1"><code>(hashmap-intern! hashmap key failure)</code></h2>
<p>The hashmap-intern! procedure is the same as hashmap-intern, except that it is permitted to mutate and return the hashmap argument as its first value rather than allocating a new hashmap.</p>
<h2 id="hashmap-update-hashmap-key-updater-failure-success"><code>(hashmap-update hashmap key updater [failure [success]])</code></h2>
<p>TODO</p>
<h2 id="hashmap-update-hashmap-key-updater-failure-success-1"><code>(hashmap-update! hashmap key updater [failure [success]])</code></h2>
<p>The hashmap-update! procedure is the same as hashmap-update, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h2 id="hashmap-updatedefault-hashmap-key-updater-default"><code>(hashmap-update/default hashmap key updater default)</code></h2>
<p>TODO</p>
<h2 id="hashmap-updatedefault-hashmap-key-updater-default-1"><code>(hashmap-update!/default hashmap key updater default)</code></h2>
<p>The hashmap-update!/default procedure is the same as hashmap-update/default, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h2 id="hashmap-pop-hashmap-failure"><code>(hashmap-pop hashmap [failure])</code></h2>
<p>The hashmap-pop procedure exported from (srfi 146) chooses the association with the least key from hashmap and returns three values, a newly allocated hashmap that uses the same comparator as hashmap and contains all associations of hashmap except the chosen one, and the key and the value of the chosen association. If hashmap contains no association and failure is supplied, then failure is invoked in tail context on no arguments and its values returned. Otherwise, it is an error.</p>
<h2 id="hashmap-pop-hashmap-failure-1"><code>(hashmap-pop! hashmap [failure])</code></h2>
<p>The hashmap-pop! procedure is the same as hashmap-pop, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h2 id="hashmap-search-hashmap-key-failure-success"><code>(hashmap-search hashmap key failure success)</code></h2>
<p>The hashmap hashmap is searched in order (that is in the order of the stored keys) for an association with key key. If it is not found, then the failure procedure is tail-called with two continuation arguments, insert and ignore, and is expected to tail-call one of them. If an association with key key is found, then the success procedure is tail-called with the matching key of hashmap, the associated value, and two continuations, update and remove, and is expected to tail-call one of them.</p>
<p>It is an error if the continuation arguments are invoked, but not in tail position in the failure and success procedures. It is also an error if the failure and success procedures return to their implicit continuation without invoking one of their continuation arguments.</p>
<p>The effects of the continuations are as follows (where obj is any Scheme object):</p>
<ul>
<li><p>Invoking (insert value obj) causes a hashmap to be newly allocated that uses the same comparator as the hashmap hashmap and contains all the associations of hashmap, and in addition a new association hashmap key to value.</p></li>
<li><p>Invoking (ignore obj) has no effects; in particular, no new hashmap is allocated (but see below).</p></li>
<li><p>Invoking (update new-key new-value obj) causes a hashmap to be newly allocated that uses the same comparator as the hashmap and contains all the associations of hashmap, except for the association with key key, which is replaced by a new association hashmap new-key to new-value.</p></li>
<li><p>Invoking (remove obj) causes a hashmap to be newly allocated that uses the same comparator as the hashmap and contains all the associations of hashmap, except for the association with key key.</p></li>
</ul>
<p>In all cases, two values are returned: the possibly newly allocated hashmap and obj.</p>
<h2 id="hashmap-search-hashmap-key-failure-success-1"><code>(hashmap-search! hashmap key failure success)</code></h2>
<p>The hashmap-search! procedure is the same as hashmap-search, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h2 id="hashmap-size-hashmap"><code>(hashmap-size hashmap)</code></h2>
<p>Returns the number of associations in hashmap as an exact integer.</p>
<h2 id="hashmap-find-predicate-hashmap-failure"><code>(hashmap-find predicate hashmap failure)</code></h2>
<p>Returns the association with the least key of the hashmap hashmap consisting of a key and value as two values such that predicate returns a true value when invoked with key and value as arguments, or the result of tail-calling failure with no arguments if there is none. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h2 id="hashmap-count-predicate-hashmap"><code>(hashmap-count predicate hashmap)</code></h2>
<p>Returns the number of associations of the hashmap hashmap that satisfy predicate (in the sense of hashmap-find) as an exact integer. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h2 id="hashmap-any-predicate-hashmap"><code>(hashmap-any? predicate hashmap)</code></h2>
<p>Returns #t if any association of the hashmap hashmap satisfies predicate (in the sense of hashmap-find), or #f otherwise. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h2 id="hashmap-every-predicate-hashmap"><code>(hashmap-every? predicate hashmap)</code></h2>
<p>Returns #t if every association of the hashmap hashmap satisfies predicate (in the sense of hashmap-find), or #f otherwise. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h2 id="hashmap-keys-hashmap"><code>(hashmap-keys hashmap)</code></h2>
<p>Returns a newly allocated list of all the keys in increasing order in the hashmap hashmap.</p>
<h2 id="hashmap-values-hashmap"><code>(hashmap-values hashmap)</code></h2>
<p>Returns a newly allocated list of all the values in increasing order of the keys in the hashmap hashmap.</p>
<h2 id="hashmap-entries-hashmap"><code>(hashmap-entries hashmap)</code></h2>
<p>Returns two values, a newly allocated list of all the keys in the hashmap hashmap, and a newly allocated list of all the values in the hashmap hashmap in increasing order of the keys.</p>
<h2 id="hashmap-map-proc-comparator-hashmap"><code>(hashmap-map proc comparator hashmap)</code></h2>
<p>Applies proc, which returns two values, on two arguments, the key and value of each association of hashmap in increasing order of the keys and returns a newly allocated hashmap that uses the comparator comparator, and which contains the results of the applications inserted as keys and values.</p>
<h2 id="hashmap-map-list-proc-hashmap"><code>(hashmap-map-&gt;list proc hashmap)</code></h2>
<p>Calls proc for every association in increasing order of the keys in the hashmap hashmap with two arguments: the key of the association and the value of the association. The values returned by the invocations of proc are accumulated into a list, which is returned.</p>
<h2 id="hashmap-for-each-proc-hashmap"><code>(hashmap-for-each proc hashmap)</code></h2>
<p>Invokes proc for every association in the hashmap hashmap in increasing order of the keys, discarding the returned values, with two arguments: the key of the association and the value of the association. Returns an unspecified value.</p>
<h2 id="hashmap-fold-proc-nil-hashmap"><code>(hashmap-fold proc nil hashmap)</code></h2>
<p>Invokes proc for each association of the hashmap hashmap in increasing order of the keys with three arguments: the key of the association, the value of the association, and an accumulated result of the previous invocation. For the first invocation, nil is used as the third argument. Returns the result of the last invocation, or nil if there was no invocation.</p>
<h2 id="hashmap-filter-predicate-hashmap"><code>(hashmap-filter predicate hashmap)</code></h2>
<p>Returns a newly allocated hashmap with the same comparator as the hashmap hashmap, containing just the associations of hashmap that satisfy predicate (in the sense of hashmap-find).</p>
<h2 id="hashmap-filter-predicate-hashmap-1"><code>(hashmap-filter! predicate hashmap)</code></h2>
<p>A linear update procedure that returns a hashmap containing just the associations of hashmap that satisfy predicate.</p>
<h2 id="hashmap-remove-predicate-hashmap"><code>(hashmap-remove predicate hashmap)</code></h2>
<p>Returns a newly allocated hashmap with the same comparator as the hashmap hashmap, containing just the associations of hashmap that do not satisfy predicate (in the sense of hashmap-find).</p>
<h2 id="hashmap-remove-predicate-hashmap-1"><code>(hashmap-remove! predicate hashmap)</code></h2>
<p>A linear update procedure that returns a hashmap containing just the associations of hashmap that do not satisfy predicate.</p>
<h2 id="hashmap-partition-predicate-hashmap"><code>(hashmap-partition predicate hashmap)</code></h2>
<p>Returns two values: a newly allocated hashmap with the same comparator as the hashmap hashmap that contains just the associations of hashmap that satisfy predicate (in the sense of hashmap-find), and another newly allocated hashmap, also with the same comparator, that contains just the associations of hashmap that do not satisfy predicate.</p>
<h2 id="hashmap-partition-predicate-hashmap-1"><code>(hashmap-partition! predicate hashmap)</code></h2>
<p>A linear update procedure that returns two hashmaps containing the associations of hashmap that do and do not, respectively, satisfy predicate.</p>
<h2 id="hashmap-copy-hashmap"><code>(hashmap-copy hashmap)</code></h2>
<p>Returns a newly allocated hashmap containing the associations of the hashmap hashmap, and using the same comparator.</p>
<h2 id="hashmap-alist-hashmap"><code>(hashmap-&gt;alist hashmap)</code></h2>
<p>Returns a newly allocated association list containing the associations of the hashmap in increasing order of the keys. Each association in the list is a pair whose car is the key and whose cdr is the associated value.</p>
<h2 id="alist-hashmap-comparator-alist"><code>(alist-&gt;hashmap comparator alist)</code></h2>
<p>Returns a newly allocated hashmap, created as if by hashmap using the comparator comparator, that contains the associations in the list, which consist of a pair whose car is the key and whose cdr is the value. Associations earlier in the list take precedence over those that come later.</p>
<h2 id="alist-hashmap-hashmap-alist"><code>(alist-&gt;hashmap! hashmap alist)</code></h2>
<p>A linear update procedure that returns a hashmap that contains the associations of both hashmap and alist. Associations in the hashmap and those earlier in the list take precedence over those that come later.</p>
<h2 id="hashmap-union-hashmap1-hashmap2-..."><code>(hashmap-union hashmap1 hashmap2 ...)</code></h2>
<h2 id="hashmap-intersection-hashmap1-hashmap2-..."><code>(hashmap-intersection hashmap1 hashmap2 ...)</code></h2>
<h2 id="hashmap-difference-hashmap1-hashmap2-..."><code>(hashmap-difference hashmap1 hashmap2 ...)</code></h2>
<h2 id="hashmap-xor-hashmap1-hashmap2-..."><code>(hashmap-xor hashmap1 hashmap2 ...)</code></h2>
<p>Return a newly allocated hashmap whose set of associations is the union, intersection, asymmetric difference, or symmetric difference of the sets of associations of the hashmaps hashmaps. Asymmetric difference is extended to more than two hashmaps by taking the difference between the first hashmap and the union of the others. Symmetric difference is not extended beyond two hashmaps. When comparing associations, only the keys are compared. In case of duplicate keys (in the sense of the hashmaps comparators), associations in the result hashmap are drawn from the first hashmap in which they appear.</p>
<h2 id="hashmap-union-hashmap1-hashmap2-...-1"><code>(hashmap-union! hashmap1 hashmap2 ...)</code></h2>
<h2 id="hashmap-intersection-hashmap1-hashmap2-...-1"><code>(hashmap-intersection! hashmap1 hashmap2 ...)</code></h2>
<h2 id="hashmap-difference-hashmap1-hashmap2-...-1"><code>(hashmap-difference! hashmap1 hashmap2 ...)</code></h2>
<h2 id="hashmap-xor-hashmap1-hashmap2-...-1"><code>(hashmap-xor! hashmap1 hashmap2 ...)</code></h2>
<p>These procedures are the linear update analogs of the corresponding pure functional procedures above.</p>
<h2 id="comparator-obj-2"><code>(comparator? obj)</code></h2>
<p>Type predicate for comparators as exported by <code>(scheme comparator)</code>.</p>
<h2 id="hashmap-comparator"><code>hashmap-comparator</code></h2>
<p>hashmap-comparator is constructed by invoking make-hashmap-comparator on (make-default-comparator).</p>
<h2 id="make-hashmap-comparator-comparator"><code>(make-hashmap-comparator comparator)</code></h2>
<p>Returns a comparator for hashmaps that is compatible with the equality predicate (hashmap=? comparator hashmap1 hashmap2). If make-hashmap-comparator is imported from (srfi 146), it provides a (partial) ordering predicate that is applicable to pairs of hashmaps with the same (key) comparator. If (make-hashmap-comparator) is imported from (srfi 146 hash), it provides an implementation-dependent hash function.</p>
<p>If make-hashmap-comparator is imported from (srfi 146), the lexicographic ordering with respect to the keys (and, in case a tiebreak is necessary, with respect to the ordering of the values) is used for hashmaps sharing a comparator.</p>
<p>The existence of comparators returned by make-hashmap-comparator allows hashmaps whose keys are hashmaps themselves, and it allows to compare hashmaps whose values are hashmaps. # <code>(scheme ephemeron)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-124/">SRFI-124</a>, that is itself based on the MIT Scheme Reference Manual.</p>
<p>An ephemeron is an object with two components called its key and its datum. It differs from an ordinary pair as follows: if the garbage collector (GC) can prove that there are no references to the key except from the ephemeron itself and possibly from the datum, then it is free to break the ephemeron, dropping its reference to both key and datum. In other words, an ephemeron can be broken when nobody else cares about its key. Ephemerons can be used to construct weak vectors or lists and (possibly in combination with finalizers) weak hash tables.</p>
<h2 id="ephemeron-obj"><code>(ephemeron? obj)</code></h2>
<p>Returns #t if object is an ephemeron; otherwise returns #f.</p>
<h2 id="make-ephemeron-key-datum"><code>(make-ephemeron key datum)</code></h2>
<p>Returns a newly allocated ephemeron, with components key and datum. Note that if key and datum are the same in the sense of eq?, the ephemeron is effectively a weak reference to the object.</p>
<h2 id="ephemeron-broken-ephemeron"><code>(ephemeron-broken? ephemeron)</code></h2>
<p>Returns #t if ephemeron has been broken; otherwise returns #f.</p>
<p>This procedure must be used with care. If it returns #f, that guarantees only that prior evaluations of ephemeron-key or ephemeron-datum yielded the key or datum that was stored in ephemeron. However, it makes no guarantees about subsequent calls to ephemeron-key or ephemeron-datum, because the GC may run and break the ephemeron immediately after ephemeron-broken? returns. Thus, the correct idiom to fetch an ephemeron’s key and datum and use them if the ephemeron is not broken is:</p>
<div class="sourceCode" id="cb464"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb464-1"><a href="#cb464-1" aria-hidden="true" tabindex="-1"></a>     (<span class="kw">let</span> ((key (ephemeron-key ephemeron))</span>
<span id="cb464-2"><a href="#cb464-2" aria-hidden="true" tabindex="-1"></a>           (datum (ephemeron-datum ephemeron)))</span>
<span id="cb464-3"><a href="#cb464-3" aria-hidden="true" tabindex="-1"></a>       (<span class="kw">if</span> (ephemeron-broken? ephemeron)</span>
<span id="cb464-4"><a href="#cb464-4" aria-hidden="true" tabindex="-1"></a>           <span class="op">...</span> broken <span class="kw">case</span> <span class="op">...</span></span>
<span id="cb464-5"><a href="#cb464-5" aria-hidden="true" tabindex="-1"></a>           <span class="op">...</span> code using key <span class="kw">and</span> datum <span class="op">...</span>))</span></code></pre></div>
<h2 id="ephemeron-key-ephemeron"><code>(ephemeron-key ephemeron)</code></h2>
<h2 id="ephemeron-value-ephemeron"><code>(ephemeron-value ephemeron)</code></h2>
<p>These return the key or datum component, respectively, of ephemeron. If ephemeron has been broken, these operations return #f, but they can also return #f if that is what was stored as the key or datum.</p>
<h2 id="reference-barrier-key"><code>(reference-barrier key)</code></h2>
<p>This procedure is optional.</p>
<p>This procedure ensures that the garbage collector does not break an ephemeron containing an unreferenced key before a certain point in a program. The program can invoke a reference barrier on the key by calling this procedure, which guarantees that even if the program does not use the key, it will be considered strongly reachable until after reference-barrier returns.</p>
</body>
</html>
