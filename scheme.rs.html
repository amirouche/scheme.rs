<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>scheme.rs</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<p>Let’s agree that <em>serif</em> fonts do not always carry boring stuff. And have a taste of it:</p>
<blockquote>
<p>Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary. — <a href="http://r7rs.org/">Revised 7 Report on the Algorithmic Language Scheme</a>, Introduction.</p>
</blockquote>
<p>Otherwise said, Scheme offers a minimalist core of powerful primitives upon which one can build abstractions to solve (real world) problems.</p>
<p>The Scheme universe is vast and prolific. As programming languages, Scheme dialects target various niches and implement various paradigms. Some of them are part of the de facto standards (namely RnRS and SRFIs).</p>
<p>The best-known paradigm of agreed-upon practices revolve around Functional Programming.</p>
<p>Scheme might be a dynamically typed language, but it can compete with its scions and siblings when performance matters.</p>
<p>Few programming languages can compete with Scheme when it comes to computer science whether it is Programming Language Theory, or Artificial Intelligence.</p>
<p>That being said, Scheme implementations might be missing some love. That’s a good opportunity for you to learn something useful and give something back.</p>
<p>Or, like others, to make it your secret sauce.</p>
<h2 id="discourse"><a href="/discourse/">Discourse</a></h2>
<h2 id="tutorial"><a href="/tutorial/">Tutorial</a></h2>
<h2 id="specification"><a href="/specification/">Specification</a></h2>
<h2 id="standard-libraries">Standard Libraries</h2>
<ul>
<li><a href="/scheme/base/"><code>(scheme base)</code></a> R7RS-small</li>
<li><a href="/scheme/bitwise/"><code>(scheme bitwise)</code></a></li>
<li><a href="/scheme/box/"><code>(scheme box)</code></a></li>
<li><a href="/scheme/bytevector/"><code>(scheme bytevector)</code></a></li>
<li><a href="/scheme/case-lambda/"><code>(scheme case-lambda)</code></a> R7RS-small</li>
<li><a href="/scheme/char/"><code>(scheme char)</code></a> R7RS-small</li>
<li><a href="/scheme/charset/"><code>(scheme charset)</code></a></li>
<li><a href="/scheme/comparator/"><code>(scheme comparator)</code></a></li>
<li><a href="/scheme/complex/"><code>(scheme complex)</code></a> R7RS-small</li>
<li><a href="/scheme/cxr/"><code>(scheme cxr)</code></a> R7RS-small</li>
<li><a href="/scheme/division/"><code>(scheme division)</code></a></li>
<li><a href="/scheme/ephemeron/"><code>(scheme ephemeron)</code></a></li>
<li><a href="/scheme/eval/"><code>(scheme eval)</code></a> R7RS-small</li>
<li><a href="/scheme/file/"><code>(scheme file)</code></a> R7RS-small</li>
<li><a href="/scheme/fixnum/"><code>(scheme fixnum)</code></a></li>
<li><a href="/scheme/flonum/"><code>(scheme flonum)</code></a></li>
<li><a href="/scheme/generator/"><code>(scheme generator)</code></a></li>
<li><a href="/scheme/hash-table/"><code>(scheme hash-table)</code></a></li>
<li><a href="/scheme/idque/"><code>(scheme idque)</code></a></li>
<li><a href="/scheme/ilist/"><code>(scheme ilist)</code></a></li>
<li><a href="/scheme/inexact/"><code>(scheme inexact)</code></a> R7RS-small</li>
<li><a href="/scheme/lazy/"><code>(scheme lazy)</code></a> R7RS-small</li>
<li><a href="/scheme/list/"><code>(scheme list)</code></a></li>
<li><a href="/scheme/list-queue/"><code>(scheme list-queue)</code></a></li>
<li><a href="/scheme/load/"><code>(scheme load)</code></a> R7RS-small</li>
<li><a href="/scheme/lseq/"><code>(scheme lseq)</code></a></li>
<li><a href="/scheme/mapping/"><code>(scheme mapping)</code></a></li>
<li><a href="/scheme/mapping-hash/"><code>(scheme mapping-hash)</code></a></li>
<li><a href="/scheme/process-context/"><code>(scheme process-context)</code></a> R7RS-small</li>
<li><a href="/scheme/r5rs/"><code>(scheme r5rs)</code></a> R7RS-small</li>
<li><a href="/scheme/read/"><code>(scheme read)</code></a> R7RS-small</li>
<li><a href="/scheme/regex/"><code>(scheme regex)</code></a></li>
<li><a href="/scheme/repl/"><code>(scheme repl)</code></a> R7RS-small</li>
<li><a href="/scheme/rlist/"><code>(scheme rlist)</code></a></li>
<li><a href="/scheme/set/"><code>(scheme set)</code></a></li>
<li><a href="/scheme/show/"><code>(scheme show)</code></a></li>
<li><a href="/scheme/sort/"><code>(scheme sort)</code></a></li>
<li><a href="/scheme/stream/"><code>(scheme stream)</code></a></li>
<li><a href="/scheme/text/"><code>(scheme text)</code></a></li>
<li><a href="/scheme/time/"><code>(scheme time)</code></a> R7RS-small</li>
<li><a href="/scheme/vector/"><code>(scheme vector)</code></a></li>
<li><a href="/scheme/write/"><code>(scheme write)</code></a> R7RS-small</li>
</ul>
<h2 id="source-and-single-page-files">Source, and single page files</h2>
<p>You can find the <a href="https://git.sr.ht/~amirouche/scheme.rs">source over the rainbow</a>. There is available a <a href="scheme.rs.md">single markdown file</a>, and a <a href="scheme.rs.html">single html file</a> and a <a href="scheme.rs.pdf">pdf</a>;</p>
<h2 id="license">LICENSE</h2>
<p>Except otherwise noted, this documentation is licensed under the SRFI license:</p>
<p>Copyright (C) Amirouche Amazigh BOUBEKKI, and contributors (2021).</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. # A cheatsheet on Discourse.</p>
<h2 id="the-three-gates-of-speech">The three gates of speech</h2>
<p>Before you speak, let your words pass through three gates.</p>
<ul>
<li>At the first gate, ask yourself, is it true.</li>
<li>At the second gate ask, is it necessary.</li>
<li>At the third gate ask, is it kind.</li>
</ul>
<h2 id="rogerian-rhetoric">Rogerian rhetoric</h2>
<blockquote>
<ol type="1">
<li><p>You should attempt to re-express your target’s position so clearly, vividly, and fairly that your target says, “Thanks, I wish I’d thought of putting it that way.”</p></li>
<li><p>You should list any points of agreement (especially if they are not matters of general or widespread agreement).</p></li>
<li><p>You should mention anything you have learned from your target.</p></li>
<li><p>Only then are you permitted to say so much as a word of rebuttal or criticism.</p></li>
</ol>
<p>— <a href="https://wikiless.org/wiki/Rogerian_rhetoric?lang=en#Dennett&#39;s_version">Dennett’s version of Rapoport’s Rules</a></p>
</blockquote>
<h2 id="argument-ranking">Argument Ranking</h2>
<ul>
<li><p>●●●●● - High-level generators - Disagreements that remain when everyone understands exactly what’s being argued, and agrees on what all the evidence says, but have vague and hard-to-define reasons for disagreeing.</p></li>
<li><p>●●●●○ - Operationalizing - Where both parties understand they’re in a cooperative effort to fix exactly what they’re arguing about.</p></li>
<li><p>●●●○○ - Survey of evidence - Not trying to devastate the other person with a mountain of facts and start looking at the studies and arguments on both sides and figuring out what kind of complex picture they paint.</p></li>
<li><p>●●●○○ - Disputing definitions - Argument hinges on the meaning of words, or whether something counts as a member of a category or not.</p></li>
<li><p>●●○○○ - Single Studies - Better than scattered facts, proving they at least looked into the issue formally.</p></li>
<li><p>●●○○○ - Demands for rigor - Attempts to demand that an opposing argument be held to such strict standards that nothing could possibly clear the bar.</p></li>
<li><p>●○○○○ - Single Facts- One fact, which admittedly does support their argument, but presented as if it solves the debate in and of itself.</p></li>
<li><p>●○○○○ - Gotchas - Short claims that purport to be devastating proof that one side can’t possibly be right.</p></li>
<li><p>○○○○○ - Social shaming- A demand for listeners to place someone outside the boundary of whom deserve to be heard.</p></li>
</ul>
<blockquote>
<p>“How to apologize: Quickly, specifically, sincerely.”</p>
<p>— Kevin Kelly</p>
</blockquote>
<h3 id="arguments">Arguments</h3>
<ul>
<li><strong>Ad baculum</strong> : Argument relying on an appeal to fear or a threat.</li>
<li><strong>Ad ignorantiam</strong> : Argument relying on people’s ignorance.</li>
<li><strong>Ad populum</strong> : Argument relying on sentimental weakness.</li>
<li><strong>Ad verecundiam</strong> : Argument relying on the the words of an “expert”, or authority.</li>
<li><strong>Ex silentio</strong> : Argument relying on ignorance.</li>
<li><strong>Ex nihilo</strong> : An argument that bears no relation to the previous topic of discussion.</li>
<li><strong>Non sequitur</strong> : An inference that does not follow from established premises or evidence.</li>
</ul>
<h3 id="responses">Responses</h3>
<ul>
<li><strong>Akrasia</strong> : State of acting against one’s better judgment.</li>
<li><strong>Connotation</strong> : Emotional association with a word.</li>
<li><strong>Intransigence</strong> : Refusal to change one’s views or to agree about something.</li>
<li><strong>Inferential distance</strong> : Gap between the background knowledge and epistemology of a person trying to explain an idea, and the background knowledge and epistemology of the person trying to understand it.</li>
<li><strong>Straw man</strong> : Creating a false or made up scenario and then attacking it. Painting your opponent with false colors only deflects the purpose of the argument.</li>
<li><strong>Steel man</strong> : To steelman is to address the strongest possible variant or the most charitable interpretation of an idea, rather than the most available phrasings.</li>
<li><strong>Red herring</strong> : A diversion from the active topic.</li>
<li><strong>Rationalization</strong> : Starts from a conclusion, and then works backward to arrive at arguments apparently favouring that conclusion. Rationalization argues for a side already selected.</li>
<li><strong>Dogpiling</strong> : A disagreement wherein one person says something wrong or offensive, and a large number of people comment in response to tell them how wrong they are, and continue to disparage the original commenter beyond any reasonable time limit.</li>
<li><strong>Grandstanding</strong> : An action that is intended to make people notice and admire you, behaving in a way that makes people pay attention to you instead of thinking about more important matters.</li>
<li><strong>Whataboutism</strong> : An attempt to discredit an opponent’s position by charging them with hypocrisy without directly refuting or disproving their argument.</li>
<li><strong>Dissensus</strong> : The deliberate avoidance of consensus.</li>
</ul>
<h3 id="beliefs">Beliefs</h3>
<ul>
<li><p><strong>Belief</strong> : The mental state in which an individual holds a proposition to be true.</p></li>
<li><p><strong>Priors</strong> : The beliefs an agent holds regarding a fact, hypothesis or consequence, before being presented with evidence.</p></li>
<li><p><strong>Alief</strong> : An independent source of emotional reaction which can coexist with a contradictory belief. Example The fear felt when a monster jumps out of the darkness in a scary movie is based on the alief that the monster is about to attack you, even though you believe that it cannot.</p></li>
<li><p><strong>Proper belief</strong> : Requires observations, gets updated upon encountering new evidence, and provides practical benefit in anticipated experience.</p></li>
<li><p><strong>Improper belief</strong> : Is a belief that isn’t concerned with describing the territory. Note that the fact that a belief just happens to be true doesn’t mean you’re right to have it. If you buy a lottery ticket, certain that it’s a winning ticket (for no reason), and it happens to be, believing that was still a mistake.</p></li>
<li><p><strong>Belief in belief</strong> : Where it is difficult to believe a thing, it is often much easier to believe that you ought to believe it. Were you to really believe and not just believe in belief, the consequences of error would be much more severe. When someone makes up excuses in advance, it would seem to require that belief, and belief in belief, have become unsynchronized.</p></li>
<li><p><strong>A Priori</strong> : Knowledge which we can be sure of without any empirical evidence(evidence from our senses). So, knowledge that you could realize if you were just a mind floating in a void unconnected to a body.</p></li>
</ul>
<blockquote>
<p>“A leader is best when people barely know they exists, when their work is done, their aim fulfilled, people will say: we did it ourselves.”</p>
<p>— 老子(Lao Tse), 道德經(Dao De Jing)</p>
</blockquote>
<p>The first principle of Wikipedia etiquette has been said to be <strong>Assume Good Faith</strong>, also they <strong>Be Bold, but not Reckless</strong>.</p>
<p><strong>Wrong discourse</strong></p>
<ul>
<li><p>Answer: Jumping into a conversation with endless unapplicable, unrealistic or unrelated answers to the question.</p></li>
<li><p>Question: Spouting accusations while cowardly hiding behind the claim of just asking questions, and ignoring the answers. Asking loaded questions.</p></li>
</ul>
<p><strong>Good discourse</strong></p>
<ul>
<li><p>Answer: A clear and honest response to the central point of a question without an aggressive attempt to convince.</p></li>
<li><p>Question: question asked with the intention to be fair, open, and honest, regardless of the outcome of the interaction.</p></li>
</ul>
<p>Social rules are expected to be broken from time to time, in that regard they are different from a code of conduct.</p>
<h3 id="response-ranking">Response Ranking</h3>
<ul>
<li>●●●●●● - Central point - Commit to refute explicitly the central point.</li>
<li>●●●●●○ - Refutation - Argue a conflicting passage, explain why it’s mistaken.</li>
<li>●●●●○○ - Counterargument - Contradict with added reasoning or evidence.</li>
<li>●●●○○○ - Contradiction - State the opposing case, what.</li>
<li>●●○○○○ - Responding to Tone - Responding to the author’s tone, how.</li>
<li>●○○○○○ - Ad Hominem - Attacking the author directly, who.</li>
</ul>
<h3 id="interaction-ranking">Interaction Ranking</h3>
<h4 id="discussion">Discussion</h4>
<ul>
<li><p>●●●●● - Release - Initiating a discussion on the lessons learnt from a project.</p></li>
<li><p>●●●●○ - Update - Presenting the recent development of a personal experience, ongoing event or work in progress.</p></li>
<li><p>●●●○○ - Soapbox - Spontaneous and or enthusiastic posts about a general topic of interest or finding.</p></li>
</ul>
<h4 id="low-effort">Low-Effort</h4>
<ul>
<li><p>●●○○○ - Rant- Venting frustration publicly without explicitly looking to have a conversation about the matter.</p></li>
<li><p>●○○○○ - Shitpost - Aggressively or ironically looking for the biggest reaction with the least effort possible. Includes subtoots and vague-posting.</p></li>
</ul>
<h3 id="emotional-reaction">Emotional Reaction</h3>
<ul>
<li><p><strong>Seduction</strong> - You are led to feel that the fulfillment of your dreams depends on your doing what the other is encouraging you to do.</p></li>
<li><p><strong>Alignment</strong> - The interests of the system are presented as fulfilling your emotional needs. You are led to feel that your survival, your viability in society or your very identity depends on your doing what the other is requiring of you.</p></li>
<li><p><strong>Reduction</strong> - Complex subjects are reduced to a single, emotionally charged issue.</p></li>
<li><p><strong>Polarization</strong> - Issues are presented in such a way that you are either right or wrong. You are told that any dialogue between different perspectives is suspect, dangerous or simply not permissible.</p></li>
<li><p><strong>Marginalization</strong> - You are made to feel that your own interests (or interests that run counter to the interests of the other) are inconsequential.</p></li>
<li><p><strong>Framing</strong> - The terms of a debate are set so that issues that threaten the system cannot be articulated or discussed. You are led to ignore aspects of the issue that may be vitally important to your own interests but are contrary to the interests of the other that is seeking to make you act in their interests.</p></li>
</ul>
<h2 id="quotes">Quotes</h2>
<blockquote>
<p>“Kings speak for the realm, governors for the state, popes for the church. Indeed, the titled, as titled, cannot speak <strong>with</strong> annyone.”</p>
<p>— James P. Carse, Finite and Infinite Games</p>
</blockquote>
<blockquote>
<p>“Instead of trying to prove your opponent wrong, try to see in what sense he might be right.” — Robert Nozick, Anarchy, State, and Utopia</p>
</blockquote>
<blockquote>
<p>“I don’t argue: I just say what I know or what I believe, as the case may be.” — John W. Cohan</p>
</blockquote>
<blockquote>
<p>“You should mention anything you have learned from your target.”</p>
</blockquote>
<h2 id="license-1">LICENSE</h2>
<p>The whole page is licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0">cc-by-nc-sa</a>; it is slightly adapted from https://wiki.xxiivv.com/site/discourse.html to be able to support the static site generator used on https://scheme.rs and to avoid the words “bad” (replaced with “wrong”) and “faith” (replaced with “discourse”), a few other changes, see <a href="https://git.sr.ht/~amirouche/scheme.rs/log/main/item/discourse/index.md">history</a> for complete log. # Tutorial</p>
<h2 id="basics">Basics</h2>
<h3 id="continuation">Continuation</h3>
<p>After reading this section you will be able to write basic Scheme programs. In particular, you will study:</p>
<ul>
<li><p>How to comment code</p></li>
<li><p>How to write literals for builtin types</p></li>
<li><p>How to call a procedure</p></li>
<li><p>How to define a variable</p></li>
<li><p>How to compare objects</p></li>
<li><p>How to define a procedure</p></li>
</ul>
<h3 id="how-to-comment-code">How to comment code</h3>
<p>You can comment code with the semi-colon, that is <code>;</code>. Idiomatic code use two semi-colons:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">;; Everything after one semi-colon is a comment.</span></span></code></pre></div>
<p>The following sections will use two semi-colons with followed by an arrow <code>=&gt;</code> to describe the return value.</p>
<h3 id="how-to-write-literals-for-builtin-types">How to write literals for builtin types</h3>
<h4 id="number">number</h4>
<ul>
<li>Integers can be written as usual <code>42</code></li>
<li>Inexact reals can be written as usual <code>3.1415</code></li>
<li>There is more number types. It is called the <a href="https://en.wikipedia.org/wiki/Numerical_tower">Numerical tower</a></li>
</ul>
<h4 id="boolean">boolean</h4>
<ul>
<li>false: <code>#f</code></li>
<li>true: <code>#t</code></li>
</ul>
<h4 id="characters">characters</h4>
<p>Characters can be written with their natural representation prefixed with <code>#\\</code>, for instance the character <code>x</code> is represented in Scheme code as follow:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ch">#\x</span></span></code></pre></div>
<h4 id="string">string</h4>
<p>A string is written with double quotes, that is <code>"</code>, for instance:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="st">&quot;hello world&quot;</span></span></code></pre></div>
<h4 id="symbol">symbol</h4>
<p>A symbol is most of the time written with a simple quote prefix, that is <code>'</code>. For instance:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>&#39;unique</span></code></pre></div>
<h4 id="pair">pair</h4>
<p>A pair of the symbol <code>'pi</code> and the value <code>3.1415</code> can be written as:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>&#39;(pi . <span class="fl">3.1415</span>)</span></code></pre></div>
<h4 id="list">list</h4>
<p>A list can be written as literals separated by one space and enclosed by parenthesis. For instance, the following list has three items:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>&#39;(unique <span class="st">&quot;hello world&quot;</span> (pi . <span class="fl">3.1415</span>))`</span></code></pre></div>
<p>The first item is the symbol <code>'unique</code>, the second item is a string, the third item is a pair.</p>
<p>The empty list is written <code>'()</code>.</p>
<h4 id="vector">vector</h4>
<p>A vector looks somewhat like a list but without the explicit simple quote. It use a hash prefix. For instance, the following vector has three items:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>#(unique <span class="st">&quot;hello world&quot;</span> <span class="dv">42</span>)</span></code></pre></div>
<p>The first item is the symbol <code>'unique</code>, the second item is a string, the third item is a number.</p>
<h4 id="bytevector">bytevector</h4>
<p>A bytevector is like vector but can contain only bytes. It looks like a list of integers, prefixed with <code>#vu8</code>. For instance, the following bytevector has three bytes:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>#vu8(<span class="dv">0</span> <span class="dv">42</span> <span class="dv">255</span>)</span></code></pre></div>
<h3 id="how-to-call-a-procedure">How to call a procedure</h3>
<p>A procedure call looks like a list without the simple quote prefix.</p>
<p>The following describe the addition 21 and 21:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>(<span class="op">+</span> <span class="dv">21</span> <span class="dv">21</span>) <span class="co">;; =&gt; 42</span></span></code></pre></div>
<p>It returns <code>42</code>. So does the following multiplication:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>(* <span class="dv">21</span> <span class="dv">2</span>) <span class="co">;; =&gt; 42</span></span></code></pre></div>
<p>The first item is a procedure object. Most of the time, procedure names are made of letters separated with dashes. That usually called <code>kebab-case</code>.</p>
<p>Here is another procedure call:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>(<span class="kw">string-append</span> <span class="st">&quot;hello&quot;</span> <span class="st">&quot; &quot;</span> <span class="st">&quot;world&quot;</span>) <span class="co">;; =&gt; &quot;hello world&quot;</span></span></code></pre></div>
<p>It will return a string <code>"hello world"</code>.</p>
<h3 id="how-to-define-a-variable">How to define a variable</h3>
<p>The first kind of variables that you encountered are procedures, things like <code>+</code>, <code>*</code> or <code>string-append</code>.</p>
<p>Variables can also contain constants. You can use <code>define</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>%thruth <span class="dv">42</span>)</span></code></pre></div>
<p>The above code will create a variable called <code>%thruth</code> that contains <code>42</code>.</p>
<p>Look at this very complicated computation:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>(<span class="op">+</span> %thruth <span class="dv">1</span> (* <span class="dv">2</span> <span class="dv">647</span>)) <span class="co">;; =&gt; 1337</span></span></code></pre></div>
<h3 id="how-to-compare-objects">How to compare objects</h3>
<h4 id="identity-equivalence">Identity equivalence</h4>
<p>To compare by identity, in pratice, whether two object represent the same memory location, you can use the procedure <code>eq?</code>.</p>
<p>In the case where you are comparing symbols you can use the procedure <code>eq?</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>(<span class="kw">eq?</span> &#39;unique &#39;unique) <span class="co">;; =&gt; #t</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>(<span class="kw">eq?</span> &#39;unique &#39;singleton) <span class="co">;; =&gt; #f</span></span></code></pre></div>
<h3 id="equivalence">Equivalence</h3>
<p>If you do not know the type of the compared objects, or the objects can be of different types, you can use the procedure <code>equal?</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>(<span class="kw">equal?</span> <span class="dv">#t</span> <span class="st">&quot;true&quot;</span>) <span class="co">;; =&gt; #f</span></span></code></pre></div>
<p>The string <code>"true"</code> is not equivalent to the boolean <code>#t</code>.</p>
<p>It is rare to use <code>equal?</code>, because, usually, you know the type of the compared objects and the compared object have the same type.</p>
<h3 id="equivalence-predicates">Equivalence predicates</h3>
<p>The astute reader might have recognized a pattern in the naming of the equivalence procedures <code>eq?</code> and <code>equal?</code>: both end with a question mark. That is a convention that all procedures that can only return a boolean should end with a question mark. Those are called <em>predicates</em>.</p>
<p>They are predicates for every builtin types. For instance string type has a string equivalence predicate written <code>string=?</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>(<span class="kw">string=?</span> <span class="st">&quot;hello&quot;</span> <span class="st">&quot;hello world&quot;</span> <span class="st">&quot;hello, world!&quot;</span>) <span class="co">;; =&gt; #f</span></span></code></pre></div>
<p>The predicate procedure <code>string=?</code> will return <code>#t</code> if all arguments are the same string, in the sense they contain the same characters.</p>
<h3 id="how-to-define-a-procedure">How to define a procedure</h3>
<p>The simplest procedure ever, is the procedure that takes no argument and returns itself:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(ruse)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>  ruse)</span></code></pre></div>
<p>The above is sugar syntax for the following:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> ruse </span>(<span class="kw">lambda</span> () ruse))</span></code></pre></div>
<p>A procedure that takes no arguments is called a <em>thunk</em>. Indentation and the newline are cosmetic conventions. If you call the procedure <code>ruse</code>, it will return <code>ruse</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>(<span class="kw">eq?</span> ruse (ruse))</span></code></pre></div>
<p>One can define a procedure that adds one as follow:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(add1 number)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>  (<span class="op">+</span> number <span class="dv">1</span>))</span></code></pre></div>
<p>The predicate to compare numbers is <code>=</code>. Hence, the following:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a>(<span class="op">=</span> <span class="dv">2006</span> (add1 <span class="dv">2005</span>)) <span class="co">;; =&gt; #t</span></span></code></pre></div>
<p>Mind the fact that it returns a new number. It does not mutate the value even if it is passed as a variable.</p>
<p>Let’s imagine a procedure that appends a name to the string <code>"Hello"</code>. For instance, given <code>"Aziz"</code> or a variable containing <code>"Aziz"</code>, it will return <code>"Hello Aziz"</code>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> name </span><span class="st">&quot;Aziz&quot;</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(say-hello name)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>  (<span class="kw">string-append</span> <span class="st">&quot;Hello &quot;</span> name))</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>(<span class="kw">string=?</span> <span class="st">&quot;Hello Aziz&quot;</span> (say-hello name)) <span class="co">;; =&gt; #t</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a><span class="co">;; XXX: the variable name still contains &quot;Aziz&quot;</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>(<span class="kw">string=?</span> name <span class="st">&quot;Aziz&quot;</span>)) <span class="co">;; =&gt; #t</span></span></code></pre></div>
<p>It does not matter for the callee whether the arguments are passed as variables or literals:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a>(<span class="kw">string=?</span> <span class="st">&quot;Hello John&quot;</span>  (say-hello <span class="st">&quot;John&quot;</span>)) <span class="co">;; =&gt; #t</span></span></code></pre></div>
<h3 id="backtrack">Backtrack</h3>
<p>In this section you learned:</p>
<ul>
<li><p>How to comment code using a semi-colon character <code>;</code></p></li>
<li><p>How to write literals for builtin types</p>
<ul>
<li>integer: <code>42</code></li>
<li>float: <code>3.1415</code></li>
<li>symbol: <code>'unique</code></li>
<li>string: <code>"hello world"</code></li>
<li>pair: <code>(pi . 3.1415)</code></li>
<li>list: <code>'(42 "hello world" (pi . 3.1415))</code></li>
<li>vector: <code>#(42 "hello world" (pi . 3.1415))</code></li>
<li>bytevector: <code>#vu8(1 42 255)</code></li>
</ul></li>
<li><p>How to call a procedure <code>(string-append "hello " "Aziz")</code></p></li>
<li><p>How to define a variable <code>(define %thruth 42)</code></p></li>
<li><p>How to compare objects using their type specific predicates. For instance: <code>(string=? "hello" "hello")</code></p></li>
<li><p>How to define a procedure again using <code>define</code> with slightly different syntax <code>(define (add1 number) (+ number 1))</code></p></li>
</ul>
<h2 id="forward">Forward</h2>
<h3 id="continuation-1">Continuation</h3>
<p>After reading this section you will be able to write more complex Scheme code. In particular you will study:</p>
<ul>
<li><p>How to create lexical bindings</p></li>
<li><p>How to set a variable</p></li>
<li><p>How to do a branch <code>if</code></p></li>
<li><p>How to create a new type</p></li>
<li><p>How to write a named-let</p></li>
</ul>
<h3 id="how-to-create-lexical-bindings">How to create lexical bindings</h3>
<p>Lexical bindings can be created with <code>let</code>, <code>let*</code>, <code>letrec</code> and <code>letrec*</code>. They have slightly different behaviors, but the same syntax:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>(<span class="kw">let</span> (&lt;binding&gt; ...) &lt;expression&gt; ...)</span></code></pre></div>
<p>Where <code>&lt;binding&gt;</code> looks like an association of a variable name with the initial value it is holding. For instance:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>(<span class="kw">let</span> ((a <span class="dv">1</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>      (b <span class="dv">2</span>))</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>  (<span class="op">+</span> a b <span class="dv">3</span>)) <span class="co">;; =&gt; 6</span></span></code></pre></div>
<p>The above <code>let</code> form will bind <code>a</code> to <code>1</code>, <code>b</code> to <code>2</code> and return the output of <code>(+ a b 3)</code> that is <code>6</code>.</p>
<h3 id="how-to-set-a-variable">How to set a variable</h3>
<p>To change what a variable holds without overriding it or mutating the object contained in the varialbe, you can use <code>set!</code>. Mind the exclamation mark, it is a convention that forms that have a side-effect ends with a exclamation mark. For instance:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>%thruth <span class="dv">42</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a>(<span class="kw">display</span> %truth)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a>(<span class="kw">newline</span>)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>(set! %thruth <span class="dv">101</span>)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a>(<span class="kw">display</span> %truth)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a>(<span class="kw">newline</span>)</span></code></pre></div>
<h3 id="how-to-do-a-branch-if">How to do a branch <code>if</code></h3>
<p>Scheme <code>if</code> will consider false, only the object <code>#f</code>. Hence, one can do the following:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a>(<span class="kw">if</span> <span class="dv">#t</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>  (<span class="kw">display</span> <span class="st">&quot;true&quot;</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>  (<span class="kw">display</span> <span class="st">&quot;never executed&quot;</span>))</span></code></pre></div>
<p>Similarly:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a>(<span class="kw">if</span> <span class="dv">#f</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>  (<span class="kw">display</span> <span class="st">&quot;never executed&quot;</span>)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>  (<span class="kw">display</span> <span class="st">&quot;false&quot;</span>))</span></code></pre></div>
<p>In particular, the number zero is true according to scheme <code>if</code>:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>(<span class="kw">if</span> <span class="dv">0</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>  (<span class="kw">display</span> <span class="st">&quot;zero is true&quot;</span>)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>  (<span class="kw">display</span> <span class="st">&quot;never executed&quot;</span>))</span></code></pre></div>
<p>If you want to check whether a value is zero you can use the predicate <code>zero?</code> like so:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a>(<span class="kw">if</span> (<span class="kw">zero?</span> %thruth)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>   (<span class="kw">display</span> <span class="st">&quot;%thruth is zero&quot;</span>)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>   (<span class="kw">display</span> <span class="st">&quot;%thruth is not zero&quot;</span>))</span></code></pre></div>
<p>Or the less idiomatic predicate <code>=</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a>(<span class="kw">if</span> (<span class="op">=</span> %truth <span class="dv">0</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>  (<span class="kw">display</span> <span class="st">&quot;%thruth is zero&quot;</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a>  (<span class="kw">display</span> <span class="st">&quot;%thruth is not zero&quot;</span>))</span></code></pre></div>
<h3 id="how-to-create-a-new-type">How to create a new type</h3>
<p>To create a new type you can use the macro <code>define-record-type</code>. For instance, in a todo list application, we will need an <code>&lt;item&gt;</code> type that can be defined as:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a>(define-record-type &lt;item&gt;</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>  (make-item title body status)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a>  item?</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a>  (title item-title item-title!)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a>  (body item-body item-body!)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true"></a>  (status item-status item-status!))</span></code></pre></div>
<p>Where:</p>
<ul>
<li><code>&lt;item&gt;</code> is the record name,</li>
<li><code>make-item</code> is the constructor of record instances,</li>
<li><code>item?</code> is the predicate that allows to tell whether an object is a <code>&lt;item&gt;</code> type,</li>
<li><code>title</code>, <code>body</code> and <code>status</code> are fields with their associated getters and setters. Setters ends with an exclamation mark. They will mutate the object. Setters are optional.</li>
</ul>
<p>Here is an example use of the above <code>&lt;item&gt;</code> definition:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> item </span>(make-item <span class="st">&quot;Learn Scheme&quot;</span> <span class="st">&quot;The Scheme programming language is awesome, I should learn it&quot;</span> &#39;todo))</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a><span class="co">;; To change the status, one can do the following:</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a>(item-status! item &#39;wip)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true"></a><span class="co">;; to get the title, one can do the following:</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true"></a></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true"></a>(<span class="kw">display</span> (item-title item))</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true"></a>(<span class="kw">newline</span>)</span></code></pre></div>
<h3 id="how-to-write-a-named-let">How to write a named-let</h3>
<p>A named-let allows to do recursion without going through the ceremony of defining a separate procedure. In pratice, it used in similar contexts such as <code>for</code> or <code>while</code> loop in other languages. Given the procedure <code>(cons item items)</code> that will return a new list with <code>ITEMS</code> as tail and <code>ITEM</code> as first item, study the following code:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a>(<span class="kw">let</span> loop ((index <span class="dv">0</span>)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>           (out &#39;())</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a>  (<span class="kw">if</span> (<span class="op">=</span> index <span class="dv">10</span>)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a>      (<span class="kw">display</span> out)</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a>      (loop (<span class="op">+</span> index <span class="dv">1</span>) (<span class="kw">cons</span> index out))))</span></code></pre></div>
<p>It is equivalent to the following:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(loop index out)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>  (<span class="kw">if</span> (<span class="op">=</span> index <span class="dv">10</span>)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>      (<span class="kw">display</span> out)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true"></a>      (loop (<span class="op">+</span> index <span class="dv">1</span>) (<span class="kw">cons</span> index out))))</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true"></a>(loop <span class="dv">0</span> &#39;())</span></code></pre></div>
<p>A named-let, look like a <code>let</code> form that can be used to bind variables prefixed with a name. Here is some pseudo-code that describe the syntax of the named-let form:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a>(<span class="kw">let</span> &lt;name&gt; (&lt;binding&gt; ...) expression ...))</span></code></pre></div>
<p>So <code>&lt;binding&gt;</code> and <code>&lt;expression&gt;</code> are very similar to a <code>let</code>. <code>&lt;name&gt;</code> will be bound to a procedure that takes as many argument as there is <code>&lt;binding&gt;</code> and its body will be <code>&lt;expression&gt; ...</code>. It will be called with the associated objects in <code>&lt;binding&gt; ...</code>. <code>expression</code> can call <code>&lt;name&gt;</code> most likely in tail call position but not necessarly. If the named-let is not tail-recursive, it is also known to be a <em>grow the stack recursive call</em>. Another way to see the named-let is pseudo-code:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> &lt;name&gt; </span>(<span class="kw">lambda</span> &lt;formals&gt; &lt;expression&gt; ...))</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a>(&lt;name&gt; &lt;arguments&gt; ...)</span></code></pre></div>
<p>Where:</p>
<ul>
<li><code>&lt;formals&gt;</code> are the variable names from <code>&lt;binding&gt; ...</code></li>
<li><code>&lt;arguments&gt;</code> are the initial object bound in <code>&lt;binding&gt; ...</code></li>
</ul>
<p>That is all.</p>
<h3 id="backtrack-1">Backtrack</h3>
<ul>
<li><p>How to create lexical bindings with <code>let</code>, <code>let*</code>, <code>letrec</code> and <code>letrec*</code>,</p></li>
<li><p>How to set a variable using <code>(set! %thruth 42)</code>,</p></li>
<li><p>How to do a <code>if</code> with <code>(if %thruth (display "That is true") (display   "That is false"))</code>,</p></li>
<li><p>How to create a new type using <code>define-record-type</code> that can look like:</p></li>
</ul>
<div class="sourceCode" id="cb38"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a>(define-record-type &lt;record-name&gt;</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a>  (make-record-name field0 ...)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a>  record-name?</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true"></a>  (field0 record-name-field0 record-name-field0!))</span></code></pre></div>
<ul>
<li>How to write a named-let, for instance an infinite loop will look like:</li>
</ul>
<div class="sourceCode" id="cb39"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a>(<span class="kw">let</span> loop ((index <span class="dv">0</span>))</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a>  (<span class="kw">display</span> index)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true"></a>  (loop (<span class="op">+</span> index <span class="dv">1</span>)))</span></code></pre></div>
<h2 id="beyond">Beyond</h2>
<h3 id="continuation-2">Continuation</h3>
<p>After reading this section you will be able to create libraries.</p>
<h3 id="backtrack-2">Backtrack</h3>
<h2 id="elements-of-style">Elements of Style</h2>
<!--
- See scheme style guides
- See common lisp style guides
- See clojure style guides
- Better to avoid `eqv?` -->
<h1 id="r7rs-small-specification">R<sup><small>7</small></sup>RS small specification</h1>
<p>Note: This is a port of R<sup><small>7</small></sup>RS specification from tex to markdown that is rendered to html. It does not include formal semantics.</p>
<h2 id="summary">Summary</h2>
<p>The report gives a defining description of the programming language Scheme. Scheme is a statically scoped and properly tail recursive dialect of the Lisp programming language <span class="citation" data-cites="McCarthy"></span> invented by Guy Lewis Steele Jr. and Gerald Jay Sussman. It was designed to have exceptionally clear and simple semantics and few different ways to form expressions. A wide variety of programming paradigms, including imperative, functional, and object-oriented styles, find convenient expression in Scheme.</p>
<p>The introduction offers a brief history of the language and of the report.</p>
<p>The first three chapters present the fundamental ideas of the language and describe the notational conventions used for describing the language and for writing programs in the language.</p>
<p>Chapters <a href="#expressionchapter">[expressionchapter]</a> and <a href="#programchapter">[programchapter]</a> describe the syntax and semantics of expressions, definitions, programs, and libraries.</p>
<p>Chapter <a href="#builtinchapter">[builtinchapter]</a> describes Scheme’s built-in procedures, which include all of the language’s data manipulation and input/output primitives.</p>
<p>Chapter <a href="#formalchapter">[formalchapter]</a> provides a formal syntax for Scheme written in extended BNF, along with a formal denotational semantics. An example of the use of the language follows the formal syntax and semantics.</p>
<p>Appendix <a href="#stdlibraries">[stdlibraries]</a> provides a list of the standard libraries and the identifiers that they export.</p>
<p>Appendix <a href="#stdfeatures">[stdfeatures]</a> provides a list of optional but standardized implementation feature names.</p>
<p>The report concludes with a list of references and an alphabetic index.</p>
<p><em>Note:</em> The editors of the R<sup><small>5</small></sup>RS and R<sup><small>6</small></sup>RS reports are listed as authors of this report in recognition of the substantial portions of this report that are copied directly from R<sup><small>5</small></sup>RS and R<sup><small>6</small></sup>RS. There is no intended implication that those editors, individually or collectively, support or do not support this report.</p>
<h2 id="contents">Contents</h2>
<p>Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary. Scheme demonstrates that a very small number of rules for forming expressions, with no restrictions on how they are composed, suffice to form a practical and efficient programming language that is flexible enough to support most of the major programming paradigms in use today.</p>
<p>Scheme was one of the first programming languages to incorporate first-class procedures as in the lambda calculus, thereby proving the usefulness of static scope rules and block structure in a dynamically typed language. Scheme was the first major dialect of Lisp to distinguish procedures from lambda expressions and symbols, to use a single lexical environment for all variables, and to evaluate the operator position of a procedure call in the same way as an operand position. By relying entirely on procedure calls to express iteration, Scheme emphasized the fact that tail-recursive procedure calls are essentially GOTOs that pass arguments, thus allowing a programming style that is both coherent and efficient. Scheme was the first widely used programming language to embrace first-class escape procedures, from which all previously known sequential control structures can be synthesized. A subsequent version of Scheme introduced the concept of exact and inexact numbers, an extension of Common Lisp’s generic arithmetic. More recently, Scheme became the first programming language to support hygienic macros, which permit the syntax of a block-structured language to be extended in a consistent and reliable manner.</p>
<h3 id="background">Background</h3>
<p>The first description of Scheme was written in 1975 <span class="citation" data-cites="Scheme75"></span>. A revised report <span class="citation" data-cites="Scheme78"></span> appeared in 1978, which described the evolution of the language as its MIT implementation was upgraded to support an innovative compiler <span class="citation" data-cites="Rabbit"></span>. Three distinct projects began in 1981 and 1982 to use variants of Scheme for courses at MIT, Yale, and Indiana University <span class="citation" data-cites="Rees82 MITScheme Scheme311"></span>. An introductory computer science textbook using Scheme was published in 1984 <span class="citation" data-cites="SICP"></span>.</p>
<p>As Scheme became more widespread, local dialects began to diverge until students and researchers occasionally found it difficult to understand code written at other sites. Fifteen representatives of the major implementations of Scheme therefore met in October 1984 to work toward a better and more widely accepted standard for Scheme. Their report, the RRRS <span class="citation" data-cites="RRRS"></span>, was published at MIT and Indiana University in the summer of 1985. Further revision took place in the spring of 1986, resulting in the R<sup><small>3</small></sup>RS <span class="citation" data-cites="R3RS"></span>. Work in the spring of 1988 resulted in R<sup><small>4</small></sup>RS <span class="citation" data-cites="R4RS"></span>, which became the basis for the IEEE Standard for the Scheme Programming Language in 1991 <span class="citation" data-cites="IEEEScheme"></span>. In 1998, several additions to the IEEE standard, including high-level hygienic macros, multiple return values, and eval, were finalized as the R<sup><small>5</small></sup>RS <span class="citation" data-cites="R5RS"></span>.</p>
<p>In the fall of 2006, work began on a more ambitious standard, including many new improvements and stricter requirements made in the interest of improved portability. The resulting standard, the R<sup><small>6</small></sup>RS, was completed in August 2007 <span class="citation" data-cites="R6RS"></span>, and was organized as a core language and set of mandatory standard libraries. Several new implementations of Scheme conforming to it were created. However, most existing R<sup><small>5</small></sup>RS implementations (even excluding those which are essentially unmaintained) did not adopt R<sup><small>6</small></sup>RS, or adopted only selected parts of it.</p>
<p>In consequence, the Scheme Steering Committee decided in August 2009 to divide the standard into two separate but compatible languages — a “small” language, suitable for educators, researchers, and users of embedded languages, focused on R<sup><small>5</small></sup>RS compatibility, and a “large” language focused on the practical needs of mainstream software development, intended to become a replacement for R<sup><small>6</small></sup>RS. The present report describes the “small” language of that effort: therefore it cannot be considered in isolation as the successor to R<sup><small>6</small></sup>RS.</p>
<p>We intend this report to belong to the entire Scheme community, and so we grant permission to copy it in whole or in part without fee. In particular, we encourage implementers of Scheme to use this report as a starting point for manuals and other documentation, modifying it as necessary.</p>
<h3 id="acknowledgments">Acknowledgments</h3>
<p>We would like to thank the members of the Steering Committee, William Clinger, Marc Feeley, Chris Hanson, Jonathan Rees, and Olin Shivers, for their support and guidance.</p>
<p>This report is very much a community effort, and we’d like to thank everyone who provided comments and feedback, including the following people: David Adler, Eli Barzilay, Taylan Ulrich Bayırlı/Kammer, Marco Benelli, Pierpaolo Bernardi, Peter Bex, Per Bothner, John Boyle, Taylor Campbell, Raffael Cavallaro, Ray Dillinger, Biep Durieux, Sztefan Edwards, Helmut Eller, Justin Ethier, Jay Reynolds Freeman, Tony Garnock-Jones, Alan Manuel Gloria, Steve Hafner, Sven Hartrumpf, Brian Harvey, Moritz Heidkamp, Jean-Michel Hufflen, Aubrey Jaffer, Takashi Kato, Shiro Kawai, Richard Kelsey, Oleg Kiselyov, Pjotr Kourzanov, Jonathan Kraut, Daniel Krueger, Christian Stigen Larsen, Noah Lavine, Stephen Leach, Larry D. Lee, Kun Liang, Thomas Lord, Vincent Stewart Manis, Perry Metzger, Michael Montague, Mikael More, Vitaly Magerya, Vincent Manis, Vassil Nikolov, Joseph Wayne Norton, Yuki Okumura, Daichi Oohashi, Jeronimo Pellegrini, Jussi Piitulainen, Alex Queiroz, Jim Rees, Grant Rettke, Andrew Robbins, Devon Schudy, Bakul Shah, Robert Smith, Arthur Smyles, Michael Sperber, John David Stone, Jay Sulzberger, Malcolm Tredinnick, Sam Tobin-Hochstadt, Andre van Tonder, Daniel Villeneuve, Denis Washington, Alan Watson, Mark H. Weaver, Göran Weinholt, David A. Wheeler, Andy Wingo, James Wise, Jörg F. Wittenberger, Kevin A. Wortman, Sascha Ziemann.</p>
<p>In addition we would like to thank all the past editors, and the people who helped them in turn: Hal Abelson, Norman Adams, David Bartley, Alan Bawden, Michael Blair, Gary Brooks, George Carrette, Andy Cromarty, Pavel Curtis, Jeff Dalton, Olivier Danvy, Ken Dickey, Bruce Duba, Robert Findler, Andy Freeman, Richard Gabriel, Yekta Gürsel, Ken Haase, Robert Halstead, Robert Hieb, Paul Hudak, Morry Katz, Eugene Kohlbecker, Chris Lindblad, Jacob Matthews, Mark Meyer, Jim Miller, Don Oxley, Jim Philbin, Kent Pitman, John Ramsdell, Guillermo Rozas, Mike Shaff, Jonathan Shapiro, Guy Steele, Julie Sussman, Perry Wagle, Mitchel Wand, Daniel Weise, Henry Wu, and Ozan Yigit. We thank Carol Fessenden, Daniel Friedman, and Christopher Haynes for permission to use text from the Scheme 311 version 4 reference manual. We thank Texas Instruments, Inc. for permission to use text from the <em>TI Scheme Language Reference Manual</em> <span class="citation" data-cites="TImanual85"></span>. We gladly acknowledge the influence of manuals for MIT Scheme <span class="citation" data-cites="MITScheme"></span>, T <span class="citation" data-cites="Rees84"></span>, Scheme 84 <span class="citation" data-cites="Scheme84"></span>, Common Lisp <span class="citation" data-cites="CLtL"></span>, and Algol 60 <span class="citation" data-cites="Naur63"></span>, as well as the following SRFIs: 0, 1, 4, 6, 9, 11, 13, 16, 30, 34, 39, 43, 46, 62, and 87, all of which are available at http://srfi.schemers.org.</p>
<h2 id="overview-of-scheme">Overview of Scheme</h2>
<h3 id="semantics">Semantics</h3>
<p>This section gives an overview of Scheme’s semantics. A detailed informal semantics is the subject of chapters <a href="#basicchapter">[basicchapter]</a> through <a href="#builtinchapter">[builtinchapter]</a>. For reference purposes, section <a href="#formalsemanticssection">[formalsemanticssection]</a> provides a formal semantics of Scheme.</p>
<p>Scheme is a statically scoped programming language. Each use of a variable is associated with a lexically apparent binding of that variable.</p>
<p>Scheme is a dynamically typed language. Types are associated with values (also called objects) rather than with variables. Statically typed languages, by contrast, associate types with variables and expressions as well as with values.</p>
<p>All objects created in the course of a Scheme computation, including procedures and continuations, have unlimited extent. No Scheme object is ever destroyed. The reason that implementations of Scheme do not (usually!) run out of storage is that they are permitted to reclaim the storage occupied by an object if they can prove that the object cannot possibly matter to any future computation.</p>
<p>Implementations of Scheme are required to be properly tail-recursive. This allows the execution of an iterative computation in constant space, even if the iterative computation is described by a syntactically recursive procedure. Thus with a properly tail-recursive implementation, iteration can be expressed using the ordinary procedure-call mechanics, so that special iteration constructs are useful only as syntactic sugar. See section <a href="#proper%20tail%20recursion">[proper tail recursion]</a>.</p>
<p>Scheme procedures are objects in their own right. Procedures can be created dynamically, stored in data structures, returned as results of procedures, and so on.</p>
<p>One distinguishing feature of Scheme is that continuations, which in most other languages only operate behind the scenes, also have “first-class” status. Continuations are useful for implementing a wide variety of advanced control constructs, including non-local exits, backtracking, and coroutines. See section <a href="#continuations">[continuations]</a>.</p>
<p>Arguments to Scheme procedures are always passed by value, which means that the actual argument expressions are evaluated before the procedure gains control, regardless of whether the procedure needs the result of the evaluation.</p>
<p>Scheme’s model of arithmetic is designed to remain as independent as possible of the particular ways in which numbers are represented within a computer. In Scheme, every integer is a rational number, every rational is a real, and every real is a complex number. Thus the distinction between integer and real arithmetic, so important to many programming languages, does not appear in Scheme. In its place is a distinction between exact arithmetic, which corresponds to the mathematical ideal, and inexact arithmetic on approximations. Exact arithmetic is not limited to integers.</p>
<h3 id="syntax">Syntax</h3>
<p>Scheme, like most dialects of Lisp, employs a fully parenthesized prefix notation for programs and other data; the grammar of Scheme generates a sublanguage of the language used for data. An important consequence of this simple, uniform representation is that Scheme programs and data can easily be treated uniformly by other Scheme programs. For example, the eval procedure evaluates a Scheme program expressed as data.</p>
<p>The read procedure performs syntactic as well as lexical decomposition of the data it reads. The read procedure parses its input as data (section <a href="#datumsyntax">[datumsyntax]</a>), not as program.</p>
<p>The formal syntax of Scheme is described in section <a href="#BNF">[BNF]</a>.</p>
<h3 id="notation-and-terminology">Notation and terminology</h3>
<h4 id="base-and-optional-features">Base and optional features</h4>
<p>Every identifier defined in this report appears in one or more of several <code>libraries</code>. Identifiers defined in the <em>base library</em> are not marked specially in the body of the report. This library includes the core syntax of Scheme and generally useful procedures that manipulate data. For example, the variable abs is bound to a procedure of one argument that computes the absolute value of a number, and the variable + is bound to a procedure that computes sums. The full list all the standard libraries and the identifiers they export is given in Appendix <a href="#stdlibraries">[stdlibraries]</a>.</p>
<p>All implementations of Scheme:</p>
<ul>
<li><p>Must provide the base library and all the identifiers exported from it.</p></li>
<li><p>May provide or omit the other libraries given in this report, but each library must either be provided in its entirety, exporting no additional identifiers, or else omitted altogether.</p></li>
<li><p>May provide other libraries not described in this report.</p></li>
<li><p>May also extend the function of any identifier in this report, provided the extensions are not in conflict with the language reported here.</p></li>
<li><p>Must support portable code by providing a mode of operation in which the lexical syntax does not conflict with the lexical syntax described in this report.</p></li>
</ul>
<h4 id="error-situations-and-unspecified-behavior">Error situations and unspecified behavior</h4>
<p>When speaking of an error situation, this report uses the phrase “an error is signaled” to indicate that implementations must detect and report the error. An error is signaled by raising a non-continuable exception, as if by the procedure raise as described in section <a href="#exceptionsection">[exceptionsection]</a>. The object raised is implementation-dependent and need not be distinct from objects previously used for the same purpose. In addition to errors signaled in situations described in this report, programmers can signal their own errors and handle signaled errors.</p>
<p>The phrase “an error that satisfies <em>predicate</em> is signaled” means that an error is signaled as above. Furthermore, if the object that is signaled is passed to the specified predicate (such as file-error? or read-error?), the predicate returns <code>#t</code>.</p>
<p>If such wording does not appear in the discussion of an error, then implementations are not required to detect or report the error, though they are encouraged to do so. Such a situation is sometimes, but not always, referred to with the phrase “an error.” In such a situation, an implementation may or may not signal an error; if it does signal an error, the object that is signaled may or may not satisfy the predicates error-object?, file-error?, or read-error?. Alternatively, implementations may provide non-portable extensions.</p>
<p>For example, it is an error for a procedure to be passed an argument of a type that the procedure is not explicitly specified to handle, even though such domain errors are seldom mentioned in this report. Implementations may signal an error, extend a procedure’s domain of definition to include such arguments, or fail catastrophically.</p>
<p>This report uses the phrase “may report a violation of an implementation restriction” to indicate circumstances under which an implementation is permitted to report that it is unable to continue execution of a correct program because of some restriction imposed by the implementation. Implementation restrictions are discouraged, but implementations are encouraged to report violations of implementation restrictions.</p>
<p>For example, an implementation may report a violation of an implementation restriction if it does not have enough storage to run a program, or if an arithmetic operation would produce an exact number that is too large for the implementation to represent.</p>
<p>If the value of an expression is said to be “unspecified,” then the expression must evaluate to some object without signaling an error, but the value depends on the implementation; this report explicitly does not say what value is returned.</p>
<p>Finally, the words and phrases “must,” “must not,” “shall,” “shall not,” “should,” “should not,” “may,” “required,” “recommended,” and “optional,” although not capitalized in this report, are to be interpreted as described in RFC 2119 <span class="citation" data-cites="rfc2119"></span>. They are used only with reference to implementer or implementation behavior, not with reference to programmer or program behavior.</p>
<h4 id="entry-format">Entry format</h4>
<p>Chapters <a href="#expressionchapter">[expressionchapter]</a> and <a href="#builtinchapter">[builtinchapter]</a> are organized into entries. Each entry describes one language feature or a group of related features, where a feature is either a syntactic construct or a procedure. An entry begins with one or more header lines of the form</p>
<blockquote>
<p><code>template</code> <em>category</em></p>
</blockquote>
<p>for identifiers in the base library, or</p>
<blockquote>
<p><code>template</code> <em>name</em> library <em>category</em></p>
</blockquote>
<p>where <code>name</code> is the short name of a library as defined in Appendix <a href="#stdlibraries">[stdlibraries]</a>.</p>
<p>If <code>category</code> is “syntax,” the entry describes an expression type, and the template gives the syntax of the expression type. Components of expressions are designated by syntactic variables, which are written using angle brackets, for example expression and variable. Syntactic variables are intended to denote segments of program text; for example, expression stands for any string of characters which is a syntactically valid expression. The notation</p>
<pre><code>thing ...</code></pre>
<p>indicates zero or more occurrences of a <code>thing</code>, and</p>
<pre><code>thing thing ...</code></pre>
<p>indicates one or more occurrences of a thing.</p>
<p>If <code>category</code> is “auxiliary syntax,” then the entry describes a syntax binding that occurs only as part of specific surrounding expressions. Any use as an independent syntactic construct or variable is an error.</p>
<p>If <code>category</code> is “procedure,” then the entry describes a procedure, and the header line gives a template for a call to the procedure. Argument names in the template are <em>italicized</em>. Thus the header line</p>
<blockquote>
<p><code>(vector-ref vector k)</code> <em>procedure</em></p>
</blockquote>
<p>indicates that the procedure bound to the <code>vector-ref</code> variable takes two arguments, a vector <code>vector</code> and an exact non-negative integer <code>k</code> (see below). The header lines</p>
<blockquote>
<p><code>(make-vector k)</code> <em>procedure</em></p>
</blockquote>
<blockquote>
<p><code>(make-vector k fill)</code> <em>procedure</em></p>
</blockquote>
<p>indicate that the <code>make-vector</code> procedure must be defined to take either one or two arguments.</p>
<p>It is an error for a procedure to be presented with an argument that it is not specified to handle. For succinctness, we follow the convention that if an argument name is also the name of a type listed in section <a href="#disjointness">[disjointness]</a>, then it is an error if that argument is not of the named type. For example, the header line for <code>vector-ref</code> given above dictates that the first argument to <code>vector-ref</code> is a vector. The following naming conventions also imply type restrictions:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">alist</td>
<td style="text-align: left;">association list (list of pairs)</td>
</tr>
<tr class="even">
<td style="text-align: left;">boolean</td>
<td style="text-align: left;">boolean value (<code>#t</code> or <code>#f</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">byte</td>
<td style="text-align: left;">exact integer 0 ≤ byte &lt; 256</td>
</tr>
<tr class="even">
<td style="text-align: left;">bytevector</td>
<td style="text-align: left;">bytevector</td>
</tr>
<tr class="odd">
<td style="text-align: left;">char</td>
<td style="text-align: left;">character</td>
</tr>
<tr class="even">
<td style="text-align: left;">end</td>
<td style="text-align: left;">exact non-negative integer</td>
</tr>
<tr class="odd">
<td style="text-align: left;">k, k<sub>1</sub>, … k<sub>j</sub>, …</td>
<td style="text-align: left;">exact non-negative integer</td>
</tr>
<tr class="even">
<td style="text-align: left;">letters</td>
<td style="text-align: left;">alphabetic character</td>
</tr>
<tr class="odd">
<td style="text-align: left;">list, list<sub>1</sub>, … list<sub>j</sub>, …</td>
<td style="text-align: left;">list (see section <a href="#listsection">[listsection]</a>)</td>
</tr>
<tr class="even">
<td style="text-align: left;">n, n<sub>1</sub>, … n<sub>j</sub>, …</td>
<td style="text-align: left;">integer</td>
</tr>
<tr class="odd">
<td style="text-align: left;">obj</td>
<td style="text-align: left;">any object</td>
</tr>
<tr class="even">
<td style="text-align: left;">pair</td>
<td style="text-align: left;">pair</td>
</tr>
<tr class="odd">
<td style="text-align: left;">port</td>
<td style="text-align: left;">port</td>
</tr>
<tr class="even">
<td style="text-align: left;">proc</td>
<td style="text-align: left;">procedure</td>
</tr>
<tr class="odd">
<td style="text-align: left;">q, q<sub>1</sub>, … q<sub>j</sub>, …</td>
<td style="text-align: left;">rational number</td>
</tr>
<tr class="even">
<td style="text-align: left;">start</td>
<td style="text-align: left;">exact non-negative integer</td>
</tr>
<tr class="odd">
<td style="text-align: left;">string</td>
<td style="text-align: left;">string</td>
</tr>
<tr class="even">
<td style="text-align: left;">symbol</td>
<td style="text-align: left;">symbol</td>
</tr>
<tr class="odd">
<td style="text-align: left;">thunk</td>
<td style="text-align: left;">zero-argument procedure</td>
</tr>
<tr class="even">
<td style="text-align: left;">vector</td>
<td style="text-align: left;">vector</td>
</tr>
<tr class="odd">
<td style="text-align: left;">x, x<sub>1</sub>, … x<sub>j</sub>, …</td>
<td style="text-align: left;">real number</td>
</tr>
<tr class="even">
<td style="text-align: left;">y, y<sub>1</sub>, … y<sub>j</sub>, …</td>
<td style="text-align: left;">real number</td>
</tr>
<tr class="odd">
<td style="text-align: left;">z, z<sub>1</sub>, … z<sub>j</sub>, …</td>
<td style="text-align: left;">complex number</td>
</tr>
</tbody>
</table>
<p>The names <code>start</code> and <code>end</code> are used as indexes into strings, vectors, and bytevectors. Their use implies the following:</p>
<ul>
<li><p>It is an error if <code>start</code> is greater than <code>end</code>.</p></li>
<li><p>It is an error if <code>end</code> is greater than the length of the string, vector, or bytevector.</p></li>
<li><p>If <code>start</code> is omitted, it is assumed to be zero.</p></li>
<li><p>If <code>end</code> is omitted, it assumed to be the length of the string, vector, or bytevector.</p></li>
<li><p>The index <code>start</code> is always inclusive and the index <code>end</code> is always exclusive. As an example, consider a string. If <code>start</code> and <code>end</code> are the same, an empty substring is referred to, and if <code>start</code> is zero and <code>end</code> is the length of <code>string</code>, then the entire string is referred to.</p></li>
</ul>
<h4 id="evaluation-examples">Evaluation examples</h4>
<p>The symbol “=&gt;” used in program examples is read “evaluates to.” For example,</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a>(* <span class="dv">5</span> <span class="dv">8</span>) <span class="co">;; =&gt; 40</span></span></code></pre></div>
<p>means that the expression <code>(* 5 8)</code> evaluates to the object <code>40</code>. Or, more precisely: the expression given by the sequence of characters “<code>(* 5 8)</code>” evaluates, in an environment containing the base library, to an object that can be represented externally by the sequence of characters “<code>40</code>.” See section <a href="#externalreps">[externalreps]</a> for a discussion of external representations of objects.</p>
<h4 id="naming-conventions">Naming conventions</h4>
<p>By convention, <code>?</code> is the final character of the names of procedures that always return a boolean value. Such procedures are called <em>predicates</em>. Predicates are generally understood to be side-effect free, except that they may raise an exception when passed the wrong type of argument.</p>
<p>Similarly, <code>!</code> is the final character of the names of procedures that store values into previously allocated locations (see section <a href="#storagemodel">[storagemodel]</a>). Such procedures are called <em>mutation procedures</em>. The value returned by a mutation procedure is unspecified.</p>
<p>By convention, “<code>-&gt;</code>” appears within the names of procedures that take an object of one type and return an analogous object of another type. For example, list-&gt;vector takes a list and returns a vector whose elements are the same as those of the list.</p>
<p>A <em>command</em> is a procedure that does not return useful values to its continuation.</p>
<p>A <em>thunk</em> is a procedure that does not accept arguments.</p>
<h2 id="lexical-conventions">Lexical conventions</h2>
<p>This section gives an informal account of some of the lexical conventions used in writing Scheme programs. For a formal syntax of Scheme, see section <a href="#BNF">[BNF]</a>.</p>
<h3 id="identifiers">Identifiers</h3>
<p>An identifier is any sequence of letters, digits, and “extended identifier characters” provided that it does not have a prefix which is a valid number. However, the <code>.</code> token (a single period) used in the list syntax is not an identifier.</p>
<p>All implementations of Scheme must support the following extended identifier characters:</p>
<pre><code>!\ \$ \% &amp; * + - . / :\ &lt; = &gt; ? @ ^ _ ~ %</code></pre>
<p>Alternatively, an identifier can be represented by a sequence of zero or more characters enclosed within vertical lines (|), analogous to string literals. Any character, including whitespace characters, but excluding the backslash and vertical line characters, can appear verbatim in such an identifier. In addition, characters can be specified using either an inline hex escape or the same escapes available in strings.</p>
<p>For example, the identifier <code>|H\x65;llo|</code> is the same identifier as <code>Hello</code>, and in an implementation that supports the appropriate Unicode character the identifier <code>|\x3BB;|</code> is the same as the identifier <code>λ</code>. What is more, <code>|\t\t|</code> and <code>|\x9;\x9;|</code> are the same. Note that <code>||</code> is a valid identifier that is different from any other identifier.</p>
<p>Here are some examples of identifiers:</p>
<pre><code>...                      {+}
+soup+                   &lt;=?
-&gt;string                 a34kTMNs
lambda                   list-&gt;vector
q                        V17a
|two words|              |two\x20;words|
the-word-recursion-has-many-meanings</code></pre>
<p>See section <a href="#extendedalphas">[extendedalphas]</a> for the formal syntax of identifiers.</p>
<p>Identifiers have two uses within Scheme programs:</p>
<ul>
<li><p>Any identifier can be used as a variable or as a syntactic keyword (see sections <a href="#variablesection">[variablesection]</a> and <a href="#macrosection">[macrosection]</a>).</p></li>
<li><p>When an identifier appears as a literal or within a literal (see section <a href="#quote">[quote]</a>), it is being used to denote a <em>symbol</em> (see section <a href="#symbolsection">[symbolsection]</a>).</p></li>
</ul>
<p>In contrast with earlier revisions of the report <span class="citation" data-cites="R5RS"></span>, the syntax distinguishes between upper and lower case in identifiers and in characters specified using their names. However, it does not distinguish between upper and lower case in numbers, nor in inline hex escapes used in the syntax of identifiers, characters, or strings. None of the identifiers defined in this report contain upper-case characters, even when they appear to do so as a result of the English-language convention of capitalizing the first word of a sentence.</p>
<p>The following directives give explicit control over case folding.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a><span class="co">#!fold-case</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true"></a><span class="co">#!no-fold-case</span></span></code></pre></div>
<p>These directives can appear anywhere comments are permitted (see section <a href="#wscommentsection">[wscommentsection]</a>) but must be followed by a delimiter. They are treated as comments, except that they affect the reading of subsequent data from the same port. The #!fold-case directive causes subsequent identifiers and character names to be case-folded as if by string-foldcase (see section <a href="#stringsection">[stringsection]</a>). It has no effect on character literals. The #!no-fold-case directive causes a return to the default, non-folding behavior.</p>
<h3 id="whitespace-and-comments">Whitespace and comments</h3>
<p><em>Whitespace</em> characters include the space, tab, and newline characters. (Implementations may provide additional whitespace characters such as page break.) Whitespace is used for improved readability and as necessary to separate tokens from each other, a token being an indivisible lexical unit such as an identifier or number, but is otherwise insignificant. Whitespace can occur between any two tokens, but not within a token. Whitespace occurring inside a string or inside a symbol delimited by vertical lines is significant.</p>
<p>The lexical syntax includes several comment forms. Comments are treated exactly like whitespace.</p>
<p>A semicolon (<code>;</code>) indicates the start of a line comment. The comment continues to the end of the line on which the semicolon appears.</p>
<p>Another way to indicate a comment is to prefix a datum (cf. section <a href="#datumsyntax">[datumsyntax]</a>) with <code>#;</code> and optional whitespace. The comment consists of the comment prefix <code>#;</code>, the space, and the datum together. This notation is useful for “commenting out” sections of code.</p>
<p>Block comments are indicated with properly nested <code>#|</code> and <code>|#</code> pairs.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true"></a>#|</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true"></a>The FACT procedure computes the factorial</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true"></a>of a non-negative integer.</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true"></a>|#</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> fact</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true"></a>  (<span class="kw">lambda</span> (n)</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true"></a>    (<span class="kw">if</span> (<span class="op">=</span> n <span class="dv">0</span>)</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true"></a>        #<span class="co">;(= n 1)</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true"></a>        <span class="dv">1</span>        <span class="co">;Base case: return 1</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true"></a>        (* n (fact (<span class="op">-</span> n <span class="dv">1</span>))))))</span></code></pre></div>
<h3 id="other-notations">Other notations</h3>
<p>For a description of the notations used for numbers, see section <a href="#numbersection">[numbersection]</a>.</p>
<ul>
<li><p><code>. + -</code> These are used in numbers, and can also occur anywhere in an identifier. A delimited plus or minus sign by itself is also an identifier. A delimited period (not occurring within a number or identifier) is used in the notation for pairs (section <a href="#listsection">[listsection]</a>), and to indicate a rest-parameter in a formal parameter list (section <a href="#lambda">[lambda]</a>). Note that a sequence of two or more periods <em>is</em> an identifier.</p></li>
<li><p><code>( )</code> Parentheses are used for grouping and to notate lists (section <a href="#listsection">[listsection]</a>).</p></li>
<li><p><code>'</code> The apostrophe (single quote) character is used to indicate literal data (section <a href="#quote">[quote]</a>).</p></li>
<li><p>` The grave accent (backquote) character is used to indicate partly constant data (section <a href="#quasiquote">[quasiquote]</a>).</p></li>
<li><p><code>, ,@</code> The character comma and the sequence comma at-sign are used in conjunction with quasiquotation (section <a href="#quasiquote">[quasiquote]</a>).</p></li>
<li><p><code>"</code> The quotation mark character is used to delimit strings (section <a href="#stringsection">[stringsection]</a>).</p></li>
<li><p><code>\</code> Backslash is used in the syntax for character constants (section <a href="#charactersection">[charactersection]</a>) and as an escape character within string constants (section <a href="#stringsection">[stringsection]</a>) and identifiers (section <a href="#extendedalphas">[extendedalphas]</a>).</p></li>
<li><p><code>[ ] { }</code> Left and right square and curly brackets (braces) are reserved for possible future extensions to the language.</p></li>
<li><p><code>#</code> The number sign is used for a variety of purposes depending on the character that immediately follows it:</p></li>
<li><p><code>#t</code> <code>#f</code> These are the boolean constants (section <a href="#booleansection">[booleansection]</a>), along with the alternatives <code>#true</code> and <code>#false</code>.</p></li>
<li><p><code>#\</code> This introduces a character constant (section <a href="#charactersection">[charactersection]</a>).</p></li>
<li><p><code>#(</code> This introduces a vector constant (section <a href="#vectorsection">[vectorsection]</a>). Vector constants are terminated by <code>)</code> .</p></li>
<li><p><code>#u8(</code> This introduces a bytevector constant (section <a href="#bytevectorsection">[bytevectorsection]</a>). Bytevector constants are terminated by <code>)</code> .</p></li>
<li><p><code>#e #i #b #o #d #x</code> These are used in the notation for numbers (section <a href="#numbernotations">[numbernotations]</a>).</p></li>
<li><p><code>#n= #n#</code> These are used for labeling and referencing other literal data (section <a href="#labelsection">[labelsection]</a>).</p></li>
</ul>
<h3 id="datum-labels">Datum labels</h3>
<blockquote>
<p><code>#n=datum</code> <em>lexicalsyntax</em></p>
</blockquote>
<blockquote>
<p><code>#n#</code> <em>lexical syntax</em></p>
</blockquote>
<p>The lexical syntax <code>#n=datum</code> reads the same as datum, but also results in datum being labelled by <code>n</code>. It is an error if <code>n</code> is not a sequence of digits.</p>
<p>The lexical syntax <code>#n#</code> serves as a reference to some object labelled by <code>#n=</code>; the result is the same object as the <code>#n=</code> (see section <a href="#equivalencesection">[equivalencesection]</a>).</p>
<p>Together, these syntaxes permit the notation of structures with shared or circular substructure.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true"></a>(<span class="kw">let</span> ((x (<span class="kw">list</span> &#39;a &#39;b &#39;c)))</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true"></a>  (<span class="kw">set-cdr!</span> (<span class="kw">cddr</span> x) x)</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true"></a>  x) <span class="co">;; =&gt; #0=(a b c . #0#)</span></span></code></pre></div>
<p>The scope of a datum label is the portion of the outermost datum in which it appears that is to the right of the label. Consequently, a reference #n# can occur only after a label #n=; it is an error to attempt a forward reference. In addition, it is an error if the reference appears as the labelled object itself (as in #n= #n#), because the object labelled by #n= is not well defined in this case.</p>
<p>It is an error for a program or library to include circular references except in literals. In particular, it is an error for quasiquote (section <a href="#quasiquote">[quasiquote]</a>) to contain them.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true"></a>#<span class="dv">1</span>=(<span class="kw">begin</span> (<span class="kw">display</span> <span class="ch">#\x</span>) #<span class="dv">1</span>#)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true"></a><span class="co">;; =&gt; error</span></span></code></pre></div>
<h2 id="basic-concepts">Basic concepts</h2>
<h3 id="variables-syntactic-keywords-and-regions">Variables, syntactic keywords, and regions</h3>
<p>An identifier can name either a type of syntax or a location where a value can be stored. An identifier that names a type of syntax is called a <em>syntactic keyword</em> and is said to be <em>bound</em> to a transformer for that syntax. An identifier that names a location is called a <em>variable</em> and is said to be <em>bound</em> to that location. The set of all visible bindings in effect at some point in a program is known as the <em>environment</em> in effect at that point. The value stored in the location to which a variable is bound is called the variable’s value. By abuse of terminology, the variable is sometimes said to name the value or to be bound to the value. This is not quite accurate, but confusion rarely results from this practice.</p>
<p>Certain expression types are used to create new kinds of syntax and to bind syntactic keywords to those new syntaxes, while other expression types create new locations and bind variables to those locations. These expression types are called <em>binding constructs</em>.</p>
<p>Those that bind syntactic keywords are listed in section <a href="#macrosection">[macrosection]</a>. The most fundamental of the variable binding constructs is the lambda expression, because all other variable binding constructs (except top-level bindings) can be explained in terms of lambda expressions. The other variable binding constructs are let, let*, letrec, letrec*, let-values, let*-values, and do expressions (see sections <a href="#lambda">[lambda]</a>, <a href="#letrec">[letrec]</a>, and <a href="#do">[do]</a>).</p>
<p>Scheme is a language with block structure. To each place where an identifier is bound in a program there corresponds a <em>region</em> of the program text within which the binding is visible. The region is determined by the particular binding construct that establishes the binding; if the binding is established by a lambda expression, for example, then its region is the entire lambda expression. Every mention of an identifier refers to the binding of the identifier that established the innermost of the regions containing the use. If there is no binding of the identifier whose region contains the use, then the use refers to the binding for the variable in the global environment, if any (chapters <a href="#expressionchapter">[expressionchapter]</a> and <a href="#initialenv">[initialenv]</a>); if there is no binding for the identifier, it is said to be <em>unbound</em>.</p>
<h3 id="disjointness-of-types">Disjointness of types</h3>
<p>No object satisfies more than one of the following predicates:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a><span class="kw">boolean?</span>          bytevector?</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true"></a><span class="kw">char?</span>             <span class="kw">eof-object?</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true"></a><span class="kw">null?</span>             <span class="kw">number?</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true"></a><span class="kw">pair?</span>             <span class="kw">port?</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true"></a><span class="kw">procedure?</span>        <span class="kw">string?</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true"></a><span class="kw">symbol?</span>           <span class="kw">vector?</span></span></code></pre></div>
<p>and all predicates created by define-record-type.</p>
<p>These predicates define the types <em>boolean, bytevector, character</em>, the empty list object, <em>eof-object, number, pair, port, procedure, string, symbol, vector</em>, and all record types.</p>
<p>Although there is a separate boolean type, any Scheme value can be used as a boolean value for the purpose of a conditional test. As explained in section <a href="#booleansection">[booleansection]</a>, all values count as true in such a test except for #f. This report uses the word “true” to refer to any Scheme value except #f, and the word “false” to refer to #f.</p>
<h3 id="external-representations">External representations</h3>
<p>An important concept in Scheme (and Lisp) is that of the <em>external representation</em> of an object as a sequence of characters. For example, an external representation of the integer 28 is the sequence of characters “<code>28</code>”, and an external representation of a list consisting of the integers 8 and 13 is the sequence of characters “<code>(8 13)</code>”.</p>
<p>The external representation of an object is not necessarily unique. The integer 28 also has representations “<code>#e28.000</code>” and “<code>#x1c</code>”, and the list in the previous paragraph also has the representations “<code>( 08 13 )</code>” and “<code>(8 . (13 . ()))</code>” (see section <a href="#listsection">[listsection]</a>).</p>
<p>Many objects have standard external representations, but some, such as procedures, do not have standard representations (although particular implementations may define representations for them).</p>
<p>An external representation can be written in a program to obtain the corresponding object (see quote, section <a href="#quote">[quote]</a>).</p>
<p>External representations can also be used for input and output. The procedure read (section <a href="#read">[read]</a>) parses external representations, and the procedure write (section <a href="#write">[write]</a>) generates them. Together, they provide an elegant and powerful input/output facility.</p>
<p>Note that the sequence of characters “<code>(+ 2 6)</code>” is <em>not</em> an external representation of the integer 8, even though it <em>is</em> an expression evaluating to the integer 8; rather, it is an external representation of a three-element list, the elements of which are the symbol <code>+</code> and the integers 2 and 6. Scheme’s syntax has the property that any sequence of characters that is an expression is also the external representation of some object. This can lead to confusion, since it is not always obvious out of context whether a given sequence of characters is intended to denote data or program, but it is also a source of power, since it facilitates writing programs such as interpreters and compilers that treat programs as data (or vice versa).</p>
<p>The syntax of external representations of various kinds of objects accompanies the description of the primitives for manipulating the objects in the appropriate sections of chapter <a href="#initialenv">[initialenv]</a>.</p>
<h3 id="storage-model">Storage model</h3>
<p>Variables and objects such as pairs, strings, vectors, and bytevectors implicitly denote locations or sequences of locations. A string, for example, denotes as many locations as there are characters in the string. A new value can be stored into one of these locations using the <code>string-set!</code> procedure, but the string continues to denote the same locations as before.</p>
<p>An object fetched from a location, by a variable reference or by a procedure such as car, vector-ref, or string-ref, is equivalent in the sense of <code>eqv?</code> (section <a href="#equivalencesection">[equivalencesection]</a>) to the object last stored in the location before the fetch.</p>
<p>Every location is marked to show whether it is in use. No variable or object ever refers to a location that is not in use.</p>
<p>Whenever this report speaks of storage being newly allocated for a variable or object, what is meant is that an appropriate number of locations are chosen from the set of locations that are not in use, and the chosen locations are marked to indicate that they are now in use before the variable or object is made to denote them. Notwithstanding this, it is understood that the empty list cannot be newly allocated, because it is a unique object. It is also understood that empty strings, empty vectors, and empty bytevectors, which contain no locations, may or may not be newly allocated.</p>
<p>Every object that denotes locations is either mutable or immutable. Literal constants, the strings returned by <code>symbol-&gt;string</code>, and possibly the environment returned by scheme-report-environment are immutable objects. All objects created by the other procedures listed in this report are mutable. It is an error to attempt to store a new value into a location that is denoted by an immutable object.</p>
<p>These locations are to be understood as conceptual, not physical. Hence, they do not necessarily correspond to memory addresses, and even if they do, the memory address might not be constant.</p>
<p><em>Rationale:</em> In many systems it is desirable for constants (i.e. the values of literal expressions) to reside in read-only memory. Making it an error to alter constants permits this implementation strategy, while not requiring other systems to distinguish between mutable and immutable objects.</p>
<h3 id="proper-tail-recursion">Proper tail recursion</h3>
<p>Implementations of Scheme are required to be <em>properly tail-recursive</em>. Procedure calls that occur in certain syntactic contexts defined below are <em>tail calls</em>. A Scheme implementation is properly tail-recursive if it supports an unbounded number of active tail calls. A call is <em>active</em> if the called procedure might still return. Note that this includes calls that might be returned from either by the current continuation or by continuations captured earlier by call-with-current-continuation that are later invoked. In the absence of captured continuations, calls could return at most once and the active calls would be those that had not yet returned. A formal definition of proper tail recursion can be found in <span class="citation" data-cites="propertailrecursion"></span>.</p>
<p><em>Rationale:</em></p>
<p>Intuitively, no space is needed for an active tail call because the continuation that is used in the tail call has the same semantics as the continuation passed to the procedure containing the call. Although an improper implementation might use a new continuation in the call, a return to this new continuation would be followed immediately by a return to the continuation passed to the procedure. A properly tail-recursive implementation returns to that continuation directly.</p>
<p>Proper tail recursion was one of the central ideas in Steele and Sussman’s original version of Scheme. Their first Scheme interpreter implemented both functions and actors. Control flow was expressed using actors, which differed from functions in that they passed their results on to another actor instead of returning to a caller. In the terminology of this section, each actor finished with a tail call to another actor.</p>
<p>Steele and Sussman later observed that in their interpreter the code for dealing with actors was identical to that for functions and thus there was no need to include both in the language.</p>
<p>A <em>tail call</em> is a procedure call that occurs in a <em>tail context</em>. Tail contexts are defined inductively. Note that a tail context is always determined with respect to a particular lambda expression.</p>
<ul>
<li><p>The last expression within the body of a lambda expression, shown as tail expression below, occurs in a tail context. The same is true of all the bodies of case-lambda expressions. ̄ | ̄ (lāmbda formals expression tail expression)</p>
<p>(case-lambda (formals tail body))</p></li>
<li><p>If one of the following expressions is in a tail context, then the subexpressions shown as tail expression are in a tail context. These were derived from rules in the grammar given in chapter <a href="#formalchapter">[formalchapter]</a> by replacing some occurrences of body with tail body, some occurrences of expression with tail expression, and some occurrences of sequence with tail sequence. Only those rules that contain tail contexts are shown here.</p>
<p>```scheme (if expression tail expression tail expression)</p>
<p>(if expression tail expression)</p>
<p>(cond cond_clause …)</p>
<p>(cond cond clause … (else tail sequence))</p>
<p>(case expression …)</p>
<p>(case expression (else tail sequence))</p>
<p>(and expression tail expression)</p>
<p>(or expression tail expression)</p>
<p>(when test tail sequence)</p>
<p>(unless test tail sequence)</p>
<p>(let (binding spec) tail body)</p>
<p>(let variable (binding spec) tail body)</p>
<p>(let* (binding spec) tail body)</p>
<p>(letrec (binding spec) tail body)</p>
<p>(letrec* (binding spec) tail body)</p>
<p>(let-values (mv binding spec) tail body)</p>
<p>(let*-values (mv binding spec) tail body)</p>
<p>(let-syntax (syntax spec) tail body)</p>
<p>(letrec-syntax (syntax spec) tail body)</p>
<p>(begin tail sequence)</p>
<p>(do (̄iteration spec) (test tail sequence) )</p></li>
</ul>
<p>where</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a>cond clause ⟶  (test tail sequence)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true"></a>case clause ⟶  ((datum) tail sequence)</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true"></a>tail body ⟶  definition tail sequence</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true"></a>tail sequence ⟶  expression tail expression</span></code></pre></div>
<ul>
<li>If a cond or case expression is in a tail context, and has a clause of the form (expression<sub>1</sub> =&gt; expression<sub>2</sub>) then the (implied) call to the procedure that results from the evaluation of expression<sub>2</sub> is in a tail context. expression<sub>2</sub> itself is not in a tail context.</li>
</ul>
<p>Certain procedures defined in this report are also required to perform tail calls. The first argument passed to <code>apply</code> and to <code>call-with-current-continuation</code>, and the second argument passed to <code>call-with-values</code>, must be called via a tail call. Similarly, <code>eval</code> must evaluate its first argument as if it were in tail position within the <code>eval</code> procedure.</p>
<p>In the following example the only tail call is the call to f. None of the calls to g or h are tail calls. The reference to x is in a tail context, but it is not a call and thus is not a tail call.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a>(<span class="kw">lambda</span> ()</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true"></a>  (<span class="kw">if</span> (g)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true"></a>      (<span class="kw">let</span> ((x (h)))</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true"></a>        x)</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true"></a>      (<span class="kw">and</span> (g) (f))))</span></code></pre></div>
<p><em>Note:</em> Implementations may recognize that some non-tail calls, such as the call to h above, can be evaluated as though they were tail calls. In the example above, the let expression could be compiled as a tail call to h. (The possibility of h returning an unexpected number of values can be ignored, because in that case the effect of the let is explicitly unspecified and implementation-dependent.)</p>
<h2 id="expressions">Expressions</h2>
<p>Expression types are categorized as <em>primitive</em> or <em>derived</em>. Primitive expression types include variables and procedure calls. Derived expression types are not semantically primitive, but can instead be defined as macros. Suitable syntax definitions of some of the derived expressions are given in section <a href="#derivedsection">[derivedsection]</a>.</p>
<p>The procedures force, promise?, make-promise, and make-parameter are also described in this chapter because they are intimately associated with the delay, delay-force, and parameterize expression types.</p>
<h3 id="primitive-expression-types">Primitive expression types</h3>
<h4 id="variable-references">Variable references</h4>
<p>variable  syntax An expression consisting of a variable (section <a href="#variablesection">[variablesection]</a>) is a variable reference. The value of the variable reference is the value stored in the location to which the variable is bound. It is an error to reference an unbound variable.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> x </span><span class="dv">28</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true"></a>x <span class="co">;; =&gt; 28</span></span></code></pre></div>
<h4 id="literal-expressions">Literal expressions</h4>
<p>(quote <em>datum</em>)  syntax <code>’</code>datum  syntax constant  syntax (quote datum) evaluates to datum. Datum can be any external representation of a Scheme object (see section <a href="#externalreps">[externalreps]</a>). This notation is used to include literal constants in Scheme code.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true"></a>(quote a) <span class="co">;; =&gt; a</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true"></a>(quote #(a b c)) <span class="co">;; =&gt; #(a b c)</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true"></a>(quote (<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">;; =&gt; (+ 1 2)</span></span></code></pre></div>
<p>(quote datum) can be abbreviated as <code>’</code>datum. The two notations are equivalent in all respects.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true"></a>&#39;a <span class="co">;; =&gt; a</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true"></a>&#39;#(a b c) <span class="co">;; =&gt; #(a b c)</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true"></a>&#39;() <span class="co">;; =&gt; ()</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true"></a>&#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="co">;; =&gt; (+ 1 2)</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true"></a>&#39;(quote a) <span class="co">;; =&gt; (quote a)</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true"></a>&#39;&#39;a <span class="co">;; =&gt; (quote a)</span></span></code></pre></div>
<p>Numerical constants, string constants, character constants, vector constants, bytevector constants, and boolean constants evaluate to themselves; they need not be quoted.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true"></a>&#39;<span class="dv">145932</span> <span class="co">;; =&gt; 145932</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true"></a><span class="dv">145932</span> <span class="co">;; =&gt; 145932</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true"></a>&#39;<span class="st">&quot;abc&quot;</span> <span class="co">;; =&gt; &quot;abc&quot;</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true"></a><span class="st">&quot;abc&quot;</span> <span class="co">;; =&gt; &quot;abc&quot;</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true"></a>&#39;<span class="ch">#\a</span> <span class="co">;; =&gt; #\a</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true"></a><span class="ch">#\a</span> <span class="co">;; =&gt; #\a</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true"></a>&#39;#(a <span class="dv">10</span>) <span class="co">;; =&gt; #(a 10)</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true"></a>#(a <span class="dv">10</span>) <span class="co">;; =&gt; #(a 10)</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true"></a>&#39;#u8(<span class="dv">64</span> <span class="dv">65</span>) <span class="co">;; =&gt; #u8(64 65)</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true"></a>#u8(<span class="dv">64</span> <span class="dv">65</span>) <span class="co">;; =&gt; #u8(64 65)</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true"></a>&#39;<span class="dv">#t</span> <span class="co">;; =&gt; #t</span></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true"></a><span class="dv">#t</span> <span class="co">;; =&gt; #t</span></span></code></pre></div>
<p>As noted in section <a href="#storagemodel">[storagemodel]</a>, it is an error to attempt to alter a constant (i.e. the value of a literal expression) using a mutation procedure like set-car! or string-set!.</p>
<h4 id="procedure-calls">Procedure calls</h4>
<p>(operator operand<sub>1</sub> … )  syntax A procedure call is written by enclosing in parentheses an expression for the procedure to be called followed by expressions for the arguments to be passed to it. The operator and operand expressions are evaluated (in an unspecified order) and the resulting procedure is passed the resulting arguments.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true"></a>(<span class="op">+</span> <span class="dv">3</span> <span class="dv">4</span>) <span class="co">;; =&gt; 7</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true"></a>((<span class="kw">if</span> <span class="dv">#f</span> <span class="op">+</span> *) <span class="dv">3</span> <span class="dv">4</span>) <span class="co">;; =&gt; 12</span></span></code></pre></div>
<p>The procedures in this document are available as the values of variables exported by the standard libraries. For example, the addition and multiplication procedures in the above examples are the values of the variables + and * in the base library. New procedures are created by evaluating lambda expressions (see section <a href="#lambda">[lambda]</a>).</p>
<p>Procedure calls can return any number of values (see <code>values</code> in section <a href="#proceduresection">[proceduresection]</a>). Most of the procedures defined in this report return one value or, for procedures such as apply, pass on the values returned by a call to one of their arguments. Exceptions are noted in the individual descriptions.</p>
<p><em>Note:</em> In contrast to other dialects of Lisp, the order of evaluation is unspecified, and the operator expression and the operand expressions are always evaluated with the same evaluation rules.</p>
<p><em>Note:</em> Although the order of evaluation is otherwise unspecified, the effect of any concurrent evaluation of the operator and operand expressions is constrained to be consistent with some sequential order of evaluation. The order of evaluation may be chosen differently for each procedure call.</p>
<p><em>Note:</em> In many dialects of Lisp, the empty list, <code>()</code>, is a legitimate expression evaluating to itself. In Scheme, it is an error.</p>
<h4 id="procedures">Procedures</h4>
<p>(lambda <em>formals body</em>)  syntax <em>Syntax:</em> Formals is a formal arguments list as described below, and body is a sequence of zero or more definitions followed by one or more expressions.</p>
<p><em>Semantics:</em> A lambda expression evaluates to a procedure. The environment in effect when the lambda expression was evaluated is remembered as part of the procedure. When the procedure is later called with some actual arguments, the environment in which the lambda expression was evaluated will be extended by binding the variables in the formal argument list to fresh locations, and the corresponding actual argument values will be stored in those locations. (A <em>fresh</em> location is one that is distinct from every previously existing location.) Next, the expressions in the body of the lambda expression (which, if it contains definitions, represents a letrec* form — see section <a href="#letrecstar">[letrecstar]</a>) will be evaluated sequentially in the extended environment. The results of the last expression in the body will be returned as the results of the procedure call.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true"></a>(<span class="kw">lambda</span> (x) (<span class="op">+</span> x x)) <span class="co">;; =&gt; a procedure</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true"></a>((<span class="kw">lambda</span> (x) (<span class="op">+</span> x x)) <span class="dv">4</span>) <span class="co">;; =&gt; 8</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> reverse-subtract</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true"></a>  (<span class="kw">lambda</span> (x y) (<span class="op">-</span> y x)))</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true"></a>(reverse-subtract <span class="dv">7</span> <span class="dv">10</span>) <span class="co">;; =&gt; 3</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true"></a></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> add4</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true"></a>  (<span class="kw">let</span> ((x <span class="dv">4</span>))</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true"></a>    (<span class="kw">lambda</span> (y) (<span class="op">+</span> x y))))</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true"></a>(add4 <span class="dv">6</span>) <span class="co">;; =&gt; 10</span></span></code></pre></div>
<p>Formals have one of the following forms:</p>
<ul>
<li><p><code>(variable_1 ...)</code>: The procedure takes a fixed number of arguments; when the procedure is called, the arguments will be stored in fresh locations that are bound to the corresponding variables.</p></li>
<li><p>variable: The procedure takes any number of arguments; when the procedure is called, the sequence of actual arguments is converted into a newly allocated list, and the list is stored in a fresh location that is bound to variable.</p></li>
<li><p><code>(variable_1 ... variable_{n} . variable_{n+1})</code>: If a space-delimited period precedes the last variable, then the procedure takes <em>n</em> or more arguments, where <em>n</em> is the number of formal arguments before the period (it is an error if there is not at least one). The value stored in the binding of the last variable will be a newly allocated list of the actual arguments left over after all the other actual arguments have been matched up against the other formal arguments.</p></li>
</ul>
<p>It is an error for a variable to appear more than once in formals.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true"></a>((<span class="kw">lambda</span> x x) <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>) <span class="co">;; =&gt; (3 4 5 6)</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true"></a>((<span class="kw">lambda</span> (x y . z) z) <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>) <span class="co">;; =&gt; (5 6)</span></span></code></pre></div>
<p>Each procedure created as the result of evaluating a lambda expression is (conceptually) tagged with a storage location, in order to make <code>eqv?</code> and <code>eq?</code> work on procedures (see section <a href="#equivalencesection">[equivalencesection]</a>).</p>
<h4 id="conditionals">Conditionals</h4>
<blockquote>
<p><code>(if test consequent alternate)</code> <em>syntax</em></p>
</blockquote>
<blockquote>
<p><code>(if test consequent)</code> <em>syntax</em></p>
</blockquote>
<p><em>Syntax:</em> Test, consequent, and alternate are expressions.</p>
<p><em>Semantics:</em> An if expression is evaluated as follows: first, <code>test</code> is evaluated. If it yields a true value (see section <a href="#booleansection">[booleansection]</a>), then <code>consequent</code> is evaluated and its values are returned. Otherwise <code>alternate</code> is evaluated and its values are returned. If test yields a false value and no alternate is specified, then the result of the expression is unspecified.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true"></a>(<span class="kw">if</span> (<span class="op">&gt;</span> <span class="dv">3</span> <span class="dv">2</span>) &#39;yes &#39;no) <span class="co">;; =&gt; yes</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true"></a>(<span class="kw">if</span> (<span class="op">&gt;</span> <span class="dv">2</span> <span class="dv">3</span>) &#39;yes &#39;no) <span class="co">;; =&gt; no</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true"></a>(<span class="kw">if</span> (<span class="op">&gt;</span> <span class="dv">3</span> <span class="dv">2</span>)</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true"></a>    (<span class="op">-</span> <span class="dv">3</span> <span class="dv">2</span>)</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true"></a>    (<span class="op">+</span> <span class="dv">3</span> <span class="dv">2</span>)) <span class="co">;; =&gt; 1</span></span></code></pre></div>
<h4 id="assignments">Assignments</h4>
<blockquote>
<p><code>(set! variable expression)</code> <em>syntax</em></p>
</blockquote>
<p><em>Semantics:</em> Expression is evaluated, and the resulting value is stored in the location to which variable is bound. It is an error if variable is not bound either in some region enclosing the set! expression or else globally. The result of the set! expression is unspecified.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> x </span><span class="dv">2</span>)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true"></a>(<span class="op">+</span> x <span class="dv">1</span>) <span class="co">;; =&gt; 3</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true"></a>(set! x <span class="dv">4</span>) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true"></a>(<span class="op">+</span> x <span class="dv">1</span>) <span class="co">;; =&gt; 5</span></span></code></pre></div>
<h4 id="inclusion">Inclusion</h4>
<blockquote>
<p><code>(include string ...)</code> <em>syntax</em></p>
</blockquote>
<blockquote>
<p><code>(include-ci sitring ... *)</code> <em>syntax</em></p>
</blockquote>
<p><em>Semantics:</em> Both <code>include</code> and <code>include-ci</code> take one or more filenames expressed as string literals, apply an implementation-specific algorithm to find corresponding files, read the contents of the files in the specified order as if by repeated applications of read, and effectively replace the include or include-ci expression with a begin expression containing what was read from the files. The difference between the two is that <code>include-ci</code> reads each file as if it began with the #!fold-case directive, while <code>include</code> does not.</p>
<p><em>Note:</em> Implementations are encouraged to search for files in the directory which contains the including file, and to provide a way for users to specify other directories to search.</p>
<h3 id="derived-expression-types">Derived expression types</h3>
<p>The constructs in this section are hygienic, as discussed in section <a href="#macrosection">[macrosection]</a>. For reference purposes, section <a href="#derivedsection">[derivedsection]</a> gives syntax definitions that will convert most of the constructs described in this section into the primitive constructs described in the previous section.</p>
<h4 id="conditionals-1">Conditionals</h4>
<blockquote>
<p><code>(cond clause ... )</code> <em>syntax</em></p>
</blockquote>
<blockquote>
<p><code>else</code> <em>auxiliary syntax</em></p>
</blockquote>
<blockquote>
<p><code>=&gt;</code> <em>auxiliary syntax</em></p>
</blockquote>
<p><em>Syntax:</em> Clauses take one of two forms, either</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true"></a>(&lt;test&gt; &lt;expression&gt; ...)</span></code></pre></div>
<p>where test is any expression, or</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true"></a>(&lt;test&gt; <span class="op">=&gt;</span> &lt;expression&gt;)</span></code></pre></div>
<p>The last clause can be an “else clause,” which has the form</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true"></a>(<span class="kw">else</span> &lt;expression&gt; &lt;expression&gt; ...)</span></code></pre></div>
<p><em>Semantics:</em> A cond expression is evaluated by evaluating the test expressions of successive clauses in order until one of them evaluates to a true value (see section <a href="#booleansection">[booleansection]</a>). When a test evaluates to a true value, the remaining expressions in its clause are evaluated in order, and the results of the last expression in the clause are returned as the results of the entire cond expression.</p>
<p>If the selected clause contains only the test and no expressions, then the value of the test is returned as the result. If the selected clause uses the <code>=&gt;</code> alternate form, then the expression is evaluated. It is an error if its value is not a procedure that accepts one argument. This procedure is then called on the value of the test and the values returned by this procedure are returned by the cond expression.</p>
<p>If all tests evaluate to #f, and there is no else clause, then the result of the conditional expression is unspecified; if there is an else clause, then its expressions are evaluated in order, and the values of the last one are returned.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true"></a>(<span class="kw">cond</span> ((<span class="op">&gt;</span> <span class="dv">3</span> <span class="dv">2</span>) &#39;greater)</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true"></a>      ((<span class="op">&lt;</span> <span class="dv">3</span> <span class="dv">2</span>) &#39;less)) <span class="co">;; =&gt; greater</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true"></a></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true"></a>(<span class="kw">cond</span> ((<span class="op">&gt;</span> <span class="dv">3</span> <span class="dv">3</span>) &#39;greater)</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true"></a>      ((<span class="op">&lt;</span> <span class="dv">3</span> <span class="dv">3</span>) &#39;less)</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true"></a>      (<span class="kw">else</span> &#39;equal)) <span class="co">;; =&gt; equal</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true"></a></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true"></a>(<span class="kw">cond</span> ((<span class="kw">assv</span> &#39;b &#39;((a <span class="dv">1</span>) (b <span class="dv">2</span>))) <span class="op">=&gt;</span> <span class="kw">cadr</span>)</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true"></a>      (<span class="kw">else</span> <span class="dv">#f</span>)) <span class="co">;; =&gt; 2</span></span></code></pre></div>
<blockquote>
<p><code>(case key clause ...)</code> <em>syntax</em></p>
</blockquote>
<p><em>Syntax:</em> Key can be any expression. Each clause has the form</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true"></a>((&lt;datum&gt; ...) &lt;expression&gt; &lt;expression&gt; ...)</span></code></pre></div>
<p>where each datum is an external representation of some object. It is an error if any of the datums are the same anywhere in the expression. Alternatively, a clause can be of the form</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true"></a>((&lt;datum&gt; ...) <span class="op">=&gt;</span> &lt;expression&gt;)</span></code></pre></div>
<p>The last clause can be an “else clause,” which has one of the forms</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true"></a>(<span class="kw">else</span> &lt;expression&gt; &lt;expression&gt; ...)</span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true"></a>(<span class="kw">else</span> <span class="op">=&gt;</span> &lt;expression&gt;)</span></code></pre></div>
<p><em>Semantics:</em> A case expression is evaluated as follows. Key is evaluated and its result is compared against each datum. If the result of evaluating key is the same (in the sense of eqv?; see section <a href="#eqv?">[eqv?]</a>) to a datum, then the expressions in the corresponding clause are evaluated in order and the results of the last expression in the clause are returned as the results of the case expression.</p>
<p>If the result of evaluating key is different from every datum, then if there is an else clause, its expressions are evaluated and the results of the last are the results of the case expression; otherwise the result of the case expression is unspecified.</p>
<p>If the selected clause or else clause uses the <code>=&gt;</code> alternate form, then the expression is evaluated. It is an error if its value is not a procedure accepting one argument. This procedure is then called on the value of the key and the values returned by this procedure are returned by the case expression.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true"></a>(<span class="kw">case</span> (* <span class="dv">2</span> <span class="dv">3</span>)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true"></a>  ((<span class="dv">2</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">7</span>) &#39;prime)</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true"></a>  ((<span class="dv">1</span> <span class="dv">4</span> <span class="dv">6</span> <span class="dv">8</span> <span class="dv">9</span>) &#39;composite)) <span class="co">;; =&gt; composite</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true"></a>(<span class="kw">case</span> (<span class="kw">car</span> &#39;(c d))</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true"></a>  ((a) &#39;a)</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true"></a>  ((b) &#39;b)) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true"></a>(<span class="kw">case</span> (<span class="kw">car</span> &#39;(c d))</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true"></a>  ((a e i o u) &#39;vowel)</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true"></a>  ((w y) &#39;semivowel)</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true"></a>  (<span class="kw">else</span> <span class="op">=&gt;</span> (<span class="kw">lambda</span> (x) x))) <span class="co">;; =&gt; c</span></span></code></pre></div>
<blockquote>
<p><code>(and test ... *)</code> syntax</p>
</blockquote>
<p><em>Semantics:</em> The test expressions are evaluated from left to right, and if any expression evaluates to <code>#f</code> (see section <a href="#booleansection">[booleansection]</a>), then <code>#f</code> is returned. Any remaining expressions are not evaluated. If all the expressions evaluate to true values, the values of the last expression are returned. If there are no expressions, then <code>#t</code> is returned.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true"></a>(<span class="kw">and</span> (<span class="op">=</span> <span class="dv">2</span> <span class="dv">2</span>) (<span class="op">&gt;</span> <span class="dv">2</span> <span class="dv">1</span>)) <span class="co">;; =&gt; #t</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true"></a>(<span class="kw">and</span> (<span class="op">=</span> <span class="dv">2</span> <span class="dv">2</span>) (<span class="op">&lt;</span> <span class="dv">2</span> <span class="dv">1</span>)) <span class="co">;; =&gt; #f</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true"></a>(<span class="kw">and</span> <span class="dv">1</span> <span class="dv">2</span> &#39;c &#39;(f g)) <span class="co">;; =&gt; (f g)</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true"></a>(<span class="kw">and</span>) <span class="co">;; =&gt; #t</span></span></code></pre></div>
<blockquote>
<p><code>(or test .... *)</code> <em>syntax</em></p>
</blockquote>
<p><em>Semantics:</em> The test expressions are evaluated from left to right, and the value of the first expression that evaluates to a true value (see section <a href="#booleansection">[booleansection]</a>) is returned. Any remaining expressions are not evaluated. If all expressions evaluate to <code>#f</code> or if there are no expressions, then <code>#f</code> is returned.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true"></a>(<span class="kw">or</span> (<span class="op">=</span> <span class="dv">2</span> <span class="dv">2</span>) (<span class="op">&gt;</span> <span class="dv">2</span> <span class="dv">1</span>)) <span class="co">;; =&gt; #t</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true"></a>(<span class="kw">or</span> (<span class="op">=</span> <span class="dv">2</span> <span class="dv">2</span>) (<span class="op">&lt;</span> <span class="dv">2</span> <span class="dv">1</span>)) <span class="co">;; =&gt; #t</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true"></a>(<span class="kw">or</span> <span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#f</span>) <span class="co">;; =&gt; #f</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true"></a>(<span class="kw">or</span> (<span class="kw">memq</span> &#39;b &#39;(a b c))</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true"></a>    (<span class="op">/</span> <span class="dv">3</span> <span class="dv">0</span>)) <span class="co">;; =&gt; (b c)</span></span></code></pre></div>
<blockquote>
<p><code>(when test expression ...)</code> syntax</p>
</blockquote>
<p><em>Syntax:</em> The test is an expression.</p>
<p><em>Semantics:</em> The test is evaluated, and if it evaluates to a true value, the expressions are evaluated in order. The result of the when expression is unspecified.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true"></a>(when (<span class="op">=</span> <span class="dv">1</span> <span class="fl">1.0</span>)</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true"></a>  (<span class="kw">display</span> <span class="st">&quot;1&quot;</span>)</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true"></a>  (<span class="kw">display</span> <span class="st">&quot;2&quot;</span>)) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true"></a><span class="co">;; and prints 12</span></span></code></pre></div>
<blockquote>
<p>`(unless test expression …) <em>syntax</em></p>
</blockquote>
<p><em>Syntax:</em> The test is an expression.</p>
<p><em>Semantics:</em> The test is evaluated, and if it evaluates to #f, the expressions are evaluated in order. The result of the unless expression is unspecified.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true"></a>(unless (<span class="op">=</span> <span class="dv">1</span> <span class="fl">1.0</span>)</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true"></a>  (<span class="kw">display</span> <span class="st">&quot;1&quot;</span>)</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true"></a>  (<span class="kw">display</span> <span class="st">&quot;2&quot;</span>)) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true"></a><span class="co">;; and prints nothing</span></span></code></pre></div>
<blockquote>
<p><code>(cond-expand ce-clause ...)</code> <em>syntax</em></p>
</blockquote>
<p><em>Syntax:</em> The <code>cond-expand</code> expression type provides a way to statically expand different expressions depending on the implementation. A <code>ce-clause</code> takes the following form:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true"></a>(feature requirement expression ...)</span></code></pre></div>
<p>The last clause can be an “else clause,” which has the form</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true"></a>(<span class="kw">else</span> expression ...)</span></code></pre></div>
<p>A feature requirement takes one of the following forms:</p>
<ul>
<li><p><code>feature identifier</code></p></li>
<li><p><code>(library library name)</code></p></li>
<li><p><code>(and feature requirement ...)</code></p></li>
<li><p><code>(or feature requirement ...)</code></p></li>
<li><p><code>(not feature requirement)</code></p></li>
</ul>
<p><em>Semantics:</em> Each implementation maintains a list of feature identifiers which are present, as well as a list of libraries which can be imported. The value of a feature requirement is determined by replacing each feature identifier and <code>(library library name)</code> on the implementation’s lists with <code>#t</code>, and all other feature identifiers and library names with #f, then evaluating the resulting expression as a Scheme boolean expression under the normal interpretation of and, or, and not.</p>
<p>A <code>cond-expand</code> is then expanded by evaluating the feature requirements of successive ce-clauses in order until one of them returns <code>#t</code>. When a true clause is found, the corresponding expressions are expanded to a begin, and the remaining clauses are ignored. If none of the feature requirements evaluate to #t, then if there is an else clause, its expressions are included. Otherwise, the behavior of the <code>cond-expand</code> is unspecified. Unlike cond, cond-expand does not depend on the value of any variables.</p>
<p>The exact features provided are implementation-defined, but for portability a core set of features is given in appendix <a href="#stdfeatures">[stdfeatures]</a>.</p>
<h4 id="binding-constructs">Binding constructs</h4>
<p>The binding constructs let, let*, letrec, letrec*, let-values, and let*-values give Scheme a block structure, like Algol 60. The syntax of the first four constructs is identical, but they differ in the regions they establish for their variable bindings. In a let expression, the initial values are computed before any of the variables become bound; in a let* expression, the bindings and evaluations are performed sequentially; while in letrec and letrec* expressions, all the bindings are in effect while their initial values are being computed, thus allowing mutually recursive definitions. The let-values and let*-values constructs are analogous to let and let* respectively, but are designed to handle multiple-valued expressions, binding different identifiers to the returned values.</p>
<blockquote>
<p><code>(let bindings body)</code> <em>syntax</em></p>
</blockquote>
<p><em>Syntax:</em> Bindings has the form</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true"></a>((&lt;variable&gt; &lt;init&gt;) ...)</span></code></pre></div>
<p>where each init is an expression, and body is a sequence of zero or more definitions followed by a sequence of one or more expressions as described in section <a href="#lambda">[lambda]</a>. It is an error for a variable to appear more than once in the list of variables being bound.</p>
<p><em>Semantics:</em> The inits are evaluated in the current environment (in some unspecified order), the variables are bound to fresh locations holding the results, the body is evaluated in the extended environment, and the values of the last expression of body are returned. Each binding of a variable has body as its region.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true"></a>(<span class="kw">let</span> ((x <span class="dv">2</span>) (y <span class="dv">3</span>))</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true"></a>  (* x y)) <span class="co">;; =&gt; 6</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true"></a></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true"></a>(<span class="kw">let</span> ((x <span class="dv">2</span>) (y <span class="dv">3</span>))</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true"></a>  (<span class="kw">let</span> ((x <span class="dv">7</span>)</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true"></a>        (z (<span class="op">+</span> x y)))</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true"></a>    (* z x))) <span class="co">;; =&gt; 35</span></span></code></pre></div>
<p>See also “named let,” section <a href="#namedlet">[namedlet]</a>.</p>
<blockquote>
<p><code>(let* bindings body)</code> syntax</p>
</blockquote>
<p><em>Syntax:</em> Bindings has the form</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true"></a>((&lt;variable&gt; &lt;init&gt;) ...)</span></code></pre></div>
<p>and body is a sequence of zero or more definitions followed by one or more expressions as described in section <a href="#lambda">[lambda]</a>.</p>
<p><em>Semantics:</em> The let* binding construct is similar to let, but the bindings are performed sequentially from left to right, and the region of a binding indicated by (variable init) is that part of the let* expression to the right of the binding. Thus the second binding is done in an environment in which the first binding is visible, and so on. The variables need not be distinct.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true"></a>(<span class="kw">let</span> ((x <span class="dv">2</span>) (y <span class="dv">3</span>))</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true"></a>  (<span class="kw">let*</span> ((x <span class="dv">7</span>)</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true"></a>         (z (<span class="op">+</span> x y)))</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true"></a>    (* z x))) <span class="co">;; =&gt; 70</span></span></code></pre></div>
<blockquote>
<p><code>(letrec bindings body)</code> <em>syntax</em></p>
</blockquote>
<p><em>Syntax:</em> Bindings has the form</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true"></a>((&lt;variable&gt; &lt;init&gt;) ...)</span></code></pre></div>
<p>and body is a sequence of zero or more definitions followed by one or more expressions as described in section <a href="#lambda">[lambda]</a>. It is an error for a variable to appear more than once in the list of variables being bound.</p>
<p><em>Semantics:</em> The variables are bound to fresh locations holding unspecified values, the inits are evaluated in the resulting environment (in some unspecified order), each variable is assigned to the result of the corresponding init, the body is evaluated in the resulting environment, and the values of the last expression in body are returned. Each binding of a variable has the entire letrec expression as its region, making it possible to define mutually recursive procedures.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true"></a>(<span class="kw">letrec</span> ((<span class="kw">even?</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true"></a>          (<span class="kw">lambda</span> (n)</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true"></a>            (<span class="kw">if</span> (<span class="kw">zero?</span> n)</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true"></a>                <span class="dv">#t</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true"></a>                (<span class="kw">odd?</span> (<span class="op">-</span> n <span class="dv">1</span>)))))</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true"></a>         (<span class="kw">odd?</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true"></a>          (<span class="kw">lambda</span> (n)</span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true"></a>            (<span class="kw">if</span> (<span class="kw">zero?</span> n)</span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true"></a>                <span class="dv">#f</span></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true"></a>                (<span class="kw">even?</span> (<span class="op">-</span> n <span class="dv">1</span>))))))</span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true"></a>  (<span class="kw">even?</span> <span class="dv">88</span>))</span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true"></a><span class="co">;; =&gt; #t</span></span></code></pre></div>
<p>One restriction on letrec is very important: if it is not possible to evaluate each init without assigning or referring to the value of any variable, it is an error. The restriction is necessary because letrec is defined in terms of a procedure call where a lambda expression binds the variables to the values of the inits. In the most common uses of letrec, all the inits are lambda expressions and the restriction is satisfied automatically.</p>
<blockquote>
<p><code>(letrec* bindings body)</code> syntax</p>
</blockquote>
<p><em>Syntax:</em> Bindings has the form</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true"></a>((&lt;variable&gt; &lt;init&gt;) ...)</span></code></pre></div>
<p>and body is a sequence of zero or more definitions followed by one or more expressions as described in section <a href="#lambda">[lambda]</a>. It is an error for a variable to appear more than once in the list of variables being bound.</p>
<p><em>Semantics:</em> The variables are bound to fresh locations, each variable is assigned in left-to-right order to the result of evaluating the corresponding init (interleaving evaluations and assignments), the body is evaluated in the resulting environment, and the values of the last expression in body are returned. Despite the left-to-right evaluation and assignment order, each binding of a variable has the entire letrec* expression as its region, making it possible to define mutually recursive procedures.</p>
<p>If it is not possible to evaluate each init without assigning or referring to the value of the corresponding variable or the variable of any of the bindings that follow it in bindings, it is an error. Another restriction is that it is an error to invoke the continuation of an init more than once.</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true"></a><span class="co">;; Returns the arithmetic, geometric, and</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true"></a><span class="co">;; harmonic means of a nested list of numbers</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(means ton)</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true"></a>  (letrec*</span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true"></a>      ((mean</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true"></a>        (<span class="kw">lambda</span> (f g)</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true"></a>          (f (<span class="op">/</span> (sum g ton) n))))</span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true"></a>       (sum</span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true"></a>        (<span class="kw">lambda</span> (g ton)</span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true"></a>          (<span class="kw">if</span> (<span class="kw">null?</span> ton)</span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true"></a>              (<span class="op">+</span>)</span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true"></a>              (<span class="kw">if</span> (<span class="kw">number?</span> ton)</span>
<span id="cb83-13"><a href="#cb83-13" aria-hidden="true"></a>                  (g ton)</span>
<span id="cb83-14"><a href="#cb83-14" aria-hidden="true"></a>                  (<span class="op">+</span> (sum g (<span class="kw">car</span> ton))</span>
<span id="cb83-15"><a href="#cb83-15" aria-hidden="true"></a>                     (sum g (<span class="kw">cdr</span> ton)))))))</span>
<span id="cb83-16"><a href="#cb83-16" aria-hidden="true"></a>       (n (sum (<span class="kw">lambda</span> (x) <span class="dv">1</span>) ton)))</span>
<span id="cb83-17"><a href="#cb83-17" aria-hidden="true"></a>    (<span class="kw">values</span> (mean <span class="kw">values</span> <span class="kw">values</span>)</span>
<span id="cb83-18"><a href="#cb83-18" aria-hidden="true"></a>            (mean <span class="kw">exp</span> <span class="kw">log</span>)</span>
<span id="cb83-19"><a href="#cb83-19" aria-hidden="true"></a>            (mean <span class="op">/</span> <span class="op">/</span>))))</span></code></pre></div>
<p>Evaluating <code>(means ’(3 (1 4)))</code> returns three values: <code>8/3</code>, <code>2.28942848510666</code> (approximately), and <code>36/19</code>.</p>
<blockquote>
<p><code>(let-values mv binding spec body)</code> <em>syntax</em></p>
</blockquote>
<p><em>Syntax:</em> Mv binding spec has the form</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true"></a>((&lt;formals&gt; &lt;init&gt;) ...)</span></code></pre></div>
<p>where each init is an expression, and body is zero or more definitions followed by a sequence of one or more expressions as described in section <a href="#lambda">[lambda]</a>. It is an error for a variable to appear more than once in the set of formals.</p>
<p><em>Semantics:</em> The inits are evaluated in the current environment (in some unspecified order) as if by invoking call-with-values, and the variables occurring in the formals are bound to fresh locations holding the values returned by the inits, where the formals are matched to the return values in the same way that the formals in a lambda expression are matched to the arguments in a procedure call. Then, the body is evaluated in the extended environment, and the values of the last expression of body are returned. Each binding of a variable has body as its region.</p>
<p>It is an error if the formals do not match the number of values returned by the corresponding init.</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true"></a>(let-values (((root rem) (exact-integer-sqrt <span class="dv">32</span>)))</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true"></a>  (* root rem)) <span class="co">;; =&gt; 35</span></span></code></pre></div>
<blockquote>
<p><code>(let*-values mv binding spec body)</code> <em>syntax</em></p>
</blockquote>
<p><em>Syntax:</em> Mv binding spec has the form</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true"></a>((&lt;formals&gt; &lt;init&gt;) ...)</span></code></pre></div>
<p>and body is a sequence of zero or more definitions followed by one or more expressions as described in section <a href="#lambda">[lambda]</a>. In each formals, it is an error if any variable appears more than once.</p>
<p><em>Semantics:</em> The let*-values construct is similar to let-values, but the inits are evaluated and bindings created sequentially from left to right, with the region of the bindings of each formals including the inits to its right as well as body. Thus the second init is evaluated in an environment in which the first set of bindings is visible and initialized, and so on.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true"></a>(<span class="kw">let</span> ((a &#39;a) (b &#39;b) (x &#39;x) (y &#39;y))</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true"></a>  (let*-values (((a b) (<span class="kw">values</span> x y))</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true"></a>                ((x y) (<span class="kw">values</span> a b)))</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true"></a>    (<span class="kw">list</span> a b x y))) <span class="co">;; =&gt; (x y x y)</span></span></code></pre></div>
<h4 id="sequencing">Sequencing</h4>
<p>Both of Scheme’s sequencing constructs are named begin, but the two have slightly different forms and uses:</p>
<blockquote>
<p><code>(begin expression-or-definition ...)</code> <em>syntax</em></p>
</blockquote>
<p>This form of begin can appear as part of a body, or at the outermost level of a program, or at the REPL, or directly nested in a begin that is itself of this form. It causes the contained expressions and definitions to be evaluated exactly as if the enclosing begin construct were not present.</p>
<p><em>Rationale:</em> This form is commonly used in the output of macros (see section <a href="#macrosection">[macrosection]</a>) which need to generate multiple definitions and splice them into the context in which they are expanded.</p>
<blockquote>
<p><code>(begin expression ...)</code> <em>syntax</em></p>
</blockquote>
<p>This form of begin can be used as an ordinary expression. The expressions are evaluated sequentially from left to right, and the values of the last expression are returned. This expression type is used to sequence side effects such as assignments or input and output.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> x </span><span class="dv">0</span>)</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true"></a></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true"></a>(<span class="kw">and</span> (<span class="op">=</span> x <span class="dv">0</span>)</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true"></a>     (<span class="kw">begin</span> (set! x <span class="dv">5</span>)</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true"></a>            (<span class="op">+</span> x <span class="dv">1</span>))) <span class="co">;; =&gt; 6</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true"></a></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true"></a>(<span class="kw">begin</span> (<span class="kw">display</span> <span class="st">&quot;4 plus 1 equals &quot;</span>)</span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true"></a>       (<span class="kw">display</span> (<span class="op">+</span> <span class="dv">4</span> <span class="dv">1</span>))) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true"></a><span class="co">;; and prints 4 plus 1 equals 5</span></span></code></pre></div>
<p>Note that there is a third form of begin used as a library declaration: see section <a href="#librarydeclarations">[librarydeclarations]</a>.</p>
<h4 id="iteration">Iteration</h4>
<blockquote>
<p><code>(do ((variable&lt;sub&gt;1&lt;/sub&gt; init&lt;sub&gt;1&lt;/sub&gt; step&lt;sub&gt;1&lt;/sub&gt;) ...) (test expression ...) command ...)</code> syntax</p>
</blockquote>
<p><em>Syntax:</em> All of init, step, test, and command are expressions.</p>
<p><em>Semantics:</em> A do expression is an iteration construct. It specifies a set of variables to be bound, how they are to be initialized at the start, and how they are to be updated on each iteration. When a termination condition is met, the loop exits after evaluating the expressions.</p>
<p>A do expression is evaluated as follows: The init expressions are evaluated (in some unspecified order), the variables are bound to fresh locations, the results of the init expressions are stored in the bindings of the variables, and then the iteration phase begins.</p>
<p>Each iteration begins by evaluating test; if the result is false (see section <a href="#booleansection">[booleansection]</a>), then the command expressions are evaluated in order for effect, the step expressions are evaluated in some unspecified order, the variables are bound to fresh locations, the results of the steps are stored in the bindings of the variables, and the next iteration begins.</p>
<p>If test evaluates to a true value, then the expressions are evaluated from left to right and the values of the last expression are returned. If no expressions are present, then the value of the do expression is unspecified.</p>
<p>The region of the binding of a variable consists of the entire do expression except for the inits. It is an error for a variable to appear more than once in the list of do variables.</p>
<p>A step can be omitted, in which case the effect is the same as if (variable init variable) had been written instead of (variable init).</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true"></a>(<span class="kw">do</span> ((vec (<span class="kw">make-vector</span> <span class="dv">5</span>))</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true"></a>     (i <span class="dv">0</span> (<span class="op">+</span> i <span class="dv">1</span>)))</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true"></a>    ((<span class="op">=</span> i <span class="dv">5</span>) vec)</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true"></a>  (<span class="kw">vector-set!</span> vec i i)) <span class="co">;; =&gt; #(0 1 2 3 4)</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true"></a></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true"></a>(<span class="kw">let</span> ((x &#39;(<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">7</span> <span class="dv">9</span>)))</span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true"></a>  (<span class="kw">do</span> ((x x (<span class="kw">cdr</span> x))</span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true"></a>       (sum <span class="dv">0</span> (<span class="op">+</span> sum (<span class="kw">car</span> x))))</span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true"></a>      ((<span class="kw">null?</span> x) sum))) <span class="co">;; =&gt; 25</span></span></code></pre></div>
<blockquote>
<p><code>(let bindings body ...)</code> <em>syntax</em></p>
</blockquote>
<p><em>Semantics:</em> “Named let” is a variant on the syntax of <code>let</code> which provides a more general looping construct than do and can also be used to express recursion. It has the same syntax and semantics as ordinary let except that variable is bound within body to a procedure whose formal arguments are the bound variables and whose body is body. Thus the execution of body can be repeated by invoking the procedure named by variable.</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true"></a>(<span class="kw">let</span> loop ((numbers &#39;(<span class="dv">3</span> <span class="dv">-2</span> <span class="dv">1</span> <span class="dv">6</span> <span class="dv">-5</span>))</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true"></a>           (nonneg &#39;())</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true"></a>           (neg &#39;()))</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true"></a>  (<span class="kw">cond</span> ((<span class="kw">null?</span> numbers) (<span class="kw">list</span> nonneg neg))</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true"></a>        ((<span class="op">&gt;=</span> (<span class="kw">car</span> numbers) <span class="dv">0</span>)</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true"></a>         (loop (<span class="kw">cdr</span> numbers)</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true"></a>               (<span class="kw">cons</span> (<span class="kw">car</span> numbers) nonneg)</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true"></a>               neg))</span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true"></a>        ((<span class="op">&lt;</span> (<span class="kw">car</span> numbers) <span class="dv">0</span>)</span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true"></a>         (loop (<span class="kw">cdr</span> numbers)</span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true"></a>               nonneg</span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true"></a>               (<span class="kw">cons</span> (<span class="kw">car</span> numbers) neg)))))</span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true"></a><span class="co">;; =&gt; ((6 1 3) (-5 -2))</span></span></code></pre></div>
<h4 id="delayed-evaluation">Delayed evaluation</h4>
<blockquote>
<p><code>(delay expression)</code> <em>lazy</em> library <em>syntax</em></p>
</blockquote>
<p><em>Semantics:</em> The delay construct is used together with the procedure <code>force</code> to implement <em>lazy evaluation</em> or <em>call by need</em>. <code>(delay expression)</code> returns an object called a <em>promise</em> which at some point in the future can be asked (by the force procedure) to evaluate expression, and deliver the resulting value.</p>
<p>The effect of expression returning multiple values is unspecified.</p>
<blockquote>
<p><code>(delay-force expression)</code> <em>lazy</em> library <em>syntax</em></p>
</blockquote>
<p><em>Semantics:</em> The expression <code>(delay-force *expression*)</code> is conceptually similar to <code>(delay (force *expression*))</code>, with the difference that forcing the result of delay-force will in effect result in a tail call to <code>(force *expression*)</code>, while forcing the result of <code>(delay (force *expression*))</code> might not. Thus iterative lazy algorithms that might result in a long series of chains of <code>delay</code> and <code>force</code> can be rewritten using <code>delay-force</code> to prevent consuming unbounded space during evaluation.</p>
<blockquote>
<p><code>(force *promise*)</code> <em>lazy</em> library <em>procedure</em></p>
</blockquote>
<p>The force procedure forces the value of a <code>promise</code> created by <code>delay</code>, <code>delay-force</code>, or <code>make-promise</code>. If no value has been computed for the promise, then a value is computed and returned. The value of the promise must be cached (or “memoized”) so that if it is forced a second time, the previously computed value is returned. Consequently, a delayed expression is evaluated using the parameter values and exception handler of the call to force which first requested its value. If <code>promise</code> is not a promise, it may be returned unchanged.</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true"></a>(<span class="kw">force</span> (delay (<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>))) <span class="co">;; =&gt; 3</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true"></a>(<span class="kw">let</span> ((p (delay (<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>))))</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true"></a>  (<span class="kw">list</span> (<span class="kw">force</span> p) (<span class="kw">force</span> p)))</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true"></a><span class="co">;; =&gt; (3 3)</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true"></a></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> integers</span></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true"></a>  (<span class="kw">letrec</span> ((next</span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true"></a>            (<span class="kw">lambda</span> (n)</span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true"></a>              (delay (<span class="kw">cons</span> n (next (<span class="op">+</span> n <span class="dv">1</span>)))))))</span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true"></a>    (next <span class="dv">0</span>)))</span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> head</span></span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true"></a>  (<span class="kw">lambda</span> (stream) (<span class="kw">car</span> (<span class="kw">force</span> stream))))</span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> tail</span></span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true"></a>  (<span class="kw">lambda</span> (stream) (<span class="kw">cdr</span> (<span class="kw">force</span> stream))))</span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true"></a></span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true"></a>(head (tail (tail integers)))</span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true"></a><span class="co">;; =&gt; 2</span></span></code></pre></div>
<p>The following example is a mechanical transformation of a lazy stream-filtering algorithm into Scheme. Each call to a constructor is wrapped in delay, and each argument passed to a deconstructor is wrapped in force. The use of (delay-force …) instead of (delay (force …)) around the body of the procedure ensures that an ever-growing sequence of pending promises does not exhaust available storage, because force will in effect force such sequences iteratively.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(stream-filter p? s)</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true"></a>  (delay-force</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true"></a>   (<span class="kw">if</span> (<span class="kw">null?</span> (<span class="kw">force</span> s))</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true"></a>       (delay &#39;())</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true"></a>       (<span class="kw">let</span> ((h (<span class="kw">car</span> (<span class="kw">force</span> s)))</span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true"></a>             (t (<span class="kw">cdr</span> (<span class="kw">force</span> s))))</span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true"></a>         (<span class="kw">if</span> (p? h)</span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true"></a>             (delay (<span class="kw">cons</span> h (stream-filter p? t)))</span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true"></a>             (stream-filter p? t))))))</span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true"></a></span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true"></a>(head (tail (tail (stream-filter <span class="kw">odd?</span> integers))))</span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true"></a><span class="co">;; =&gt; 5</span></span></code></pre></div>
<p>The following examples are not intended to illustrate good programming style, as delay, force, and delay-force are mainly intended for programs written in the functional style. However, they do illustrate the property that only one value is computed for a promise, no matter how many times it is forced.</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> count </span><span class="dv">0</span>)</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> p</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true"></a>  (delay (<span class="kw">begin</span> (set! count (<span class="op">+</span> count <span class="dv">1</span>))</span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true"></a>                (<span class="kw">if</span> (<span class="op">&gt;</span> count x)</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true"></a>                    count</span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true"></a>                    (<span class="kw">force</span> p)))))</span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> x </span><span class="dv">5</span>)</span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true"></a>p <span class="co">;; =&gt; a promise</span></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true"></a>(<span class="kw">force</span> p) <span class="co">;; =&gt; 6</span></span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true"></a>p <span class="co">;; =&gt; a promise, still</span></span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true"></a>(<span class="kw">begin</span> (set! x <span class="dv">10</span>)</span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true"></a>       (<span class="kw">force</span> p)) <span class="co">;; =&gt; 6</span></span></code></pre></div>
<p>Various extensions to this semantics of delay, force and delay-force are supported in some implementations:</p>
<ul>
<li><p>Calling force on an object that is not a promise may simply return the object.</p></li>
<li><p>It may be the case that there is no means by which a promise can be operationally distinguished from its forced value. That is, expressions like the following may evaluate to either <code>#t</code> or to #f, depending on the implementation:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true"></a>(<span class="kw">eqv?</span> (delay <span class="dv">1</span>) <span class="dv">1</span>) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true"></a>(<span class="kw">pair?</span> (delay (<span class="kw">cons</span> <span class="dv">1</span> <span class="dv">2</span>))) <span class="co">;; =&gt; unspecified</span></span></code></pre></div></li>
<li><p>Implementations may implement “implicit forcing,” where the value of a promise is forced by procedures that operate only on arguments of a certain type, like cdr and *. However, procedures that operate uniformly on their arguments, like list, must not force them.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true"></a>(<span class="op">+</span> (delay (* <span class="dv">3</span> <span class="dv">7</span>)) <span class="dv">13</span>) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true"></a>(<span class="kw">car</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true"></a> (<span class="kw">list</span> (delay (* <span class="dv">3</span> <span class="dv">7</span>)) <span class="dv">13</span>)) <span class="co">;; =&gt; a promise</span></span></code></pre></div></li>
</ul>
<blockquote>
<p><code>(promise? obj)</code> <em>lazy</em> library <em>procedure</em></p>
</blockquote>
<p>The promise? procedure returns <code>#t</code> if its argument is a promise, and #f otherwise. Note that promises are not necessarily disjoint from other Scheme types such as procedures.</p>
<blockquote>
<p><code>(make-promise obj)</code> <em>lazy</em> library <em>procedure</em></p>
</blockquote>
<p>The make-promise procedure returns a promise which, when forced, will return <code>obj</code>. It is similar to delay, but does not delay its argument: it is a procedure rather than syntax. If <code>obj</code> is already a promise, it is returned.</p>
<h4 id="dynamic-bindings">Dynamic bindings</h4>
<p>The <em>dynamic extent</em> of a procedure call is the time between when it is initiated and when it returns. In Scheme, call-with-current-continuation (section <a href="#continuations">[continuations]</a>) allows reentering a dynamic extent after its procedure call has returned. Thus, the dynamic extent of a call might not be a single, continuous time period.</p>
<p>This sections introduces <em>parameter objects</em>, which can be bound to new values for the duration of a dynamic extent. The set of all parameter bindings at a given time is called the <em>dynamic environment</em>.</p>
<blockquote>
<p><code>(make-parameter init)</code> procedure</p>
</blockquote>
<blockquote>
<p><code>(make-parameter init converter)</code> procedure</p>
</blockquote>
<p>Returns a newly allocated parameter object, which is a procedure that accepts zero arguments and returns the value associated with the parameter object. Initially, this value is the value of (<code>converter</code> <code>init</code>), or of <code>init</code> if the conversion procedure <code>converter</code> is not specified. The associated value can be temporarily changed using parameterize, which is described below.</p>
<p>The effect of passing arguments to a parameter object is implementation-dependent.</p>
<blockquote>
<p>(parameterize ((param value) …)) <em>syntax</em></p>
</blockquote>
<p><em>Syntax:</em> Both param and value are expressions.</p>
<p>It is an error if the value of any param expression is not a parameter object.</p>
<p><em>Semantics:</em> A parameterize expression is used to change the values returned by specified parameter objects during the evaluation of the body.</p>
<p>The param and value expressions are evaluated in an unspecified order. The body is evaluated in a dynamic environment in which calls to the parameters return the results of passing the corresponding values to the conversion procedure specified when the parameters were created. Then the previous values of the parameters are restored without passing them to the conversion procedure. The results of the last expression in the body are returned as the results of the entire parameterize expression.</p>
<p><em>Note:</em> If the conversion procedure is not idempotent, the results of (parameterize ((x (x))) …), which appears to bind the parameter <code>x</code> to its current value, might not be what the user expects.</p>
<p>If an implementation supports multiple threads of execution, then parameterize must not change the associated values of any parameters in any thread other than the current thread and threads created inside body.</p>
<p>Parameter objects can be used to specify configurable settings for a computation without the need to pass the value to every procedure in the call chain explicitly.</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> radix</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true"></a>  (make-parameter</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true"></a>   <span class="dv">10</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true"></a>   (<span class="kw">lambda</span> (x)</span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true"></a>     (<span class="kw">if</span> (<span class="kw">and</span> (exact-integer? x) (<span class="op">&lt;=</span> <span class="dv">2</span> x <span class="dv">16</span>))</span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true"></a>         x</span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true"></a>         (error <span class="st">&quot;invalid radix&quot;</span>)))))</span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true"></a></span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(f n) (<span class="kw">number-&gt;string</span> n (radix)))</span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true"></a></span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true"></a>(f <span class="dv">12</span>) <span class="co">;; =&gt; &quot;12&quot;</span></span>
<span id="cb96-12"><a href="#cb96-12" aria-hidden="true"></a>(parameterize ((radix <span class="dv">2</span>))</span>
<span id="cb96-13"><a href="#cb96-13" aria-hidden="true"></a>  (f <span class="dv">12</span>)) <span class="co">;; =&gt; &quot;1100&quot;</span></span>
<span id="cb96-14"><a href="#cb96-14" aria-hidden="true"></a>(f <span class="dv">12</span>) <span class="co">;; =&gt; &quot;12&quot;</span></span>
<span id="cb96-15"><a href="#cb96-15" aria-hidden="true"></a></span>
<span id="cb96-16"><a href="#cb96-16" aria-hidden="true"></a>(radix <span class="dv">16</span>) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb96-17"><a href="#cb96-17" aria-hidden="true"></a></span>
<span id="cb96-18"><a href="#cb96-18" aria-hidden="true"></a>(parameterize ((radix <span class="dv">0</span>))</span>
<span id="cb96-19"><a href="#cb96-19" aria-hidden="true"></a>  (f <span class="dv">12</span>)) <span class="co">;; =&gt; error</span></span></code></pre></div>
<h4 id="exception-handling">Exception handling</h4>
<blockquote>
<p>(guard (variable cond_clause …) express …)` syntax</p>
</blockquote>
<p><em>Syntax:</em> Each <code>cond_clause</code> is as in the specification of <code>cond</code>.</p>
<p><em>Semantics:</em> The body is evaluated with an exception handler that binds the raised object (see <code>raise</code> in section <a href="#exceptionsection">[exceptionsection]</a>) to variable and, within the scope of that binding, evaluates the clauses as if they were the clauses of a cond expression. That implicit cond expression is evaluated with the continuation and dynamic environment of the guard expression. If every cond clause’s test evaluates to <code>#f</code> and there is no else clause, then raise-continuable is invoked on the raised object within the dynamic environment of the original call to raise or raise-continuable, except that the current exception handler is that of the guard expression.</p>
<p>See section <a href="#exceptionsection">[exceptionsection]</a> for a more complete discussion of exceptions.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true"></a>(guard (condition</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true"></a>        ((<span class="kw">assq</span> &#39;a condition) <span class="op">=&gt;</span> <span class="kw">cdr</span>)</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true"></a>        ((<span class="kw">assq</span> &#39;b condition)))</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true"></a>       (raise (<span class="kw">list</span> (<span class="kw">cons</span> &#39;a <span class="dv">42</span>))))</span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true"></a><span class="co">;; =&gt; 42</span></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true"></a></span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true"></a>(guard (condition</span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true"></a>        ((<span class="kw">assq</span> &#39;a condition) <span class="op">=&gt;</span> <span class="kw">cdr</span>)</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true"></a>        ((<span class="kw">assq</span> &#39;b condition)))</span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true"></a>       (raise (<span class="kw">list</span> (<span class="kw">cons</span> &#39;b <span class="dv">23</span>))))</span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true"></a><span class="co">;; =&gt; (b . 23)</span></span></code></pre></div>
<h4 id="quasiquotation">Quasiquotation</h4>
<blockquote>
<p><code>(quasiquote qq template)</code> <em>syntax</em></p>
</blockquote>
<blockquote>
<p><code>qq_template</code> <em>syntax</em></p>
</blockquote>
<blockquote>
<p><code>unquote</code> <em>auxiliary syntax</em></p>
</blockquote>
<blockquote>
<p><code>'</code> <em>auxiliary syntax</em></p>
</blockquote>
<blockquote>
<p><code>unquote-splicing</code> <em>auxiliary syntax</em></p>
</blockquote>
<blockquote>
<p>` <em>auxiliary syntax</em></p>
</blockquote>
<p>“Quasiquote” expressions are useful for constructing a list or vector structure when some but not all of the desired structure is known in advance. If no commas appear within the qq template, the result of evaluating `<code>qq template is equivalent to the result of evaluating</code>’<code>qq template. If a comma appears within the qq template, however, the expression following the comma is evaluated (“unquoted”) and its result is inserted into the structure instead of the comma and the expression.  If a comma appears followed without intervening whitespace by a commercial at-sign (</code>’`), then it is an error if the following expression does not evaluate to a list; the opening and closing parentheses of the list are then “stripped away” and the elements of the list are inserted in place of the comma at-sign expression sequence. A comma at-sign normally appears only within a list or vector qq template.</p>
<p><em>Note:</em> In order to unquote an identifier beginning with @, it is necessary to use either an explicit unquote or to put whitespace after the comma, to avoid colliding with the comma at-sign sequence.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true"></a>`(<span class="kw">list</span> ,(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="dv">4</span>) <span class="co">;; =&gt; (list 3 4)</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true"></a>(<span class="kw">let</span> ((name &#39;a)) `(<span class="kw">list</span> ,name &#39;,name))</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true"></a><span class="co">;; =&gt; (list a (quote a))</span></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true"></a>`(a ,(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>) ,@(map <span class="kw">abs</span> &#39;(<span class="dv">4</span> <span class="dv">-5</span> <span class="dv">6</span>)) b)</span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true"></a><span class="co">;; =&gt; (a 3 4 5 6 b)</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true"></a>`((foo ,(<span class="op">-</span> <span class="dv">10</span> <span class="dv">3</span>)) ,@(<span class="kw">cdr</span> &#39;(c)) . ,(<span class="kw">car</span> &#39;(<span class="kw">cons</span>)))</span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true"></a><span class="co">;; =&gt; ((foo 7) . cons)</span></span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true"></a>`#(<span class="dv">10</span> <span class="dv">5</span> ,(<span class="kw">sqrt</span> <span class="dv">4</span>) ,@(map <span class="kw">sqrt</span> &#39;(<span class="dv">16</span> <span class="dv">9</span>)) <span class="dv">8</span>)</span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true"></a><span class="co">;; =&gt; #(10 5 2 4 3 8)</span></span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true"></a>(<span class="kw">let</span> ((foo &#39;(foo bar)) (@baz &#39;baz))</span>
<span id="cb98-11"><a href="#cb98-11" aria-hidden="true"></a>  `(<span class="kw">list</span> ,@foo , @baz))</span>
<span id="cb98-12"><a href="#cb98-12" aria-hidden="true"></a><span class="co">;; =&gt; (list foo bar baz)</span></span></code></pre></div>
<p>Quasiquote expressions can be nested. Substitutions are made only for unquoted components appearing at the same nesting level as the outermost quasiquote. The nesting level increases by one inside each successive quasiquotation, and decreases by one inside each unquotation.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true"></a>`(a `(b ,(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>) ,(foo ,(<span class="op">+</span> <span class="dv">1</span> <span class="dv">3</span>) d) e) f)</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true"></a><span class="co">;; =&gt; (a `(b ,(+ 1 2) ,(foo 4 d) e) f)</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true"></a>(<span class="kw">let</span> ((name1 &#39;x)</span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true"></a>      (name2 &#39;y))</span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true"></a>  `(a `(b ,,name1 ,&#39;,name2 d) e))</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true"></a><span class="co">;; =&gt; (a `(b ,x ,&#39;y d) e)</span></span></code></pre></div>
<p>A quasiquote expression may return either newly allocated, mutable objects or literal structure for any structure that is constructed at run time during the evaluation of the expression. Portions that do not need to be rebuilt are always literal. Thus,</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true"></a>(<span class="kw">let</span> ((a <span class="dv">3</span>)) `((<span class="dv">1</span> <span class="dv">2</span>) ,a ,<span class="dv">4</span> ,&#39;five <span class="dv">6</span>))</span></code></pre></div>
<p>may be treated as equivalent to either of the following expressions:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true"></a>`((<span class="dv">1</span> <span class="dv">2</span>) <span class="dv">3</span> <span class="dv">4</span> five <span class="dv">6</span>)</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true"></a></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true"></a>(<span class="kw">let</span> ((a <span class="dv">3</span>))</span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true"></a>  (<span class="kw">cons</span> &#39;(<span class="dv">1</span> <span class="dv">2</span>)</span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true"></a>        (<span class="kw">cons</span> a (<span class="kw">cons</span> <span class="dv">4</span> (<span class="kw">cons</span> &#39;five &#39;(<span class="dv">6</span>))))))</span></code></pre></div>
<p>However, it is not equivalent to this expression:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true"></a>(<span class="kw">let</span> ((a <span class="dv">3</span>)) (<span class="kw">list</span> (<span class="kw">list</span> <span class="dv">1</span> <span class="dv">2</span>) a <span class="dv">4</span> &#39;five <span class="dv">6</span>))</span></code></pre></div>
<p>The two notations `<code>qq template and</code>(quasiquote qq template)<code>are identical in all respects. ,expression is identical to (unquote expression), and ,@expression is identical to (unquote-splicing expression). The</code>write` procedure may output either format.</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true"></a>(quasiquote (<span class="kw">list</span> (unquote (<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="dv">4</span>))</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true"></a><span class="co">;; =&gt; (list 3 4)</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true"></a>&#39;(quasiquote (<span class="kw">list</span> (unquote (<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="dv">4</span>))</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true"></a><span class="co">;; =&gt; `(list ,(+ 1 2) 4)</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true"></a><span class="co">;; i.e., (quasiquote (list (unquote (+ 1 2)) 4))</span></span></code></pre></div>
<p>It is an error if any of the identifiers quasiquote, unquote, or unquote-splicing appear in positions within a qq template otherwise than as described above.</p>
<h4 id="case-lambda">Case-lambda</h4>
<blockquote>
<p><code>(case-lambda clause ...)</code> <em>case-lambda</em> library <em>syntax</em></p>
</blockquote>
<p><em>Syntax:</em> Each clause is of the form (formals body), where formals and body have the same syntax as in a lambda expression.</p>
<p><em>Semantics:</em> A case-lambda expression evaluates to a procedure that accepts a variable number of arguments and is lexically scoped in the same manner as a procedure resulting from a lambda expression. When the procedure is called, the first clause for which the arguments agree with formals is selected, where agreement is specified as for the formals of a lambda expression. The variables of formals are bound to fresh locations, the values of the arguments are stored in those locations, the body is evaluated in the extended environment, and the results of body are returned as the results of the procedure call.</p>
<p>It is an error for the arguments not to agree with the formals of any clause.</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> range</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true"></a>  (case-lambda</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true"></a>   ((e) (range <span class="dv">0</span> e))</span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true"></a>   ((b e) (<span class="kw">do</span> ((r &#39;() (<span class="kw">cons</span> e r))</span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true"></a>               (e (<span class="op">-</span> e <span class="dv">1</span>) (<span class="op">-</span> e <span class="dv">1</span>)))</span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true"></a>              ((<span class="op">&lt;</span> e b) r)))))</span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true"></a></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true"></a>(range <span class="dv">3</span>) <span class="co">;; =&gt; (0 1 2)</span></span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true"></a>(range <span class="dv">3</span> <span class="dv">5</span>) <span class="co">;; =&gt; (3 4)</span></span></code></pre></div>
<h3 id="macros">Macros</h3>
<p>Scheme programs can define and use new derived expression types, called <em>macros</em>. Program-defined expression types have the syntax</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true"></a>(&lt;keyword&gt; &lt;datum&gt; ...)</span></code></pre></div>
<p>where keyword is an identifier that uniquely determines the expression type. This identifier is called the <em>syntactic keyword</em>, or simply <code>keyword</code>, of the macro. The number of the datums, and their syntax, depends on the expression type.</p>
<p>Each instance of a macro is called a <em>use</em> of the macro. The set of rules that specifies how a use of a macro is transcribed into a more primitive expression is called the <code>transformer</code> of the macro.</p>
<p>The macro definition facility consists of two parts:</p>
<ul>
<li><p>A set of expressions used to establish that certain identifiers are macro keywords, associate them with macro transformers, and control the scope within which a macro is defined, and</p></li>
<li><p>a pattern language for specifying macro transformers.</p></li>
</ul>
<p>The syntactic keyword of a macro can shadow variable bindings, and local variable bindings can shadow syntactic bindings. Two mechanisms are provided to prevent unintended conflicts:</p>
<ul>
<li><p>If a macro transformer inserts a binding for an identifier (variable or keyword), the identifier will in effect be renamed throughout its scope to avoid conflicts with other identifiers. Note that a global variable definition may or may not introduce a binding; see section <a href="#defines">[defines]</a>.</p></li>
<li><p>If a macro transformer inserts a free reference to an identifier, the reference refers to the binding that was visible where the transformer was specified, regardless of any local bindings that surround the use of the macro.</p></li>
</ul>
<p>In consequence, all macros defined using the pattern language are “hygienic” and “referentially transparent” and thus preserve Scheme’s lexical scoping. <span class="citation" data-cites="Kohlbecker86 hygienic Bawden88 macrosthatwork syntacticabstraction"></span></p>
<p>Implementations may provide macro facilities of other types.</p>
<h4 id="binding-constructs-for-syntactic-keywords">Binding constructs for syntactic keywords</h4>
<p>The let-syntax and letrec-syntax binding constructs are analogous to let and letrec, but they bind syntactic keywords to macro transformers instead of binding variables to locations that contain values. Syntactic keywords can also be bound globally or locally with define-syntax; see section <a href="#define-syntax">[define-syntax]</a>.</p>
<blockquote>
<p><code>(let-syntax bindings body)</code> <em>syntax</em></p>
</blockquote>
<p><em>Syntax:</em> Bindings has the form</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true"></a>((&lt;keyword&gt; &lt;transformer-spec&gt;) ...)</span></code></pre></div>
<p>Each keyword is an identifier, each transformer spec is an instance of syntax-rules, and body is a sequence of zero or more definitions followed by one or more expressions. It is an error for a keyword to appear more than once in the list of keywords being bound.</p>
<p><em>Semantics:</em> The body is expanded in the syntactic environment obtained by extending the syntactic environment of the let-syntax expression with macros whose keywords are the keywords, bound to the specified transformers. Each binding of a keyword has body as its region.</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true"></a>(<span class="kw">let-syntax</span> ((given-that (<span class="kw">syntax-rules</span> ()</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true"></a>                           ((given-that test stmt1 stmt2 ...)</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true"></a>                            (<span class="kw">if</span> test</span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true"></a>                                (<span class="kw">begin</span> stmt1</span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true"></a>                                       stmt2 ...))))))</span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true"></a>  (<span class="kw">let</span> ((<span class="kw">if</span> <span class="dv">#t</span>))</span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true"></a>    (given-that <span class="kw">if</span> (set! <span class="kw">if</span> &#39;now))</span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true"></a>    <span class="kw">if</span>)) <span class="co">;; =&gt; now</span></span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true"></a></span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true"></a>(<span class="kw">let</span> ((x &#39;outer))</span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true"></a>  (<span class="kw">let-syntax</span> ((m (<span class="kw">syntax-rules</span> () ((m) x))))</span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true"></a>    (<span class="kw">let</span> ((x &#39;inner))</span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true"></a>      (m)))) <span class="co">;; =&gt; outer</span></span></code></pre></div>
<blockquote>
<p><code>(letrec-syntax bindings body)</code> <em>syntax</em></p>
</blockquote>
<p><em>Syntax:</em> Same as for let-syntax.</p>
<p><em>Semantics:</em> The body is expanded in the syntactic environment obtained by extending the syntactic environment of the letrec-syntax expression with macros whose keywords are the keywords, bound to the specified transformers. Each binding of a keyword has the transformer specs as well as the body within its region, so the transformers can transcribe expressions into uses of the macros introduced by the letrec-syntax expression.</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true"></a>(<span class="kw">letrec-syntax</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true"></a>    ((my-or (<span class="kw">syntax-rules</span> ()</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true"></a>              ((my-or) <span class="dv">#f</span>)</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true"></a>              ((my-or e) e)</span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true"></a>              ((my-or e1 e2 ...)</span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true"></a>               (<span class="kw">let</span> ((temp e1))</span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true"></a>                 (<span class="kw">if</span> temp</span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true"></a>                     temp</span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true"></a>                     (my-or e2 ...)))))))</span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true"></a>  (<span class="kw">let</span> ((x <span class="dv">#f</span>)</span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true"></a>        (y <span class="dv">7</span>)</span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true"></a>        (temp <span class="dv">8</span>)</span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true"></a>        (<span class="kw">let</span> <span class="kw">odd?</span>)</span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true"></a>        (<span class="kw">if</span> <span class="kw">even?</span>))</span>
<span id="cb108-15"><a href="#cb108-15" aria-hidden="true"></a>    (my-or x</span>
<span id="cb108-16"><a href="#cb108-16" aria-hidden="true"></a>           (<span class="kw">let</span> temp)</span>
<span id="cb108-17"><a href="#cb108-17" aria-hidden="true"></a>           (<span class="kw">if</span> y)</span>
<span id="cb108-18"><a href="#cb108-18" aria-hidden="true"></a>           y))) <span class="co">;; =&gt; 7</span></span></code></pre></div>
<h4 id="pattern-language">Pattern language</h4>
<p>A transformer spec has one of the following forms:</p>
<p><code>scheme TODO FIXME &gt; `(syntax-rules (pattern literal … )` *syntax* ` ...) ` (syntax-rules ellipsis (pattern literal … )  syntax ` ...)` \_  auxiliary syntax …   auxiliary syntax</code></p>
<p><em>Syntax:</em> It is an error if any of the pattern literals, or the ellipsis in the second form, is not an identifier. It is also an error if syntax rule is not of the form</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true"></a>(&lt;pattern&gt; &lt;template&gt;)</span></code></pre></div>
<p>The pattern in a syntax rule is a list pattern whose first element is an identifier.</p>
<p>A pattern is either an identifier, a constant, or one of the following</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true"></a>    (&lt;pattern&gt; ...)</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true"></a>    (&lt;pattern&gt; &lt;pattern&gt; ... . &lt;pattern&gt;)</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true"></a>    (&lt;pattern&gt; ... &lt;pattern&gt; ... &lt;pattern&gt; ...)</span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true"></a>    (&lt;pattern&gt; ... &lt;pattern&gt; ... &lt;pattern&gt; ...</span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true"></a>      . &lt;pattern&gt;)</span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true"></a>    #(&lt;pattern&gt; ...)</span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true"></a>    #(&lt;pattern&gt; ... &lt;pattern&gt; ... &lt;pattern&gt; ...)</span></code></pre></div>
<p>and a template is either an identifier, a constant, or one of the following</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true"></a>    (&lt;element&gt; ...)</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true"></a>    (&lt;element&gt; &lt;element&gt; ... . &lt;template&gt;)</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true"></a>    (... &lt;template&gt;)</span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true"></a>    #(&lt;element&gt; ...)</span></code></pre></div>
<p>where an element is a template optionally followed by an ellipsis. An ellipsis is the identifier specified in the second form of syntax-rules, or the default identifier … (three consecutive periods) otherwise.</p>
<p><em>Semantics:</em> An instance of syntax-rules produces a new macro transformer by specifying a sequence of hygienic rewrite rules. A use of a macro whose keyword is associated with a transformer specified by syntax-rules is matched against the patterns contained in the syntax rules, beginning with the leftmost syntax rule. When a match is found, the macro use is transcribed hygienically according to the template.</p>
<p>An identifier appearing within a pattern can be an underscore (_), a literal identifier listed in the list of pattern literals, or the ellipsis. All other identifiers appearing within a pattern are <em>pattern variables</em>.</p>
<p>The keyword at the beginning of the pattern in a syntax rule is not involved in the matching and is considered neither a pattern variable nor a literal identifier.</p>
<p>Pattern variables match arbitrary input elements and are used to refer to elements of the input in the template. It is an error for the same pattern variable to appear more than once in a pattern.</p>
<p>Underscores also match arbitrary input elements but are not pattern variables and so cannot be used to refer to those elements. If an underscore appears in the pattern literals list, then that takes precedence and underscores in the pattern match as literals. Multiple underscores can appear in a pattern.</p>
<p>Identifiers that appear in (pattern literal … ) are interpreted as literal identifiers to be matched against corresponding elements of the input. An element in the input matches a literal identifier if and only if it is an identifier and either both its occurrence in the macro expression and its occurrence in the macro definition have the same lexical binding, or the two identifiers are the same and both have no lexical binding.</p>
<p>A subpattern followed by ellipsis can match zero or more elements of the input, unless ellipsis appears in the pattern literals, in which case it is matched as a literal.</p>
<p>More formally, an input expression <em>E</em> matches a pattern <em>P</em> if and only if:</p>
<ul>
<li><p><em>P</em> is an underscore (_).</p></li>
<li><p><em>P</em> is a non-literal identifier; or</p></li>
<li><p><em>P</em> is a literal identifier and <em>E</em> is an identifier with the same binding; or</p></li>
<li><p><em>P</em> is a list (<em>P</em><sub>1</sub> … <em>P</em><sub><em>n</em></sub>) and <em>E</em> is a list of <em>n</em> elements that match <em>P</em><sub>1</sub> through <em>P</em><sub><em>n</em></sub>, respectively; or</p></li>
<li><p><em>P</em> is an improper list (<em>P</em><sub>1</sub> <em>P</em><sub>2</sub> … <em>P</em><sub><em>n</em></sub> . <em>P</em><sub><em>n</em> + 1</sub>) and <em>E</em> is a list or improper list of <em>n</em> or more elements that match <em>P</em><sub>1</sub> through <em>P</em><sub><em>n</em></sub>, respectively, and whose <em>n</em>th tail matches <em>P</em><sub><em>n</em> + 1</sub>; or</p></li>
<li><p><em>P</em> is of the form (<em>P</em><sub>1</sub> … <em>P</em><sub><em>k</em></sub> <em>P</em><sub><em>e</em></sub> ellipsis <em>P</em><sub><em>m</em> + 1</sub> …  <em>P</em><sub><em>n</em></sub>) where <em>E</em> is a proper list of <em>n</em> elements, the first <em>k</em> of which match <em>P</em><sub>1</sub> through <em>P</em><sub><em>k</em></sub>, respectively, whose next <em>m</em> − <em>k</em> elements each match <em>P</em><sub><em>e</em></sub>, whose remaining <em>n</em> − <em>m</em> elements match <em>P</em><sub><em>m</em> + 1</sub> through <em>P</em><sub><em>n</em></sub>; or</p></li>
<li><p><em>P</em> is of the form (<em>P</em><sub>1</sub> … <em>P</em><sub><em>k</em></sub> <em>P</em><sub><em>e</em></sub> ellipsis <em>P</em><sub><em>m</em> + 1</sub> …  <em>P</em><sub><em>n</em></sub> . <em>P</em><sub><em>x</em></sub>) where <em>E</em> is a list or improper list of <em>n</em> elements, the first <em>k</em> of which match <em>P</em><sub>1</sub> through <em>P</em><sub><em>k</em></sub>, whose next <em>m</em> − <em>k</em> elements each match <em>P</em><sub><em>e</em></sub>, whose remaining <em>n</em> − <em>m</em> elements match <em>P</em><sub><em>m</em> + 1</sub> through <em>P</em><sub><em>n</em></sub>, and whose <em>n</em>th and final cdr matches <em>P</em><sub><em>x</em></sub>; or</p></li>
<li><p><em>P</em> is a vector of the form #(<em>P</em><sub>1</sub> … <em>P</em><sub><em>n</em></sub>) and <em>E</em> is a vector of <em>n</em> elements that match <em>P</em><sub>1</sub> through <em>P</em><sub><em>n</em></sub>; or</p></li>
<li><p><em>P</em> is of the form #(<em>P</em><sub>1</sub> … <em>P</em><sub><em>k</em></sub> <em>P</em><sub><em>e</em></sub> ellipsis <em>P</em><sub><em>m</em> + 1</sub> … <em>P</em><sub><em>n</em></sub>) where <em>E</em> is a vector of <em>n</em> elements the first <em>k</em> of which match <em>P</em><sub>1</sub> through <em>P</em><sub><em>k</em></sub>, whose next <em>m</em> − <em>k</em> elements each match <em>P</em><sub><em>e</em></sub>, and whose remaining <em>n</em> − <em>m</em> elements match <em>P</em><sub><em>m</em> + 1</sub> through <em>P</em><sub><em>n</em></sub>; or</p></li>
<li><p><em>P</em> is a constant and <em>E</em> is equal to <em>P</em> in the sense of the equal? procedure.</p></li>
</ul>
<p>It is an error to use a macro keyword, within the scope of its binding, in an expression that does not match any of the patterns.</p>
<p>When a macro use is transcribed according to the template of the matching syntax rule, pattern variables that occur in the template are replaced by the elements they match in the input. Pattern variables that occur in subpatterns followed by one or more instances of the identifier ellipsis are allowed only in subtemplates that are followed by as many instances of ellipsis. They are replaced in the output by all of the elements they match in the input, distributed as indicated. It is an error if the output cannot be built up as specified.</p>
<p>Identifiers that appear in the template but are not pattern variables or the identifier ellipsis are inserted into the output as literal identifiers. If a literal identifier is inserted as a free identifier then it refers to the binding of that identifier within whose scope the instance of syntax-rules appears. If a literal identifier is inserted as a bound identifier then it is in effect renamed to prevent inadvertent captures of free identifiers.</p>
<p>A template of the form (ellipsis template) is identical to template, except that ellipses within the template have no special meaning. That is, any ellipses contained within template are treated as ordinary identifiers. In particular, the template (ellipsis ellipsis) produces a single ellipsis. This allows syntactic abstractions to expand into code containing ellipses.</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> be-like-begin</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true"></a>    ((be-like-begin name)</span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true"></a>     (<span class="ex">define-syntax</span><span class="fu"> name</span></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true"></a>       (<span class="kw">syntax-rules</span> ()</span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true"></a>         ((name expr (... ...))</span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true"></a>          (<span class="kw">begin</span> expr (... ...))))))))</span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true"></a></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true"></a>(be-like-begin sequence)</span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true"></a>(sequence <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>) <span class="co">;; =&gt; 4</span></span></code></pre></div>
<p>As an example, if <code>let</code> and <code>cond</code> are defined as in section <a href="#derivedsection">[derivedsection]</a> then they are hygienic (as required) and the following is not an error.</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true"></a>(<span class="kw">let</span> ((<span class="op">=&gt;</span> <span class="dv">#f</span>))</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true"></a>  (<span class="kw">cond</span> (<span class="dv">#t</span> <span class="op">=&gt;</span> &#39;ok))) <span class="co">;; =&gt; ok</span></span></code></pre></div>
<p>The macro transformer for cond recognizes =&gt; as a local variable, and hence an expression, and not as the base identifier =&gt;, which the macro transformer treats as a syntactic keyword. Thus the example expands into</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true"></a>(<span class="kw">let</span> ((<span class="op">=&gt;</span> <span class="dv">#f</span>))</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true"></a>  (<span class="kw">if</span> <span class="dv">#t</span> (<span class="kw">begin</span> <span class="op">=&gt;</span> &#39;ok)))</span></code></pre></div>
<p>instead of</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true"></a>(<span class="kw">let</span> ((<span class="op">=&gt;</span> <span class="dv">#f</span>))</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true"></a>  (<span class="kw">let</span> ((temp <span class="dv">#t</span>))</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true"></a>    (<span class="kw">if</span> temp (&#39;ok temp))))</span></code></pre></div>
<p>which would result in an invalid procedure call.</p>
<h4 id="signaling-errors-in-macro-transformers">Signaling errors in macro transformers</h4>
<blockquote>
<p><code>(syntax-error message args … )</code> <em>syntax</em></p>
</blockquote>
<p>syntax-error behaves similarly to error (<a href="#exceptionsection">[exceptionsection]</a>) except that implementations with an expansion pass separate from evaluation should signal an error as soon as syntax-error is expanded. This can be used as a syntax-rules template for a pattern that is an invalid use of the macro, which can provide more descriptive error messages. message is a string literal, and args arbitrary expressions providing additional information. Applications cannot count on being able to catch syntax errors with exception handlers or guards.</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> simple-let</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true"></a>    ((_ (head ... ((x . y) val) . tail)</span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true"></a>      body1 body2 ...)</span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true"></a>     (syntax-error</span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true"></a>      <span class="st">&quot;expected an identifier but got&quot;</span></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true"></a>      (x . y)))</span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true"></a>    ((_ ((name val) ...) body1 body2 ...)</span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true"></a>     ((<span class="kw">lambda</span> (name ...) body1 body2 ...)</span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true"></a>      val ...))))</span></code></pre></div>
<h2 id="program-structure">Program structure</h2>
<h3 id="programs">Programs</h3>
<p>A Scheme program consists of one or more import declarations followed by a sequence of expressions and definitions. Import declarations specify the libraries on which a program or library depends; a subset of the identifiers exported by the libraries are made available to the program. Expressions are described in chapter <a href="#expressionchapter">[expressionchapter]</a>. Definitions are either variable definitions, syntax definitions, or record-type definitions, all of which are explained in this chapter. They are valid in some, but not all, contexts where expressions are allowed, specifically at the outermost level of a program and at the beginning of a body.</p>
<p>At the outermost level of a program, <code>(begin expression or definition_1 ...)</code> is equivalent to the sequence of expressions and definitions in the <code>begin</code>. Similarly, in a body, <code>(begin definition_1 ...)</code> is equivalent to the sequence definition<sub>1</sub> … . Macros can expand into such begin forms. For the formal definition, see <a href="#sequencing">[sequencing]</a>.</p>
<p>Import declarations and definitions cause bindings to be created in the global environment or modify the value of existing global bindings. The initial environment of a program is empty, so at least one import declaration is needed to introduce initial bindings.</p>
<p>Expressions occurring at the outermost level of a program do not create any bindings. They are executed in order when the program is invoked or loaded, and typically perform some kind of initialization.</p>
<p>Programs and libraries are typically stored in files, although in some implementations they can be entered interactively into a running Scheme system. Other paradigms are possible. Implementations which store libraries in files should document the mapping from the name of a library to its location in the file system.</p>
<h3 id="import-declarations">Import declarations</h3>
<p>An import declaration takes the following form:</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true"></a>(import &lt;import-set&gt; ...)</span></code></pre></div>
<p>An import declaration provides a way to import identifiers exported by a library. Each import set names a set of bindings from a library and possibly specifies local names for the imported bindings. It takes one of the following forms:</p>
<ul>
<li><p><code>library name</code></p></li>
<li><p><code>(only import set identifier ...)</code></p></li>
<li><p><code>(except import set identifier ...)</code></p></li>
<li><p><code>(prefix import set identifier)</code></p></li>
<li><p><code>(rename import set  (identifier_1 identifier_2) ...)</code></p></li>
</ul>
<p>In the first form, all of the identifiers in the named library’s export clauses are imported with the same names (or the exported names if exported with <code>rename</code>). The additional import set forms modify this set as follows:</p>
<ul>
<li><p><code>only</code> produces a subset of the given import set including only the listed identifiers (after any renaming). It is an error if any of the listed identifiers are not found in the original set.</p></li>
<li><p><code>except</code> produces a subset of the given import set, excluding the listed identifiers (after any renaming). It is an error if any of the listed identifiers are not found in the original set.</p></li>
<li><p><code>rename</code> modifies the given import set, replacing each instance of identifier<sub>1</sub> with identifier<sub>2</sub>. It is an error if any of the listed identifier<sub>1</sub>s are not found in the original set.</p></li>
<li><p><code>prefix</code> automatically renames all identifiers in the given import set, prefixing each with the specified identifier.</p></li>
</ul>
<p>In a program or library declaration, it is an error to import the same identifier more than once with different bindings, or to redefine or mutate an imported binding with a definition or with set!, or to refer to an identifier before it is imported. However, a REPL should permit these actions.</p>
<h3 id="variable-definitions">Variable definitions</h3>
<p>A variable definition binds one or more identifiers and specifies an initial value for each of them. The simplest kind of variable definition takes one of the following forms:</p>
<ul>
<li><p><code>(define variable expression)</code></p></li>
<li><p><code>(define (variable formals) body)</code></p>
<p>Formals are either a sequence of zero or more variables, or a sequence of one or more variables followed by a space-delimited period and another variable (as in a lambda expression). This form is equivalent to</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> &lt;variable&gt;</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true"></a>  (<span class="kw">lambda</span> (&lt;formals&gt;) &lt;body&gt;))</span></code></pre></div></li>
<li><p><code>(define (variable . formal) body)</code></p>
<p>Formal is a single variable. This form is equivalent to</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> &lt;variable&gt;</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true"></a>  (<span class="kw">lambda</span> &lt;formal&gt; &lt;body&gt;))</span></code></pre></div></li>
</ul>
<h4 id="top-level-definitions">Top level definitions</h4>
<p>At the outermost level of a program, a definition</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> &lt;variable&gt; </span>&lt;expression&gt;)</span></code></pre></div>
<p>has essentially the same effect as the assignment expression</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true"></a>(set! &lt;variable&gt; &lt;expression&gt;)</span></code></pre></div>
<p>if variable is bound to a non-syntax value. However, if variable is not bound, or is a syntactic keyword, then the definition will bind variable to a new location before performing the assignment, whereas it would be an error to perform a set! on an unbound variable.</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> add3</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true"></a>  (<span class="kw">lambda</span> (x) (<span class="op">+</span> x <span class="dv">3</span>)))</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true"></a>(add3 <span class="dv">3</span>) <span class="co">;; =&gt; 6</span></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> first </span><span class="kw">car</span>)</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true"></a>(first &#39;(<span class="dv">1</span> <span class="dv">2</span>)) <span class="co">;; =&gt; 1</span></span></code></pre></div>
<h4 id="internal-definitions">Internal definitions</h4>
<p>Definitions can occur at the beginning of a body (that is, the body of a <code>lambda</code>, <code>let</code>, <code>let*</code>, <code>letrec</code>, <code>letrec*</code>, <code>let-values</code>, <code>let*-values</code>, <code>let-syntax</code>, <code>letrec-syntax</code>, <code>parameterize</code>, <code>guard</code>, or <code>case-lambda</code>). Note that such a body might not be apparent until after expansion of other syntax. Such definitions are known as <em>internal definitions</em> as opposed to the global definitions described above. The variables defined by internal definitions are local to the body. That is, variable is bound rather than assigned, and the region of the binding is the entire body. For example,</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true"></a>(<span class="kw">let</span> ((x <span class="dv">5</span>))</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true"></a>  (<span class="ex">define</span><span class="fu"> foo </span>(<span class="kw">lambda</span> (y) (bar x y)))</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true"></a>  (<span class="ex">define</span><span class="fu"> bar </span>(<span class="kw">lambda</span> (a b) (<span class="op">+</span> (* a b) a)))</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true"></a>  (foo (<span class="op">+</span> x <span class="dv">3</span>))) <span class="co">;; =&gt; 45</span></span></code></pre></div>
<p>An expanded body containing internal definitions can always be converted into a completely equivalent letrec* expression. For example, the let expression in the above example is equivalent to</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true"></a>(<span class="kw">let</span> ((x <span class="dv">5</span>))</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true"></a>  (letrec* ((foo (<span class="kw">lambda</span> (y) (bar x y)))</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true"></a>            (bar (<span class="kw">lambda</span> (a b) (<span class="op">+</span> (* a b) a))))</span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true"></a>    (foo (<span class="op">+</span> x <span class="dv">3</span>))))</span></code></pre></div>
<p>Just as for the equivalent letrec* expression, it is an error if it is not possible to evaluate each expression of every internal definition in a body without assigning or referring to the value of the corresponding variable or the variable of any of the definitions that follow it in body.</p>
<p>It is an error to define the same identifier more than once in the same body.</p>
<p>Wherever an internal definition can occur, <code>(begin definition_1 ...)</code> is equivalent to the sequence of definitions that form the body of the <code>begin</code>.</p>
<h4 id="multiple-value-definitions">Multiple-value definitions</h4>
<p>Another kind of definition is provided by define-values, which creates multiple definitions from a single expression returning multiple values. It is allowed wherever define is allowed.</p>
<p>(define-values <em>formals expression</em>)  syntax</p>
<p>It is an error if a variable appears more than once in the set of formals.</p>
<p><em>Semantics:</em> Expression is evaluated, and the formals are bound to the return values in the same way that the formals in a lambda expression are matched to the arguments in a procedure call.</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true"></a>(define-values (x y) (exact-integer-sqrt <span class="dv">17</span>))</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true"></a>(<span class="kw">list</span> x y) <span class="co">;; =&gt; (4 1)</span></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true"></a></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true"></a>(<span class="kw">let</span> ()</span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true"></a>  (define-values (x y) (<span class="kw">values</span> <span class="dv">1</span> <span class="dv">2</span>))</span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true"></a>  (<span class="op">+</span> x y)) <span class="co">;; =&gt; 3</span></span></code></pre></div>
<h3 id="syntax-definitions">Syntax definitions</h3>
<p>Syntax definitions have this form:</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> keyword </span>transformer spec)</span></code></pre></div>
<p>Keyword is an identifier, and the transformer spec is an instance of <code>syntax-rules</code>. Like variable definitions, syntax definitions can appear at the outermost level or nested within a <code>body</code>.</p>
<p>If the define-syntax occurs at the outermost level, then the global syntactic environment is extended by binding the keyword to the specified transformer, but previous expansions of any global binding for keyword remain unchanged. Otherwise, it is an <em>internal syntax definition</em>, and is local to the body in which it is defined. Any use of a syntax keyword before its corresponding definition is an error. In particular, a use that precedes an inner definition will not apply an outer definition.</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true"></a>(<span class="kw">let</span> ((x <span class="dv">1</span>) (y <span class="dv">2</span>))</span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true"></a>  (<span class="ex">define-syntax</span><span class="fu"> swap</span>!</span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true"></a>    (<span class="kw">syntax-rules</span> ()</span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true"></a>      ((swap! a b)</span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true"></a>       (<span class="kw">let</span> ((tmp a))</span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true"></a>         (set! a b)</span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true"></a>         (set! b tmp)))))</span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true"></a>  (swap! x y)</span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true"></a>  (<span class="kw">list</span> x y)) <span class="co">;; =&gt; (2 1)</span></span></code></pre></div>
<p>Macros can expand into definitions in any context that permits them. However, it is an error for a definition to define an identifier whose binding has to be known in order to determine the meaning of the definition itself, or of any preceding definition that belongs to the same group of internal definitions. Similarly, it is an error for an internal definition to define an identifier whose binding has to be known in order to determine the boundary between the internal definitions and the expressions of the body it belongs to. For example, the following are errors:</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> define </span><span class="dv">3</span>)</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true"></a></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true"></a>(<span class="kw">begin</span> (<span class="ex">define</span><span class="fu"> begin </span><span class="kw">list</span>))</span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true"></a></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true"></a>(<span class="kw">let-syntax</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true"></a>    ((foo (<span class="kw">syntax-rules</span> ()</span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true"></a>            ((foo (proc args ...) body ...)</span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true"></a>             (<span class="ex">define</span><span class="fu"> proc</span></span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true"></a>               (<span class="kw">lambda</span> (args ...)</span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true"></a>                 body ...))))))</span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true"></a>  (<span class="kw">let</span> ((x <span class="dv">3</span>))</span>
<span id="cb128-12"><a href="#cb128-12" aria-hidden="true"></a>    (foo (plus x y) (<span class="op">+</span> x y))</span>
<span id="cb128-13"><a href="#cb128-13" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> foo </span>x)</span>
<span id="cb128-14"><a href="#cb128-14" aria-hidden="true"></a>    (plus foo x)))</span></code></pre></div>
<h3 id="record-type-definitions">Record-type definitions</h3>
<p><em>Record-type definitions</em> are used to introduce new data types, called <em>record types</em>. Like other definitions, they can appear either at the outermost level or in a body. The values of a record type are called <em>records</em> and are aggregations of zero or more <em>fields</em>, each of which holds a single location. A predicate, a constructor, and field accessors and mutators are defined for each record type.</p>
<blockquote>
<p><code>(define-record-type name ... TODO FIXME)</code> <em>syntax</em></p>
</blockquote>
<p><em>Syntax:</em> name and pred are identifiers. The constructor is of the form</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true"></a>(&lt;constructore-name&gt; &lt;field-name&gt; ...)</span></code></pre></div>
<p>and each field is either of the form</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true"></a>(&lt;field-name&gt; &lt;accessor-name&gt;)</span></code></pre></div>
<p>or of the form</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true"></a>(&lt;field-name&gt; &lt;accessor-name&gt; &lt;modified-name&gt;)</span></code></pre></div>
<p>It is an error for the same identifier to occur more than once as a field name. It is also an error for the same identifier to occur more than once as an accessor or mutator name.</p>
<p>The define-record-type construct is generative: each use creates a new record type that is distinct from all existing types, including Scheme’s predefined types and other record types — even record types of the same name or structure.</p>
<p>An instance of define-record-type is equivalent to the following definitions:</p>
<ul>
<li><p>name is bound to a representation of the record type itself. This may be a run-time object or a purely syntactic representation. The representation is not utilized in this report, but it serves as a means to identify the record type for use by further language extensions.</p></li>
<li><p>constructor name is bound to a procedure that takes as many arguments as there are field names in the (constructor name … ) subexpression and returns a new record of type name. Fields whose names are listed with constructor name have the corresponding argument as their initial value. The initial values of all other fields are unspecified. It is an error for a field name to appear in constructor but not as a field name.</p></li>
<li><p>pred is bound to a predicate that returns <code>#t</code> when given a value returned by the procedure bound to constructor name and <code>#f</code> for everything else.</p></li>
<li><p>Each accessor name is bound to a procedure that takes a record of type name and returns the current value of the corresponding field. It is an error to pass an accessor a value which is not a record of the appropriate type.</p></li>
<li><p>Each modifier name is bound to a procedure that takes a record of type name and a value which becomes the new value of the corresponding field; an unspecified value is returned. It is an error to pass a modifier a first argument which is not a record of the appropriate type.</p></li>
</ul>
<p>For instance, the following record-type definition</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true"></a>(define-record-type &lt;pare&gt;</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true"></a>  (kons x y)</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true"></a>  pare?</span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true"></a>  (x kar set-kar!)</span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true"></a>  (y kdr))</span></code></pre></div>
<p>defines kons to be a constructor, kar and kdr to be accessors, set-kar! to be a modifier, and pare? to be a predicate for instances of &lt;pare&gt;.</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true"></a>(pare? (kons <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">;; =&gt; #t</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true"></a>(pare? (<span class="kw">cons</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">;; =&gt; #f</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true"></a>(kar (kons <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">;; =&gt; 1</span></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true"></a>(kdr (kons <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">;; =&gt; 2</span></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true"></a>(<span class="kw">let</span> ((k (kons <span class="dv">1</span> <span class="dv">2</span>)))</span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true"></a>  (set-kar! k <span class="dv">3</span>)</span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true"></a>  (kar k)) <span class="co">;; =&gt; 3</span></span></code></pre></div>
<h3 id="libraries">Libraries</h3>
<p>Libraries provide a way to organize Scheme programs into reusable parts with explicitly defined interfaces to the rest of the program. This section defines the notation and semantics for libraries.</p>
<h4 id="library-syntax">Library Syntax</h4>
<p>A library definition takes the following form:</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true"></a>(define-library &lt;library-name&gt;</span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true"></a>  &lt;library-declaration&gt; ...)</span></code></pre></div>
<p>library name is a list whose members are identifiers and exact non-negative integers. It is used to identify the library uniquely when importing from other programs or libraries. Libraries whose first identifier is scheme are reserved for use by this report and future versions of this report. Libraries whose first identifier is srfi are reserved for libraries implementing Scheme Requests for Implementation. It is inadvisable, but not an error, for identifiers in library names to contain any of the characters | <code>'</code> ? * &lt; " : &gt; + [ ] / or control characters after escapes are expanded.</p>
<p>A library declaration is any of:</p>
<ul>
<li><p><code>(export export spec ...)</code></p></li>
<li><p><code>(import import set ...)</code></p></li>
<li><p><code>(begin command or definition ...)</code></p></li>
<li><p><code>(include filename_1 filename_2 ...)</code></p></li>
<li><p><code>(include-ci filename_1 filename_2 ...)</code></p></li>
<li><p><code>(include-library-declarations filename_1 filename_2 ...)</code></p></li>
<li><p><code>(cond-expand ce-clause_1 ce-clause_2 ...)</code></p></li>
</ul>
<p>An <code>export</code> declaration specifies a list of identifiers which can be made visible to other libraries or programs. An export spec takes one of the following forms:</p>
<ul>
<li><p>identifier</p></li>
<li><p><code>(rename identifier_1 identifier_2)</code></p></li>
</ul>
<p>In an export spec, an identifier names a single binding defined within or imported into the library, where the external name for the export is the same as the name of the binding within the library. A <code>rename</code> spec exports the binding defined within or imported into the library and named by identifier<sub>1</sub> in each <code>(identifier_1 identifier_2)</code> pairing, using identifier<sub>2</sub> as the external name.</p>
<p>An <code>import</code> declaration provides a way to import the identifiers exported by another library. It has the same syntax and semantics as an import declaration used in a program or at the REPL (see section <a href="#import">[import]</a>).</p>
<p>The <code>begin</code>, <code>include</code>, and <code>include-ci</code> declarations are used to specify the body of the library. They have the same syntax and semantics as the corresponding expression types. This form of begin is analogous to, but not the same as, the two types of begin defined in section <a href="#sequencing">[sequencing]</a>.</p>
<p>The <code>include-library-declarations</code> declaration is similar to <code>include</code> except that the contents of the file are spliced directly into the current library definition. This can be used, for example, to share the same <code>export</code> declaration among multiple libraries as a simple form of library interface.</p>
<p>The <code>cond-expand</code> declaration has the same syntax and semantics as the <code>cond-expand</code> expression type, except that it expands to spliced-in library declarations rather than expressions enclosed in begin.</p>
<p>One possible implementation of libraries is as follows: After all <code>cond-expand</code> library declarations are expanded, a new environment is constructed for the library consisting of all imported bindings. The expressions from all <code>begin</code>, <code>include</code> and <code>include-ci</code> library declarations are expanded in that environment in the order in which they occur in the library. Alternatively, <code>cond-expand</code> and <code>import</code> declarations may be processed in left to right order interspersed with the processing of other declarations, with the environment growing as imported bindings are added to it by each <code>import</code> declaration.</p>
<p>When a library is loaded, its expressions are executed in textual order. If a library’s definitions are referenced in the expanded form of a program or library body, then that library must be loaded before the expanded program or library body is evaluated. This rule applies transitively. If a library is imported by more than one program or library, it may possibly be loaded additional times.</p>
<p>Similarly, during the expansion of a library (foo), if any syntax keywords imported from another library (bar) are needed to expand the library, then the library (bar) must be expanded and its syntax definitions evaluated before the expansion of (foo).</p>
<p>Regardless of the number of times that a library is loaded, each program or library that imports bindings from a library must do so from a single loading of that library, regardless of the number of import declarations in which it appears. That is, (import (only (foo) a)) followed by (import (only (foo) b)) has the same effect as (import (only (foo) a b)).</p>
<h4 id="library-example">Library example</h4>
<p>The following example shows how a program can be divided into libraries plus a relatively small main program <span class="citation" data-cites="life"></span>. If the main program is entered into a REPL, it is not necessary to import the base library.</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true"></a>(define-library (example grid)</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true"></a>  (export make rows cols ref each</span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true"></a>          (rename put! set!))</span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true"></a>  (import (scheme base))</span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true"></a>  (<span class="kw">begin</span></span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true"></a>    <span class="co">;; Create an NxM grid.</span></span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> </span>(make n m)</span>
<span id="cb135-8"><a href="#cb135-8" aria-hidden="true"></a>      (<span class="kw">let</span> ((grid (<span class="kw">make-vector</span> n)))</span>
<span id="cb135-9"><a href="#cb135-9" aria-hidden="true"></a>        (<span class="kw">do</span> ((i <span class="dv">0</span> (<span class="op">+</span> i <span class="dv">1</span>)))</span>
<span id="cb135-10"><a href="#cb135-10" aria-hidden="true"></a>            ((<span class="op">=</span> i n) grid)</span>
<span id="cb135-11"><a href="#cb135-11" aria-hidden="true"></a>          (<span class="kw">let</span> ((v (<span class="kw">make-vector</span> m \sharpfalse{})))</span>
<span id="cb135-12"><a href="#cb135-12" aria-hidden="true"></a>            (<span class="kw">vector-set!</span> grid i v)))))</span>
<span id="cb135-13"><a href="#cb135-13" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> </span>(rows grid)</span>
<span id="cb135-14"><a href="#cb135-14" aria-hidden="true"></a>      (<span class="kw">vector-length</span> grid))</span>
<span id="cb135-15"><a href="#cb135-15" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> </span>(cols grid)</span>
<span id="cb135-16"><a href="#cb135-16" aria-hidden="true"></a>      (<span class="kw">vector-length</span> (<span class="kw">vector-ref</span> grid <span class="dv">0</span>)))</span>
<span id="cb135-17"><a href="#cb135-17" aria-hidden="true"></a>    <span class="co">;; Return \sharpfalse{} if out of range.</span></span>
<span id="cb135-18"><a href="#cb135-18" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> </span>(ref grid n m)</span>
<span id="cb135-19"><a href="#cb135-19" aria-hidden="true"></a>      (<span class="kw">and</span> (<span class="op">&lt;</span> <span class="dv">-1</span> n (rows grid))</span>
<span id="cb135-20"><a href="#cb135-20" aria-hidden="true"></a>           (<span class="op">&lt;</span> <span class="dv">-1</span> m (cols grid))</span>
<span id="cb135-21"><a href="#cb135-21" aria-hidden="true"></a>           (<span class="kw">vector-ref</span> (<span class="kw">vector-ref</span> grid n) m)))</span>
<span id="cb135-22"><a href="#cb135-22" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> </span>(put! grid n m v)</span>
<span id="cb135-23"><a href="#cb135-23" aria-hidden="true"></a>      (<span class="kw">vector-set!</span> (<span class="kw">vector-ref</span> grid n) m v))</span>
<span id="cb135-24"><a href="#cb135-24" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> </span>(each grid proc)</span>
<span id="cb135-25"><a href="#cb135-25" aria-hidden="true"></a>      (<span class="kw">do</span> ((j <span class="dv">0</span> (<span class="op">+</span> j <span class="dv">1</span>)))</span>
<span id="cb135-26"><a href="#cb135-26" aria-hidden="true"></a>          ((<span class="op">=</span> j (rows grid)))</span>
<span id="cb135-27"><a href="#cb135-27" aria-hidden="true"></a>        (<span class="kw">do</span> ((k <span class="dv">0</span> (<span class="op">+</span> k <span class="dv">1</span>)))</span>
<span id="cb135-28"><a href="#cb135-28" aria-hidden="true"></a>            ((<span class="op">=</span> k (cols grid)))</span>
<span id="cb135-29"><a href="#cb135-29" aria-hidden="true"></a>          (proc j k (ref grid j k)))))))</span>
<span id="cb135-30"><a href="#cb135-30" aria-hidden="true"></a></span>
<span id="cb135-31"><a href="#cb135-31" aria-hidden="true"></a>(define-library (example life)</span>
<span id="cb135-32"><a href="#cb135-32" aria-hidden="true"></a>  (export life)</span>
<span id="cb135-33"><a href="#cb135-33" aria-hidden="true"></a>  (import (except (scheme base) set!)</span>
<span id="cb135-34"><a href="#cb135-34" aria-hidden="true"></a>          (scheme <span class="kw">write</span>)</span>
<span id="cb135-35"><a href="#cb135-35" aria-hidden="true"></a>          (example grid))</span>
<span id="cb135-36"><a href="#cb135-36" aria-hidden="true"></a>  (<span class="kw">begin</span></span>
<span id="cb135-37"><a href="#cb135-37" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> </span>(life-count grid i j)</span>
<span id="cb135-38"><a href="#cb135-38" aria-hidden="true"></a>      (<span class="ex">define</span><span class="fu"> </span>(count i j)</span>
<span id="cb135-39"><a href="#cb135-39" aria-hidden="true"></a>        (<span class="kw">if</span> (ref grid i j) <span class="dv">1</span> <span class="dv">0</span>))</span>
<span id="cb135-40"><a href="#cb135-40" aria-hidden="true"></a>      (<span class="op">+</span> (count (<span class="op">-</span> i <span class="dv">1</span>) (<span class="op">-</span> j <span class="dv">1</span>))</span>
<span id="cb135-41"><a href="#cb135-41" aria-hidden="true"></a>         (count (<span class="op">-</span> i <span class="dv">1</span>) j)</span>
<span id="cb135-42"><a href="#cb135-42" aria-hidden="true"></a>         (count (<span class="op">-</span> i <span class="dv">1</span>) (<span class="op">+</span> j <span class="dv">1</span>))</span>
<span id="cb135-43"><a href="#cb135-43" aria-hidden="true"></a>         (count i (<span class="op">-</span> j <span class="dv">1</span>))</span>
<span id="cb135-44"><a href="#cb135-44" aria-hidden="true"></a>         (count i (<span class="op">+</span> j <span class="dv">1</span>))</span>
<span id="cb135-45"><a href="#cb135-45" aria-hidden="true"></a>         (count (<span class="op">+</span> i <span class="dv">1</span>) (<span class="op">-</span> j <span class="dv">1</span>))</span>
<span id="cb135-46"><a href="#cb135-46" aria-hidden="true"></a>         (count (<span class="op">+</span> i <span class="dv">1</span>) j)</span>
<span id="cb135-47"><a href="#cb135-47" aria-hidden="true"></a>         (count (<span class="op">+</span> i <span class="dv">1</span>) (<span class="op">+</span> j <span class="dv">1</span>))))</span>
<span id="cb135-48"><a href="#cb135-48" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> </span>(life-alive? grid i j)</span>
<span id="cb135-49"><a href="#cb135-49" aria-hidden="true"></a>      (<span class="kw">case</span> (life-count grid i j)</span>
<span id="cb135-50"><a href="#cb135-50" aria-hidden="true"></a>        ((<span class="dv">3</span>) \sharptrue{})</span>
<span id="cb135-51"><a href="#cb135-51" aria-hidden="true"></a>        ((<span class="dv">2</span>) (ref grid i j))</span>
<span id="cb135-52"><a href="#cb135-52" aria-hidden="true"></a>        (<span class="kw">else</span> \sharpfalse{})))</span>
<span id="cb135-53"><a href="#cb135-53" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> </span>(life-print grid)</span>
<span id="cb135-54"><a href="#cb135-54" aria-hidden="true"></a>      (<span class="kw">display</span> <span class="st">&quot;\x1B;[1H\x1B;[J&quot;</span>)  <span class="co">; clear vt100</span></span>
<span id="cb135-55"><a href="#cb135-55" aria-hidden="true"></a>      (each grid</span>
<span id="cb135-56"><a href="#cb135-56" aria-hidden="true"></a>            (<span class="kw">lambda</span> (i j v)</span>
<span id="cb135-57"><a href="#cb135-57" aria-hidden="true"></a>              (<span class="kw">display</span> (<span class="kw">if</span> v <span class="st">&quot;*&quot;</span> <span class="st">&quot; &quot;</span>))</span>
<span id="cb135-58"><a href="#cb135-58" aria-hidden="true"></a>              (when (<span class="op">=</span> j (<span class="op">-</span> (cols grid) <span class="dv">1</span>))</span>
<span id="cb135-59"><a href="#cb135-59" aria-hidden="true"></a>                (<span class="kw">newline</span>)))))</span>
<span id="cb135-60"><a href="#cb135-60" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> </span>(life grid iterations)</span>
<span id="cb135-61"><a href="#cb135-61" aria-hidden="true"></a>      (<span class="kw">do</span> ((i <span class="dv">0</span> (<span class="op">+</span> i <span class="dv">1</span>))</span>
<span id="cb135-62"><a href="#cb135-62" aria-hidden="true"></a>           (grid0 grid grid1)</span>
<span id="cb135-63"><a href="#cb135-63" aria-hidden="true"></a>           (grid1 (make (rows grid) (cols grid))</span>
<span id="cb135-64"><a href="#cb135-64" aria-hidden="true"></a>                  grid0))</span>
<span id="cb135-65"><a href="#cb135-65" aria-hidden="true"></a>          ((<span class="op">=</span> i iterations))</span>
<span id="cb135-66"><a href="#cb135-66" aria-hidden="true"></a>        (each grid0</span>
<span id="cb135-67"><a href="#cb135-67" aria-hidden="true"></a>              (<span class="kw">lambda</span> (j k v)</span>
<span id="cb135-68"><a href="#cb135-68" aria-hidden="true"></a>                (<span class="kw">let</span> ((a (life-alive? grid0 j k)))</span>
<span id="cb135-69"><a href="#cb135-69" aria-hidden="true"></a>                  (set! grid1 j k a))))</span>
<span id="cb135-70"><a href="#cb135-70" aria-hidden="true"></a>        (life-print grid1)))))</span>
<span id="cb135-71"><a href="#cb135-71" aria-hidden="true"></a></span>
<span id="cb135-72"><a href="#cb135-72" aria-hidden="true"></a><span class="co">;; Main program.</span></span>
<span id="cb135-73"><a href="#cb135-73" aria-hidden="true"></a>(import (scheme base)</span>
<span id="cb135-74"><a href="#cb135-74" aria-hidden="true"></a>        (only (example life) life)</span>
<span id="cb135-75"><a href="#cb135-75" aria-hidden="true"></a>        (rename (prefix (example grid) grid-)</span>
<span id="cb135-76"><a href="#cb135-76" aria-hidden="true"></a>                (grid-make make-grid)))</span>
<span id="cb135-77"><a href="#cb135-77" aria-hidden="true"></a></span>
<span id="cb135-78"><a href="#cb135-78" aria-hidden="true"></a><span class="co">;; Initialize a grid with a glider.</span></span>
<span id="cb135-79"><a href="#cb135-79" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> grid </span>(make-grid <span class="dv">24</span> <span class="dv">24</span>))</span>
<span id="cb135-80"><a href="#cb135-80" aria-hidden="true"></a>(grid-set! grid <span class="dv">1</span> <span class="dv">1</span> \sharptrue{})</span>
<span id="cb135-81"><a href="#cb135-81" aria-hidden="true"></a>(grid-set! grid <span class="dv">2</span> <span class="dv">2</span> \sharptrue{})</span>
<span id="cb135-82"><a href="#cb135-82" aria-hidden="true"></a>(grid-set! grid <span class="dv">3</span> <span class="dv">0</span> \sharptrue{})</span>
<span id="cb135-83"><a href="#cb135-83" aria-hidden="true"></a>(grid-set! grid <span class="dv">3</span> <span class="dv">1</span> \sharptrue{})</span>
<span id="cb135-84"><a href="#cb135-84" aria-hidden="true"></a>(grid-set! grid <span class="dv">3</span> <span class="dv">2</span> \sharptrue{})</span>
<span id="cb135-85"><a href="#cb135-85" aria-hidden="true"></a></span>
<span id="cb135-86"><a href="#cb135-86" aria-hidden="true"></a><span class="co">;; Run for 80 iterations.</span></span>
<span id="cb135-87"><a href="#cb135-87" aria-hidden="true"></a>(life grid <span class="dv">80</span>)</span></code></pre></div>
<h3 id="the-repl">The REPL</h3>
<p>Implementations may provide an interactive session called a <em>REPL</em> (Read-Eval-Print Loop), where import declarations, expressions and definitions can be entered and evaluated one at a time. For convenience and ease of use, the global Scheme environment in a REPL must not be empty, but must start out with at least the bindings provided by the base library. This library includes the core syntax of Scheme and generally useful procedures that manipulate data. For example, the variable abs is bound to a procedure of one argument that computes the absolute value of a number, and the variable + is bound to a procedure that computes sums. The full list of <code>(scheme base)</code> bindings can be found in Appendix <a href="#stdlibraries">[stdlibraries]</a>.</p>
<p>Implementations may provide an initial REPL environment which behaves as if all possible variables are bound to locations, most of which contain unspecified values. Top level REPL definitions in such an implementation are truly equivalent to assignments, unless the identifier is defined as a syntax keyword.</p>
<p>An implementation may provide a mode of operation in which the REPL reads its input from a file. Such a file is not, in general, the same as a program, because it can contain import declarations in places other than the beginning.</p>
<h2 id="standard-procedures">Standard procedures</h2>
<p>This chapter describes Scheme’s built-in procedures.</p>
<p>The procedures force, promise?, and make-promise are intimately associated with the expression types delay and delay-force, and are described with them in section <a href="#force">[force]</a>. In the same way, the procedure make-parameter is intimately associated with the expression type parameterize, and is described with it in section <a href="#make-parameter">[make-parameter]</a>.</p>
<p>A program can use a global variable definition to bind any variable. It may subsequently alter any such binding by an assignment (see section <a href="#assignment">[assignment]</a>). These operations do not modify the behavior of any procedure defined in this report or imported from a library (see section <a href="#libraries">[libraries]</a>). Altering any global binding that has not been introduced by a definition has an unspecified effect on the behavior of the procedures defined in this chapter.</p>
<p>When a procedure is said to return a <em>newly allocated</em> object, it means that the locations in the object are fresh.</p>
<h3 id="equivalence-predicates-1">Equivalence predicates</h3>
<p>A <em>predicate</em> is a procedure that always returns a boolean value (#t or #f). An <em>equivalence predicate</em> is the computational analogue of a mathematical equivalence relation; it is symmetric, reflexive, and transitive. Of the equivalence predicates described in this section, eq? is the finest or most discriminating, equal? is the coarsest, and eqv? is slightly less discriminating than eq?.</p>
<p>(eqv? <strong>obj<sub>1</sub><em> </em>obj<sub>2</sub></strong>)  procedure The eqv? procedure defines a useful equivalence relation on objects. Briefly, it returns <code>#t</code> if <em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are normally regarded as the same object. This relation is left slightly open to interpretation, but the following partial specification of eqv? holds for all implementations of Scheme.</p>
<p>The eqv? procedure returns <code>#t</code> if:</p>
<ul>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are both <code>#t</code> or both #f.</p></li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are both symbols and are the same symbol according to the symbol=? procedure (section <a href="#symbolsection">[symbolsection]</a>).</p></li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are both exact numbers and are numerically equal (in the sense of =).</p></li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are both inexact numbers such that they are numerically equal (in the sense of =) and they yield the same results (in the sense of eqv?) when passed as arguments to any other procedure that can be defined as a finite composition of Scheme’s standard arithmetic procedures, provided it does not result in a NaN value.</p></li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are both characters and are the same character according to the char=? procedure (section <a href="#charactersection">[charactersection]</a>).</p></li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are both the empty list.</p></li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are pairs, vectors, bytevectors, records, or strings that denote the same location in the store (section <a href="#storagemodel">[storagemodel]</a>).</p></li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are procedures whose location tags are equal (section <a href="#lambda">[lambda]</a>).</p></li>
</ul>
<p>The eqv? procedure returns <code>#f</code> if:</p>
<ul>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are of different types (section <a href="#disjointness">[disjointness]</a>).</p></li>
<li><p>one of <em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> is <code>#t</code> but the other is #f.</p></li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are symbols but are not the same symbol according to the symbol=? procedure (section <a href="#symbolsection">[symbolsection]</a>).</p></li>
<li><p>one of <em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> is an exact number but the other is an inexact number.</p></li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are both exact numbers and are numerically unequal (in the sense of =).</p></li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are both inexact numbers such that either they are numerically unequal (in the sense of =), or they do not yield the same results (in the sense of eqv?) when passed as arguments to any other procedure that can be defined as a finite composition of Scheme’s standard arithmetic procedures, provided it does not result in a NaN value. As an exception, the behavior of eqv? is unspecified when both <em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are NaN.</p></li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are characters for which the char=? procedure returns #f.</p></li>
<li><p>one of <em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> is the empty list but the other is not.</p></li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are pairs, vectors, bytevectors, records, or strings that denote distinct locations.</p></li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are procedures that would behave differently (return different values or have different side effects) for some arguments.</p></li>
</ul>
<div class="sourceCode" id="cb136"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true"></a>(<span class="kw">eqv?</span> &#39;a &#39;a) <span class="co">;; =&gt; #t</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true"></a>(<span class="kw">eqv?</span> &#39;a &#39;b) <span class="co">;; =&gt; #f</span></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true"></a>(<span class="kw">eqv?</span> <span class="dv">2</span> <span class="dv">2</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true"></a>(<span class="kw">eqv?</span> <span class="dv">2</span> <span class="fl">2.0</span>) <span class="co">;; =&gt; #f</span></span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true"></a>(<span class="kw">eqv?</span> &#39;() &#39;()) <span class="co">;; =&gt; #t</span></span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true"></a>(<span class="kw">eqv?</span> <span class="dv">100000000</span> <span class="dv">100000000</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true"></a>(<span class="kw">eqv?</span> <span class="fl">0.0</span> +nan<span class="fl">.0</span>) <span class="co">;; =&gt; #f</span></span>
<span id="cb136-8"><a href="#cb136-8" aria-hidden="true"></a>(<span class="kw">eqv?</span> (<span class="kw">cons</span> <span class="dv">1</span> <span class="dv">2</span>) (<span class="kw">cons</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">;; =&gt; #f</span></span>
<span id="cb136-9"><a href="#cb136-9" aria-hidden="true"></a>(<span class="kw">eqv?</span> (<span class="kw">lambda</span> () <span class="dv">1</span>)</span>
<span id="cb136-10"><a href="#cb136-10" aria-hidden="true"></a>      (<span class="kw">lambda</span> () <span class="dv">2</span>)) <span class="co">;; =&gt; #f</span></span>
<span id="cb136-11"><a href="#cb136-11" aria-hidden="true"></a>(<span class="kw">let</span> ((p (<span class="kw">lambda</span> (x) x)))</span>
<span id="cb136-12"><a href="#cb136-12" aria-hidden="true"></a>  (<span class="kw">eqv?</span> p p)) <span class="co">;; =&gt; #t</span></span>
<span id="cb136-13"><a href="#cb136-13" aria-hidden="true"></a>(<span class="kw">eqv?</span> <span class="dv">#f</span> &#39;nil) <span class="co">;; =&gt; #f</span></span></code></pre></div>
<p>The following examples illustrate cases in which the above rules do not fully specify the behavior of eqv?. All that can be said about such cases is that the value returned by eqv? must be a boolean.</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true"></a>(<span class="kw">eqv?</span> <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span>) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true"></a>(<span class="kw">eqv?</span> &#39;#() &#39;#()) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true"></a>(<span class="kw">eqv?</span> (<span class="kw">lambda</span> (x) x)</span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true"></a>      (<span class="kw">lambda</span> (x) x)) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true"></a>(<span class="kw">eqv?</span> (<span class="kw">lambda</span> (x) x)</span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true"></a>      (<span class="kw">lambda</span> (y) y)) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true"></a>(<span class="kw">eqv?</span> <span class="fl">1.0e0</span> <span class="fl">1.0</span>f0) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true"></a>(<span class="kw">eqv?</span> +nan<span class="fl">.0</span> +nan<span class="fl">.0</span>) <span class="co">;; =&gt; unspecified</span></span></code></pre></div>
<p>Note that (eqv? 0.0 -0.0) will return <code>#f</code> if negative zero is distinguished, and <code>#t</code> if negative zero is not distinguished.</p>
<p>The next set of examples shows the use of eqv? with procedures that have local state. The gen-counter procedure must return a distinct procedure every time, since each procedure has its own internal counter. The gen-loser procedure, however, returns operationally equivalent procedures each time, since the local state does not affect the value or side effects of the procedures. However, eqv? may or may not detect this equivalence.</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> gen-counter</span></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true"></a>  (<span class="kw">lambda</span> ()</span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true"></a>    (<span class="kw">let</span> ((n <span class="dv">0</span>))</span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true"></a>      (<span class="kw">lambda</span> () (set! n (<span class="op">+</span> n <span class="dv">1</span>)) n))))</span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true"></a>(<span class="kw">let</span> ((g (gen-counter)))</span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true"></a>  (<span class="kw">eqv?</span> g g)) <span class="co">;; =&gt; #t</span></span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true"></a>(<span class="kw">eqv?</span> (gen-counter) (gen-counter))</span>
<span id="cb138-8"><a href="#cb138-8" aria-hidden="true"></a><span class="co">;; =&gt; #f</span></span>
<span id="cb138-9"><a href="#cb138-9" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> gen-loser</span></span>
<span id="cb138-10"><a href="#cb138-10" aria-hidden="true"></a>  (<span class="kw">lambda</span> ()</span>
<span id="cb138-11"><a href="#cb138-11" aria-hidden="true"></a>    (<span class="kw">let</span> ((n <span class="dv">0</span>))</span>
<span id="cb138-12"><a href="#cb138-12" aria-hidden="true"></a>      (<span class="kw">lambda</span> () (set! n (<span class="op">+</span> n <span class="dv">1</span>)) <span class="dv">27</span>))))</span>
<span id="cb138-13"><a href="#cb138-13" aria-hidden="true"></a>(<span class="kw">let</span> ((g (gen-loser)))</span>
<span id="cb138-14"><a href="#cb138-14" aria-hidden="true"></a>  (<span class="kw">eqv?</span> g g)) <span class="co">;; =&gt; #t</span></span>
<span id="cb138-15"><a href="#cb138-15" aria-hidden="true"></a>(<span class="kw">eqv?</span> (gen-loser) (gen-loser))</span>
<span id="cb138-16"><a href="#cb138-16" aria-hidden="true"></a><span class="co">;; =&gt; unspecified</span></span>
<span id="cb138-17"><a href="#cb138-17" aria-hidden="true"></a></span>
<span id="cb138-18"><a href="#cb138-18" aria-hidden="true"></a>(<span class="kw">letrec</span> ((f (<span class="kw">lambda</span> () (<span class="kw">if</span> (<span class="kw">eqv?</span> f g) &#39;both &#39;f)))</span>
<span id="cb138-19"><a href="#cb138-19" aria-hidden="true"></a>         (g (<span class="kw">lambda</span> () (<span class="kw">if</span> (<span class="kw">eqv?</span> f g) &#39;both &#39;g))))</span>
<span id="cb138-20"><a href="#cb138-20" aria-hidden="true"></a>  (<span class="kw">eqv?</span> f g))</span>
<span id="cb138-21"><a href="#cb138-21" aria-hidden="true"></a><span class="co">;; =&gt; unspecified</span></span>
<span id="cb138-22"><a href="#cb138-22" aria-hidden="true"></a></span>
<span id="cb138-23"><a href="#cb138-23" aria-hidden="true"></a>(<span class="kw">letrec</span> ((f (<span class="kw">lambda</span> () (<span class="kw">if</span> (<span class="kw">eqv?</span> f g) &#39;f &#39;both)))</span>
<span id="cb138-24"><a href="#cb138-24" aria-hidden="true"></a>         (g (<span class="kw">lambda</span> () (<span class="kw">if</span> (<span class="kw">eqv?</span> f g) &#39;g &#39;both))))</span>
<span id="cb138-25"><a href="#cb138-25" aria-hidden="true"></a>  (<span class="kw">eqv?</span> f g))</span>
<span id="cb138-26"><a href="#cb138-26" aria-hidden="true"></a><span class="co">;; =&gt; #f</span></span></code></pre></div>
<p>Since it is an error to modify constant objects (those returned by literal expressions), implementations may share structure between constants where appropriate. Thus the value of eqv? on constants is sometimes implementation-dependent.</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true"></a>(<span class="kw">eqv?</span> &#39;(a) &#39;(a)) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true"></a>(<span class="kw">eqv?</span> <span class="st">&quot;a&quot;</span> <span class="st">&quot;a&quot;</span>) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true"></a>(<span class="kw">eqv?</span> &#39;(b) (<span class="kw">cdr</span> &#39;(a b))) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true"></a>(<span class="kw">let</span> ((x &#39;(a)))</span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true"></a>  (<span class="kw">eqv?</span> x x)) <span class="co">;; =&gt; #t</span></span></code></pre></div>
<p>The above definition of eqv? allows implementations latitude in their treatment of procedures and literals: implementations may either detect or fail to detect that two procedures or two literals are equivalent to each other, and can decide whether or not to merge representations of equivalent objects by using the same pointer or bit pattern to represent both.</p>
<p><em>Note:</em> If inexact numbers are represented as IEEE binary floating-point numbers, then an implementation of eqv? that simply compares equal-sized inexact numbers for bitwise equality is correct by the above definition.</p>
<p>(eq? <strong>obj<sub>1</sub><em> </em>obj<sub>2</sub></strong>)  procedure The eq? procedure is similar to eqv? except that in some cases it is capable of discerning distinctions finer than those detectable by eqv?. It must always return <code>#f</code> when eqv? also would, but may return <code>#f</code> in some cases where eqv? would return #t.</p>
<p>On symbols, booleans, the empty list, pairs, and records, and also on non-empty strings, vectors, and bytevectors, eq? and eqv? are guaranteed to have the same behavior. On procedures, eq? must return true if the arguments’ location tags are equal. On numbers and characters, eq?’s behavior is implementation-dependent, but it will always return either true or false. On empty strings, empty vectors, and empty bytevectors, eq? may also behave differently from eqv?.</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true"></a>(<span class="kw">eq?</span> &#39;a &#39;a) <span class="co">;; =&gt; #t</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true"></a>(<span class="kw">eq?</span> &#39;(a) &#39;(a)) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true"></a>(<span class="kw">eq?</span> (<span class="kw">list</span> &#39;a) (<span class="kw">list</span> &#39;a)) <span class="co">;; =&gt; #f</span></span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true"></a>(<span class="kw">eq?</span> <span class="st">&quot;a&quot;</span> <span class="st">&quot;a&quot;</span>) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true"></a>(<span class="kw">eq?</span> <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span>) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true"></a>(<span class="kw">eq?</span> &#39;() &#39;()) <span class="co">;; =&gt; #t</span></span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true"></a>(<span class="kw">eq?</span> <span class="dv">2</span> <span class="dv">2</span>) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb140-8"><a href="#cb140-8" aria-hidden="true"></a>(<span class="kw">eq?</span> <span class="ch">#\A</span> <span class="ch">#\A</span>) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb140-9"><a href="#cb140-9" aria-hidden="true"></a>(<span class="kw">eq?</span> <span class="kw">car</span> <span class="kw">car</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb140-10"><a href="#cb140-10" aria-hidden="true"></a>(<span class="kw">let</span> ((n (<span class="op">+</span> <span class="dv">2</span> <span class="dv">3</span>)))</span>
<span id="cb140-11"><a href="#cb140-11" aria-hidden="true"></a>  (<span class="kw">eq?</span> n n)) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb140-12"><a href="#cb140-12" aria-hidden="true"></a>(<span class="kw">let</span> ((x &#39;(a)))</span>
<span id="cb140-13"><a href="#cb140-13" aria-hidden="true"></a>  (<span class="kw">eq?</span> x x)) <span class="co">;; =&gt; #t</span></span>
<span id="cb140-14"><a href="#cb140-14" aria-hidden="true"></a>(<span class="kw">let</span> ((x &#39;#()))</span>
<span id="cb140-15"><a href="#cb140-15" aria-hidden="true"></a>  (<span class="kw">eq?</span> x x)) <span class="co">;; =&gt; #t</span></span>
<span id="cb140-16"><a href="#cb140-16" aria-hidden="true"></a>(<span class="kw">let</span> ((p (<span class="kw">lambda</span> (x) x)))</span>
<span id="cb140-17"><a href="#cb140-17" aria-hidden="true"></a>  (<span class="kw">eq?</span> p p)) <span class="co">;; =&gt; #t</span></span></code></pre></div>
<p><em>Rationale:</em> It will usually be possible to implement eq? much more efficiently than eqv?, for example, as a simple pointer comparison instead of as some more complicated operation. One reason is that it is not always possible to compute eqv? of two numbers in constant time, whereas eq? implemented as pointer comparison will always finish in constant time.</p>
<p>(equal? <strong>obj<sub>1</sub><em> </em>obj<sub>2</sub></strong>)  procedure The equal? procedure, when applied to pairs, vectors, strings and bytevectors, recursively compares them, returning <code>#t</code> when the unfoldings of its arguments into (possibly infinite) trees are equal (in the sense of equal?) as ordered trees, and <code>#f</code> otherwise. It returns the same as eqv? when applied to booleans, symbols, numbers, characters, ports, procedures, and the empty list. If two objects are eqv?, they must be equal? as well. In all other cases, equal? may return either <code>#t</code> or #f.</p>
<p>Even if its arguments are circular data structures, equal? must always terminate.</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true"></a>(<span class="kw">equal?</span> &#39;a &#39;a) <span class="co">;; =&gt; #t</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true"></a>(<span class="kw">equal?</span> &#39;(a) &#39;(a)) <span class="co">;; =&gt; #t</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true"></a>(<span class="kw">equal?</span> &#39;(a (b) c)</span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true"></a>        &#39;(a (b) c)) <span class="co">;; =&gt; #t</span></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true"></a>(<span class="kw">equal?</span> <span class="st">&quot;abc&quot;</span> <span class="st">&quot;abc&quot;</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true"></a>(<span class="kw">equal?</span> <span class="dv">2</span> <span class="dv">2</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true"></a>(<span class="kw">equal?</span> (<span class="kw">make-vector</span> <span class="dv">5</span> &#39;a)</span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true"></a>        (<span class="kw">make-vector</span> <span class="dv">5</span> &#39;a)) <span class="co">;; =&gt; #t</span></span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true"></a>(<span class="kw">equal?</span> &#39;#<span class="dv">1</span>=(a b . #<span class="dv">1</span>#)</span>
<span id="cb141-10"><a href="#cb141-10" aria-hidden="true"></a>        &#39;#<span class="dv">2</span>=(a b a b . #<span class="dv">2</span>#)) <span class="co">;; =&gt; #t</span></span>
<span id="cb141-11"><a href="#cb141-11" aria-hidden="true"></a>(<span class="kw">equal?</span> (<span class="kw">lambda</span> (x) x)</span>
<span id="cb141-12"><a href="#cb141-12" aria-hidden="true"></a>        (<span class="kw">lambda</span> (y) y)) <span class="co">;; =&gt; unspecified</span></span></code></pre></div>
<p><em>Note:</em> A rule of thumb is that objects are generally equal? if they print the same.</p>
<h3 id="numbers">Numbers</h3>
<p>It is important to distinguish between mathematical numbers, the Scheme numbers that attempt to model them, the machine representations used to implement the Scheme numbers, and notations used to write numbers. This report uses the types <em>number</em>, <em>complex</em>, <em>real</em>, <em>rational</em>, and <em>integer</em> to refer to both mathematical numbers and Scheme numbers.</p>
<h4 id="numerical-types">Numerical types</h4>
<p>Mathematically, numbers are arranged into a tower of subtypes in which each level is a subset of the level above it:</p>
<pre><code>number
complex number
real number
rational number
integer</code></pre>
<p>For example, 3 is an integer. Therefore 3 is also a rational, a real, and a complex number. The same is true of the Scheme numbers that model 3. For Scheme numbers, these types are defined by the predicates <code>number?</code>, <code>complex?</code>, <code>real?</code>, <code>rational?</code>, and <code>integer?</code>.</p>
<p>There is no simple relationship between a number’s type and its representation inside a computer. Although most implementations of Scheme will offer at least two different representations of 3, these different representations denote the same integer.</p>
<p>Scheme’s numerical operations treat numbers as abstract data, as independent of their representation as possible. Although an implementation of Scheme may use multiple internal representations of numbers, this ought not to be apparent to a casual programmer writing simple programs.</p>
<h4 id="exactness">Exactness</h4>
<p>It is useful to distinguish between numbers that are represented exactly and those that might not be. For example, indexes into data structures must be known exactly, as must some polynomial coefficients in a symbolic algebra system. On the other hand, the results of measurements are inherently inexact, and irrational numbers may be approximated by rational and therefore inexact approximations. In order to catch uses of inexact numbers where exact numbers are required, Scheme explicitly distinguishes exact from inexact numbers. This distinction is orthogonal to the dimension of type.</p>
<p>A Scheme number is <em>exact</em> if it was written as an exact constant or was derived from exact numbers using only exact operations. A number is <em>inexact</em> if it was written as an inexact constant, if it was derived using inexact ingredients, or if it was derived using inexact operations. Thus inexactness is a contagious property of a number. In particular, an <em>exact complex number</em> has an exact real part and an exact imaginary part; all other complex numbers are <em>inexact complex numbers</em>.</p>
<p>If two implementations produce exact results for a computation that did not involve inexact intermediate results, the two ultimate results will be mathematically equal. This is generally not true of computations involving inexact numbers since approximate methods such as floating-point arithmetic may be used, but it is the duty of each implementation to make the result as close as practical to the mathematically ideal result.</p>
<p>Rational operations such as + should always produce exact results when given exact arguments. If the operation is unable to produce an exact result, then it may either report the violation of an implementation restriction or it may silently coerce its result to an inexact value. However, (/ 3 4) must not return the mathematically incorrect value 0. See section <a href="#restrictions">[restrictions]</a>.</p>
<p>Except for <code>exact</code>, the operations described in this section must generally return inexact results when given any inexact arguments. An operation may, however, return an exact result if it can prove that the value of the result is unaffected by the inexactness of its arguments. For example, multiplication of any number by an exact zero may produce an exact zero result, even if the other argument is inexact.</p>
<p>Specifically, the expression (* 0 +inf.0) may return 0, or +nan.0, or report that inexact numbers are not supported, or report that non-rational real numbers are not supported, or fail silently or noisily in other implementation-specific ways.</p>
<h4 id="implementation-restrictions">Implementation restrictions</h4>
<p>Implementations of Scheme are not required to implement the whole tower of subtypes given in section <a href="#numericaltypes">[numericaltypes]</a>, but they must implement a coherent subset consistent with both the purposes of the implementation and the spirit of the Scheme language. For example, implementations in which all numbers are real, or in which non-real numbers are always inexact, or in which exact numbers are always integer, are still quite useful.</p>
<p>Implementations may also support only a limited range of numbers of any type, subject to the requirements of this section. The supported range for exact numbers of any type may be different from the supported range for inexact numbers of that type. For example, an implementation that uses IEEE binary double-precision floating-point numbers to represent all its inexact real numbers may also support a practically unbounded range of exact integers and rationals while limiting the range of inexact reals (and therefore the range of inexact integers and rationals) to the dynamic range of the IEEE binary double format. Furthermore, the gaps between the representable inexact integers and rationals are likely to be very large in such an implementation as the limits of this range are approached.</p>
<p>An implementation of Scheme must support exact integers throughout the range of numbers permitted as indexes of lists, vectors, bytevectors, and strings or that result from computing the length of one of these. The <code>length</code>, <code>vector-length</code>, <code>bytevector-length</code>, and <code>string-length</code> procedures must return an exact integer, and it is an error to use anything but an exact integer as an index. Furthermore, any integer constant within the index range, if expressed by an exact integer syntax, must be read as an exact integer, regardless of any implementation restrictions that apply outside this range. Finally, the procedures listed below will always return exact integer results provided all their arguments are exact integers and the mathematically expected results are representable as exact integers within the implementation:</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true"></a><span class="op">-</span>                     *</span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true"></a><span class="op">+</span>                     <span class="kw">abs</span></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true"></a><span class="kw">ceiling</span>               <span class="kw">denominator</span></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true"></a>exact-integer-sqrt    <span class="kw">expt</span></span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true"></a><span class="kw">floor</span>                 floor/</span>
<span id="cb143-6"><a href="#cb143-6" aria-hidden="true"></a>floor-quotient        floor-remainder</span>
<span id="cb143-7"><a href="#cb143-7" aria-hidden="true"></a><span class="kw">gcd</span>                   <span class="kw">lcm</span></span>
<span id="cb143-8"><a href="#cb143-8" aria-hidden="true"></a><span class="kw">max</span>                   <span class="kw">min</span></span>
<span id="cb143-9"><a href="#cb143-9" aria-hidden="true"></a><span class="kw">modulo</span>                <span class="kw">numerator</span></span>
<span id="cb143-10"><a href="#cb143-10" aria-hidden="true"></a><span class="kw">quotient</span>              <span class="kw">rationalize</span></span>
<span id="cb143-11"><a href="#cb143-11" aria-hidden="true"></a><span class="kw">remainder</span>             <span class="kw">round</span></span>
<span id="cb143-12"><a href="#cb143-12" aria-hidden="true"></a>square                <span class="kw">truncate</span></span>
<span id="cb143-13"><a href="#cb143-13" aria-hidden="true"></a>truncate/             truncate-quotient</span>
<span id="cb143-14"><a href="#cb143-14" aria-hidden="true"></a>truncate-remainder</span></code></pre></div>
<p>It is recommended, but not required, that implementations support exact integers and exact rationals of practically unlimited size and precision, and to implement the above procedures and the / procedure in such a way that they always return exact results when given exact arguments. If one of these procedures is unable to deliver an exact result when given exact arguments, then it may either report a violation of an implementation restriction or it may silently coerce its result to an inexact number; such a coercion can cause an error later. Nevertheless, implementations that do not provide exact rational numbers should return inexact rational numbers rather than reporting an implementation restriction.</p>
<p>An implementation may use floating-point and other approximate representation strategies for inexact numbers. This report recommends, but does not require, that implementations that use floating-point representations follow the IEEE 754 standard, and that implementations using other representations should match or exceed the precision achievable using these floating-point standards <span class="citation" data-cites="IEEE"></span>. In particular, the description of transcendental functions in IEEE 754-2008 should be followed by such implementations, particularly with respect to infinities and NaNs.</p>
<p>Although Scheme allows a variety of written notations for numbers, any particular implementation may support only some of them. For example, an implementation in which all numbers are real need not support the rectangular and polar notations for complex numbers. If an implementation encounters an exact numerical constant that it cannot represent as an exact number, then it may either report a violation of an implementation restriction or it may silently represent the constant by an inexact number.</p>
<h4 id="implementation-extensions">Implementation extensions</h4>
<p>Implementations may provide more than one representation of floating-point numbers with differing precisions. In an implementation which does so, an inexact result must be represented with at least as much precision as is used to express any of the inexact arguments to that operation. Although it is desirable for potentially inexact operations such as sqrt to produce exact answers when applied to exact arguments, if an exact number is operated upon so as to produce an inexact result, then the most precise representation available must be used. For example, the value of (sqrt 4) should be 2, but in an implementation that provides both single and double precision floating point numbers it may be the latter but must not be the former.</p>
<p>It is the programmer’s responsibility to avoid using inexact number objects with magnitude or significand too large to be represented in the implementation.</p>
<p>In addition, implementations may distinguish special numbers called positive infinity, negative infinity, NaN, and negative zero.</p>
<p>Positive infinity is regarded as an inexact real (but not rational) number that represents an indeterminate value greater than the numbers represented by all rational numbers. Negative infinity is regarded as an inexact real (but not rational) number that represents an indeterminate value less than the numbers represented by all rational numbers.</p>
<p>Adding or multiplying an infinite value by any finite real value results in an appropriately signed infinity; however, the sum of positive and negative infinities is a NaN. Positive infinity is the reciprocal of zero, and negative infinity is the reciprocal of negative zero. The behavior of the transcendental functions is sensitive to infinity in accordance with IEEE 754.</p>
<p>A NaN is regarded as an inexact real (but not rational) number so indeterminate that it might represent any real value, including positive or negative infinity, and might even be greater than positive infinity or less than negative infinity. An implementation that does not support non-real numbers may use NaN to represent non-real values like (sqrt -1.0) and (asin 2.0).</p>
<p>A NaN always compares false to any number, including a NaN. An arithmetic operation where one operand is NaN returns NaN, unless the implementation can prove that the result would be the same if the NaN were replaced by any rational number. Dividing zero by zero results in NaN unless both zeros are exact.</p>
<p>Negative zero is an inexact real value written -0.0 and is distinct (in the sense of eqv?) from 0.0. A Scheme implementation is not required to distinguish negative zero. If it does, however, the behavior of the transcendental functions is sensitive to the distinction in accordance with IEEE 754. Specifically, in a Scheme implementing both complex numbers and negative zero, the branch cut of the complex logarithm function is such that (imag-part (log -1.0-0.0i)) is  − <em>π</em> rather than <em>π</em>.</p>
<p>Furthermore, the negation of negative zero is ordinary zero and vice versa. This implies that the sum of two or more negative zeros is negative, and the result of subtracting (positive) zero from a negative zero is likewise negative. However, numerical comparisons treat negative zero as equal to zero.</p>
<p>Note that both the real and the imaginary parts of a complex number can be infinities, NaNs, or negative zero.</p>
<h4 id="syntax-of-numerical-constants">Syntax of numerical constants</h4>
<p>The syntax of the written representations for numbers is described formally in section <a href="#numbersyntax">[numbersyntax]</a>. Note that case is not significant in numerical constants.</p>
<p>A number can be written in binary, octal, decimal, or hexadecimal by the use of a radix prefix. The radix prefixes are #b (binary), #o (octal), #d (decimal), and #x (hexadecimal). With no radix prefix, a number is assumed to be expressed in decimal.</p>
<p>A numerical constant can be specified to be either exact or inexact by a prefix. The prefixes are #e for exact, and #i for inexact. An exactness prefix can appear before or after any radix prefix that is used. If the written representation of a number has no exactness prefix, the constant is inexact if it contains a decimal point or an exponent. Otherwise, it is exact.</p>
<p>In systems with inexact numbers of varying precisions it can be useful to specify the precision of a constant. For this purpose, implementations may accept numerical constants written with an exponent marker that indicates the desired precision of the inexact representation. If so, the letter s, f, d, or l, meaning <em>short</em>, <em>single</em>, <em>double</em>, or <em>long</em> precision, respectively, can be used in place of e. The default precision has at least as much precision as <em>double</em>, but implementations may allow this default to be set by the user.</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true"></a><span class="fl">3.14159265358979</span>F0</span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true"></a><span class="co">;; Round to single --- 3.141593</span></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true"></a><span class="fl">0.6</span>L0</span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true"></a><span class="co">;; Extend to long --- .600000000000000</span></span></code></pre></div>
<p>The numbers positive infinity, negative infinity, and NaN are written +inf.0, -inf.0 and +nan.0 respectively. NaN may also be written -nan.0. The use of signs in the written representation does not necessarily reflect the underlying sign of the NaN value, if any. Implementations are not required to support these numbers, but if they do, they must do so in general conformance with IEEE 754. However, implementations are not required to support signaling NaNs, nor to provide a way to distinguish between different NaNs.</p>
<p>There are two notations provided for non-real complex numbers: the <em>rectangular notation</em> <em>a</em>+<em>b</em>i, where <em>a</em> is the real part and <em>b</em> is the imaginary part; and the <em>polar notation</em> <em>r</em>@<em>θ</em>, where <em>r</em> is the magnitude and <em>θ</em> is the phase (angle) in radians. These are related by the equation <em>a</em> + *b**i<em> = </em>r<em>cos </em>θ<em> + (</em>r<em>sin</em>θ<em>)</em>i<em>. All of </em>a<em>, </em>b<em>, </em>r<em>, and </em>θ* are real numbers.</p>
<h4 id="numerical-operations">Numerical operations</h4>
<p>The reader is referred to section <a href="#typeconventions">[typeconventions]</a> for a summary of the naming conventions used to specify restrictions on the types of arguments to numerical routines. The examples used in this section assume that any numerical constant written using an exact notation is indeed represented as an exact number. Some examples also assume that certain numerical constants written using an inexact notation can be represented without loss of accuracy; the inexact constants were chosen so that this is likely to be true in implementations that use IEEE binary doubles to represent inexact numbers.</p>
<blockquote>
<p>(number? <em>obj</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(complex? <em>obj</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(real? <em>obj</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(rational? <em>obj</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(integer? <em>obj</em>)  procedure</p>
</blockquote>
<p>These numerical type predicates can be applied to any kind of argument, including non-numbers. They return <code>#t</code> if the object is of the named type, and otherwise they return #f. In general, if a type predicate is true of a number then all higher type predicates are also true of that number. Consequently, if a type predicate is false of a number, then all lower type predicates are also false of that number.</p>
<p>If <em>z</em> is a complex number, then (real? <em>z</em>) is true if and only if (zero? (imag-part <em>z</em>)) is true. If <em>x</em> is an inexact real number, then (integer? <em>x</em>) is true if and only if (= <em>x</em> (round <em>x</em>)).</p>
<p>The numbers +inf.0, -inf.0, and +nan.0 are real but not rational.</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true"></a>(<span class="kw">complex?</span> <span class="dv">3</span>+4i) <span class="co">;; =&gt; #t</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true"></a>(<span class="kw">complex?</span> <span class="dv">3</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true"></a>(<span class="kw">real?</span> <span class="dv">3</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true"></a>(<span class="kw">real?</span> <span class="fl">-2.5</span>+0i) <span class="co">;; =&gt; #t</span></span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true"></a>(<span class="kw">real?</span> <span class="fl">-2.5+0.0</span>i) <span class="co">;; =&gt; #f</span></span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true"></a>(<span class="kw">real?</span> <span class="ch">#e</span><span class="dv">1</span>e10) <span class="co">;; =&gt; #t</span></span>
<span id="cb145-7"><a href="#cb145-7" aria-hidden="true"></a>(<span class="kw">real?</span> +inf<span class="fl">.0</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb145-8"><a href="#cb145-8" aria-hidden="true"></a>(<span class="kw">real?</span> +nan<span class="fl">.0</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb145-9"><a href="#cb145-9" aria-hidden="true"></a>(<span class="kw">rational?</span> -inf<span class="fl">.0</span>) <span class="co">;; =&gt; #f</span></span>
<span id="cb145-10"><a href="#cb145-10" aria-hidden="true"></a>(<span class="kw">rational?</span> <span class="fl">3.5</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb145-11"><a href="#cb145-11" aria-hidden="true"></a>(<span class="kw">rational?</span> <span class="dv">6</span>/<span class="dv">10</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb145-12"><a href="#cb145-12" aria-hidden="true"></a>(<span class="kw">rational?</span> <span class="dv">6</span>/<span class="dv">3</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb145-13"><a href="#cb145-13" aria-hidden="true"></a>(<span class="kw">integer?</span> <span class="dv">3</span>+0i) <span class="co">;; =&gt; #t</span></span>
<span id="cb145-14"><a href="#cb145-14" aria-hidden="true"></a>(<span class="kw">integer?</span> <span class="fl">3.0</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb145-15"><a href="#cb145-15" aria-hidden="true"></a>(<span class="kw">integer?</span> <span class="dv">8</span>/<span class="dv">4</span>) <span class="co">;; =&gt; #t</span></span></code></pre></div>
<p><em>Note:</em> The behavior of these type predicates on inexact numbers is unreliable, since any inaccuracy might affect the result.</p>
<p><em>Note:</em> In many implementations the <code>complex?</code> procedure will be the same as <code>number?</code>, but unusual implementations may represent some irrational numbers exactly or may extend the number system to support some kind of non-complex numbers.</p>
<blockquote>
<p>(exact? <strong>z</strong>)  procedure</p>
</blockquote>
<blockquote>
<p>(inexact? <strong>z</strong>)  procedure</p>
</blockquote>
<p>These numerical predicates provide tests for the exactness of a quantity. For any Scheme number, precisely one of these predicates is true.</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true"></a>(<span class="kw">exact?</span> <span class="fl">3.0</span>) <span class="co">;; =&gt; #f</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true"></a>(<span class="kw">exact?</span> <span class="ch">#e</span><span class="dv">3.0</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true"></a>(<span class="kw">inexact?</span> <span class="fl">3.</span>) <span class="co">;; =&gt; #t</span></span></code></pre></div>
<blockquote>
<p>(exact-integer? <strong>z</strong>)  procedure</p>
</blockquote>
<p>Returns <code>#t</code> if <em>z</em> is both exact and an integer; otherwise returns #f.</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true"></a>(exact-integer? <span class="dv">32</span>) <span class="co">;; =&gt; #t{}</span></span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true"></a>(exact-integer? <span class="fl">32.0</span>) <span class="co">;; =&gt; #f</span></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true"></a>(exact-integer? <span class="dv">32</span>/<span class="dv">5</span>) <span class="co">;; =&gt; #f</span></span></code></pre></div>
<blockquote>
<p>(finite? <strong>z</strong>)  inexact library procedure</p>
</blockquote>
<p>The finite? procedure returns <code>#t</code> on all real numbers except +inf.0, -inf.0, and +nan.0, and on complex numbers if their real and imaginary parts are both finite. Otherwise it returns #f.</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true"></a>(finite? <span class="dv">3</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true"></a>(finite? +inf<span class="fl">.0</span>) <span class="co">;; =&gt; #f</span></span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true"></a>(finite? <span class="fl">3.0</span>+inf<span class="fl">.0</span>i) <span class="co">;; =&gt; #f</span></span></code></pre></div>
<blockquote>
<p>(infinite? <strong>z</strong>)  inexact library procedure</p>
</blockquote>
<p>The infinite? procedure returns <code>#t</code> on the real numbers +inf.0 and -inf.0, and on complex numbers if their real or imaginary parts or both are infinite. Otherwise it returns #f.</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true"></a>(infinite? <span class="dv">3</span>) <span class="co">;; =&gt; #f</span></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true"></a>(infinite? +inf<span class="fl">.0</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true"></a>(infinite? +nan<span class="fl">.0</span>) <span class="co">;; =&gt; #f</span></span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true"></a>(infinite? <span class="fl">3.0</span>+inf<span class="fl">.0</span>i) <span class="co">;; =&gt; #t</span></span></code></pre></div>
<blockquote>
<p>(nan? <strong>z</strong>)  inexact library procedure</p>
</blockquote>
<p>The nan? procedure returns <code>#t</code> on +nan.0, and on complex numbers if their real or imaginary parts or both are +nan.0. Otherwise it returns #f.</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true"></a>(nan? +nan<span class="fl">.0</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true"></a>(nan? <span class="dv">32</span>) <span class="co">;; =&gt; #f</span></span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true"></a>(nan? +nan<span class="fl">.0+5.0</span>i) <span class="co">;; =&gt; #t</span></span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true"></a>(nan? <span class="dv">1</span>+2i) <span class="co">;; =&gt; #f</span></span></code></pre></div>
<blockquote>
<p>(= **z<em><sub>1</sub> </em>z<em><sub>2</sub> </em>z<em><sub>3</sub> … </em>)  procedure</p>
</blockquote>
<blockquote>
<p>(&lt; **x<em><sub>1</sub> </em>x<em><sub>2</sub> </em>x<em><sub>3</sub> … </em>)  procedure</p>
</blockquote>
<blockquote>
<p>(&gt; **x<em><sub>1</sub> </em>x<em><sub>2</sub> </em>x<em><sub>3</sub> … </em>)  procedure</p>
</blockquote>
<blockquote>
<p>(&lt;= **x<em><sub>1</sub> </em>x<em><sub>2</sub> </em>x<em><sub>3</sub> … </em>)  procedure</p>
</blockquote>
<blockquote>
<p>(&gt;= **x<em><sub>1</sub> </em>x<em><sub>2</sub> </em>x<em><sub>3</sub> … </em>)  procedure</p>
</blockquote>
<p>These procedures return <code>#t</code> if their arguments are (respectively): equal, monotonically increasing, monotonically decreasing, monotonically non-decreasing, or monotonically non-increasing, and <code>#f</code> otherwise. If any of the arguments are +nan.0, all the predicates return #f. They do not distinguish between inexact zero and inexact negative zero.</p>
<p>These predicates are required to be transitive.</p>
<p><em>Note:</em> The implementation approach of converting all arguments to inexact numbers if any argument is inexact is not transitive. For example, let big be (expt 2 1000), and assume that big is exact and that inexact numbers are represented by 64-bit IEEE binary floating point numbers. Then (= (- big 1) (inexact big)) and (= (inexact big) (+ big 1)) would both be true with this approach, because of the limitations of IEEE representations of large integers, whereas (= (- big 1) (+ big 1)) is false. Converting inexact values to exact numbers that are the same (in the sense of =) to them will avoid this problem, though special care must be taken with infinities.</p>
<p><em>Note:</em> While it is not an error to compare inexact numbers using these predicates, the results are unreliable because a small inaccuracy can affect the result; this is especially true of <code>=</code> and <code>zero?</code>. When in doubt, consult a numerical analyst.</p>
<blockquote>
<p>(zero? <strong>z</strong>)  procedure</p>
</blockquote>
<blockquote>
<p>(positive? <strong>x</strong>)  procedure</p>
</blockquote>
<blockquote>
<p>(negative? <strong>x</strong>)  procedure</p>
</blockquote>
<blockquote>
<p>(odd? <strong>n</strong>)  procedure</p>
</blockquote>
<blockquote>
<p>(even? <strong>n</strong>)  procedure</p>
</blockquote>
<p>These numerical predicates test a number for a particular property, returning <code>#t</code> or #f. See note above.</p>
<blockquote>
<p>(max **x<em><sub>1</sub> </em>x<em><sub>2</sub> … </em>)  procedure</p>
</blockquote>
<blockquote>
<p>(min **x<em><sub>1</sub> </em>x<em><sub>2</sub> … </em>)  procedure</p>
</blockquote>
<p>These procedures return the maximum or minimum of their arguments.</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true"></a>(<span class="kw">max</span> <span class="dv">3</span> <span class="dv">4</span>) <span class="co">;; =&gt; 4    ; exact</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true"></a>(<span class="kw">max</span> <span class="fl">3.9</span> <span class="dv">4</span>) <span class="co">;; =&gt; 4.0  ; inexact</span></span></code></pre></div>
<p><em>Note:</em> If any argument is inexact, then the result will also be inexact (unless the procedure can prove that the inaccuracy is not large enough to affect the result, which is possible only in unusual implementations). If min or max is used to compare numbers of mixed exactness, and the numerical value of the result cannot be represented as an inexact number without loss of accuracy, then the procedure may report a violation of an implementation restriction.</p>
<p>(+ <strong>z<em><sub>1</sub> … </em>)  procedure (* </strong>z<em><sub>1</sub> … </em>)  procedure These procedures return the sum or product of their arguments.</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true"></a>(<span class="op">+</span> <span class="dv">3</span> <span class="dv">4</span>) <span class="co">;; =&gt; 7</span></span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true"></a>(<span class="op">+</span> <span class="dv">3</span>) <span class="co">;; =&gt; 3</span></span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true"></a>(<span class="op">+</span>) <span class="co">;; =&gt; 0</span></span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true"></a>(* <span class="dv">4</span>) <span class="co">;; =&gt; 4</span></span>
<span id="cb152-5"><a href="#cb152-5" aria-hidden="true"></a>(*) <span class="co">;; =&gt; 1</span></span></code></pre></div>
<blockquote>
<p>(- <strong>z</strong>)  procedure</p>
</blockquote>
<blockquote>
<p>(- **z<em><sub>1</sub> </em>z<em><sub>2</sub> … </em>)  procedure</p>
</blockquote>
<blockquote>
<p>(/ <strong>z</strong>)  procedure</p>
</blockquote>
<blockquote>
<p>(/ **z<em><sub>1</sub> </em>z<em><sub>2</sub> … </em>)  procedure</p>
</blockquote>
<p>With two or more arguments, these procedures return the difference or quotient of their arguments, associating to the left. With one argument, however, they return the additive or multiplicative inverse of their argument.</p>
<p>It is an error if any argument of / other than the first is an exact zero. If the first argument is an exact zero, an implementation may return an exact zero unless one of the other arguments is a NaN.</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true"></a>(<span class="op">-</span> <span class="dv">3</span> <span class="dv">4</span>) <span class="co">;; =&gt; -1</span></span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true"></a>(<span class="op">-</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>) <span class="co">;; =&gt; -6</span></span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true"></a>(<span class="op">-</span> <span class="dv">3</span>) <span class="co">;; =&gt; -3</span></span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true"></a>(<span class="op">/</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>) <span class="co">;; =&gt; 3/20</span></span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true"></a>(<span class="op">/</span> <span class="dv">3</span>) <span class="co">;; =&gt; 1/3</span></span></code></pre></div>
<blockquote>
<p>(abs <em>x</em>)  procedure</p>
</blockquote>
<p>The abs procedure returns the absolute value of its argument.</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true"></a>(<span class="kw">abs</span> <span class="dv">-7</span>) <span class="co">;; =&gt; 7</span></span></code></pre></div>
<blockquote>
<p>(floor/ **n<em><sub>1</sub> </em>n<em><sub>2</sub></em>)  procedure</p>
</blockquote>
<blockquote>
<p>(floor-quotient **n<em><sub>1</sub> </em>n<em><sub>2</sub></em>)  procedure</p>
</blockquote>
<blockquote>
<p>(floor-remainder **n<em><sub>1</sub> </em>n<em><sub>2</sub></em>)  procedure</p>
</blockquote>
<blockquote>
<p>(truncate/ **n<em><sub>1</sub> </em>n<em><sub>2</sub></em>)  procedure</p>
</blockquote>
<blockquote>
<p>(truncate-quotient **n<em><sub>1</sub> </em>n<em><sub>2</sub></em>)  procedure</p>
</blockquote>
<blockquote>
<p>(truncate-remainder **n<em><sub>1</sub> </em>n<em><sub>2</sub></em>)  procedure</p>
</blockquote>
<p>These procedures implement number-theoretic (integer) division. It is an error if <em>n</em><sub>2</sub> is zero. The procedures ending in / return two integers; the other procedures return an integer. All the procedures compute a quotient <em>n</em><sub><em>q</em></sub> and remainder <em>n</em><sub><em>r</em></sub> such that <span class="math inline"><span class="math inline">${\\hbox{$</span>n_1<span class="math inline">$\\/}} = {\\hbox{$</span>n_2<span class="math inline">$\\/}} {\\hbox{$</span>n_q<span class="math inline">$\\/}} + {\\hbox{$</span>n_r<span class="math inline">$\\/}}$</span></span>. For each of the division operators, there are three procedures defined as follows:</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true"></a>(&lt;operator&gt;/ \vri{n} \vrii{n}) <span class="co">;; =&gt; \vr{n_q} \vr{n_r}</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true"></a>(&lt;operator&gt;-quotient \vri{n} \vrii{n}) <span class="co">;; =&gt; \vr{n_q}</span></span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true"></a>(&lt;operator&gt;-remainder \vri{n} \vrii{n}) <span class="co">;; =&gt; \vr{n_r}</span></span></code></pre></div>
<p>The remainder <em>n</em><sub><em>r</em></sub> is determined by the choice of integer <em>n</em><sub><em>q</em></sub>: <span class="math inline"><span class="math inline">${\\hbox{$</span>n_r<span class="math inline">$\\/}} = {\\hbox{$</span>n_1<span class="math inline">$\\/}} - {\\hbox{$</span>n_2<span class="math inline">$\\/}} {\\hbox{$</span>n_q<span class="math inline">$\\/}}$</span></span>. Each set of operators uses a different choice of <em>n</em><sub><em>q</em></sub>:</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 92%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;">floor</td>
<td style="text-align: left;"><span class="math inline"><span class="math inline">${\\hbox{$</span>n_q<span class="math inline">$\\/}} = \\lfloor{\\hbox{$</span>n_1<span class="math inline">$\\/}} / {\\hbox{$</span>n_2<span class="math inline">$\\/}}\\rfloor$</span></span></td>
</tr>
<tr class="even">
<td style="text-align: left;">truncate</td>
<td style="text-align: left;"><span class="math inline"><span class="math inline">${\\hbox{$</span>n_q<span class="math inline">$\\/}} = \\text{truncate}({\\hbox{$</span>n_1<span class="math inline">$\\/}} / {\\hbox{$</span>n_2<span class="math inline">$\\/}})$</span></span></td>
</tr>
</tbody>
</table>
<p>For any of the operators, and for integers <em>n</em><sub>1</sub> and <em>n</em><sub>2</sub> with <em>n</em><sub>2</sub> not equal to 0,</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true"></a>(<span class="op">=</span> \vri{n} (<span class="op">+</span> (* \vrii{n} (&lt;operator&gt;-quotient \vri{n} \vrii{n}))</span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true"></a>              (&lt;operator&gt;-remainder \vri{n} \vrii{n})))</span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true"></a> <span class="co">;; =&gt; #t</span></span></code></pre></div>
<p>provided all numbers involved in that computation are exact.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true"></a>(floor/ <span class="dv">5</span> <span class="dv">2</span>) <span class="co">;; =&gt; 2 1</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true"></a>(floor/ <span class="dv">-5</span> <span class="dv">2</span>) <span class="co">;; =&gt; -3 1</span></span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true"></a>(floor/ <span class="dv">5</span> <span class="dv">-2</span>) <span class="co">;; =&gt; -3 -1</span></span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true"></a>(floor/ <span class="dv">-5</span> <span class="dv">-2</span>) <span class="co">;; =&gt; 2 -1</span></span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true"></a>(truncate/ <span class="dv">5</span> <span class="dv">2</span>) <span class="co">;; =&gt; 2 1</span></span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true"></a>(truncate/ <span class="dv">-5</span> <span class="dv">2</span>) <span class="co">;; =&gt; -2 -1</span></span>
<span id="cb157-7"><a href="#cb157-7" aria-hidden="true"></a>(truncate/ <span class="dv">5</span> <span class="dv">-2</span>) <span class="co">;; =&gt; -2 1</span></span>
<span id="cb157-8"><a href="#cb157-8" aria-hidden="true"></a>(truncate/ <span class="dv">-5</span> <span class="dv">-2</span>) <span class="co">;; =&gt; 2 -1</span></span>
<span id="cb157-9"><a href="#cb157-9" aria-hidden="true"></a>(truncate/ <span class="fl">-5.0</span> <span class="dv">-2</span>) <span class="co">;; =&gt; 2.0 -1.0</span></span></code></pre></div>
<blockquote>
<p>(quotient **n<em><sub>1</sub> </em>n<em><sub>2</sub></em>)  procedure</p>
</blockquote>
<blockquote>
<p>(remainder **n<em><sub>1</sub> </em>n<em><sub>2</sub></em>)  procedure</p>
</blockquote>
<blockquote>
<p>(modulo **n<em><sub>1</sub> </em>n<em><sub>2</sub></em>)  procedure</p>
</blockquote>
<p>The quotient and remainder procedures are equivalent to truncate-quotient and truncate-remainder, respectively, and modulo is equivalent to floor-remainder.</p>
<p><em>Note:</em> These procedures are provided for backward compatibility with earlier versions of this report.</p>
<blockquote>
<p>(gcd **n<em><sub>1</sub> … </em>)  procedure</p>
</blockquote>
<blockquote>
<p>(lcm **n<em><sub>1</sub> … </em>)  procedure</p>
</blockquote>
<p>These procedures return the greatest common divisor or least common multiple of their arguments. The result is always non-negative.</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true"></a>(<span class="kw">gcd</span> <span class="dv">32</span> <span class="dv">-36</span>) <span class="co">;; =&gt; 4</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true"></a>(<span class="kw">gcd</span>) <span class="co">;; =&gt; 0</span></span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true"></a>(<span class="kw">lcm</span> <span class="dv">32</span> <span class="dv">-36</span>) <span class="co">;; =&gt; 288</span></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true"></a>(<span class="kw">lcm</span> <span class="fl">32.0</span> <span class="dv">-36</span>) <span class="co">;; =&gt; 288.0  ; inexact</span></span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true"></a>(<span class="kw">lcm</span>) <span class="co">;; =&gt; 1</span></span></code></pre></div>
<blockquote>
<p>(numerator <strong>q</strong>)  procedure</p>
</blockquote>
<blockquote>
<p>(denominator <strong>q</strong>)  procedure</p>
</blockquote>
<p>These procedures return the numerator or denominator of their argument; the result is computed as if the argument was represented as a fraction in lowest terms. The denominator is always positive. The denominator of 0 is defined to be 1.</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true"></a>(<span class="kw">numerator</span> (<span class="op">/</span> <span class="dv">6</span> <span class="dv">4</span>)) <span class="co">;; =&gt; 3</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true"></a>(<span class="kw">denominator</span> (<span class="op">/</span> <span class="dv">6</span> <span class="dv">4</span>)) <span class="co">;; =&gt; 2</span></span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true"></a>(<span class="kw">denominator</span></span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true"></a> (inexact (<span class="op">/</span> <span class="dv">6</span> <span class="dv">4</span>))) <span class="co">;; =&gt; 2.0</span></span></code></pre></div>
<blockquote>
<p>(floor <em>x</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(ceiling <em>x</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(truncate <em>x</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(round <em>x</em>)  procedure</p>
</blockquote>
<p>These procedures return integers. The floor procedure returns the largest integer not larger than <em>x</em>. The ceiling procedure returns the smallest integer not smaller than <em>x</em>, truncate returns the integer closest to <em>x</em> whose absolute value is not larger than the absolute value of <em>x</em>, and round returns the closest integer to <em>x</em>, rounding to even when <em>x</em> is halfway between two integers.</p>
<p><em>Rationale:</em> The round procedure rounds to even for consistency with the default rounding mode specified by the IEEE 754 IEEE floating-point standard.</p>
<p><em>Note:</em> If the argument to one of these procedures is inexact, then the result will also be inexact. If an exact value is needed, the result can be passed to the exact procedure. If the argument is infinite or a NaN, then it is returned.</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true"></a>(<span class="kw">floor</span> <span class="fl">-4.3</span>) <span class="co">;; =&gt; -5.0</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true"></a>(<span class="kw">ceiling</span> <span class="fl">-4.3</span>) <span class="co">;; =&gt; -4.0</span></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true"></a>(<span class="kw">truncate</span> <span class="fl">-4.3</span>) <span class="co">;; =&gt; -4.0</span></span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true"></a>(<span class="kw">round</span> <span class="fl">-4.3</span>) <span class="co">;; =&gt; -4.0</span></span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true"></a></span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true"></a>(<span class="kw">floor</span> <span class="fl">3.5</span>) <span class="co">;; =&gt; 3.0</span></span>
<span id="cb160-7"><a href="#cb160-7" aria-hidden="true"></a>(<span class="kw">ceiling</span> <span class="fl">3.5</span>) <span class="co">;; =&gt; 4.0</span></span>
<span id="cb160-8"><a href="#cb160-8" aria-hidden="true"></a>(<span class="kw">truncate</span> <span class="fl">3.5</span>) <span class="co">;; =&gt; 3.0</span></span>
<span id="cb160-9"><a href="#cb160-9" aria-hidden="true"></a>(<span class="kw">round</span> <span class="fl">3.5</span>) <span class="co">;; =&gt; 4.0  ; inexact</span></span>
<span id="cb160-10"><a href="#cb160-10" aria-hidden="true"></a></span>
<span id="cb160-11"><a href="#cb160-11" aria-hidden="true"></a>(<span class="kw">round</span> <span class="dv">7</span>/<span class="dv">2</span>) <span class="co">;; =&gt; 4    ; exact</span></span>
<span id="cb160-12"><a href="#cb160-12" aria-hidden="true"></a>(<span class="kw">round</span> <span class="dv">7</span>) <span class="co">;; =&gt; 7</span></span></code></pre></div>
<blockquote>
<p>(rationalize <em>x y</em>)  procedure</p>
</blockquote>
<p>The rationalize procedure returns the <em>simplest</em> rational number differing from <em>x</em> by no more than <em>y</em>. A rational number <em>r</em><sub>1</sub> is <em>simpler</em> than another rational number <em>r</em><sub>2</sub> if <em>r</em><sub>1</sub> = <em>p</em><sub>1</sub>/<em>q</em><sub>1</sub> and <em>r</em><sub>2</sub> = <em>p</em><sub>2</sub>/<em>q</em><sub>2</sub> (in lowest terms) and |<em>p</em><sub>1</sub>| ≤ |<em>p</em><sub>2</sub>| and |<em>q</em><sub>1</sub>| ≤ |<em>q</em><sub>2</sub>|. Thus 3/5 is simpler than 4/7. Although not all rationals are comparable in this ordering (consider 2/7 and 3/5), any interval contains a rational number that is simpler than every other rational number in that interval (the simpler 2/5 lies between 2/7 and 3/5). Note that 0 = 0/1 is the simplest rational of all.</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true"></a>(<span class="kw">rationalize</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true"></a> (exact <span class="fl">.3</span>) <span class="dv">1</span>/<span class="dv">10</span>) <span class="co">;; =&gt; 1/3    ; exact</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true"></a>(<span class="kw">rationalize</span> <span class="fl">.3</span> <span class="dv">1</span>/<span class="dv">10</span>) <span class="co">;; =&gt; #i1/3  ; inexact</span></span></code></pre></div>
<blockquote>
<p>(exp <strong>z</strong>)  inexact library procedure</p>
</blockquote>
<blockquote>
<p>(log <strong>z</strong>)  inexact library procedure</p>
</blockquote>
<blockquote>
<p>(log **z<em><sub>1</sub> </em>z<em><sub>2</sub></em>)  inexact library procedure</p>
</blockquote>
<blockquote>
<p>(sin <strong>z</strong>)  inexact library procedure</p>
</blockquote>
<blockquote>
<p>(cos <strong>z</strong>)  inexact library procedure</p>
</blockquote>
<blockquote>
<p>(tan <strong>z</strong>)  inexact library procedure</p>
</blockquote>
<blockquote>
<p>(asin <strong>z</strong>)  inexact library procedure</p>
</blockquote>
<blockquote>
<p>(acos <strong>z</strong>)  inexact library procedure</p>
</blockquote>
<blockquote>
<p>(atan <strong>z</strong>)  inexact library procedure</p>
</blockquote>
<blockquote>
<p>(atan <strong>y<em> </em>x</strong>)  inexact library procedure</p>
</blockquote>
<p>These procedures compute the usual transcendental functions. The log procedure computes the natural logarithm of <em>z</em> (not the base ten logarithm) if a single argument is given, or the base-<em>z</em><sub>2</sub> logarithm of <em>z</em><sub>1</sub> if two arguments are given. The asin, acos, and atan procedures compute arcsine (sin<sup>−1</sup>), arc-cosine (cos<sup>−1</sup>), and arctangent (tan<sup>−1</sup>), respectively. The two-argument variant of atan computes <code>(angle (make-rectangular x y))</code> (see below), even in implementations that don’t support complex numbers.</p>
<p>In general, the mathematical functions log, arcsine, arc-cosine, and arctangent are multiply defined. The value of log <em>z</em> is defined to be the one whose imaginary part lies in the range from  − <em>π</em> (inclusive if -0.0 is distinguished, exclusive otherwise) to <em>π</em> (inclusive). The value of log 0 is mathematically undefined. With log  defined this way, the values of sin<sup>−1</sup><em>z</em>, cos<sup>−1</sup><em>z</em>, and tan<sup>−1</sup><em>z</em> are according to the following formulæ: <span class="math display">$$\\sin^{- 1}z = - i\\log\\left( iz + \\sqrt{1 - z^{2}} \\right)$$</span> cos<sup>−1</sup><em>z</em> = <em>π</em>/2 − sin<sup>−1</sup><em>z</em> tan<sup>−1</sup><em>z</em> = (log(1+<em>i<strong>z<em>)−log(1−</em>i</strong>z</em>))/(2<em>i</em>)</p>
<p>However, (log 0.0) returns -inf.0 (and (log -0.0) returns -inf.0+<em>π</em>i) if the implementation supports infinities (and -0.0).</p>
<p>The range of (atan <em>y</em> <em>x</em>) is as in the following table. The asterisk (*) indicates that the entry applies to implementations that distinguish minus zero.</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: left;"><em>y</em> condition</th>
<th style="text-align: left;"><em>x</em> condition</th>
<th style="text-align: left;">range of result <em>r</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;"><em>y</em> = 0.0</td>
<td style="text-align: left;"><em>x</em> &gt; 0.0</td>
<td style="text-align: left;">0.0</td>
</tr>
<tr class="even">
<td style="text-align: center;">*</td>
<td style="text-align: left;"><em>y</em> =  + 0.0</td>
<td style="text-align: left;"><em>x</em> &gt; 0.0</td>
<td style="text-align: left;"> + 0.0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">*</td>
<td style="text-align: left;"><em>y</em> =  − 0.0</td>
<td style="text-align: left;"><em>x</em> &gt; 0.0</td>
<td style="text-align: left;"> − 0.0</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"><em>y</em> &gt; 0.0</td>
<td style="text-align: left;"><em>x</em> &gt; 0.0</td>
<td style="text-align: left;"><span class="math inline">$0.0 \&lt; r \&lt; \\frac{\\pi}{2}$</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;"><em>y</em> &gt; 0.0</td>
<td style="text-align: left;"><em>x</em> = 0.0</td>
<td style="text-align: left;"><span class="math inline">$\\frac{\\pi}{2}$</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"><em>y</em> &gt; 0.0</td>
<td style="text-align: left;"><em>x</em> &lt; 0.0</td>
<td style="text-align: left;"><span class="math inline">$\\frac{\\pi}{2} \&lt; r \&lt; \\pi$</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;"><em>y</em> = 0.0</td>
<td style="text-align: left;"><em>x</em> &lt; 0</td>
<td style="text-align: left;"><em>π</em></td>
</tr>
<tr class="even">
<td style="text-align: center;">*</td>
<td style="text-align: left;"><em>y</em> =  + 0.0</td>
<td style="text-align: left;"><em>x</em> &lt; 0.0</td>
<td style="text-align: left;"><em>π</em></td>
</tr>
<tr class="odd">
<td style="text-align: center;">*</td>
<td style="text-align: left;"><em>y</em> =  − 0.0</td>
<td style="text-align: left;"><em>x</em> &lt; 0.0</td>
<td style="text-align: left;"> − <em>π</em></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"><em>y</em> &lt; 0.0</td>
<td style="text-align: left;"><em>x</em> &lt; 0.0</td>
<td style="text-align: left;"><span class="math inline">$- \\pi \&lt; r \&lt; - \\frac{\\pi}{2}$</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;"><em>y</em> &lt; 0.0</td>
<td style="text-align: left;"><em>x</em> = 0.0</td>
<td style="text-align: left;"><span class="math inline">$- \\frac{\\pi}{2}$</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"><em>y</em> &lt; 0.0</td>
<td style="text-align: left;"><em>x</em> &gt; 0.0</td>
<td style="text-align: left;"><span class="math inline">$- \\frac{\\pi}{2} \&lt; r \&lt; 0.0$</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;"><em>y</em> = 0.0</td>
<td style="text-align: left;"><em>x</em> = 0.0</td>
<td style="text-align: left;">undefined</td>
</tr>
<tr class="even">
<td style="text-align: center;">*</td>
<td style="text-align: left;"><em>y</em> =  + 0.0</td>
<td style="text-align: left;"><em>x</em> =  + 0.0</td>
<td style="text-align: left;"> + 0.0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">*</td>
<td style="text-align: left;"><em>y</em> =  − 0.0</td>
<td style="text-align: left;"><em>x</em> =  + 0.0</td>
<td style="text-align: left;"> − 0.0</td>
</tr>
<tr class="even">
<td style="text-align: center;">*</td>
<td style="text-align: left;"><em>y</em> =  + 0.0</td>
<td style="text-align: left;"><em>x</em> =  − 0.0</td>
<td style="text-align: left;"><em>π</em></td>
</tr>
<tr class="odd">
<td style="text-align: center;">*</td>
<td style="text-align: left;"><em>y</em> =  − 0.0</td>
<td style="text-align: left;"><em>x</em> =  − 0.0</td>
<td style="text-align: left;"> − <em>π</em></td>
</tr>
<tr class="even">
<td style="text-align: center;">*</td>
<td style="text-align: left;"><em>y</em> =  + 0.0</td>
<td style="text-align: left;"><em>x</em> = 0</td>
<td style="text-align: left;"><span class="math inline">$\\frac{\\pi}{2}$</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">*</td>
<td style="text-align: left;"><em>y</em> =  − 0.0</td>
<td style="text-align: left;"><em>x</em> = 0</td>
<td style="text-align: left;"><span class="math inline">$- \\frac{\\pi}{2}$</span></td>
</tr>
</tbody>
</table>
</div>
<p>The above specification follows <span class="citation" data-cites="CLtL"></span>, which in turn cites <span class="citation" data-cites="Penfield81"></span>; refer to these sources for more detailed discussion of branch cuts, boundary conditions, and implementation of these functions. When it is possible, these procedures produce a real result from a real argument.</p>
<p>(square <strong>z</strong>)  procedure Returns the square of <em>z</em>. This is equivalent to (* <em>z</em> <em>z</em>).</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true"></a>(square <span class="dv">42</span>) <span class="co">;; =&gt; 1764</span></span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true"></a>(square <span class="fl">2.0</span>) <span class="co">;; =&gt; 4.0</span></span></code></pre></div>
<p>(sqrt <strong>z</strong>)  inexact library procedure Returns the principal square root of <em>z</em>. The result will have either a positive real part, or a zero real part and a non-negative imaginary part.</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true"></a>(<span class="kw">sqrt</span> <span class="dv">9</span>) <span class="co">;; =&gt; 3</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true"></a>(<span class="kw">sqrt</span> <span class="dv">-1</span>) <span class="co">;; =&gt; +i</span></span></code></pre></div>
<p>(exact-integer-sqrt <em>k</em>)  procedure Returns two non-negative exact integers <em>s</em> and <em>r</em> where <span class="math inline"><span class="math inline">$\\hbox{\\it{}k\\/} = s^2 + r$</span></span> and <span class="math inline"><span class="math inline">$\\hbox{\\it{}k\\/} \&lt; (s+1)^2$</span></span>.</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true"></a>(exact-integer-sqrt <span class="dv">4</span>) <span class="co">;; =&gt; 2 0</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true"></a>(exact-integer-sqrt <span class="dv">5</span>) <span class="co">;; =&gt; 2 1</span></span></code></pre></div>
<blockquote>
<p>(expt **z<em><sub>1</sub> </em>z<em><sub>2</sub></em>)  procedure</p>
</blockquote>
<p>Returns <em>z</em><sub>1</sub> raised to the power <em>z</em><sub>2</sub>. For nonzero <em>z</em><sub>1</sub>, this is <em>z</em><sub>1</sub><sup><em>z</em><sub>2</sub></sup> = <em>e</em><sup><em>z</em><sub>2</sub>log <em>z</em><sub>1</sub></sup> The value of 0<sup><em>z</em></sup> is 1 if (zero? z), 0 if (real-part z) is positive, and an error otherwise. Similarly for 0.0<sup><em>z</em></sup>, with inexact results.</p>
<blockquote>
<p>(make-rectangular **x<em><sub>1</sub> </em>x<em><sub>2</sub></em>) complex library procedure</p>
</blockquote>
<blockquote>
<p>(make-polar **x<em><sub>3</sub> </em>x<em><sub>4</sub></em>)  complex library procedure</p>
</blockquote>
<blockquote>
<p>(real-part <strong>z</strong>)  complex library procedure</p>
</blockquote>
<blockquote>
<p>(imag-part <strong>z</strong>)  complex library procedure</p>
</blockquote>
<blockquote>
<p>(magnitude <strong>z</strong>)  complex library procedure</p>
</blockquote>
<blockquote>
<p>(angle <strong>z</strong>)  complex library procedure</p>
</blockquote>
<p>Let <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>, and <em>x</em><sub>4</sub> be real numbers and <em>z</em> be a complex number such that <span class="math display"><span class="math display">$${\\hbox{$z$\\/}} = {\\hbox{$x_1$\\/}} +
{\\hbox{$x_2$\\/}}\\hbox{$i$} = {\\hbox{$x_3$\\/}} \\cdot e^{i
x_4}$$</span></span> Then all of</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true"></a>(<span class="kw">make-rectangular</span> \vri{x} \vrii{x}) <span class="co">;; =&gt; \vr{z}</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true"></a>(<span class="kw">make-polar</span> \vriii{x} \vriv{x}) <span class="co">;; =&gt; \vr{z}</span></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true"></a>(<span class="kw">real-part</span> \vr{z}) <span class="co">;; =&gt; \vri{x}</span></span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true"></a>(<span class="kw">imag-part</span> \vr{z}) <span class="co">;; =&gt; \vrii{x}</span></span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true"></a>(<span class="kw">magnitude</span> \vr{z}) <span class="co">;; =&gt; $|\vriii{x}|$</span></span>
<span id="cb165-6"><a href="#cb165-6" aria-hidden="true"></a>(<span class="kw">angle</span> \vr{z}) <span class="co">;; =&gt; $x_{angle}$</span></span></code></pre></div>
<p>are true, where  − <em>π</em> ≤ <em>x</em><sub><em>a<strong>n</strong>g<strong>l</strong>e</em></sub> ≤ <em>π</em> with <span class="math inline"><span class="math inline">$x_{angle} = {\\hbox{$</span>x_4<span class="math inline">$\\/}} + 2\\pi n$</span></span> for some integer <em>n</em>.</p>
<p>The make-polar procedure may return an inexact complex number even if its arguments are exact. The real-part and imag-part procedures may return exact real numbers when applied to an inexact complex number if the corresponding argument passed to make-rectangular was exact.</p>
<p><em>Rationale:</em> The magnitude procedure is the same as <code>abs</code> for a real argument, but abs is in the base library, whereas magnitude is in the optional complex library.</p>
<blockquote>
<p>(inexact <strong>z</strong>)  procedure</p>
</blockquote>
<blockquote>
<p>(exact <strong>z</strong>)  procedure</p>
</blockquote>
<p>The procedure inexact returns an inexact representation of <em>z</em>. The value returned is the inexact number that is numerically closest to the argument. For inexact arguments, the result is the same as the argument. For exact complex numbers, the result is a complex number whose real and imaginary parts are the result of applying inexact to the real and imaginary parts of the argument, respectively. If an exact argument has no reasonably close inexact equivalent (in the sense of =), then a violation of an implementation restriction may be reported.</p>
<p>The procedure exact returns an exact representation of <em>z</em>. The value returned is the exact number that is numerically closest to the argument. For exact arguments, the result is the same as the argument. For inexact non-integral real arguments, the implementation may return a rational approximation, or may report an implementation violation. For inexact complex arguments, the result is a complex number whose real and imaginary parts are the result of applying exact to the real and imaginary parts of the argument, respectively. If an inexact argument has no reasonably close exact equivalent, (in the sense of =), then a violation of an implementation restriction may be reported.</p>
<p>These procedures implement the natural one-to-one correspondence between exact and inexact integers throughout an implementation-dependent range. See section <a href="#restrictions">[restrictions]</a>.</p>
<p><em>Note:</em> These procedures were known in R<sup><small>5</small></sup>RS as exact-&gt;inexact and inexact-&gt;exact, respectively, but they have always accepted arguments of any exactness. The new names are clearer and shorter, as well as being compatible with R<sup><small>6</small></sup>RS.</p>
<h4 id="numerical-input-and-output">Numerical input and output</h4>
<blockquote>
<p>(number-&gt;string <em>z</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(number-&gt;string <em>z radix</em>)  procedure</p>
</blockquote>
<p>It is an error if <em>r<strong>a</strong>d<strong>i</strong>x</em> is not one of 2, 8, 10, or 16.</p>
<p>The procedure numberstring takes a number and a radix and returns as a string an external representation of the given number in the given radix such that</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true"></a>(<span class="kw">let</span> ((number \vr{number})</span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true"></a>      (radix \vr{radix}))</span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true"></a>  (<span class="kw">eqv?</span> number</span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true"></a>        (<span class="kw">string-&gt;number</span> (<span class="kw">number-&gt;string</span> number</span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true"></a>                                        radix)</span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true"></a>                        radix)))</span></code></pre></div>
<p>is true. It is an error if no possible result makes this expression true. If omitted, <em>r<strong>a</strong>d<strong>i</strong>x</em> defaults to 10.</p>
<p>If <em>z</em> is inexact, the radix is 10, and the above expression can be satisfied by a result that contains a decimal point, then the result contains a decimal point and is expressed using the minimum number of digits (exclusive of exponent and trailing zeroes) needed to make the above expression true <span class="citation" data-cites="howtoprint howtoread"></span>; otherwise the format of the result is unspecified.</p>
<p>The result returned by numberstring never contains an explicit radix prefix.</p>
<p><em>Note:</em> The error case can occur only when <em>z</em> is not a complex number or is a complex number with a non-rational real or imaginary part.</p>
<p><em>Rationale:</em> If <em>z</em> is an inexact number and the radix is 10, then the above expression is normally satisfied by a result containing a decimal point. The unspecified case allows for infinities, NaNs, and unusual representations.</p>
<blockquote>
<p>(string-&gt;number <em>string</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(string-&gt;number <em>string radix</em>)  procedure</p>
</blockquote>
<p>Returns a number of the maximally precise representation expressed by the given *s<strong>t</strong>r<strong>i</strong>n<strong>g<em>. It is an error if </em>r</strong>a<strong>d</strong>i**x* is not 2, 8, 10, or 16.</p>
<p>If supplied, <em>r<strong>a</strong>d<strong>i</strong>x</em> is a default radix that will be overridden if an explicit radix prefix is present in *s<strong>t</strong>r<strong>i</strong>n**g* (e.g. <code>"#o177"</code>). If <em>r<strong>a</strong>d<strong>i</strong>x</em> is not supplied, then the default radix is 10. If *s<strong>t</strong>r<strong>i</strong>n**g* is not a syntactically valid notation for a number, or would result in a number that the implementation cannot represent, then string-&gt;number returns #f. An error is never signaled due to the content of *s<strong>t</strong>r<strong>i</strong>n**g*.</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true"></a>(<span class="kw">string-&gt;number</span> <span class="st">&quot;100&quot;</span>) <span class="co">;; =&gt; 100</span></span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true"></a>(<span class="kw">string-&gt;number</span> <span class="st">&quot;100&quot;</span> <span class="dv">16</span>) <span class="co">;; =&gt; 256</span></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true"></a>(<span class="kw">string-&gt;number</span> <span class="st">&quot;1e2&quot;</span>) <span class="co">;; =&gt; 100.0</span></span></code></pre></div>
<p><em>Note:</em> The domain of string-&gt;number may be restricted by implementations in the following ways. If all numbers supported by an implementation are real, then string-&gt;number is permitted to return #f whenever *s<strong>t</strong>r<strong>i</strong>n**g* uses the polar or rectangular notations for complex numbers. If all numbers are integers, then string-&gt;number may return <code>#f</code> whenever the fractional notation is used. If all numbers are exact, then string-&gt;number may return <code>#f</code> whenever an exponent marker or explicit exactness prefix is used. If all inexact numbers are integers, then string-&gt;number may return <code>#f</code> whenever a decimal point is used.</p>
<p>The rules used by a particular implementation for string-&gt;number must also be applied to read and to the routine that reads programs, in order to maintain consistency between internal numeric processing, I/O, and the processing of programs. As a consequence, the R<sup><small>5</small></sup>RS permission to return <code>#f</code> when <em>string</em> has an explicit radix prefix has been withdrawn.</p>
<h3 id="booleans">Booleans</h3>
<p>The standard boolean objects for true and false are written as <code>#t</code> and #f. Alternatively, they can be written #true and #false, respectively. What really matters, though, are the objects that the Scheme conditional expressions (if, cond, and, or, when, unless, do) treat as true or false. The phrase “a true value” (or sometimes just “true”) means any object treated as true by the conditional expressions, and the phrase “a false value” (or “false”) means any object treated as false by the conditional expressions.</p>
<p>Of all the Scheme values, only <code>#f</code> counts as false in conditional expressions. All other Scheme values, including #t, count as true.</p>
<p><em>Note:</em> Unlike some other dialects of Lisp, Scheme distinguishes <code>#f</code> and the empty list from each other and from the symbol <code>nil</code>.</p>
<p>Boolean constants evaluate to themselves, so they do not need to be quoted in programs.</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true"></a><span class="dv">#t</span> <span class="co">;; =&gt; #t</span></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true"></a><span class="dv">#f</span> <span class="co">;; =&gt; #f</span></span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true"></a>&#39;<span class="dv">#f</span> <span class="co">;; =&gt; #f</span></span></code></pre></div>
<blockquote>
<p>(not <em>obj</em>)  procedure</p>
</blockquote>
<p>The not procedure returns <code>#t</code> if <em>obj</em> is false, and returns #f otherwise.</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true"></a>(<span class="kw">not</span> <span class="dv">#t</span>) <span class="co">;; =&gt; #f</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true"></a>(<span class="kw">not</span> <span class="dv">3</span>) <span class="co">;; =&gt; #f</span></span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true"></a>(<span class="kw">not</span> (<span class="kw">list</span> <span class="dv">3</span>)) <span class="co">;; =&gt; #f</span></span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true"></a>(<span class="kw">not</span> <span class="dv">#f</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true"></a>(<span class="kw">not</span> &#39;()) <span class="co">;; =&gt; #f</span></span>
<span id="cb169-6"><a href="#cb169-6" aria-hidden="true"></a>(<span class="kw">not</span> (<span class="kw">list</span>)) <span class="co">;; =&gt; #f</span></span>
<span id="cb169-7"><a href="#cb169-7" aria-hidden="true"></a>(<span class="kw">not</span> &#39;nil) <span class="co">;; =&gt; #f</span></span></code></pre></div>
<blockquote>
<p>(boolean? <em>obj</em>)  procedure</p>
</blockquote>
<p>The boolean? predicate returns <code>#t</code> if <em>obj</em> is either <code>#t</code> or <code>#f</code> and returns <code>#f</code> otherwise.</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true"></a>(<span class="kw">boolean?</span> <span class="dv">#f</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true"></a>(<span class="kw">boolean?</span> <span class="dv">0</span>) <span class="co">;; =&gt; #f</span></span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true"></a>(<span class="kw">boolean?</span> &#39;()) <span class="co">;; =&gt; #f</span></span></code></pre></div>
<blockquote>
<p>(boolean=? **boolean<sub>1</sub><em> </em>boolean<sub>2</sub><em> </em>boolean<sub>3</sub><em> … </em>) procedure</p>
</blockquote>
<p>Returns <code>#t</code> if all the arguments are <code>#t</code> or all are #f.</p>
<h3 id="pairs-and-lists">Pairs and lists</h3>
<p>A <em>pair</em> (sometimes called a <em>dotted pair</em>) is a record structure with two fields called the car and cdr fields (for historical reasons). Pairs are created by the procedure cons. The car and cdr fields are accessed by the procedures car and cdr. The car and cdr fields are assigned by the procedures set-car! and set-cdr!.</p>
<p>Pairs are used primarily to represent lists. A <em>list</em> can be defined recursively as either the empty list or a pair whose cdr is a list. More precisely, the set of lists is defined as the smallest set <em>X</em> such that</p>
<ul>
<li><p>The empty list is in <em>X</em>.</p></li>
<li><p>If <em>list</em> is in <em>X</em>, then any pair whose cdr field contains <em>list</em> is also in <em>X</em>.</p></li>
</ul>
<p>The objects in the car fields of successive pairs of a list are the elements of the list. For example, a two-element list is a pair whose car is the first element and whose cdr is a pair whose car is the second element and whose cdr is the empty list. The length of a list is the number of elements, which is the same as the number of pairs.</p>
<p>The empty list is a special object of its own type. It is not a pair, it has no elements, and its length is zero.</p>
<p><em>Note:</em> The above definitions imply that all lists have finite length and are terminated by the empty list.</p>
<p>The most general notation (external representation) for Scheme pairs is the “dotted” notation (<em>c<sub>1</sub></em> . <em>c<sub>2</sub></em>) where <em>c<sub>1</sub></em> is the value of the car field and <em>c<sub>2</sub></em> is the value of the cdr field. For example (4 . 5) is a pair whose car is 4 and whose cdr is 5. Note that (4 . 5) is the external representation of a pair, not an expression that evaluates to a pair.</p>
<p>A more streamlined notation can be used for lists: the elements of the list are simply enclosed in parentheses and separated by spaces. The empty list is written <code>()</code>. For example,</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true"></a>(a b c d e)</span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true"></a>(a . (b . (c . (d . (e . ())))))</span></code></pre></div>
<p>are equivalent notations for a list of symbols.</p>
<p>A chain of pairs not ending in the empty list is called an <em>improper list</em>. Note that an improper list is not a list. The list and dotted notations can be combined to represent improper lists:</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true"></a>(a b c . d)</span></code></pre></div>
<p>is equivalent to</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true"></a>(a . (b . (c . d)))</span></code></pre></div>
<p>Whether a given pair is a list depends upon what is stored in the cdr field. When the <code>set-cdr!</code> procedure is used, an object can be a list one moment and not the next:</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> x </span>(<span class="kw">list</span> &#39;a &#39;b &#39;c))</span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> y </span>x)</span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true"></a>y <span class="co">;; =&gt; (a b c)</span></span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true"></a>(<span class="kw">list?</span> y) <span class="co">;; =&gt; #t</span></span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true"></a>(<span class="kw">set-cdr!</span> x <span class="dv">4</span>) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true"></a>x <span class="co">;; =&gt; (a . 4)</span></span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true"></a>(<span class="kw">eqv?</span> x y) <span class="co">;; =&gt; #t</span></span>
<span id="cb175-8"><a href="#cb175-8" aria-hidden="true"></a>y <span class="co">;; =&gt; (a . 4)</span></span>
<span id="cb175-9"><a href="#cb175-9" aria-hidden="true"></a>(<span class="kw">list?</span> y) <span class="co">;; =&gt; #f</span></span>
<span id="cb175-10"><a href="#cb175-10" aria-hidden="true"></a>(<span class="kw">set-cdr!</span> x x) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb175-11"><a href="#cb175-11" aria-hidden="true"></a>(<span class="kw">list?</span> x) <span class="co">;; =&gt; #f</span></span></code></pre></div>
<p>Within literal expressions and representations of objects read by the <code>read</code> procedure, the forms <code>’</code>datum, `<code>datum,</code>,<code>datum, and</code>,@<code>datum denote two-element lists whose first elements are the symbols</code>quote<code>,</code>quasiquote<code>,</code>unquote<code>, and</code>unquote-splicing`, respectively. The second element in each case is datum. This convention is supported so that arbitrary Scheme programs can be represented as lists. That is, according to Scheme’s grammar, every expression is also a datum (see section <a href="#datum">[datum]</a>). Among other things, this permits the use of the read procedure to parse Scheme programs. See section <a href="#externalreps">[externalreps]</a>.</p>
<blockquote>
<p>(pair? <em>obj</em>)  procedure</p>
</blockquote>
<p>The pair? predicate returns <code>#t</code> if <em>obj</em> is a pair, and otherwise returns #f.</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true"></a>(<span class="kw">pair?</span> &#39;(a . b)) <span class="co">;; =&gt; #t</span></span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true"></a>(<span class="kw">pair?</span> &#39;(a b c)) <span class="co">;; =&gt; #t</span></span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true"></a>(<span class="kw">pair?</span> &#39;()) <span class="co">;; =&gt; #f</span></span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true"></a>(<span class="kw">pair?</span> &#39;#(a b)) <span class="co">;; =&gt; #f</span></span></code></pre></div>
<blockquote>
<p>(cons <strong>obj<sub>1</sub><em> </em>obj<sub>2</sub></strong>)  procedure</p>
</blockquote>
<p>Returns a newly allocated pair whose car is <em>obj<sub>1</sub></em> and whose cdr is <em>obj<sub>2</sub></em>. The pair is guaranteed to be different (in the sense of eqv?) from every existing object.</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true"></a>(<span class="kw">cons</span> &#39;a &#39;()) <span class="co">;; =&gt; (a)</span></span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true"></a>(<span class="kw">cons</span> &#39;(a) &#39;(b c d)) <span class="co">;; =&gt; ((a) b c d)</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true"></a>(<span class="kw">cons</span> <span class="st">&quot;a&quot;</span> &#39;(b c)) <span class="co">;; =&gt; (&quot;a&quot; b c)</span></span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true"></a>(<span class="kw">cons</span> &#39;a <span class="dv">3</span>) <span class="co">;; =&gt; (a . 3)</span></span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true"></a>(<span class="kw">cons</span> &#39;(a b) &#39;c) <span class="co">;; =&gt; ((a b) . c)</span></span></code></pre></div>
<blockquote>
<p>(car <em>pair</em>)  procedure</p>
</blockquote>
<p>Returns the contents of the car field of <em>pair</em>. Note that it is an error to take the car of the empty list.</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true"></a>(<span class="kw">car</span> &#39;(a b c)) <span class="co">;; =&gt; a</span></span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true"></a>(<span class="kw">car</span> &#39;((a) b c d)) <span class="co">;; =&gt; (a)</span></span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true"></a>(<span class="kw">car</span> &#39;(<span class="dv">1</span> . <span class="dv">2</span>)) <span class="co">;; =&gt; 1</span></span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true"></a>(<span class="kw">car</span> &#39;()) <span class="co">;; =&gt; error</span></span></code></pre></div>
<blockquote>
<p>(cdr <em>pair</em>)  procedure</p>
</blockquote>
<p>Returns the contents of the cdr field of <em>pair</em>. Note that it is an error to take the cdr of the empty list.</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true"></a>(<span class="kw">cdr</span> &#39;((a) b c d)) <span class="co">;; =&gt; (b c d)</span></span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true"></a>(<span class="kw">cdr</span> &#39;(<span class="dv">1</span> . <span class="dv">2</span>)) <span class="co">;; =&gt; 2</span></span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true"></a>(<span class="kw">cdr</span> &#39;()) <span class="co">;; =&gt; error</span></span></code></pre></div>
<blockquote>
<p>(set-car! <em>pair obj</em>)  procedure</p>
</blockquote>
<p>Stores <em>obj</em> in the car field of <em>pair</em>.</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(f) (<span class="kw">list</span> &#39;not-a-constant-list))</span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(g) &#39;(constant-list))</span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true"></a>(<span class="kw">set-car!</span> (f) <span class="dv">3</span>) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true"></a>(<span class="kw">set-car!</span> (g) <span class="dv">3</span>) <span class="co">;; =&gt; error</span></span></code></pre></div>
<blockquote>
<p>(set-cdr! <em>pair obj</em>)  procedure</p>
</blockquote>
<p>Stores <em>obj</em> in the cdr field of <em>pair</em>.</p>
<blockquote>
<p><code>(cadr pair)</code> procedure</p>
</blockquote>
<blockquote>
<p>(caar <em>pair</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(cadr <em>pair</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(cdar <em>pair</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(cddr <em>pair</em>)  procedure</p>
</blockquote>
<p>These procedures are compositions of car and cdr as follows:</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">caar</span> x) (<span class="kw">car</span> (<span class="kw">car</span> x)))</span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">cadr</span> x) (<span class="kw">car</span> (<span class="kw">cdr</span> x)))</span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">cdar</span> x) (<span class="kw">cdr</span> (<span class="kw">car</span> x)))</span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">cddr</span> x) (<span class="kw">cdr</span> (<span class="kw">cdr</span> x)))</span></code></pre></div>
<blockquote>
<p>(caaar <em>pair</em>)  cxr library procedure</p>
</blockquote>
<blockquote>
<p>(caadr <em>pair</em>)  cxr library procedure</p>
</blockquote>
<blockquote>
<p>(cdddar <em>pair</em>)  cxr library procedure</p>
</blockquote>
<blockquote>
<p>(cddddr <em>pair</em>)  cxr library procedure</p>
</blockquote>
<p>These twenty-four procedures are further compositions of car and cdr on the same principles. For example, caddr could be defined by</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> caddr </span>(<span class="kw">lambda</span> (x) (<span class="kw">car</span> (<span class="kw">cdr</span> (<span class="kw">cdr</span> x)))))</span></code></pre></div>
<p>Arbitrary compositions up to four deep are provided.</p>
<blockquote>
<p>(null? <em>obj</em>)  procedure</p>
</blockquote>
<p>Returns <code>#t</code> if <em>obj</em> is the empty list, otherwise returns #f.</p>
<blockquote>
<p>(list? <em>obj</em>)  procedure</p>
</blockquote>
<p>Returns <code>#t</code> if <em>obj</em> is a list. Otherwise, it returns #f. By definition, all lists have finite length and are terminated by the empty list.</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true"></a>(<span class="kw">list?</span> &#39;(a b c)) <span class="co">;; =&gt; #t</span></span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true"></a>(<span class="kw">list?</span> &#39;()) <span class="co">;; =&gt; #t</span></span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true"></a>(<span class="kw">list?</span> &#39;(a . b)) <span class="co">;; =&gt; #f</span></span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true"></a>(<span class="kw">let</span> ((x (<span class="kw">list</span> &#39;a)))</span>
<span id="cb183-5"><a href="#cb183-5" aria-hidden="true"></a>  (<span class="kw">set-cdr!</span> x x)</span>
<span id="cb183-6"><a href="#cb183-6" aria-hidden="true"></a>  (<span class="kw">list?</span> x)) <span class="co">;; =&gt; #f</span></span></code></pre></div>
<blockquote>
<p>(make-list <em>k</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(make-list <em>k fill</em>)  procedure</p>
</blockquote>
<p>Returns a newly allocated list of <em>k</em> elements. If a second argument is given, then each element is initialized to <em>fill</em>. Otherwise the initial contents of each element is unspecified.</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true"></a>(make-list <span class="dv">2</span> <span class="dv">3</span>) <span class="co">;; =&gt; (3 3)</span></span></code></pre></div>
<blockquote>
<p>(list **obj<em> … </em>)  procedure</p>
</blockquote>
<p>Returns a newly allocated list of its arguments.</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true"></a>(<span class="kw">list</span> &#39;a (<span class="op">+</span> <span class="dv">3</span> <span class="dv">4</span>) &#39;c) <span class="co">;; =&gt; (a 7 c)</span></span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true"></a>(<span class="kw">list</span>) <span class="co">;; =&gt; ()</span></span></code></pre></div>
<blockquote>
<p>(length <em>list</em>)  procedure</p>
</blockquote>
<p>Returns the length of <em>list</em>.</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true"></a>(<span class="kw">length</span> &#39;(a b c)) <span class="co">;; =&gt; 3</span></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true"></a>(<span class="kw">length</span> &#39;(a (b) (c d e))) <span class="co">;; =&gt; 3</span></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true"></a>(<span class="kw">length</span> &#39;()) <span class="co">;; =&gt; 0</span></span></code></pre></div>
<blockquote>
<p>(append <em>list … </em>)  procedure</p>
</blockquote>
<p>The last argument, if there is one, can be of any type.</p>
<p>Returns a list consisting of the elements of the first <em>list</em> followed by the elements of the other <em>list</em>s. If there are no arguments, the empty list is returned. If there is exactly one argument, it is returned. Otherwise the resulting list is always newly allocated, except that it shares structure with the last argument. An improper list results if the last argument is not a proper list.</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true"></a>(<span class="kw">append</span> &#39;(x) &#39;(y)) <span class="co">;; =&gt; (x y)</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true"></a>(<span class="kw">append</span> &#39;(a) &#39;(b c d)) <span class="co">;; =&gt; (a b c d)</span></span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true"></a>(<span class="kw">append</span> &#39;(a (b)) &#39;((c))) <span class="co">;; =&gt; (a (b) (c))</span></span>
<span id="cb187-4"><a href="#cb187-4" aria-hidden="true"></a></span>
<span id="cb187-5"><a href="#cb187-5" aria-hidden="true"></a>(<span class="kw">append</span> &#39;(a b) &#39;(c . d)) <span class="co">;; =&gt; (a b c . d)</span></span>
<span id="cb187-6"><a href="#cb187-6" aria-hidden="true"></a>(<span class="kw">append</span> &#39;() &#39;a) <span class="co">;; =&gt; a</span></span></code></pre></div>
<blockquote>
<p>(reverse <em>list</em>)  procedure</p>
</blockquote>
<p>Returns a newly allocated list consisting of the elements of <em>list</em> in reverse order.</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true"></a>(<span class="kw">reverse</span> &#39;(a b c)) <span class="co">;; =&gt; (c b a)</span></span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true"></a>(<span class="kw">reverse</span> &#39;(a (b c) d (e (f)))) <span class="co">;; =&gt; ((e (f)) d (b c) a)</span></span></code></pre></div>
<blockquote>
<p>(list-tail <em>list </em>k**)  procedure</p>
</blockquote>
<p>It is an error if <em>list</em> has fewer than <em>k</em> elements.</p>
<p>Returns the sublist of <em>list</em> obtained by omitting the first <em>k</em> elements. The list-tail procedure could be defined by</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> list-tail</span></span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true"></a>  (<span class="kw">lambda</span> (x k)</span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true"></a>    (<span class="kw">if</span> (<span class="kw">zero?</span> k)</span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true"></a>        x</span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true"></a>        (<span class="kw">list-tail</span> (<span class="kw">cdr</span> x) (<span class="op">-</span> k <span class="dv">1</span>)))))</span></code></pre></div>
<blockquote>
<p>(list-ref <em>list </em>k**)  procedure</p>
</blockquote>
<p>The <em>list</em> argument can be circular, but it is an error if <em>list</em> has <em>k</em> or fewer elements.</p>
<p>Returns the <em>k</em>th element of <em>list</em>. (This is the same as the car of <code>(list-tail list k)</code>.)</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true"></a>(<span class="kw">list-ref</span> &#39;(a b c d) <span class="dv">2</span>) <span class="co">;; =&gt; c</span></span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true"></a>(<span class="kw">list-ref</span> &#39;(a b c d)</span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true"></a>          (exact (<span class="kw">round</span> <span class="fl">1.8</span>))) <span class="co">;; =&gt; c</span></span></code></pre></div>
<blockquote>
<p>(list-set! <em>list k obj</em>)  procedure</p>
</blockquote>
<p>It is an error if <em>k</em> is not a valid index of <em>list</em>.</p>
<p>The list-set! procedure stores <em>obj</em> in element <em>k</em> of <em>list</em>.</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true"></a>(<span class="kw">let</span> ((ls (<span class="kw">list</span> &#39;one &#39;two &#39;five!)))</span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true"></a>  (list-set! ls <span class="dv">2</span> &#39;three)</span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true"></a>  ls) <span class="co">;; =&gt; (one two three)</span></span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true"></a></span>
<span id="cb191-5"><a href="#cb191-5" aria-hidden="true"></a>(list-set! &#39;(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="dv">1</span> <span class="st">&quot;oops&quot;</span>) <span class="co">;; =&gt; error  ; constant list</span></span></code></pre></div>
<blockquote>
<p>(memq <em>obj list</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(memv <em>obj list</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(member <em>obj list</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(member <em>obj list compare</em>)  procedure</p>
</blockquote>
<p>These procedures return the first sublist of <em>list</em> whose car is <em>obj</em>, where the sublists of <em>list</em> are the non-empty lists returned by <code>(list-tail list k)</code> for <em>k</em> less than the length of <em>list</em>. If <em>obj</em> does not occur in <em>list</em>, then <code>#f</code> (not the empty list) is returned. The memq procedure uses eq? to compare <em>obj</em> with the elements of <em>list</em>, while memv uses eqv? and member uses <em>compare</em>, if given, and equal? otherwise.</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true"></a>(<span class="kw">memq</span> &#39;a &#39;(a b c)) <span class="co">;; =&gt; (a b c)</span></span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true"></a>(<span class="kw">memq</span> &#39;b &#39;(a b c)) <span class="co">;; =&gt; (b c)</span></span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true"></a>(<span class="kw">memq</span> &#39;a &#39;(b c d)) <span class="co">;; =&gt; #f</span></span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true"></a>(<span class="kw">memq</span> (<span class="kw">list</span> &#39;a) &#39;(b (a) c)) <span class="co">;; =&gt; #f</span></span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true"></a>(<span class="kw">member</span> (<span class="kw">list</span> &#39;a)</span>
<span id="cb192-6"><a href="#cb192-6" aria-hidden="true"></a>        &#39;(b (a) c)) <span class="co">;; =&gt; ((a) c)</span></span>
<span id="cb192-7"><a href="#cb192-7" aria-hidden="true"></a>(<span class="kw">member</span> <span class="st">&quot;B&quot;</span></span>
<span id="cb192-8"><a href="#cb192-8" aria-hidden="true"></a>        &#39;(<span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span> <span class="st">&quot;c&quot;</span>)</span>
<span id="cb192-9"><a href="#cb192-9" aria-hidden="true"></a>        <span class="kw">string-ci=?</span>) <span class="co">;; =&gt; (&quot;b&quot; &quot;c&quot;)</span></span>
<span id="cb192-10"><a href="#cb192-10" aria-hidden="true"></a>(<span class="kw">memq</span> <span class="dv">101</span> &#39;(<span class="dv">100</span> <span class="dv">101</span> <span class="dv">102</span>)) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb192-11"><a href="#cb192-11" aria-hidden="true"></a>(<span class="kw">memv</span> <span class="dv">101</span> &#39;(<span class="dv">100</span> <span class="dv">101</span> <span class="dv">102</span>)) <span class="co">;; =&gt; (101 102)</span></span></code></pre></div>
<blockquote>
<p>(assq <em>obj alist</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(assv <em>obj alist</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(assoc <em>obj alist</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(assoc <em>obj alist compare</em>)  procedure</p>
</blockquote>
<p>It is an error if <em>alist</em> (for “association list”) is not a list of pairs.</p>
<p>These procedures find the first pair in <em>alist</em> whose car field is <em>obj</em>, and returns that pair. If no pair in <em>alist</em> has <em>obj</em> as its car, then <code>#f</code> (not the empty list) is returned. The assq procedure uses eq? to compare <em>obj</em> with the car fields of the pairs in <em>alist</em>, while assv uses eqv? and assoc uses <em>compare</em> if given and equal? otherwise.</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> e </span>&#39;((a <span class="dv">1</span>) (b <span class="dv">2</span>) (c <span class="dv">3</span>)))</span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true"></a>(<span class="kw">assq</span> &#39;a e) <span class="co">;; =&gt; (a 1)</span></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true"></a>(<span class="kw">assq</span> &#39;b e) <span class="co">;; =&gt; (b 2)</span></span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true"></a>(<span class="kw">assq</span> &#39;d e) <span class="co">;; =&gt; #f</span></span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true"></a>(<span class="kw">assq</span> (<span class="kw">list</span> &#39;a) &#39;(((a)) ((b)) ((c))))</span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true"></a><span class="co">;; =&gt; #f</span></span>
<span id="cb193-7"><a href="#cb193-7" aria-hidden="true"></a>(<span class="kw">assoc</span> (<span class="kw">list</span> &#39;a) &#39;(((a)) ((b)) ((c))))</span>
<span id="cb193-8"><a href="#cb193-8" aria-hidden="true"></a><span class="co">;; =&gt; ((a))</span></span>
<span id="cb193-9"><a href="#cb193-9" aria-hidden="true"></a>(<span class="kw">assoc</span> <span class="fl">2.0</span> &#39;((<span class="dv">1</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">4</span>) (<span class="dv">3</span> <span class="dv">9</span>)) <span class="op">=</span>)</span>
<span id="cb193-10"><a href="#cb193-10" aria-hidden="true"></a><span class="co">;; =&gt; (2 4)</span></span>
<span id="cb193-11"><a href="#cb193-11" aria-hidden="true"></a>(<span class="kw">assq</span> <span class="dv">5</span> &#39;((<span class="dv">2</span> <span class="dv">3</span>) (<span class="dv">5</span> <span class="dv">7</span>) (<span class="dv">11</span> <span class="dv">13</span>)))</span>
<span id="cb193-12"><a href="#cb193-12" aria-hidden="true"></a><span class="co">;; =&gt; unspecified</span></span>
<span id="cb193-13"><a href="#cb193-13" aria-hidden="true"></a>(<span class="kw">assv</span> <span class="dv">5</span> &#39;((<span class="dv">2</span> <span class="dv">3</span>) (<span class="dv">5</span> <span class="dv">7</span>) (<span class="dv">11</span> <span class="dv">13</span>)))</span>
<span id="cb193-14"><a href="#cb193-14" aria-hidden="true"></a><span class="co">;; =&gt; (5 7)</span></span></code></pre></div>
<p><em>Rationale:</em> Although they are often used as predicates, memq, memv, member, assq, assv, and assoc do not have question marks in their names because they return potentially useful values rather than just <code>#t</code> or #f.</p>
<blockquote>
<p>(list-copy <em>obj</em>)  procedure</p>
</blockquote>
<p>Returns a newly allocated copy of the given <em>obj</em> if it is a list. Only the pairs themselves are copied; the cars of the result are the same (in the sense of eqv?) as the cars of <em>list</em>. If <em>obj</em> is an improper list, so is the result, and the final cdrs are the same in the sense of eqv?. An <em>obj</em> which is not a list is returned unchanged. It is an error if <em>obj</em> is a circular list.</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> a </span>&#39;(<span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span> <span class="dv">8</span>)) <span class="co">; a may be immutable</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> b </span>(list-copy a))</span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true"></a>(<span class="kw">set-car!</span> b <span class="dv">3</span>)        <span class="co">; b is mutable</span></span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true"></a>b <span class="co">;; =&gt; (3 8 2 8)</span></span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true"></a>a <span class="co">;; =&gt; (1 8 2 8)</span></span></code></pre></div>
<h3 id="symbols">Symbols</h3>
<p>Symbols are objects whose usefulness rests on the fact that two symbols are identical (in the sense of eqv?) if and only if their names are spelled the same way. For instance, they can be used the way enumerated values are used in other languages.</p>
<p>The rules for writing a symbol are exactly the same as the rules for writing an identifier; see sections <a href="#syntaxsection">[syntaxsection]</a> and <a href="#identifiersyntax">[identifiersyntax]</a>.</p>
<p>It is guaranteed that any symbol that has been returned as part of a literal expression, or read using the read procedure, and subsequently written out using the write procedure, will read back in as the identical symbol (in the sense of eqv?).</p>
<p><em>Note:</em> Some implementations have values known as “uninterned symbols,” which defeat write/read invariance, and also violate the rule that two symbols are the same if and only if their names are spelled the same. This report does not specify the behavior of implementation-dependent extensions.</p>
<blockquote>
<p>(symbol? <em>obj</em>)  procedure</p>
</blockquote>
<p>Returns <code>#t</code> if <em>obj</em> is a symbol, otherwise returns #f.</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true"></a>(<span class="kw">symbol?</span> &#39;foo) <span class="co">;; =&gt; #t</span></span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true"></a>(<span class="kw">symbol?</span> (<span class="kw">car</span> &#39;(a b))) <span class="co">;; =&gt; #t</span></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true"></a>(<span class="kw">symbol?</span> <span class="st">&quot;bar&quot;</span>) <span class="co">;; =&gt; #f</span></span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true"></a>(<span class="kw">symbol?</span> &#39;nil) <span class="co">;; =&gt; #t</span></span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true"></a>(<span class="kw">symbol?</span> &#39;()) <span class="co">;; =&gt; #f</span></span>
<span id="cb195-6"><a href="#cb195-6" aria-hidden="true"></a>(<span class="kw">symbol?</span> <span class="dv">#f</span>) <span class="co">;; =&gt; #f</span></span></code></pre></div>
<blockquote>
<p>(symbol=? **symbol<sub>1</sub><em> </em>symbol<sub>2</sub><em> </em>symbol<sub>3</sub><em> … </em>) procedure</p>
</blockquote>
<p>Returns <code>#t</code> if all the arguments all have the same names in the sense of string=?.</p>
<p><em>Note:</em> The definition above assumes that none of the arguments are uninterned symbols.</p>
<blockquote>
<p>(symbol-&gt;string <em>symbol</em>)  procedure</p>
</blockquote>
<p>Returns the name of <em>symbol</em> as a string, but without adding escapes. It is an error to apply mutation procedures like <code>string-set!</code> to strings returned by this procedure.</p>
<div class="sourceCode" id="cb196"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true"></a>(<span class="kw">symbol-&gt;string</span> &#39;flying-fish)</span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true"></a><span class="co">;; =&gt; &quot;flying-fish&quot;</span></span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true"></a>(<span class="kw">symbol-&gt;string</span> &#39;Martin) <span class="co">;; =&gt; &quot;Martin&quot;</span></span>
<span id="cb196-4"><a href="#cb196-4" aria-hidden="true"></a>(<span class="kw">symbol-&gt;string</span></span>
<span id="cb196-5"><a href="#cb196-5" aria-hidden="true"></a> (<span class="kw">string-&gt;symbol</span> <span class="st">&quot;Malvina&quot;</span>))</span>
<span id="cb196-6"><a href="#cb196-6" aria-hidden="true"></a><span class="co">;; =&gt; &quot;Malvina&quot;</span></span></code></pre></div>
<blockquote>
<p>(string-&gt;symbol <em>string</em>)  procedure</p>
</blockquote>
<p>Returns the symbol whose name is <em>string</em>. This procedure can create symbols with names containing special characters that would require escaping when written, but does not interpret escapes in its input.</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true"></a>(<span class="kw">string-&gt;symbol</span> <span class="st">&quot;mISSISSIppi&quot;</span>)  <span class="co">;; =&gt; mISSISSIppi</span></span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true"></a>(<span class="kw">eqv?</span> &#39;bitBlt (<span class="kw">string-&gt;symbol</span> <span class="st">&quot;bitBlt&quot;</span>)) <span class="co">;; =&gt; #t</span></span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true"></a>(<span class="kw">eqv?</span> &#39;LollyPop</span>
<span id="cb197-4"><a href="#cb197-4" aria-hidden="true"></a>      (<span class="kw">string-&gt;symbol</span></span>
<span id="cb197-5"><a href="#cb197-5" aria-hidden="true"></a>       (<span class="kw">symbol-&gt;string</span> &#39;LollyPop))) <span class="co">;; =&gt; #t</span></span>
<span id="cb197-6"><a href="#cb197-6" aria-hidden="true"></a>    (<span class="kw">string=?</span> <span class="st">&quot;K. Harper, M.D.&quot;</span></span>
<span id="cb197-7"><a href="#cb197-7" aria-hidden="true"></a>              (<span class="kw">symbol-&gt;string</span></span>
<span id="cb197-8"><a href="#cb197-8" aria-hidden="true"></a>               (<span class="kw">string-&gt;symbol</span> <span class="st">&quot;K. Harper, M.D.&quot;</span>))) <span class="co">;; =&gt; #t</span></span></code></pre></div>
<h3 id="characters-1">Characters</h3>
<p>Characters are objects that represent printed characters such as letters and digits. All Scheme implementations must support at least the ASCII character repertoire: that is, Unicode characters U+0000 through U+007F. Implementations may support any other Unicode characters they see fit, and may also support non-Unicode characters as well. Except as otherwise specified, the result of applying any of the following procedures to a non-Unicode character is implementation-dependent.</p>
<p>Characters are written using the notation <code>#``'</code>character or <code>#``'</code>character name or <code>#``'</code>xhex scalar value.</p>
<p>The following character names must be supported by all implementations with the given values. Implementations may add other names provided they cannot be interpreted as hex scalar values preceded by x.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">; <span class="roman">U+0007</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">; <span class="roman">U+0008</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">; <span class="roman">U+007F</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">; <span class="roman">U+001B</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">; the linefeed character, <span class="roman">U+000A</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">; the null character, <span class="roman">U+0000</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">; the return character, <span class="roman">U+000D</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">; the preferred way to write a space</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">; the tab character, <span class="roman">U+0009</span></td>
</tr>
</tbody>
</table>
<p>Here are some additional examples:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">; lower case letter</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">; upper case letter</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">; left parenthesis</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">; the space character</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">; <em>λ</em> (if character is supported)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">; <em>ι</em> (if character and name are supported)</td>
</tr>
</tbody>
</table>
<p>Case is significant in <code>#``'</code>character, and in <code>#``'</code>⟨character name⟩, but not in <code>#``'</code>xhex scalar value. If character in <code>#``'</code>character is alphabetic, then any character immediately following character cannot be one that can appear in an identifier. This rule resolves the ambiguous case where, for example, the sequence of characters “<code>#' space</code>” could be taken to be either a representation of the space character or a representation of the character “<code>#' s</code>” followed by a representation of the symbol “<code>pace</code>.”</p>
<p>Characters written in the <code>#``'</code> notation are self-evaluating. That is, they do not have to be quoted in programs.</p>
<p>Some of the procedures that operate on characters ignore the difference between upper case and lower case. The procedures that ignore case have “<code>-ci</code>” (for “case insensitive”) embedded in their names.</p>
<blockquote>
<p>(char? <em>obj</em>)  procedure</p>
</blockquote>
<p>Returns <code>#t</code> if <em>obj</em> is a character, otherwise returns #f.</p>
<blockquote>
<p>(char=? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>) procedure</p>
</blockquote>
<blockquote>
<p>(char&lt;? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>) procedure</p>
</blockquote>
<blockquote>
<p>(char&gt;? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>) procedure</p>
</blockquote>
<blockquote>
<p>(char&lt;=? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>) procedure</p>
</blockquote>
<blockquote>
<p>(char&gt;=? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>) procedure</p>
</blockquote>
<p>These procedures return <code>#t</code> if the results of passing their arguments to charinteger are respectively equal, monotonically increasing, monotonically decreasing, monotonically non-decreasing, or monotonically non-increasing.</p>
<p>These predicates are required to be transitive.</p>
<blockquote>
<p>(char-ci=? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>) char library procedure</p>
</blockquote>
<blockquote>
<p>(char-ci&lt;? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>) char library procedure</p>
</blockquote>
<blockquote>
<p>(char-ci&gt;? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>) char library procedure</p>
</blockquote>
<blockquote>
<p>(char-ci&lt;=? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>) char library procedure</p>
</blockquote>
<blockquote>
<p>(char-ci&gt;=? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>) char library procedure</p>
</blockquote>
<p>These procedures are similar to char=? et cetera, but they treat upper case and lower case letters as the same. For example, (char-ci=? #<code>'</code>A #<code>'</code>a) returns #t.</p>
<p>Specifically, these procedures behave as if char-foldcase were applied to their arguments before they were compared.</p>
<blockquote>
<p>(char-alphabetic? <em>char</em>)  char library procedure</p>
</blockquote>
<blockquote>
<p>(char-numeric? <em>char</em>)  char library procedure</p>
</blockquote>
<blockquote>
<p>(char-whitespace? <em>char</em>)  char library procedure</p>
</blockquote>
<blockquote>
<p>(char-upper-case? <em>letter</em>)  char library procedure</p>
</blockquote>
<blockquote>
<p>(char-lower-case? <em>letter</em>)  char library procedure</p>
</blockquote>
<p>These procedures return <code>#t</code> if their arguments are alphabetic, numeric, whitespace, upper case, or lower case characters, respectively, otherwise they return #f.</p>
<p>Specifically, they must return <code>#t</code> when applied to characters with the Unicode properties Alphabetic, Numeric_Type=Decimal, White_Space, Uppercase, and Lowercase respectively, and <code>#f</code> when applied to any other Unicode characters. Note that many Unicode characters are alphabetic but neither upper nor lower case.</p>
<blockquote>
<p>(digit-value <em>char</em>)  char library procedure</p>
</blockquote>
<p>This procedure returns the numeric value (0 to 9) of its argument if it is a numeric digit (that is, if char-numeric? returns #t), or <code>#f</code> on any other character.</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true"></a>(digit-value <span class="ch">#\3</span>) <span class="co">;; =&gt; 3</span></span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true"></a>(digit-value <span class="ch">#\x</span>0664) <span class="co">;; =&gt; 4</span></span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true"></a>(digit-value <span class="ch">#\x</span>0AE6) <span class="co">;; =&gt; 0</span></span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true"></a>(digit-value <span class="ch">#\x</span>0EA6) <span class="co">;; =&gt; #f</span></span></code></pre></div>
<blockquote>
<p>(char-&gt;integer <em>char</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(integer-&gt;char <strong>n</strong>)  procedure</p>
</blockquote>
<p>Given a Unicode character, charinteger returns an exact integer between 0 and <code>#xD7FF</code> or between <code>#xE000</code> and <code>#x10FFFF</code> which is equal to the Unicode scalar value of that character. Given a non-Unicode character, it returns an exact integer greater than <code>#x10FFFF</code>. This is true independent of whether the implementation uses the Unicode representation internally.</p>
<p>Given an exact integer that is the value returned by a character when charinteger is applied to it, integerchar returns that character.</p>
<blockquote>
<p>(char-upcase <em>char</em>)  char library procedure</p>
</blockquote>
<blockquote>
<p>(char-downcase <em>char</em>)  char library procedure</p>
</blockquote>
<blockquote>
<p>(char-foldcase <em>char</em>)  char library procedure</p>
</blockquote>
<p>The char-upcase procedure, given an argument that is the lowercase part of a Unicode casing pair, returns the uppercase member of the pair, provided that both characters are supported by the Scheme implementation. Note that language-sensitive casing pairs are not used. If the argument is not the lowercase member of such a pair, it is returned.</p>
<p>The char-downcase procedure, given an argument that is the uppercase part of a Unicode casing pair, returns the lowercase member of the pair, provided that both characters are supported by the Scheme implementation. Note that language-sensitive casing pairs are not used. If the argument is not the uppercase member of such a pair, it is returned.</p>
<p>The char-foldcase procedure applies the Unicode simple case-folding algorithm to its argument and returns the result. Note that language-sensitive folding is not used. If the character that results from folding is not supported by the implementation, the argument is returned. See UAX #44 <span class="citation" data-cites="uax44"></span> (part of the Unicode Standard) for details.</p>
<p>Note that many Unicode lowercase characters do not have uppercase equivalents.</p>
<h3 id="strings">Strings</h3>
<p>Strings are sequences of characters. Strings are written as sequences of characters enclosed within quotation marks ("). Within a string literal, various escape sequences represent characters other than themselves. Escape sequences always start with a backslash (<code>'</code>):</p>
<ul>
<li><p><code>'</code>a : alarm, U+0007</p></li>
<li><p><code>'</code>b : backspace, U+0008</p></li>
<li><p><code>'</code>t : character tabulation, U+0009</p></li>
<li><p><code>'</code>n : linefeed, U+000A</p></li>
<li><p><code>'</code>r : return, U+000D</p></li>
<li><p><code>' ``"</code> : double quote, U+0022</p></li>
<li><p><code>' ``'</code> : backslash, U+005C</p></li>
<li><p><code>'</code>| : vertical line, U+007C</p></li>
<li><p><code>'</code>intraline whitespaceline ending intraline whitespace : nothing</p></li>
<li><p><code>'</code>xhex scalar value; : specified character (note the terminating semi-colon).</p></li>
</ul>
<p>The result is unspecified if any other character in a string occurs after a backslash.</p>
<p>Except for a line ending, any character outside of an escape sequence stands for itself in the string literal. A line ending which is preceded by <code>'</code>intraline whitespace expands to nothing (along with any trailing intraline whitespace), and can be used to indent strings for improved legibility. Any other line ending has the same effect as inserting a <code>'</code>n character into the string.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true"></a><span class="st">&quot;The word </span><span class="ch">\&quot;</span><span class="st">recursion</span><span class="ch">\&quot;</span><span class="st"> has many meanings.&quot;</span></span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true"></a><span class="st">&quot;Another example:\ntwo lines of text&quot;</span></span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true"></a><span class="st">&quot;Here&#39;s text \</span></span>
<span id="cb199-4"><a href="#cb199-4" aria-hidden="true"></a><span class="st">       containing just one line&quot;</span></span>
<span id="cb199-5"><a href="#cb199-5" aria-hidden="true"></a><span class="st">&quot;\x03B1; is named GREEK SMALL LETTER ALPHA.&quot;</span></span></code></pre></div>
<p>The <em>length</em> of a string is the number of characters that it contains. This number is an exact, non-negative integer that is fixed when the string is created. The <em>valid indexes</em> of a string are the exact non-negative integers less than the length of the string. The first character of a string has index 0, the second has index 1, and so on.</p>
<p>Some of the procedures that operate on strings ignore the difference between upper and lower case. The names of the versions that ignore case end with “-ci” (for “case insensitive”).</p>
<p>Implementations may forbid certain characters from appearing in strings. However, with the exception of <code>#' null</code>, ASCII characters must not be forbidden. For example, an implementation might support the entire Unicode repertoire, but only allow characters U+0001 to U+00FF (the Latin-1 repertoire without <code>#' null</code>) in strings.</p>
<p>It is an error to pass such a forbidden character to make-string, string, string-set!, or string-fill!, as part of the list passed to liststring, or as part of the vector passed to vectorstring (see section <a href="#vectortostring">[vectortostring]</a>), or in UTF-8 encoded form within a bytevector passed to utf8string (see section <a href="#utf8tostring">[utf8tostring]</a>). It is also an error for a procedure passed to string-map (see section <a href="#stringmap">[stringmap]</a>) to return a forbidden character, or for read-string (see section <a href="#readstring">[readstring]</a>) to attempt to read one.</p>
<blockquote>
<p>(string? <em>obj</em>)  procedure</p>
</blockquote>
<p>Returns <code>#t</code> if <em>obj</em> is a string, otherwise returns #f.</p>
<blockquote>
<p>(make-string <strong>k</strong>)  procedure</p>
</blockquote>
<blockquote>
<p>(make-string **k<em> char</em>)  procedure</p>
</blockquote>
<p>The make-string procedure returns a newly allocated string of length <em>k</em>. If <em>char</em> is given, then all the characters of the string are initialized to <em>char</em>, otherwise the contents of the string are unspecified.</p>
<blockquote>
<p>(string <em>char … </em>)  procedure</p>
</blockquote>
<p>Returns a newly allocated string composed of the arguments. It is analogous to list.</p>
<blockquote>
<p>(string-length <em>string</em>)  procedure</p>
</blockquote>
<p>Returns the number of characters in the given <em>string</em>.</p>
<blockquote>
<p>(string-ref <em>string </em>k**)  procedure</p>
</blockquote>
<p>It is an error if <em>k</em> is not a valid index of <em>string</em>.</p>
<p>The string-ref procedure returns character <em>k</em> of <em>string</em> using zero-origin indexing. There is no requirement for this procedure to execute in constant time.</p>
<blockquote>
<p>(string-set! <em>string k char</em>)  procedure</p>
</blockquote>
<p>It is an error if <em>k</em> is not a valid index of <em>string</em>.</p>
<p>The string-set! procedure stores <em>char</em> in element <em>k</em> of <em>string</em>. There is no requirement for this procedure to execute in constant time.</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(f) (<span class="kw">make-string</span> <span class="dv">3</span> <span class="ch">#\*</span>))</span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(g) <span class="st">&quot;***&quot;</span>)</span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true"></a>(<span class="kw">string-set!</span> (f) <span class="dv">0</span> <span class="ch">#\?</span>) <span class="co">;; =&gt; unspecified</span></span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true"></a>(<span class="kw">string-set!</span> (g) <span class="dv">0</span> <span class="ch">#\?</span>) <span class="co">;; =&gt; error</span></span>
<span id="cb200-5"><a href="#cb200-5" aria-hidden="true"></a>(<span class="kw">string-set!</span> (<span class="kw">symbol-&gt;string</span> &#39;immutable)</span>
<span id="cb200-6"><a href="#cb200-6" aria-hidden="true"></a>             <span class="dv">0</span></span>
<span id="cb200-7"><a href="#cb200-7" aria-hidden="true"></a>             <span class="ch">#\?</span>) <span class="co">;; =&gt; error</span></span></code></pre></div>
<blockquote>
<p>(string=? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>) procedure</p>
</blockquote>
<p>Returns <code>#t</code> if all the strings are the same length and contain exactly the same characters in the same positions, otherwise returns #f.</p>
<blockquote>
<p>(string-ci=? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>) char library procedure</p>
</blockquote>
<p>Returns <code>#t</code> if, after case-folding, all the strings are the same length and contain the same characters in the same positions, otherwise returns #f. Specifically, these procedures behave as if string-foldcase were applied to their arguments before comparing them.</p>
<blockquote>
<p>(string&lt;? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>) procedure</p>
</blockquote>
<blockquote>
<p>(string-ci&lt;? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>) char library procedure</p>
</blockquote>
<blockquote>
<p>(string&gt;? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>) procedure</p>
</blockquote>
<blockquote>
<p>(string-ci&gt;? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>) char library procedure</p>
</blockquote>
<blockquote>
<p>(string&lt;=? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>) procedure</p>
</blockquote>
<blockquote>
<p>(string-ci&lt;=? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>) char library procedure</p>
</blockquote>
<blockquote>
<p>(string&gt;=? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>) procedure</p>
</blockquote>
<blockquote>
<p>(string-ci&gt;=? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>) char library procedure</p>
</blockquote>
<p>These procedures return <code>#t</code> if their arguments are (respectively): monotonically increasing, monotonically decreasing, monotonically non-decreasing, or monotonically non-increasing.</p>
<p>These predicates are required to be transitive.</p>
<p>These procedures compare strings in an implementation-defined way. One approach is to make them the lexicographic extensions to strings of the corresponding orderings on characters. In that case, string&lt;? would be the lexicographic ordering on strings induced by the ordering char&lt;? on characters, and if the two strings differ in length but are the same up to the length of the shorter string, the shorter string would be considered to be lexicographically less than the longer string. However, it is also permitted to use the natural ordering imposed by the implementation’s internal representation of strings, or a more complex locale-specific ordering.</p>
<p>In all cases, a pair of strings must satisfy exactly one of string&lt;?, string=?, and string&gt;?, and must satisfy string&lt;=? if and only if they do not satisfy string&gt;? and string&gt;=? if and only if they do not satisfy string&lt;?.</p>
<p>The “<code>-ci</code>” procedures behave as if they applied string-foldcase to their arguments before invoking the corresponding procedures without “<code>-ci</code>”.</p>
<blockquote>
<p>(string-upcase <em>string</em>)  char library procedure</p>
</blockquote>
<blockquote>
<p>(string-downcase <em>string</em>)  char library procedure</p>
</blockquote>
<blockquote>
<p>(string-foldcase <em>string</em>)  char library procedure</p>
</blockquote>
<p>These procedures apply the Unicode full string uppercasing, lowercasing, and case-folding algorithms to their arguments and return the result. In certain cases, the result differs in length from the argument. If the result is equal to the argument in the sense of string=?, the argument may be returned. Note that language-sensitive mappings and foldings are not used.</p>
<p>The Unicode Standard prescribes special treatment of the Greek letter <em>Σ</em>, whose normal lower-case form is <em>σ</em> but which becomes ς at the end of a word. See UAX #44 <span class="citation" data-cites="uax44"></span> (part of the Unicode Standard) for details. However, implementations of string-downcase are not required to provide this behavior, and may choose to change <em>Σ</em> to <em>σ</em> in all cases.</p>
<blockquote>
<p>(substring <em>string start end</em>)  procedure</p>
</blockquote>
<p>The substring procedure returns a newly allocated string formed from the characters of <em>string</em> beginning with index <em>start</em> and ending with index <em>end</em>. This is equivalent to calling string-copy with the same arguments, but is provided for backward compatibility and stylistic flexibility.</p>
<blockquote>
<p>(string-append **string<em> … </em>)  procedure</p>
</blockquote>
<p>Returns a newly allocated string whose characters are the concatenation of the characters in the given strings.</p>
<blockquote>
<p>(string-&gt;list <em>string</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(string-&gt;list <em>string start</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(string-&gt;list <em>string start end</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(list-&gt;string <em>list</em>)  procedure</p>
</blockquote>
<p>It is an error if any element of <em>list</em> is not a character.</p>
<p>The stringlist procedure returns a newly allocated list of the characters of <em>string</em> between <em>start</em> and <em>end</em>. liststring returns a newly allocated string formed from the elements in the list <em>list</em>. In both procedures, order is preserved. stringlist and liststring are inverses so far as equal? is concerned.</p>
<blockquote>
<p>(string-copy <em>string</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(string-copy <em>string start</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(string-copy <em>string start end</em>)  procedure</p>
</blockquote>
<p>Returns a newly allocated copy of the part of the given <em>string</em> between <em>start</em> and <em>end</em>.</p>
<blockquote>
<p>(string-copy! <em>to at from</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(string-copy! <em>to at from start</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(string-copy! <em>to at from start end</em>)  procedure</p>
</blockquote>
<p>It is an error if <em>at</em> is less than zero or greater than the length of <em>to</em>. It is also an error if (- (string-length <em>to</em>) <em>at</em>) is less than (- <em>end</em> <em>start</em>).</p>
<p>Copies the characters of string <em>from</em> between <em>start</em> and <em>end</em> to string <em>to</em>, starting at <em>at</em>. The order in which characters are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary string and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances.</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> a </span><span class="st">&quot;12345&quot;</span>)</span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> b </span>(<span class="kw">string-copy</span> <span class="st">&quot;abcde&quot;</span>))</span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true"></a>(string-copy! b <span class="dv">1</span> a <span class="dv">0</span> <span class="dv">2</span>)</span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true"></a>b <span class="co">;; =&gt; &quot;a12de&quot;</span></span></code></pre></div>
<blockquote>
<p>(string-fill! <em>string fill</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(string-fill! <em>string fill start</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(string-fill! <em>string fill start end</em>)  procedure</p>
</blockquote>
<p>It is an error if <em>fill</em> is not a character.</p>
<p>The string-fill! procedure stores <em>fill</em> in the elements of <em>string</em> between <em>start</em> and <em>end</em>.</p>
<h3 id="vectors">Vectors</h3>
<p>Vectors are heterogeneous structures whose elements are indexed by integers. A vector typically occupies less space than a list of the same length, and the average time needed to access a randomly chosen element is typically less for the vector than for the list.</p>
<p>The <em>length</em> of a vector is the number of elements that it contains. This number is a non-negative integer that is fixed when the vector is created. The <em>valid indexes</em> of a vector are the exact non-negative integers less than the length of the vector. The first element in a vector is indexed by zero, and the last element is indexed by one less than the length of the vector.</p>
<p>Vectors are written using the notation <code>#(obj ...)</code>. For example, a vector of length 3 containing the number zero in element 0, the list (2 2 2 2) in element 1, and the string “Anna” in element 2 can be written as follows:</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true"></a>#(<span class="dv">0</span> (<span class="dv">2</span> <span class="dv">2</span> <span class="dv">2</span> <span class="dv">2</span>) <span class="st">&quot;Anna&quot;</span>)</span></code></pre></div>
<p>Vector constants are self-evaluating, so they do not need to be quoted in programs.</p>
<blockquote>
<p>(vector? <em>obj</em>)  procedure</p>
</blockquote>
<p>Returns <code>#t</code> if <em>obj</em> is a vector; otherwise returns #f.</p>
<blockquote>
<p>(make-vector <em>k</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(make-vector <em>k fill</em>)  procedure</p>
</blockquote>
<p>Returns a newly allocated vector of <em>k</em> elements. If a second argument is given, then each element is initialized to <em>fill</em>. Otherwise the initial contents of each element is unspecified.</p>
<blockquote>
<p>(vector <em>obj … </em>)  procedure</p>
</blockquote>
<p>Returns a newly allocated vector whose elements contain the given arguments. It is analogous to list.</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true"></a>(<span class="kw">vector</span> &#39;a &#39;b &#39;c) <span class="co">;; =&gt; #(a b c)</span></span></code></pre></div>
<blockquote>
<p>(vector-length <em>vector</em>)  procedure</p>
</blockquote>
<p>Returns the number of elements in <em>vector</em> as an exact integer.</p>
<blockquote>
<p>(vector-ref <em>vector k</em>)  procedure</p>
</blockquote>
<p>It is an error if <em>k</em> is not a valid index of <em>vector</em>.</p>
<p>The vector-ref procedure returns the contents of element <em>k</em> of <em>vector</em>.</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true"></a>(<span class="kw">vector-ref</span> &#39;#(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">8</span> <span class="dv">13</span> <span class="dv">21</span>)</span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true"></a>            <span class="dv">5</span>) <span class="co">;; =&gt; 8</span></span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true"></a>(<span class="kw">vector-ref</span> &#39;#(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">8</span> <span class="dv">13</span> <span class="dv">21</span>)</span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true"></a>            (exact</span>
<span id="cb204-5"><a href="#cb204-5" aria-hidden="true"></a>             (<span class="kw">round</span> (* <span class="dv">2</span> (<span class="kw">acos</span> <span class="dv">-1</span>))))) <span class="co">;; =&gt; 13</span></span></code></pre></div>
<blockquote>
<p>(vector-set! <em>vector k obj</em>)  procedure</p>
</blockquote>
<p>It is an error if <em>k</em> is not a valid index of <em>vector</em>.</p>
<p>The vector-set! procedure stores <em>obj</em> in element <em>k</em> of <em>vector</em>.</p>
<div class="sourceCode" id="cb205"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true"></a>(<span class="kw">let</span> ((vec (<span class="kw">vector</span> <span class="dv">0</span> &#39;(<span class="dv">2</span> <span class="dv">2</span> <span class="dv">2</span> <span class="dv">2</span>) <span class="st">&quot;Anna&quot;</span>)))</span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true"></a>  (<span class="kw">vector-set!</span> vec <span class="dv">1</span> &#39;(<span class="st">&quot;Sue&quot;</span> <span class="st">&quot;Sue&quot;</span>))</span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true"></a>  vec) <span class="co">;; =&gt; #(0 (&quot;Sue&quot; &quot;Sue&quot;) &quot;Anna&quot;)</span></span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true"></a></span>
<span id="cb205-5"><a href="#cb205-5" aria-hidden="true"></a>(<span class="kw">vector-set!</span> &#39;#(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="dv">1</span> <span class="st">&quot;doe&quot;</span>) <span class="co">;; =&gt; error  ; constant vector</span></span></code></pre></div>
<blockquote>
<p>(vector-&gt;list <em>vector</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(vector-&gt;list <em>vector start</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(vector-&gt;list <em>vector start end</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(list-&gt;vector <em>list</em>)  procedure</p>
</blockquote>
<p>The vector-&gt;list procedure returns a newly allocated list of the objects contained in the elements of <em>vector</em> between <em>start</em> and <em>end</em>. The list-&gt;vector procedure returns a newly created vector initialized to the elements of the list <em>list</em>.</p>
<p>In both procedures, order is preserved.</p>
<div class="sourceCode" id="cb206"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true"></a>(vector-&gt;list &#39;#(dah dah didah)) <span class="co">;; =&gt; (dah dah didah)</span></span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true"></a>(vector-&gt;list &#39;#(dah dah didah) <span class="dv">1</span> <span class="dv">2</span>) <span class="co">;; =&gt; (dah)</span></span>
<span id="cb206-3"><a href="#cb206-3" aria-hidden="true"></a>(list-&gt;vector &#39;(dididit dah)) <span class="co">;; =&gt; #(dididit dah)</span></span></code></pre></div>
<blockquote>
<p>(vector-&gt;string <em>vector</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(vector-&gt;string <em>vector start</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(vector-&gt;string <em>vector start end</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(string-&gt;vector <em>string</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(string-&gt;vector <em>string start</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(string-&gt;vector <em>string start end</em>)  procedure</p>
</blockquote>
<p>It is an error if any element of <em>vector</em> between <em>start</em> and <em>end</em> is not a character.</p>
<p>The vector-&gt;string procedure returns a newly allocated string of the objects contained in the elements of <em>vector</em> between <em>start</em> and <em>end</em>. The string-&gt;vector procedure returns a newly created vector initialized to the elements of the string <em>string</em> between <em>start</em> and <em>end</em>.</p>
<p>In both procedures, order is preserved.</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true"></a>(string-&gt;vector <span class="st">&quot;ABC&quot;</span>) <span class="co">;; =&gt; #(#\A #\B #\C)</span></span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true"></a>(vector-&gt;string</span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true"></a> #(<span class="ch">#\1</span> <span class="ch">#\2</span> <span class="ch">#\3</span>) <span class="co">;; =&gt; &quot;123&quot;</span></span></code></pre></div>
<blockquote>
<p>(vector-copy <em>vector</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(vector-copy <em>vector start</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(vector-copy <em>vector start end</em>)  procedure</p>
</blockquote>
<p>Returns a newly allocated copy of the elements of the given <em>vector</em> between <em>start</em> and <em>end</em>. The elements of the new vector are the same (in the sense of eqv?) as the elements of the old.</p>
<div class="sourceCode" id="cb208"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> a </span>#(<span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span> <span class="dv">8</span>)) <span class="co">; a may be immutable</span></span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> b </span>(vector-copy a))</span>
<span id="cb208-3"><a href="#cb208-3" aria-hidden="true"></a>(<span class="kw">vector-set!</span> b <span class="dv">0</span> <span class="dv">3</span>)   <span class="co">; b is mutable</span></span>
<span id="cb208-4"><a href="#cb208-4" aria-hidden="true"></a>b <span class="co">;; =&gt; #(3 8 2 8)</span></span>
<span id="cb208-5"><a href="#cb208-5" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> c </span>(vector-copy b <span class="dv">1</span> <span class="dv">3</span>))</span>
<span id="cb208-6"><a href="#cb208-6" aria-hidden="true"></a>c <span class="co">;; =&gt; #(8 2)</span></span></code></pre></div>
<blockquote>
<p>(vector-copy! <em>to at from</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(vector-copy! <em>to at from start</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(vector-copy! <em>to at from start end</em>)  procedure</p>
</blockquote>
<p>It is an error if <em>at</em> is less than zero or greater than the length of <em>to</em>. It is also an error if (- (vector-length <em>to</em>) <em>at</em>) is less than (- <em>end</em> <em>start</em>).</p>
<p>Copies the elements of vector <em>from</em> between <em>start</em> and <em>end</em> to vector <em>to</em>, starting at <em>at</em>. The order in which elements are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary vector and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances.</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> a </span>(<span class="kw">vector</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>))</span>
<span id="cb209-2"><a href="#cb209-2" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> b </span>(<span class="kw">vector</span> <span class="dv">10</span> <span class="dv">20</span> <span class="dv">30</span> <span class="dv">40</span> <span class="dv">50</span>))</span>
<span id="cb209-3"><a href="#cb209-3" aria-hidden="true"></a>(vector-copy! b <span class="dv">1</span> a <span class="dv">0</span> <span class="dv">2</span>)</span>
<span id="cb209-4"><a href="#cb209-4" aria-hidden="true"></a>b <span class="co">;; =&gt; #(10 1 2 40 50)</span></span></code></pre></div>
<blockquote>
<p>(vector-append **vector<em> … </em>)  procedure</p>
</blockquote>
<p>Returns a newly allocated vector whose elements are the concatenation of the elements of the given vectors.</p>
<div class="sourceCode" id="cb210"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true"></a>(vector-append #(a b c) #(d e f)) <span class="co">;; =&gt; #(a b c d e f)</span></span></code></pre></div>
<blockquote>
<p>(vector-fill! <em>vector fill</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(vector-fill! <em>vector fill start</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(vector-fill! <em>vector fill start end</em>)  procedure</p>
</blockquote>
<p>The vector-fill! procedure stores <em>fill</em> in the elements of <em>vector</em> between <em>start</em> and <em>end</em>.</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> a </span>(<span class="kw">vector</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>))</span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true"></a>(<span class="kw">vector-fill!</span> a &#39;smash <span class="dv">2</span> <span class="dv">4</span>)</span>
<span id="cb211-3"><a href="#cb211-3" aria-hidden="true"></a>a <span class="co">;; =&gt; #(1 2 smash smash 5)</span></span></code></pre></div>
<h3 id="bytevectors">Bytevectors</h3>
<p><em>Bytevectors</em> represent blocks of binary data. They are fixed-length sequences of bytes, where a <em>byte</em> is an exact integer in the range from 0 to 255 inclusive. A bytevector is typically more space-efficient than a vector containing the same values.</p>
<p>The <em>length</em> of a bytevector is the number of elements that it contains. This number is a non-negative integer that is fixed when the bytevector is created. The <em>valid indexes</em> of a bytevector are the exact non-negative integers less than the length of the bytevector, starting at index zero as with vectors.</p>
<p>Bytevectors are written using the notation <code>#u8(byte ...)</code>. For example, a bytevector of length 3 containing the byte 0 in element 0, the byte 10 in element 1, and the byte 5 in element 2 can be written as follows:</p>
<div class="sourceCode" id="cb212"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true"></a>#u8(<span class="dv">0</span> <span class="dv">10</span> <span class="dv">5</span>)</span></code></pre></div>
<p>Bytevector constants are self-evaluating, so they do not need to be quoted in programs.</p>
<blockquote>
<p>(bytevector? <em>obj</em>)  procedure</p>
</blockquote>
<p>Returns <code>#t</code> if <em>obj</em> is a bytevector. Otherwise, <code>#f</code> is returned.</p>
<blockquote>
<p>(make-bytevector <em>k</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(make-bytevector <em>k byte</em>)  procedure</p>
</blockquote>
<p>The make-bytevector procedure returns a newly allocated bytevector of length <em>k</em>. If <em>byte</em> is given, then all elements of the bytevector are initialized to <em>byte</em>, otherwise the contents of each element are unspecified.</p>
<div class="sourceCode" id="cb213"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true"></a>(make-bytevector <span class="dv">2</span> <span class="dv">12</span>) <span class="co">;; =&gt; #u8(12 12)</span></span></code></pre></div>
<blockquote>
<p>(bytevector **byte<em> … </em>)  procedure</p>
</blockquote>
<p>Returns a newly allocated bytevector containing its arguments.</p>
<div class="sourceCode" id="cb214"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true"></a>(bytevector <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span>) <span class="co">;; =&gt; #u8(1 3 5 1 3 5)</span></span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true"></a>(bytevector) <span class="co">;; =&gt; #u8()</span></span></code></pre></div>
<blockquote>
<p>(bytevector-length <em>bytevector</em>)  procedure</p>
</blockquote>
<p>Returns the length of <em>bytevector</em> in bytes as an exact integer.</p>
<blockquote>
<p>(bytevector-u8-ref <em>bytevector k</em>)  procedure</p>
</blockquote>
<p>It is an error if <em>k</em> is not a valid index of <em>bytevector</em>.</p>
<p>Returns the <em>k</em>th byte of <em>bytevector</em>.</p>
<div class="sourceCode" id="cb215"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true"></a>(bytevector-u8-ref &#39;#u8(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">8</span> <span class="dv">13</span> <span class="dv">21</span>)</span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true"></a>                   <span class="dv">5</span>) <span class="co">;; =&gt; 8</span></span></code></pre></div>
<blockquote>
<p>(bytevector-u8-set! <em>bytevector k byte</em>)  procedure</p>
</blockquote>
<p>It is an error if <em>k</em> is not a valid index of <em>bytevector</em>.</p>
<p>Stores <em>byte</em> as the <em>k</em>th byte of <em>bytevector</em>.</p>
<div class="sourceCode" id="cb216"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true"></a>(<span class="kw">let</span> ((bv (bytevector <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)))</span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true"></a>  (bytevector-u8-set! bv <span class="dv">1</span> <span class="dv">3</span>)</span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true"></a>  bv) <span class="co">;; =&gt; #u8(1 3 3 4)</span></span></code></pre></div>
<blockquote>
<p>(bytevector-copy <em>bytevector</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(bytevector-copy <em>bytevector start</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(bytevector-copy <em>bytevector start end</em>)  procedure</p>
</blockquote>
<p>Returns a newly allocated bytevector containing the bytes in <em>bytevector</em> between <em>start</em> and <em>end</em>.</p>
<div class="sourceCode" id="cb217"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> a </span>#u8(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>))</span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true"></a>(bytevector-copy a <span class="dv">2</span> <span class="dv">4</span>)) <span class="co">;; =&gt; #u8(3 4)</span></span></code></pre></div>
<blockquote>
<p>(bytevector-copy! <em>to at from</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(bytevector-copy! <em>to at from start</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(bytevector-copy! <em>to at from start end</em>)  procedure</p>
</blockquote>
<p>It is an error if <em>at</em> is less than zero or greater than the length of <em>to</em>. It is also an error if (- (bytevector-length <em>to</em>) <em>at</em>) is less than (- <em>end</em> <em>start</em>).</p>
<p>Copies the bytes of bytevector <em>from</em> between <em>start</em> and <em>end</em> to bytevector <em>to</em>, starting at <em>at</em>. The order in which bytes are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary bytevector and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances.</p>
<div class="sourceCode" id="cb218"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> a </span>(bytevector <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>))</span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> b </span>(bytevector <span class="dv">10</span> <span class="dv">20</span> <span class="dv">30</span> <span class="dv">40</span> <span class="dv">50</span>))</span>
<span id="cb218-3"><a href="#cb218-3" aria-hidden="true"></a>(bytevector-copy! b <span class="dv">1</span> a <span class="dv">0</span> <span class="dv">2</span>)</span>
<span id="cb218-4"><a href="#cb218-4" aria-hidden="true"></a>b <span class="co">;; =&gt; #u8(10 1 2 40 50)</span></span></code></pre></div>
<p><em>Note:</em> This procedure appears in R<sup><small>6</small></sup>RS, but places the source before the destination, contrary to other such procedures in Scheme.</p>
<blockquote>
<p>(bytevector-append **bytevector<em> … </em>)  procedure</p>
</blockquote>
<p>Returns a newly allocated bytevector whose elements are the concatenation of the elements in the given bytevectors.</p>
<div class="sourceCode" id="cb219"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true"></a>(bytevector-append #u8(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span>) #u8(<span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)) <span class="co">;; =&gt; #u8(0 1 2 3 4 5)</span></span></code></pre></div>
<blockquote>
<p>(utf8-&gt;string <em>bytevector</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(utf8-&gt;string <em>bytevector start</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(utf8-&gt;string <em>bytevector start end</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(string-&gt;utf8 <em>string</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(string-&gt;utf8 <em>string start</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(string-&gt;utf8 <em>string start end</em>)  procedure</p>
</blockquote>
<p>It is an error for <em>bytevector</em> to contain invalid UTF-8 byte sequences.</p>
<p>These procedures translate between strings and bytevectors that encode those strings using the UTF-8 encoding. The utf8string procedure decodes the bytes of a bytevector between <em>start</em> and <em>end</em> and returns the corresponding string; the stringutf8 procedure encodes the characters of a string between <em>start</em> and <em>end</em> and returns the corresponding bytevector.</p>
<div class="sourceCode" id="cb220"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true"></a>(utf8-&gt;string #u8(<span class="ch">#x</span><span class="dv">41</span>)) <span class="co">;; =&gt; &quot;A&quot;</span></span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true"></a>(string-&gt;utf8 <span class="st">&quot;λ&quot;</span>) <span class="co">;; =&gt; #u8(#xCE #xBB)</span></span></code></pre></div>
<h3 id="control-features">Control features</h3>
<p>This section describes various primitive procedures which control the flow of program execution in special ways. Procedures in this section that invoke procedure arguments always do so in the same dynamic environment as the call of the original procedure. The procedure? predicate is also described here.</p>
<p>(procedure? <em>obj</em>)  procedure Returns <code>#t</code> if <em>obj</em> is a procedure, otherwise returns #f.</p>
<div class="sourceCode" id="cb221"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true"></a>(<span class="kw">procedure?</span> <span class="kw">car</span>) <span class="co">;; =&gt; #t</span></span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true"></a>(<span class="kw">procedure?</span> &#39;car) <span class="co">;; =&gt; #f</span></span>
<span id="cb221-3"><a href="#cb221-3" aria-hidden="true"></a>(<span class="kw">procedure?</span> (<span class="kw">lambda</span> (x) (* x x)))</span>
<span id="cb221-4"><a href="#cb221-4" aria-hidden="true"></a> <span class="co">;; =&gt; #t</span></span>
<span id="cb221-5"><a href="#cb221-5" aria-hidden="true"></a>(<span class="kw">procedure?</span> &#39;(<span class="kw">lambda</span> (x) (* x x)))</span>
<span id="cb221-6"><a href="#cb221-6" aria-hidden="true"></a><span class="co">;; =&gt; #f</span></span>
<span id="cb221-7"><a href="#cb221-7" aria-hidden="true"></a>(<span class="kw">call-with-current-continuation</span> <span class="kw">procedure?</span>)</span>
<span id="cb221-8"><a href="#cb221-8" aria-hidden="true"></a><span class="co">;; =&gt; #t</span></span></code></pre></div>
<blockquote>
<p>(apply <em>proc </em>arg<sub>1</sub><em> … args</em>)  procedure</p>
</blockquote>
<p>The apply procedure calls <em>proc</em> with the elements of the list <code>(append (list *arg&lt;sub&gt;1&lt;/sub&gt;* … ) *args*)</code> as the actual arguments.</p>
<div class="sourceCode" id="cb222"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true"></a>(apply <span class="op">+</span> (<span class="kw">list</span> <span class="dv">3</span> <span class="dv">4</span>)) <span class="co">;; =&gt; 7</span></span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true"></a></span>
<span id="cb222-3"><a href="#cb222-3" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> compose</span></span>
<span id="cb222-4"><a href="#cb222-4" aria-hidden="true"></a>  (<span class="kw">lambda</span> (f g)</span>
<span id="cb222-5"><a href="#cb222-5" aria-hidden="true"></a>    (<span class="kw">lambda</span> args</span>
<span id="cb222-6"><a href="#cb222-6" aria-hidden="true"></a>      (f (apply g args)))))</span>
<span id="cb222-7"><a href="#cb222-7" aria-hidden="true"></a></span>
<span id="cb222-8"><a href="#cb222-8" aria-hidden="true"></a>((compose <span class="kw">sqrt</span> *) <span class="dv">12</span> <span class="dv">75</span>) <span class="co">;; =&gt; 30</span></span></code></pre></div>
<blockquote>
<p>(map <em>proc </em>list<sub>1</sub><em> </em>list<sub>2</sub><em> … </em>)  procedure</p>
</blockquote>
<p>It is an error if <em>proc</em> does not accept as many arguments as there are <em>list</em>s and return a single value.</p>
<p>The map procedure applies <em>proc</em> element-wise to the elements of the <em>list</em>s and returns a list of the results, in order. If more than one <em>list</em> is given and not all lists have the same length, map terminates when the shortest list runs out. The <em>list</em>s can be circular, but it is an error if all of them are circular. It is an error for <em>proc</em> to mutate any of the lists. The dynamic order in which <em>proc</em> is applied to the elements of the <em>list</em>s is unspecified. If multiple returns occur from map, the values returned by earlier returns are not mutated.</p>
<div class="sourceCode" id="cb223"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true"></a>(map <span class="kw">cadr</span> &#39;((a b) (d e) (g h))) <span class="co">;; =&gt; (b e h)</span></span>
<span id="cb223-2"><a href="#cb223-2" aria-hidden="true"></a></span>
<span id="cb223-3"><a href="#cb223-3" aria-hidden="true"></a>(map (<span class="kw">lambda</span> (n) (<span class="kw">expt</span> n n))</span>
<span id="cb223-4"><a href="#cb223-4" aria-hidden="true"></a>     &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)) <span class="co">;; =&gt; (1 4 27 256 3125)</span></span>
<span id="cb223-5"><a href="#cb223-5" aria-hidden="true"></a></span>
<span id="cb223-6"><a href="#cb223-6" aria-hidden="true"></a>(map <span class="op">+</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) &#39;(<span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span>)) <span class="co">;; =&gt; (5 7 9)</span></span>
<span id="cb223-7"><a href="#cb223-7" aria-hidden="true"></a></span>
<span id="cb223-8"><a href="#cb223-8" aria-hidden="true"></a>(<span class="kw">let</span> ((count <span class="dv">0</span>))</span>
<span id="cb223-9"><a href="#cb223-9" aria-hidden="true"></a>  (map (<span class="kw">lambda</span> (ignored)</span>
<span id="cb223-10"><a href="#cb223-10" aria-hidden="true"></a>         (set! count (<span class="op">+</span> count <span class="dv">1</span>))</span>
<span id="cb223-11"><a href="#cb223-11" aria-hidden="true"></a>         count)</span>
<span id="cb223-12"><a href="#cb223-12" aria-hidden="true"></a>       &#39;(a b))) <span class="co">;; =&gt; (1 2) \var{or} (2 1)</span></span></code></pre></div>
<blockquote>
<p>(string-map <em>proc </em>string<sub>1</sub><em> </em>string<sub>2</sub><em> … </em>) procedure</p>
</blockquote>
<p>It is an error if <em>proc</em> does not accept as many arguments as there are <em>string</em>s and return a single character.</p>
<p>The string-map procedure applies <em>proc</em> element-wise to the elements of the <em>string</em>s and returns a string of the results, in order. If more than one <em>string</em> is given and not all strings have the same length, string-map terminates when the shortest string runs out. The dynamic order in which <em>proc</em> is applied to the elements of the <em>string</em>s is unspecified. If multiple returns occur from string-map, the values returned by earlier returns are not mutated.</p>
<div class="sourceCode" id="cb224"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true"></a>(string-map char-foldcase <span class="st">&quot;AbdEgH&quot;</span>) <span class="co">;; =&gt; &quot;abdegh&quot;</span></span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true"></a></span>
<span id="cb224-3"><a href="#cb224-3" aria-hidden="true"></a>(string-map</span>
<span id="cb224-4"><a href="#cb224-4" aria-hidden="true"></a> (<span class="kw">lambda</span> (c)</span>
<span id="cb224-5"><a href="#cb224-5" aria-hidden="true"></a>   (<span class="kw">integer-&gt;char</span> (<span class="op">+</span> <span class="dv">1</span> (<span class="kw">char-&gt;integer</span> c))))</span>
<span id="cb224-6"><a href="#cb224-6" aria-hidden="true"></a> <span class="st">&quot;HAL&quot;</span>) <span class="co">;; =&gt; &quot;IBM&quot;</span></span>
<span id="cb224-7"><a href="#cb224-7" aria-hidden="true"></a></span>
<span id="cb224-8"><a href="#cb224-8" aria-hidden="true"></a>(string-map</span>
<span id="cb224-9"><a href="#cb224-9" aria-hidden="true"></a> (<span class="kw">lambda</span> (c k)</span>
<span id="cb224-10"><a href="#cb224-10" aria-hidden="true"></a>   ((<span class="kw">if</span> (<span class="kw">eqv?</span> k <span class="ch">#\u</span>) <span class="kw">char-upcase</span> <span class="kw">char-downcase</span>)</span>
<span id="cb224-11"><a href="#cb224-11" aria-hidden="true"></a>    c))</span>
<span id="cb224-12"><a href="#cb224-12" aria-hidden="true"></a> <span class="st">&quot;studlycaps xxx&quot;</span></span>
<span id="cb224-13"><a href="#cb224-13" aria-hidden="true"></a> <span class="st">&quot;ululululul&quot;</span>) <span class="co">;; =&gt; &quot;StUdLyCaPs&quot;</span></span></code></pre></div>
<blockquote>
<p>(vector-map <em>proc </em>vector<sub>1</sub><em> </em>vector<sub>2</sub><em> … </em>) procedure</p>
</blockquote>
<p>It is an error if <em>proc</em> does not accept as many arguments as there are <em>vector</em>s and return a single value.</p>
<p>The vector-map procedure applies <em>proc</em> element-wise to the elements of the <em>vector</em>s and returns a vector of the results, in order. If more than one <em>vector</em> is given and not all vectors have the same length, vector-map terminates when the shortest vector runs out. The dynamic order in which <em>proc</em> is applied to the elements of the <em>vector</em>s is unspecified. If multiple returns occur from vector-map, the values returned by earlier returns are not mutated.</p>
<div class="sourceCode" id="cb225"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true"></a>(vector-map <span class="kw">cadr</span> &#39;#((a b) (d e) (g h))) <span class="co">;; =&gt; #(b e h)</span></span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true"></a></span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true"></a>(vector-map (<span class="kw">lambda</span> (n) (<span class="kw">expt</span> n n))</span>
<span id="cb225-4"><a href="#cb225-4" aria-hidden="true"></a>            &#39;#(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)) <span class="co">;; =&gt; #(1 4 27 256 3125)</span></span>
<span id="cb225-5"><a href="#cb225-5" aria-hidden="true"></a></span>
<span id="cb225-6"><a href="#cb225-6" aria-hidden="true"></a>(vector-map <span class="op">+</span> &#39;#(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) &#39;#(<span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span>)) <span class="co">;; =&gt; #(5 7 9)</span></span>
<span id="cb225-7"><a href="#cb225-7" aria-hidden="true"></a></span>
<span id="cb225-8"><a href="#cb225-8" aria-hidden="true"></a>(<span class="kw">let</span> ((count <span class="dv">0</span>))</span>
<span id="cb225-9"><a href="#cb225-9" aria-hidden="true"></a>  (vector-map</span>
<span id="cb225-10"><a href="#cb225-10" aria-hidden="true"></a>   (<span class="kw">lambda</span> (ignored)</span>
<span id="cb225-11"><a href="#cb225-11" aria-hidden="true"></a>     (set! count (<span class="op">+</span> count <span class="dv">1</span>))</span>
<span id="cb225-12"><a href="#cb225-12" aria-hidden="true"></a>     count)</span>
<span id="cb225-13"><a href="#cb225-13" aria-hidden="true"></a>   &#39;#(a b))) <span class="co">;; =&gt; #(1 2) \var{or} #(2 1)</span></span></code></pre></div>
<blockquote>
<p>(for-each <em>proc </em>list<sub>1</sub><em> </em>list<sub>2</sub><em> … </em>)  procedure</p>
</blockquote>
<p>It is an error if <em>proc</em> does not accept as many arguments as there are <em>list</em>s.</p>
<p>The arguments to for-each are like the arguments to map, but for-each calls <em>proc</em> for its side effects rather than for its values. Unlike map, for-each is guaranteed to call <em>proc</em> on the elements of the <em>list</em>s in order from the first element(s) to the last, and the value returned by for-each is unspecified. If more than one <em>list</em> is given and not all lists have the same length, for-each terminates when the shortest list runs out. The <em>list</em>s can be circular, but it is an error if all of them are circular.</p>
<p>It is an error for <em>proc</em> to mutate any of the lists.</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true"></a>(<span class="kw">let</span> ((v (<span class="kw">make-vector</span> <span class="dv">5</span>)))</span>
<span id="cb226-2"><a href="#cb226-2" aria-hidden="true"></a>  (<span class="kw">for-each</span> (<span class="kw">lambda</span> (i)</span>
<span id="cb226-3"><a href="#cb226-3" aria-hidden="true"></a>              (<span class="kw">vector-set!</span> v i (* i i)))</span>
<span id="cb226-4"><a href="#cb226-4" aria-hidden="true"></a>            &#39;(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))</span>
<span id="cb226-5"><a href="#cb226-5" aria-hidden="true"></a>  v) <span class="co">;; =&gt; #(0 1 4 9 16)</span></span></code></pre></div>
<blockquote>
<p>(string-for-each <em>proc </em>string<sub>1</sub><em> </em>string<sub>2</sub><em> … </em>) procedure</p>
</blockquote>
<p>It is an error if <em>proc</em> does not accept as many arguments as there are <em>string</em>s.</p>
<p>The arguments to string-for-each are like the arguments to string-map, but string-for-each calls <em>proc</em> for its side effects rather than for its values. Unlike string-map, string-for-each is guaranteed to call <em>proc</em> on the elements of the <em>string</em>s in order from the first element(s) to the last, and the value returned by string-for-each is unspecified. If more than one <em>string</em> is given and not all strings have the same length, string-for-each terminates when the shortest string runs out. It is an error for <em>proc</em> to mutate any of the strings.</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true"></a>(<span class="kw">let</span> ((v &#39;()))</span>
<span id="cb227-2"><a href="#cb227-2" aria-hidden="true"></a>  (string-for-each</span>
<span id="cb227-3"><a href="#cb227-3" aria-hidden="true"></a>   (<span class="kw">lambda</span> (c) (set! v (<span class="kw">cons</span> (<span class="kw">char-&gt;integer</span> c) v)))</span>
<span id="cb227-4"><a href="#cb227-4" aria-hidden="true"></a>   <span class="st">&quot;abcde&quot;</span>)</span>
<span id="cb227-5"><a href="#cb227-5" aria-hidden="true"></a>  v) <span class="co">;; =&gt; (101 100 99 98 97)</span></span></code></pre></div>
<blockquote>
<p>(vector-for-each <em>proc </em>vector<sub>1</sub><em> </em>vector<sub>2</sub><em> … </em>) procedure</p>
</blockquote>
<p>It is an error if <em>proc</em> does not accept as many arguments as there are <em>vector</em>s.</p>
<p>The arguments to vector-for-each are like the arguments to vector-map, but vector-for-each calls <em>proc</em> for its side effects rather than for its values. Unlike vector-map, vector-for-each is guaranteed to call <em>proc</em> on the elements of the <em>vector</em>s in order from the first element(s) to the last, and the value returned by vector-for-each is unspecified. If more than one <em>vector</em> is given and not all vectors have the same length, vector-for-each terminates when the shortest vector runs out. It is an error for <em>proc</em> to mutate any of the vectors.</p>
<div class="sourceCode" id="cb228"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true"></a>(<span class="kw">let</span> ((v (make-list <span class="dv">5</span>)))</span>
<span id="cb228-2"><a href="#cb228-2" aria-hidden="true"></a>  (vector-for-each</span>
<span id="cb228-3"><a href="#cb228-3" aria-hidden="true"></a>   (<span class="kw">lambda</span> (i) (list-set! v i (* i i)))</span>
<span id="cb228-4"><a href="#cb228-4" aria-hidden="true"></a>   &#39;#(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))</span>
<span id="cb228-5"><a href="#cb228-5" aria-hidden="true"></a>  v) <span class="co">;; =&gt; (0 1 4 9 16)</span></span></code></pre></div>
<blockquote>
<p>(call-with-current-continuation <em>proc</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(call/cc <em>proc</em>)  procedure</p>
</blockquote>
<p>It is an error if <em>proc</em> does not accept one argument.</p>
<p>The procedure call-with-current-continuation (or its equivalent abbreviation call/cc) packages the current continuation (see the rationale below) as an “escape procedure” and passes it as an argument to <em>proc</em>. The escape procedure is a Scheme procedure that, if it is later called, will abandon whatever continuation is in effect at that later time and will instead use the continuation that was in effect when the escape procedure was created. Calling the escape procedure will cause the invocation of <em>before</em> and <em>after</em> thunks installed using <code>dynamic-wind</code>.</p>
<p>The escape procedure accepts the same number of arguments as the continuation to the original call to <code>call-with-current-continuation</code>. Most continuations take only one value. Continuations created by the call-with-values procedure (including the initialization expressions of define-values, let-values, and let*-values expressions), take the number of values that the consumer expects. The continuations of all non-final expressions within a sequence of expressions, such as in lambda, case-lambda, begin, let, let*, letrec, letrec*, let-values, let*-values, let-syntax, letrec-syntax, parameterize, guard, case, cond, when, and unless expressions, take an arbitrary number of values because they discard the values passed to them in any event. The effect of passing no values or more than one value to continuations that were not created in one of these ways is unspecified.</p>
<p>The escape procedure that is passed to <em>proc</em> has unlimited extent just like any other procedure in Scheme. It can be stored in variables or data structures and can be called as many times as desired. However, like the raise and error procedures, it never returns to its caller.</p>
<p>The following examples show only the simplest ways in which call-with-current-continuation is used. If all real uses were as simple as these examples, there would be no need for a procedure with the power of call-with-current-continuation.</p>
<div class="sourceCode" id="cb229"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true"></a>(<span class="kw">call-with-current-continuation</span></span>
<span id="cb229-2"><a href="#cb229-2" aria-hidden="true"></a> (<span class="kw">lambda</span> (exit)</span>
<span id="cb229-3"><a href="#cb229-3" aria-hidden="true"></a>   (<span class="kw">for-each</span> (<span class="kw">lambda</span> (x)</span>
<span id="cb229-4"><a href="#cb229-4" aria-hidden="true"></a>               (<span class="kw">if</span> (<span class="kw">negative?</span> x)</span>
<span id="cb229-5"><a href="#cb229-5" aria-hidden="true"></a>                   (exit x)))</span>
<span id="cb229-6"><a href="#cb229-6" aria-hidden="true"></a>             &#39;(<span class="dv">54</span> <span class="dv">0</span> <span class="dv">37</span> <span class="dv">-3</span> <span class="dv">245</span> <span class="dv">19</span>))</span>
<span id="cb229-7"><a href="#cb229-7" aria-hidden="true"></a>   <span class="dv">#t</span>)) <span class="co">;; =&gt; -3</span></span>
<span id="cb229-8"><a href="#cb229-8" aria-hidden="true"></a></span>
<span id="cb229-9"><a href="#cb229-9" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> list-length</span></span>
<span id="cb229-10"><a href="#cb229-10" aria-hidden="true"></a>  (<span class="kw">lambda</span> (obj)</span>
<span id="cb229-11"><a href="#cb229-11" aria-hidden="true"></a>    (<span class="kw">call-with-current-continuation</span></span>
<span id="cb229-12"><a href="#cb229-12" aria-hidden="true"></a>     (<span class="kw">lambda</span> (return)</span>
<span id="cb229-13"><a href="#cb229-13" aria-hidden="true"></a>       (<span class="kw">letrec</span> ((r</span>
<span id="cb229-14"><a href="#cb229-14" aria-hidden="true"></a>                 (<span class="kw">lambda</span> (obj)</span>
<span id="cb229-15"><a href="#cb229-15" aria-hidden="true"></a>                   (<span class="kw">cond</span> ((<span class="kw">null?</span> obj) <span class="dv">0</span>)</span>
<span id="cb229-16"><a href="#cb229-16" aria-hidden="true"></a>                         ((<span class="kw">pair?</span> obj)</span>
<span id="cb229-17"><a href="#cb229-17" aria-hidden="true"></a>                          (<span class="op">+</span> (r (<span class="kw">cdr</span> obj)) <span class="dv">1</span>))</span>
<span id="cb229-18"><a href="#cb229-18" aria-hidden="true"></a>                         (<span class="kw">else</span> (return <span class="dv">#f</span>))))))</span>
<span id="cb229-19"><a href="#cb229-19" aria-hidden="true"></a>         (r obj))))))</span>
<span id="cb229-20"><a href="#cb229-20" aria-hidden="true"></a></span>
<span id="cb229-21"><a href="#cb229-21" aria-hidden="true"></a>(list-length &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)) <span class="co">;; =&gt; 4</span></span>
<span id="cb229-22"><a href="#cb229-22" aria-hidden="true"></a></span>
<span id="cb229-23"><a href="#cb229-23" aria-hidden="true"></a>(list-length &#39;(a b . c)) <span class="co">;; =&gt; #f</span></span></code></pre></div>
<p><em>Rationale:</em></p>
<p>A common use of call-with-current-continuation is for structured, non-local exits from loops or procedure bodies, but in fact call-with-current-continuation is useful for implementing a wide variety of advanced control structures. In fact, raise and guard provide a more structured mechanism for non-local exits.</p>
<p>Whenever a Scheme expression is evaluated there is a <em>continuation</em> wanting the result of the expression. The continuation represents an entire (default) future for the computation. If the expression is evaluated at the REPL, for example, then the continuation might take the result, print it on the screen, prompt for the next input, evaluate it, and so on forever. Most of the time the continuation includes actions specified by user code, as in a continuation that will take the result, multiply it by the value stored in a local variable, add seven, and give the answer to the REPL’s continuation to be printed. Normally these ubiquitous continuations are hidden behind the scenes and programmers do not think much about them. On rare occasions, however, a programmer needs to deal with continuations explicitly. The call-with-current-continuation procedure allows Scheme programmers to do that by creating a procedure that acts just like the current continuation.</p>
<blockquote>
<p>(values <em>obj …</em>)  procedure</p>
</blockquote>
<p>Delivers all of its arguments to its continuation. The <code>values</code> procedure might be defined as follows:</p>
<div class="sourceCode" id="cb230"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">values</span> . things)</span>
<span id="cb230-2"><a href="#cb230-2" aria-hidden="true"></a>  (<span class="kw">call-with-current-continuation</span></span>
<span id="cb230-3"><a href="#cb230-3" aria-hidden="true"></a>   (<span class="kw">lambda</span> (cont) (apply cont things))))</span></code></pre></div>
<blockquote>
<p>(call-with-values <em>producer consumer</em>)  procedure</p>
</blockquote>
<p>Calls its <em>producer</em> argument with no arguments and a continuation that, when passed some values, calls the <em>consumer</em> procedure with those values as arguments. The continuation for the call to <em>consumer</em> is the continuation of the call to <code>call-with-values</code>.</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true"></a>(<span class="kw">call-with-values</span> (<span class="kw">lambda</span> () (<span class="kw">values</span> <span class="dv">4</span> <span class="dv">5</span>))</span>
<span id="cb231-2"><a href="#cb231-2" aria-hidden="true"></a>  (<span class="kw">lambda</span> (a b) b))</span>
<span id="cb231-3"><a href="#cb231-3" aria-hidden="true"></a><span class="co">;; =&gt; 5</span></span>
<span id="cb231-4"><a href="#cb231-4" aria-hidden="true"></a></span>
<span id="cb231-5"><a href="#cb231-5" aria-hidden="true"></a>(<span class="kw">call-with-values</span> * <span class="op">-</span>) <span class="co">;; =&gt; -1</span></span></code></pre></div>
<blockquote>
<p>(dynamic-wind <em>before thunk after</em>)  procedure</p>
</blockquote>
<p>Calls <em>thunk</em> without arguments, returning the result(s) of this call. <em>Before</em> and <em>after</em> are called, also without arguments, as required by the following rules. Note that, in the absence of calls to continuations captured using <code>call-with-current-continuation</code>, the three arguments are called once each, in order. <em>Before</em> is called whenever execution enters the dynamic extent of the call to <em>thunk</em> and <em>after</em> is called whenever it exits that dynamic extent. The dynamic extent of a procedure call is the period between when the call is initiated and when it returns. The <em>before</em> and <em>after</em> thunks are called in the same dynamic environment as the call to dynamic-wind. In Scheme, because of call-with-current-continuation, the dynamic extent of a call is not always a single, connected time period. It is defined as follows:</p>
<ul>
<li><p>The dynamic extent is entered when execution of the body of the called procedure begins.</p></li>
<li><p>The dynamic extent is also entered when execution is not within the dynamic extent and a continuation is invoked that was captured (using call-with-current-continuation) during the dynamic extent.</p></li>
<li><p>It is exited when the called procedure returns.</p></li>
<li><p>It is also exited when execution is within the dynamic extent and a continuation is invoked that was captured while not within the dynamic extent.</p></li>
</ul>
<p>If a second call to dynamic-wind occurs within the dynamic extent of the call to <em>thunk</em> and then a continuation is invoked in such a way that the <em>after</em>s from these two invocations of dynamic-wind are both to be called, then the <em>after</em> associated with the second (inner) call to dynamic-wind is called first.</p>
<p>If a second call to dynamic-wind occurs within the dynamic extent of the call to <em>thunk</em> and then a continuation is invoked in such a way that the <em>before</em>s from these two invocations of dynamic-wind are both to be called, then the <em>before</em> associated with the first (outer) call to dynamic-wind is called first.</p>
<p>If invoking a continuation requires calling the <em>before</em> from one call to dynamic-wind and the <em>after</em> from another, then the <em>after</em> is called first.</p>
<p>The effect of using a captured continuation to enter or exit the dynamic extent of a call to <em>before</em> or <em>after</em> is unspecified.</p>
<div class="sourceCode" id="cb232"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true"></a>(<span class="kw">let</span> ((path &#39;())</span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true"></a>      (c <span class="dv">#f</span>))</span>
<span id="cb232-3"><a href="#cb232-3" aria-hidden="true"></a>  (<span class="kw">let</span> ((add (<span class="kw">lambda</span> (s)</span>
<span id="cb232-4"><a href="#cb232-4" aria-hidden="true"></a>               (set! path (<span class="kw">cons</span> s path)))))</span>
<span id="cb232-5"><a href="#cb232-5" aria-hidden="true"></a>    (<span class="kw">dynamic-wind</span></span>
<span id="cb232-6"><a href="#cb232-6" aria-hidden="true"></a>        (<span class="kw">lambda</span> () (add &#39;connect))</span>
<span id="cb232-7"><a href="#cb232-7" aria-hidden="true"></a>        (<span class="kw">lambda</span> ()</span>
<span id="cb232-8"><a href="#cb232-8" aria-hidden="true"></a>          (add (<span class="kw">call-with-current-continuation</span></span>
<span id="cb232-9"><a href="#cb232-9" aria-hidden="true"></a>                (<span class="kw">lambda</span> (c0)</span>
<span id="cb232-10"><a href="#cb232-10" aria-hidden="true"></a>                  (set! c c0)</span>
<span id="cb232-11"><a href="#cb232-11" aria-hidden="true"></a>                  &#39;talk1))))</span>
<span id="cb232-12"><a href="#cb232-12" aria-hidden="true"></a>        (<span class="kw">lambda</span> () (add &#39;disconnect)))</span>
<span id="cb232-13"><a href="#cb232-13" aria-hidden="true"></a>    (<span class="kw">if</span> (<span class="op">&lt;</span> (<span class="kw">length</span> path) <span class="dv">4</span>)</span>
<span id="cb232-14"><a href="#cb232-14" aria-hidden="true"></a>        (c &#39;talk2)</span>
<span id="cb232-15"><a href="#cb232-15" aria-hidden="true"></a>        (<span class="kw">reverse</span> path))))</span>
<span id="cb232-16"><a href="#cb232-16" aria-hidden="true"></a><span class="co">;; =&gt; (connect talk1 disconnect connect talk2 disconnect)</span></span></code></pre></div>
<h3 id="exceptions">Exceptions</h3>
<p>This section describes Scheme’s exception-handling and exception-raising procedures. For the concept of Scheme exceptions, see section <a href="#errorsituations">[errorsituations]</a>. See also <a href="#guard">[guard]</a> for the guard syntax.</p>
<p><em>Exception handler</em>s are one-argument procedures that determine the action the program takes when an exceptional situation is signaled. The system implicitly maintains a current exception handler in the dynamic environment.</p>
<p>The program raises an exception by invoking the current exception handler, passing it an object encapsulating information about the exception. Any procedure accepting one argument can serve as an exception handler and any object can be used to represent an exception.</p>
<blockquote>
<p>(with-exception-handler <strong>handler<em> </em>thunk</strong>)  procedure</p>
</blockquote>
<p>It is an error if <em>handler</em> does not accept one argument. It is also an error if <em>thunk</em> does not accept zero arguments.</p>
<p>The with-exception-handler procedure returns the results of invoking <em>thunk</em>. <em>Handler</em> is installed as the current exception handler in the dynamic environment used for the invocation of <em>thunk</em>.</p>
<div class="sourceCode" id="cb233"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true"></a>(<span class="kw">call-with-current-continuation</span></span>
<span id="cb233-2"><a href="#cb233-2" aria-hidden="true"></a> (<span class="kw">lambda</span> (k)</span>
<span id="cb233-3"><a href="#cb233-3" aria-hidden="true"></a>   (with-exception-handler</span>
<span id="cb233-4"><a href="#cb233-4" aria-hidden="true"></a>    (<span class="kw">lambda</span> (x)</span>
<span id="cb233-5"><a href="#cb233-5" aria-hidden="true"></a>      (<span class="kw">display</span> <span class="st">&quot;condition: &quot;</span>)</span>
<span id="cb233-6"><a href="#cb233-6" aria-hidden="true"></a>      (<span class="kw">write</span> x)</span>
<span id="cb233-7"><a href="#cb233-7" aria-hidden="true"></a>      (<span class="kw">newline</span>)</span>
<span id="cb233-8"><a href="#cb233-8" aria-hidden="true"></a>      (k &#39;exception))</span>
<span id="cb233-9"><a href="#cb233-9" aria-hidden="true"></a>    (<span class="kw">lambda</span> ()</span>
<span id="cb233-10"><a href="#cb233-10" aria-hidden="true"></a>      (<span class="op">+</span> <span class="dv">1</span> (raise &#39;an-error))))))</span>
<span id="cb233-11"><a href="#cb233-11" aria-hidden="true"></a><span class="co">;; =&gt; exception and prints condition: an-error</span></span>
<span id="cb233-12"><a href="#cb233-12" aria-hidden="true"></a></span>
<span id="cb233-13"><a href="#cb233-13" aria-hidden="true"></a>(with-exception-handler</span>
<span id="cb233-14"><a href="#cb233-14" aria-hidden="true"></a> (<span class="kw">lambda</span> (x)</span>
<span id="cb233-15"><a href="#cb233-15" aria-hidden="true"></a>   (<span class="kw">display</span> <span class="st">&quot;something went wrong\n&quot;</span>))</span>
<span id="cb233-16"><a href="#cb233-16" aria-hidden="true"></a> (<span class="kw">lambda</span> ()</span>
<span id="cb233-17"><a href="#cb233-17" aria-hidden="true"></a>   (<span class="op">+</span> <span class="dv">1</span> (raise &#39;an-error))))</span>
<span id="cb233-18"><a href="#cb233-18" aria-hidden="true"></a><span class="co">;; prints something went wrong</span></span></code></pre></div>
<p>After printing, the second example then raises another exception.</p>
<blockquote>
<p>(raise <strong>obj</strong>)  procedure</p>
</blockquote>
<p>Raises an exception by invoking the current exception handler on <em>obj</em>. The handler is called with the same dynamic environment as that of the call to raise, except that the current exception handler is the one that was in place when the handler being called was installed. If the handler returns, a secondary exception is raised in the same dynamic environment as the handler. The relationship between <em>obj</em> and the object raised by the secondary exception is unspecified.</p>
<blockquote>
<p>(raise-continuable <strong>obj</strong>)  procedure</p>
</blockquote>
<p>Raises an exception by invoking the current exception handler on <em>obj</em>. The handler is called with the same dynamic environment as the call to raise-continuable, except that: (1) the current exception handler is the one that was in place when the handler being called was installed, and (2) if the handler being called returns, then it will again become the current exception handler. If the handler returns, the values it returns become the values returned by the call to raise-continuable.</p>
<div class="sourceCode" id="cb234"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true"></a>(with-exception-handler</span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true"></a> (<span class="kw">lambda</span> (con)</span>
<span id="cb234-3"><a href="#cb234-3" aria-hidden="true"></a>   (<span class="kw">cond</span></span>
<span id="cb234-4"><a href="#cb234-4" aria-hidden="true"></a>    ((<span class="kw">string?</span> con)</span>
<span id="cb234-5"><a href="#cb234-5" aria-hidden="true"></a>     (<span class="kw">display</span> con))</span>
<span id="cb234-6"><a href="#cb234-6" aria-hidden="true"></a>    (<span class="kw">else</span></span>
<span id="cb234-7"><a href="#cb234-7" aria-hidden="true"></a>     (<span class="kw">display</span> <span class="st">&quot;a warning has been issued&quot;</span>)))</span>
<span id="cb234-8"><a href="#cb234-8" aria-hidden="true"></a>   <span class="dv">42</span>)</span>
<span id="cb234-9"><a href="#cb234-9" aria-hidden="true"></a> (<span class="kw">lambda</span> ()</span>
<span id="cb234-10"><a href="#cb234-10" aria-hidden="true"></a>   (<span class="op">+</span> (raise-continuable <span class="st">&quot;should be a number&quot;</span>)</span>
<span id="cb234-11"><a href="#cb234-11" aria-hidden="true"></a>      <span class="dv">23</span>)))</span>
<span id="cb234-12"><a href="#cb234-12" aria-hidden="true"></a><span class="co">;; prints: should be a number</span></span>
<span id="cb234-13"><a href="#cb234-13" aria-hidden="true"></a><span class="co">;; =&gt; 65</span></span></code></pre></div>
<blockquote>
<p>(error **message<em> </em>obj<em> …</em>)  procedure</p>
</blockquote>
<p><em>Message</em> should be a string.</p>
<p>Raises an exception as if by calling raise on a newly allocated implementation-defined object which encapsulates the information provided by <em>message</em>, as well as any <em>obj</em>s, known as the <em>irritants</em>. The procedure error-object? must return <code>#t</code> on such objects.</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(null-list? l)</span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true"></a>  (<span class="kw">cond</span> ((<span class="kw">pair?</span> l) <span class="dv">#f</span>)</span>
<span id="cb235-3"><a href="#cb235-3" aria-hidden="true"></a>        ((<span class="kw">null?</span> l) <span class="dv">#t</span>)</span>
<span id="cb235-4"><a href="#cb235-4" aria-hidden="true"></a>        (<span class="kw">else</span></span>
<span id="cb235-5"><a href="#cb235-5" aria-hidden="true"></a>         (error</span>
<span id="cb235-6"><a href="#cb235-6" aria-hidden="true"></a>          <span class="st">&quot;null-list?: argument out of domain&quot;</span></span>
<span id="cb235-7"><a href="#cb235-7" aria-hidden="true"></a>          l))))</span></code></pre></div>
<blockquote>
<p>(error-object? <em>obj</em>)  procedure</p>
</blockquote>
<p>Returns <code>#t</code> if <em>obj</em> is an object created by error or one of an implementation-defined set of objects. Otherwise, it returns #f. The objects used to signal errors, including those which satisfy the predicates file-error? and read-error?, may or may not satisfy error-object?.</p>
<blockquote>
<p>(error-object-message <em>error-object</em>)  procedure</p>
</blockquote>
<p>Returns the message encapsulated by <em>error-object</em>.</p>
<blockquote>
<p>(error-object-irritants <em>error-object</em>)  procedure</p>
</blockquote>
<p>Returns a list of the irritants encapsulated by <em>error-object</em>.</p>
<blockquote>
<p>(read-error? <em>obj</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(file-error? <em>obj</em>)  procedure</p>
</blockquote>
<p>Error type predicates. Returns <code>#t</code> if <em>obj</em> is an object raised by the read procedure or by the inability to open an input or output port on a file, respectively. Otherwise, it returns #f.</p>
<h3 id="environments-and-evaluation">Environments and evaluation</h3>
<blockquote>
<p>(environment <strong>l</strong>i<strong>s</strong>t<em><sub>1</sub> … </em>)  eval library procedure</p>
</blockquote>
<p>This procedure returns a specifier for the environment that results by starting with an empty environment and then importing each <em>list</em>, considered as an import set, into it. (See section <a href="#libraries">[libraries]</a> for a description of import sets.) The bindings of the environment represented by the specifier are immutable, as is the environment itself.</p>
<blockquote>
<p>(scheme-report-environment <em>version</em>)  r5rs library procedure</p>
</blockquote>
<p>If <em>version</em> is equal to 5, corresponding to R<sup><small>5</small></sup>RS, scheme-report-environment returns a specifier for an environment that contains only the bindings defined in the R<sup><small>5</small></sup>RS library. Implementations must support this value of <em>version</em>.</p>
<p>Implementations may also support other values of <em>version</em>, in which case they return a specifier for an environment containing bindings corresponding to the specified version of the report. If <em>version</em> is neither 5 nor another value supported by the implementation, an error is signaled.</p>
<p>The effect of defining or assigning (through the use of eval) an identifier bound in a scheme-report-environment (for example car) is unspecified. Thus both the environment and the bindings it contains may be immutable.</p>
<blockquote>
<p>(null-environment <em>version</em>)  r5rs library procedure</p>
</blockquote>
<p>If <em>version</em> is equal to 5, corresponding to R<sup><small>5</small></sup>RS, the null-environment procedure returns a specifier for an environment that contains only the bindings for all syntactic keywords defined in the R<sup><small>5</small></sup>RS library. Implementations must support this value of <em>version</em>.</p>
<p>Implementations may also support other values of <em>version</em>, in which case they return a specifier for an environment containing appropriate bindings corresponding to the specified version of the report. If <em>version</em> is neither 5 nor another value supported by the implementation, an error is signaled.</p>
<p>The effect of defining or assigning (through the use of eval) an identifier bound in a scheme-report-environment (for example car) is unspecified. Thus both the environment and the bindings it contains may be immutable.</p>
<blockquote>
<p>(interaction-environment)  repl library procedure</p>
</blockquote>
<p>This procedure returns a specifier for a mutable environment that contains an implementation-defined set of bindings, typically a superset of those exported by <code>(scheme base)</code>. The intent is that this procedure will return the environment in which the implementation would evaluate expressions entered by the user into a REPL.</p>
<blockquote>
<p>(eval <em>expr-or-def environment-specifier</em>)  eval library procedure</p>
</blockquote>
<p>If <em>expr-or-def</em> is an expression, it is evaluated in the specified environment and its values are returned. If it is a definition, the specified identifier(s) are defined in the specified environment, provided the environment is not immutable. Implementations may extend eval to allow other objects.</p>
<div class="sourceCode" id="cb236"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true"></a>(<span class="kw">eval</span> &#39;(* <span class="dv">7</span> <span class="dv">3</span>) (environment &#39;(scheme base)))</span>
<span id="cb236-2"><a href="#cb236-2" aria-hidden="true"></a><span class="co">;; =&gt; 21</span></span>
<span id="cb236-3"><a href="#cb236-3" aria-hidden="true"></a></span>
<span id="cb236-4"><a href="#cb236-4" aria-hidden="true"></a>(<span class="kw">let</span> ((f (<span class="kw">eval</span> &#39;(<span class="kw">lambda</span> (f x) (f x x))</span>
<span id="cb236-5"><a href="#cb236-5" aria-hidden="true"></a>               (<span class="kw">null-environment</span> <span class="dv">5</span>))))</span>
<span id="cb236-6"><a href="#cb236-6" aria-hidden="true"></a>  (f <span class="op">+</span> <span class="dv">10</span>))</span>
<span id="cb236-7"><a href="#cb236-7" aria-hidden="true"></a><span class="co">;; =&gt; 20</span></span>
<span id="cb236-8"><a href="#cb236-8" aria-hidden="true"></a>(<span class="kw">eval</span> &#39;(<span class="ex">define</span><span class="fu"> foo </span><span class="dv">32</span>)</span>
<span id="cb236-9"><a href="#cb236-9" aria-hidden="true"></a>      (environment &#39;(scheme base)))</span>
<span id="cb236-10"><a href="#cb236-10" aria-hidden="true"></a><span class="co">;; =&gt; error is signaled</span></span></code></pre></div>
<h3 id="input-and-output">Input and output</h3>
<h4 id="ports">Ports</h4>
<p>Ports represent input and output devices. To Scheme, an input port is a Scheme object that can deliver data upon command, while an output port is a Scheme object that can accept data. Whether the input and output port types are disjoint is implementation-dependent.</p>
<p>Different <em>port types</em> operate on different data. Scheme implementations are required to support <em>textual ports</em> and <em>binary ports</em>, but may also provide other port types.</p>
<p>A textual port supports reading or writing of individual characters from or to a backing store containing characters using read-char and write-char below, and it supports operations defined in terms of characters, such as read and write.</p>
<p>A binary port supports reading or writing of individual bytes from or to a backing store containing bytes using read-u8 and write-u8 below, as well as operations defined in terms of bytes. Whether the textual and binary port types are disjoint is implementation-dependent.</p>
<p>Ports can be used to access files, devices, and similar things on the host system on which the Scheme program is running.</p>
<blockquote>
<p>(call-with-port <em>port proc</em>)  procedure</p>
</blockquote>
<p>It is an error if <em>proc</em> does not accept one argument.</p>
<p>The call-with-port procedure calls <em>proc</em> with <em>port</em> as an argument. If <em>proc</em> returns, then the port is closed automatically and the values yielded by the <em>proc</em> are returned. If <em>proc</em> does not return, then the port must not be closed automatically unless it is possible to prove that the port will never again be used for a read or write operation.</p>
<p><em>Rationale:</em> Because Scheme’s escape procedures have unlimited extent, it is possible to escape from the current continuation but later to resume it. If implementations were permitted to close the port on any escape from the current continuation, then it would be impossible to write portable code using both call-with-current-continuation and call-with-port.</p>
<blockquote>
<p>(call-with-input-file <em>string proc</em>)  file library procedure</p>
</blockquote>
<blockquote>
<p>(call-with-output-file <em>string proc</em>)  file library procedure</p>
</blockquote>
<p>It is an error if <em>proc</em> does not accept one argument.</p>
<p>These procedures obtain a textual port obtained by opening the named file for input or output as if by open-input-file or open-output-file. The port and <em>proc</em> are then passed to a procedure equivalent to call-with-port.</p>
<blockquote>
<p>(input-port? <em>obj</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(output-port? <em>obj</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(textual-port? <em>obj</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(binary-port? <em>obj</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(port? <em>obj</em>)  procedure</p>
</blockquote>
<p>These procedures return <code>#t</code> if <em>obj</em> is an input port, output port, textual port, binary port, or any kind of port, respectively. Otherwise they return #f.</p>
<blockquote>
<p>(input-port-open? <em>port</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(output-port-open? <em>port</em>)  procedure</p>
</blockquote>
<p>Returns <code>#t</code> if <em>port</em> is still open and capable of performing input or output, respectively, and <code>#f</code> otherwise.</p>
<blockquote>
<p>(current-input-port)  procedure</p>
</blockquote>
<blockquote>
<p>(current-output-port)  procedure</p>
</blockquote>
<blockquote>
<p>(current-error-port)  procedure</p>
</blockquote>
<p>Returns the current default input port, output port, or error port (an output port), respectively. These procedures are parameter objects, which can be overridden with parameterize (see section <a href="#make-parameter">[make-parameter]</a>). The initial bindings for these are implementation-defined textual ports.</p>
<blockquote>
<p>(with-input-from-file <em>string thunk</em>)  file library procedure</p>
</blockquote>
<blockquote>
<p>(with-output-to-file <em>string thunk</em>)  file library procedure</p>
</blockquote>
<p>The file is opened for input or output as if by open-input-file or open-output-file, and the new port is made to be the value returned by current-input-port or current-output-port (as used by <code>(read)</code>, <code>(write obj)</code>, and so forth). The <em>thunk</em> is then called with no arguments. When the <em>thunk</em> returns, the port is closed and the previous default is restored. It is an error if <em>thunk</em> does not accept zero arguments. Both procedures return the values yielded by <em>thunk</em>. If an escape procedure is used to escape from the continuation of these procedures, they behave exactly as if the current input or output port had been bound dynamically with parameterize.</p>
<blockquote>
<p>(open-input-file <em>string</em>)  file library procedure</p>
</blockquote>
<blockquote>
<p>(open-binary-input-file <em>string</em>)  file library procedure</p>
</blockquote>
<p>Takes a <em>string</em> for an existing file and returns a textual input port or binary input port that is capable of delivering data from the file. If the file does not exist or cannot be opened, an error that satisfies file-error? is signaled.</p>
<blockquote>
<p>(open-output-file <em>string</em>)  file library procedure</p>
</blockquote>
<blockquote>
<p>(open-binary-output-file <em>string</em>)  file library procedure</p>
</blockquote>
<p>Takes a <em>string</em> naming an output file to be created and returns a textual output port or binary output port that is capable of writing data to a new file by that name.</p>
<p>If a file with the given name already exists, the effect is unspecified. If the file cannot be opened, an error that satisfies file-error? is signaled.</p>
<blockquote>
<p>(close-port <em>port</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(close-input-port <em>port</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(close-output-port <em>port</em>)  procedure</p>
</blockquote>
<p>Closes the resource associated with <em>port</em>, rendering the <em>port</em> incapable of delivering or accepting data. It is an error to apply the last two procedures to a port which is not an input or output port, respectively. Scheme implementations may provide ports which are simultaneously input and output ports, such as sockets; the close-input-port and close-output-port procedures can then be used to close the input and output sides of the port independently.</p>
<p>These routines have no effect if the port has already been closed.</p>
<blockquote>
<p>(open-input-string <em>string</em>)  procedure</p>
</blockquote>
<p>Takes a string and returns a textual input port that delivers characters from the string. If the string is modified, the effect is unspecified.</p>
<blockquote>
<p>(open-output-string)  procedure</p>
</blockquote>
<p>Returns a textual output port that will accumulate characters for retrieval by get-output-string.</p>
<blockquote>
<p>(get-output-string <em>port</em>)  procedure</p>
</blockquote>
<p>It is an error if <em>port</em> was not created with open-output-string.</p>
<p>Returns a string consisting of the characters that have been output to the port so far in the order they were output. If the result string is modified, the effect is unspecified.</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true"></a>(parameterize</span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true"></a>    ((<span class="kw">current-output-port</span></span>
<span id="cb237-3"><a href="#cb237-3" aria-hidden="true"></a>      (open-output-string)))</span>
<span id="cb237-4"><a href="#cb237-4" aria-hidden="true"></a>  (<span class="kw">display</span> <span class="st">&quot;piece&quot;</span>)</span>
<span id="cb237-5"><a href="#cb237-5" aria-hidden="true"></a>  (<span class="kw">display</span> <span class="st">&quot; by piece &quot;</span>)</span>
<span id="cb237-6"><a href="#cb237-6" aria-hidden="true"></a>  (<span class="kw">display</span> <span class="st">&quot;by piece.&quot;</span>)</span>
<span id="cb237-7"><a href="#cb237-7" aria-hidden="true"></a>  (<span class="kw">newline</span>)</span>
<span id="cb237-8"><a href="#cb237-8" aria-hidden="true"></a>  (get-output-string (<span class="kw">current-output-port</span>)))</span>
<span id="cb237-9"><a href="#cb237-9" aria-hidden="true"></a><span class="co">;; =&gt; &quot;piece by piece by piece.\n&quot;</span></span></code></pre></div>
<blockquote>
<p>(open-input-bytevector <em>bytevector</em>)  procedure</p>
</blockquote>
<p>Takes a bytevector and returns a binary input port that delivers bytes from the bytevector.</p>
<blockquote>
<p>(open-output-bytevector)  procedure</p>
</blockquote>
<p>Returns a binary output port that will accumulate bytes for retrieval by get-output-bytevector.</p>
<blockquote>
<p>(get-output-bytevector <em>port</em>)  procedure</p>
</blockquote>
<p>It is an error if <em>port</em> was not created with open-output-bytevector.</p>
<p>Returns a bytevector consisting of the bytes that have been output to the port so far in the order they were output.</p>
<h4 id="input">Input</h4>
<p>If <em>port</em> is omitted from any input procedure, it defaults to the value returned by (current-input-port). It is an error to attempt an input operation on a closed port.</p>
<blockquote>
<p>(read)  read library procedure</p>
</blockquote>
<blockquote>
<p>(read <em>port</em>)  read library procedure</p>
</blockquote>
<p>The read procedure converts external representations of Scheme objects into the objects themselves. That is, it is a parser for the non-terminal datum (see sections <a href="#datum">[datum]</a> and <a href="#listsection">[listsection]</a>). It returns the next object parsable from the given textual input <em>port</em>, updating <em>port</em> to point to the first character past the end of the external representation of the object.</p>
<p>Implementations may support extended syntax to represent record types or other types that do not have datum representations.</p>
<p>If an end of file is encountered in the input before any characters are found that can begin an object, then an end-of-file object is returned. The port remains open, and further attempts to read will also return an end-of-file object. If an end of file is encountered after the beginning of an object’s external representation, but the external representation is incomplete and therefore not parsable, an error that satisfies read-error? is signaled.</p>
<blockquote>
<p>(read-char)  procedure</p>
</blockquote>
<blockquote>
<p>(read-char <em>port</em>)  procedure</p>
</blockquote>
<p>Returns the next character available from the textual input <em>port</em>, updating the <em>port</em> to point to the following character. If no more characters are available, an end-of-file object is returned.</p>
<blockquote>
<p>(peek-char)  procedure</p>
</blockquote>
<blockquote>
<p>(peek-char <em>port</em>)  procedure</p>
</blockquote>
<p>Returns the next character available from the textual input <em>port</em>, but <em>without</em> updating the <em>port</em> to point to the following character. If no more characters are available, an end-of-file object is returned.</p>
<p><em>Note:</em> The value returned by a call to peek-char is the same as the value that would have been returned by a call to read-char with the same <em>port</em>. The only difference is that the very next call to read-char or peek-char on that <em>port</em> will return the value returned by the preceding call to peek-char. In particular, a call to peek-char on an interactive port will hang waiting for input whenever a call to read-char would have hung.</p>
<blockquote>
<p>(read-line)  procedure</p>
</blockquote>
<blockquote>
<p>(read-line <em>port</em>)  procedure</p>
</blockquote>
<p>Returns the next line of text available from the textual input <em>port</em>, updating the <em>port</em> to point to the following character. If an end of line is read, a string containing all of the text up to (but not including) the end of line is returned, and the port is updated to point just past the end of line. If an end of file is encountered before any end of line is read, but some characters have been read, a string containing those characters is returned. If an end of file is encountered before any characters are read, an end-of-file object is returned. For the purpose of this procedure, an end of line consists of either a linefeed character, a carriage return character, or a sequence of a carriage return character followed by a linefeed character. Implementations may also recognize other end of line characters or sequences.</p>
<blockquote>
<p>(eof-object? <em>obj</em>)  procedure</p>
</blockquote>
<p>Returns <code>#t</code> if <em>obj</em> is an end-of-file object, otherwise returns #f. The precise set of end-of-file objects will vary among implementations, but in any case no end-of-file object will ever be an object that can be read in using read.</p>
<blockquote>
<p>(eof-object)  procedure</p>
</blockquote>
<p>Returns an end-of-file object, not necessarily unique.</p>
<blockquote>
<p>(char-ready?)  procedure</p>
</blockquote>
<blockquote>
<p>(char-ready? <em>port</em>)  procedure</p>
</blockquote>
<p>Returns <code>#t</code> if a character is ready on the textual input <em>port</em> and returns <code>#f</code> otherwise. If char-ready returns <code>#t</code> then the next read-char operation on the given <em>port</em> is guaranteed not to hang. If the <em>port</em> is at end of file then char-ready? returns #t.</p>
<p><em>Rationale:</em> The char-ready? procedure exists to make it possible for a program to accept characters from interactive ports without getting stuck waiting for input. Any input editors associated with such ports must ensure that characters whose existence has been asserted by char-ready? cannot be removed from the input. If char-ready? were to return <code>#f</code> at end of file, a port at end of file would be indistinguishable from an interactive port that has no ready characters.</p>
<blockquote>
<p>(read-string <em>k</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(read-string <em>k port</em>)  procedure</p>
</blockquote>
<p>Reads the next <em>k</em> characters, or as many as are available before the end of file, from the textual input <em>port</em> into a newly allocated string in left-to-right order and returns the string. If no characters are available before the end of file, an end-of-file object is returned.</p>
<blockquote>
<p>(read-u8)  procedure</p>
</blockquote>
<blockquote>
<p>(read-u8 <em>port</em>)  procedure</p>
</blockquote>
<p>Returns the next byte available from the binary input <em>port</em>, updating the <em>port</em> to point to the following byte. If no more bytes are available, an end-of-file object is returned.</p>
<blockquote>
<p>(peek-u8)  procedure</p>
</blockquote>
<blockquote>
<p>(peek-u8 <em>port</em>)  procedure</p>
</blockquote>
<p>Returns the next byte available from the binary input <em>port</em>, but <em>without</em> updating the <em>port</em> to point to the following byte. If no more bytes are available, an end-of-file object is returned.</p>
<blockquote>
<p>(u8-ready?)  procedure (u8-ready? <em>port</em>)  procedure</p>
</blockquote>
<p>Returns <code>#t</code> if a byte is ready on the binary input <em>port</em> and returns #f otherwise. If u8-ready? returns <code>#t</code> then the next read-u8 operation on the given <em>port</em> is guaranteed not to hang. If the <em>port</em> is at end of file then u8-ready? returns #t.</p>
<blockquote>
<p>(read-bytevector <em>k</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(read-bytevector <em>k port</em>)  procedure</p>
</blockquote>
<p>Reads the next <em>k</em> bytes, or as many as are available before the end of file, from the binary input <em>port</em> into a newly allocated bytevector in left-to-right order and returns the bytevector. If no bytes are available before the end of file, an end-of-file object is returned.</p>
<blockquote>
<p>(read-bytevector! <em>bytevector</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(read-bytevector! <em>bytevector port</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(read-bytevector! <em>bytevector port start</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(read-bytevector! <em>bytevector port start end</em>)  procedure</p>
</blockquote>
<p>Reads the next <em>e<strong>n</strong>d</em> − <em>s<strong>t</strong>a<strong>r</strong>t</em> bytes, or as many as are available before the end of file, from the binary input <em>port</em> into <em>bytevector</em> in left-to-right order beginning at the <em>start</em> position. If <em>end</em> is not supplied, reads until the end of <em>bytevector</em> has been reached. If <em>start</em> is not supplied, reads beginning at position 0. Returns the number of bytes read. If no bytes are available, an end-of-file object is returned.</p>
<h4 id="output">Output</h4>
<p>If <em>port</em> is omitted from any output procedure, it defaults to the value returned by (current-output-port). It is an error to attempt an output operation on a closed port.</p>
<blockquote>
<p>(write <em>obj</em>)  write library procedure</p>
</blockquote>
<blockquote>
<p>(write <em>obj port</em>)  write library procedure</p>
</blockquote>
<p>Writes a representation of <em>obj</em> to the given textual output <em>port</em>. Strings that appear in the written representation are enclosed in quotation marks, and within those strings backslash and quotation mark characters are escaped by backslashes. Symbols that contain non-ASCII characters are escaped with vertical lines. Character objects are written using the #<code>'</code> notation.</p>
<p>If <em>obj</em> contains cycles which would cause an infinite loop using the normal written representation, then at least the objects that form part of the cycle must be represented using datum labels as described in section <a href="#labelsection">[labelsection]</a>. Datum labels must not be used if there are no cycles.</p>
<p>Implementations may support extended syntax to represent record types or other types that do not have datum representations.</p>
<p>The write procedure returns an unspecified value.</p>
<blockquote>
<p>(write-shared <em>obj</em>)  write library procedure</p>
</blockquote>
<blockquote>
<p>(write-shared <em>obj port</em>)  write library procedure</p>
</blockquote>
<p>The write-shared procedure is the same as write, except that shared structure must be represented using datum labels for all pairs and vectors that appear more than once in the output.</p>
<blockquote>
<p>(write-simple <em>obj</em>)  write library procedure</p>
</blockquote>
<blockquote>
<p>(write-simple <em>obj port</em>)  write library procedure</p>
</blockquote>
<p>The write-simple procedure is the same as write, except that shared structure is never represented using datum labels. This can cause write-simple not to terminate if <em>obj</em> contains circular structure.</p>
<blockquote>
<p>(display <em>obj</em>)  write library procedure</p>
</blockquote>
<blockquote>
<p>(display <em>obj port</em>)  write library procedure</p>
</blockquote>
<p>Writes a representation of <em>obj</em> to the given textual output <em>port</em>. Strings that appear in the written representation are output as if by write-string instead of by write. Symbols are not escaped. Character objects appear in the representation as if written by write-char instead of by write.</p>
<p>The display representation of other objects is unspecified. However, display must not loop forever on self-referencing pairs, vectors, or records. Thus if the normal write representation is used, datum labels are needed to represent cycles as in write.</p>
<p>Implementations may support extended syntax to represent record types or other types that do not have datum representations.</p>
<p>The display procedure returns an unspecified value.</p>
<p><em>Rationale:</em> The write procedure is intended for producing machine-readable output and display for producing human-readable output.</p>
<blockquote>
<p>(newline)  procedure</p>
</blockquote>
<blockquote>
<p>(newline <em>port</em>)  procedure</p>
</blockquote>
<p>Writes an end of line to textual output <em>port</em>. Exactly how this is done differs from one operating system to another. Returns an unspecified value.</p>
<blockquote>
<p>(write-char <em>char</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(write-char <em>char port</em>)  procedure</p>
</blockquote>
<p>Writes the character <em>char</em> (not an external representation of the character) to the given textual output <em>port</em> and returns an unspecified value.</p>
<blockquote>
<p>(write-string <em>string</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(write-string <em>string port</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(write-string <em>string port start</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(write-string <em>string port start end</em>)  procedure</p>
</blockquote>
<p>Writes the characters of <em>string</em> from <em>start</em> to <em>end</em> in left-to-right order to the textual output <em>port</em>.</p>
<blockquote>
<p>(write-u8 <em>byte</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(write-u8 <em>byte port</em>)  procedure</p>
</blockquote>
<p>Writes the <em>byte</em> to the given binary output <em>port</em> and returns an unspecified value.</p>
<blockquote>
<p>(write-bytevector <em>bytevector</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(write-bytevector <em>bytevector port</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(write-bytevector <em>bytevector port start</em>)  procedure</p>
</blockquote>
<blockquote>
<p>(write-bytevector <em>bytevector port start end</em>)  procedure</p>
</blockquote>
<p>Writes the bytes of <em>bytevector</em> from <em>start</em> to <em>end</em> in left-to-right order to the binary output <em>port</em>.</p>
<blockquote>
<p>(flush-output-port)  procedure</p>
</blockquote>
<blockquote>
<p>(flush-output-port <em>port</em>)  procedure</p>
</blockquote>
<p>Flushes any buffered output from the buffer of output-port to the underlying file or device and returns an unspecified value.</p>
<h3 id="system-interface">System interface</h3>
<p>Questions of system interface generally fall outside of the domain of this report. However, the following operations are important enough to deserve description here.</p>
<blockquote>
<p>(load <em>filename</em>)  load library procedure</p>
</blockquote>
<blockquote>
<p>(load <em>filename environment-specifier</em>)  load library procedure</p>
</blockquote>
<p>It is an error if <em>filename</em> is not a string.</p>
<p>An implementation-dependent operation is used to transform <em>filename</em> into the name of an existing file containing Scheme source code. The load procedure reads expressions and definitions from the file and evaluates them sequentially in the environment specified by <em>environment-specifier</em>. If <em>environment-specifier</em> is omitted, (interaction-environment) is assumed.</p>
<p>It is unspecified whether the results of the expressions are printed. The load procedure does not affect the values returned by current-input-port and current-output-port. It returns an unspecified value.</p>
<p><em>Rationale:</em> For portability, load must operate on source files. Its operation on other kinds of files necessarily varies among implementations.</p>
<blockquote>
<p>(file-exists? <em>filename</em>)  file library procedure</p>
</blockquote>
<p>It is an error if <em>filename</em> is not a string.</p>
<p>The file-exists? procedure returns <code>#t</code> if the named file exists at the time the procedure is called, and <code>#f</code> otherwise.</p>
<blockquote>
<p>(delete-file <em>filename</em>)  file library procedure</p>
</blockquote>
<p>It is an error if <em>filename</em> is not a string.</p>
<p>The delete-file procedure deletes the named file if it exists and can be deleted, and returns an unspecified value. If the file does not exist or cannot be deleted, an error that satisfies file-error? is signaled.</p>
<blockquote>
<p>(command-line)  process-context library procedure</p>
</blockquote>
<p>Returns the command line passed to the process as a list of strings. The first string corresponds to the command name, and is implementation-dependent. It is an error to mutate any of these strings.</p>
<blockquote>
<p>(exit)  process-context library procedure</p>
</blockquote>
<blockquote>
<p>(exit <em>obj</em>)  process-context library procedure</p>
</blockquote>
<p>Runs all outstanding dynamic-wind <em>after</em> procedures, terminates the running program, and communicates an exit value to the operating system. If no argument is supplied, or if <em>obj</em> is #t, the exit procedure should communicate to the operating system that the program exited normally. If <em>obj</em> is #f, the exit procedure should communicate to the operating system that the program exited abnormally. Otherwise, exit should translate <em>obj</em> into an appropriate exit value for the operating system, if possible.</p>
<p>The exit procedure must not signal an exception or return to its continuation.</p>
<p><em>Note:</em> Because of the requirement to run handlers, this procedure is not just the operating system’s exit procedure.</p>
<blockquote>
<p>(emergency-exit)  process-context library procedure</p>
</blockquote>
<blockquote>
<p>(emergency-exit <em>obj</em>)  process-context library procedure</p>
</blockquote>
<p>Terminates the program without running any outstanding dynamic-wind <em>after</em> procedures and communicates an exit value to the operating system in the same manner as exit.</p>
<p><em>Note:</em> The emergency-exit procedure corresponds to the _exit procedure in Windows and Posix.</p>
<blockquote>
<p>(get-environment-variable <em>name</em>)  process-context library procedure</p>
</blockquote>
<p>Many operating systems provide each running process with an <em>environment</em> consisting of <em>environment variables</em>. (This environment is not to be confused with the Scheme environments that can be passed to eval: see section <a href="#environments">[environments]</a>.) Both the name and value of an environment variable are strings. The procedure get-environment-variable returns the value of the environment variable <em>name</em>, or <code>#f</code> if the named environment variable is not found. It may use locale information to encode the name and decode the value of the environment variable. It is an error if get-environment-variable can’t decode the value. It is also an error to mutate the resulting string.</p>
<div class="sourceCode" id="cb238"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true"></a>(get-environment-variable <span class="st">&quot;PATH&quot;</span>) <span class="co">;; =&gt; &quot;/usr/local/bin:/usr/bin:/bin&quot;</span></span></code></pre></div>
<p>(get-environment-variables)  process-context library procedure Returns the names and values of all the environment variables as an alist, where the car of each entry is the name of an environment variable and the cdr is its value, both as strings. The order of the list is unspecified. It is an error to mutate any of these strings or the alist itself.</p>
<div class="sourceCode" id="cb239"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true"></a>(get-environment-variables) <span class="co">;; =&gt; ((&quot;USER&quot; . &quot;root&quot;) (&quot;HOME&quot; . &quot;/&quot;))</span></span></code></pre></div>
<p>(current-second)  time library procedure Returns an inexact number representing the current time on the International Atomic Time (TAI) scale. The value 0.0 represents midnight on January 1, 1970 TAI (equivalent to 8.000082 seconds before midnight Universal Time) and the value 1.0 represents one TAI second later. Neither high accuracy nor high precision are required; in particular, returning Coordinated Universal Time plus a suitable constant might be the best an implementation can do.</p>
<p>As of 2018, a TAI-UTC offset table can be found at <span class="citation" data-cites="TAI"></span>.</p>
<blockquote>
<p>(current-jiffy)  time library procedure Returns the number of <em>jiffies</em> as an exact integer that have elapsed since an arbitrary, implementation-defined epoch. A jiffy is an implementation-defined fraction of a second which is defined by the return value of the jiffies-per-second procedure. The starting epoch is guaranteed to be constant during a run of the program, but may vary between runs.</p>
</blockquote>
<p><em>Rationale:</em> Jiffies are allowed to be implementation-dependent so that current-jiffy can execute with minimum overhead. It should be very likely that a compactly represented integer will suffice as the returned value. Any particular jiffy size will be inappropriate for some implementations: a microsecond is too long for a very fast machine, while a much smaller unit would force many implementations to return integers which have to be allocated for most calls, rendering current-jiffy less useful for accurate timing measurements.</p>
<blockquote>
<p>(jiffies-per-second)  time library procedure</p>
</blockquote>
<p>Returns an exact integer representing the number of jiffies per SI second. This value is an implementation-specified constant.</p>
<div class="sourceCode" id="cb240"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(time-length)</span>
<span id="cb240-2"><a href="#cb240-2" aria-hidden="true"></a>  (<span class="kw">let</span> ((<span class="kw">list</span> (make-list <span class="dv">100000</span>))</span>
<span id="cb240-3"><a href="#cb240-3" aria-hidden="true"></a>        (start (current-jiffy)))</span>
<span id="cb240-4"><a href="#cb240-4" aria-hidden="true"></a>    (<span class="kw">length</span> <span class="kw">list</span>)</span>
<span id="cb240-5"><a href="#cb240-5" aria-hidden="true"></a>    (<span class="op">/</span> (<span class="op">-</span> (current-jiffy) start)</span>
<span id="cb240-6"><a href="#cb240-6" aria-hidden="true"></a>       (jiffies-per-second))))</span></code></pre></div>
<blockquote>
<p>(features)  procedure</p>
</blockquote>
<p>Returns a list of the feature identifiers which cond-expand treats as true. It is an error to modify this list. Here is an example of what features might return:</p>
<div class="sourceCode" id="cb241"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb241-1"><a href="#cb241-1" aria-hidden="true"></a>(features) \ev</span>
<span id="cb241-2"><a href="#cb241-2" aria-hidden="true"></a>(r7rs ratios exact-complex full-unicode</span>
<span id="cb241-3"><a href="#cb241-3" aria-hidden="true"></a>      gnu-linux little-endian</span>
<span id="cb241-4"><a href="#cb241-4" aria-hidden="true"></a>      fantastic-scheme</span>
<span id="cb241-5"><a href="#cb241-5" aria-hidden="true"></a>      fantastic-scheme<span class="fl">-1.0</span></span>
<span id="cb241-6"><a href="#cb241-6" aria-hidden="true"></a>      space-ship-control-system)</span></code></pre></div>
<h3 id="derived-expression-types-1">Derived expression types</h3>
<p>This section gives syntax definitions for the derived expression types in terms of the primitive expression types (literal, variable, call, lambda, if, and set!), except for quasiquote.</p>
<p>Conditional derived syntax types:</p>
<div class="sourceCode" id="cb242"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> cond</span></span>
<span id="cb242-2"><a href="#cb242-2" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> (<span class="kw">else</span> <span class="op">=&gt;</span>)</span>
<span id="cb242-3"><a href="#cb242-3" aria-hidden="true"></a>    ((<span class="kw">cond</span> (<span class="kw">else</span> result1 result2 ...))</span>
<span id="cb242-4"><a href="#cb242-4" aria-hidden="true"></a>     (<span class="kw">begin</span> result1 result2 ...))</span>
<span id="cb242-5"><a href="#cb242-5" aria-hidden="true"></a>    ((<span class="kw">cond</span> (test <span class="op">=&gt;</span> result))</span>
<span id="cb242-6"><a href="#cb242-6" aria-hidden="true"></a>     (<span class="kw">let</span> ((temp test))</span>
<span id="cb242-7"><a href="#cb242-7" aria-hidden="true"></a>       (<span class="kw">if</span> temp (result temp))))</span>
<span id="cb242-8"><a href="#cb242-8" aria-hidden="true"></a>    ((<span class="kw">cond</span> (test <span class="op">=&gt;</span> result) clause1 clause2 ...)</span>
<span id="cb242-9"><a href="#cb242-9" aria-hidden="true"></a>     (<span class="kw">let</span> ((temp test))</span>
<span id="cb242-10"><a href="#cb242-10" aria-hidden="true"></a>       (<span class="kw">if</span> temp</span>
<span id="cb242-11"><a href="#cb242-11" aria-hidden="true"></a>           (result temp)</span>
<span id="cb242-12"><a href="#cb242-12" aria-hidden="true"></a>           (<span class="kw">cond</span> clause1 clause2 ...))))</span>
<span id="cb242-13"><a href="#cb242-13" aria-hidden="true"></a>    ((<span class="kw">cond</span> (test)) test)</span>
<span id="cb242-14"><a href="#cb242-14" aria-hidden="true"></a>    ((<span class="kw">cond</span> (test) clause1 clause2 ...)</span>
<span id="cb242-15"><a href="#cb242-15" aria-hidden="true"></a>     (<span class="kw">let</span> ((temp test))</span>
<span id="cb242-16"><a href="#cb242-16" aria-hidden="true"></a>       (<span class="kw">if</span> temp</span>
<span id="cb242-17"><a href="#cb242-17" aria-hidden="true"></a>           temp</span>
<span id="cb242-18"><a href="#cb242-18" aria-hidden="true"></a>           (<span class="kw">cond</span> clause1 clause2 ...))))</span>
<span id="cb242-19"><a href="#cb242-19" aria-hidden="true"></a>    ((<span class="kw">cond</span> (test result1 result2 ...))</span>
<span id="cb242-20"><a href="#cb242-20" aria-hidden="true"></a>     (<span class="kw">if</span> test (<span class="kw">begin</span> result1 result2 ...)))</span>
<span id="cb242-21"><a href="#cb242-21" aria-hidden="true"></a>    ((<span class="kw">cond</span> (test result1 result2 ...)</span>
<span id="cb242-22"><a href="#cb242-22" aria-hidden="true"></a>           clause1 clause2 ...)</span>
<span id="cb242-23"><a href="#cb242-23" aria-hidden="true"></a>     (<span class="kw">if</span> test</span>
<span id="cb242-24"><a href="#cb242-24" aria-hidden="true"></a>         (<span class="kw">begin</span> result1 result2 ...)</span>
<span id="cb242-25"><a href="#cb242-25" aria-hidden="true"></a>         (<span class="kw">cond</span> clause1 clause2 ...)))))</span>
<span id="cb242-26"><a href="#cb242-26" aria-hidden="true"></a></span>
<span id="cb242-27"><a href="#cb242-27" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> case</span></span>
<span id="cb242-28"><a href="#cb242-28" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> (<span class="kw">else</span> <span class="op">=&gt;</span>)</span>
<span id="cb242-29"><a href="#cb242-29" aria-hidden="true"></a>    ((<span class="kw">case</span> (key ...)</span>
<span id="cb242-30"><a href="#cb242-30" aria-hidden="true"></a>       clauses ...)</span>
<span id="cb242-31"><a href="#cb242-31" aria-hidden="true"></a>     (<span class="kw">let</span> ((atom-key (key ...)))</span>
<span id="cb242-32"><a href="#cb242-32" aria-hidden="true"></a>       (<span class="kw">case</span> atom-key clauses ...)))</span>
<span id="cb242-33"><a href="#cb242-33" aria-hidden="true"></a>    ((<span class="kw">case</span> key</span>
<span id="cb242-34"><a href="#cb242-34" aria-hidden="true"></a>       (<span class="kw">else</span> <span class="op">=&gt;</span> result))</span>
<span id="cb242-35"><a href="#cb242-35" aria-hidden="true"></a>     (result key))</span>
<span id="cb242-36"><a href="#cb242-36" aria-hidden="true"></a>    ((<span class="kw">case</span> key</span>
<span id="cb242-37"><a href="#cb242-37" aria-hidden="true"></a>       (<span class="kw">else</span> result1 result2 ...))</span>
<span id="cb242-38"><a href="#cb242-38" aria-hidden="true"></a>     (<span class="kw">begin</span> result1 result2 ...))</span>
<span id="cb242-39"><a href="#cb242-39" aria-hidden="true"></a>    ((<span class="kw">case</span> key</span>
<span id="cb242-40"><a href="#cb242-40" aria-hidden="true"></a>       ((atoms ...) <span class="op">=&gt;</span> result))</span>
<span id="cb242-41"><a href="#cb242-41" aria-hidden="true"></a>     (<span class="kw">if</span> (<span class="kw">memv</span> key &#39;(atoms ...))</span>
<span id="cb242-42"><a href="#cb242-42" aria-hidden="true"></a>         (result key)))</span>
<span id="cb242-43"><a href="#cb242-43" aria-hidden="true"></a>    ((<span class="kw">case</span> key</span>
<span id="cb242-44"><a href="#cb242-44" aria-hidden="true"></a>       ((atoms ...) result1 result2 ...))</span>
<span id="cb242-45"><a href="#cb242-45" aria-hidden="true"></a>     (<span class="kw">if</span> (<span class="kw">memv</span> key &#39;(atoms ...))</span>
<span id="cb242-46"><a href="#cb242-46" aria-hidden="true"></a>         (<span class="kw">begin</span> result1 result2 ...)))</span>
<span id="cb242-47"><a href="#cb242-47" aria-hidden="true"></a>    ((<span class="kw">case</span> key</span>
<span id="cb242-48"><a href="#cb242-48" aria-hidden="true"></a>       ((atoms ...) <span class="op">=&gt;</span> result)</span>
<span id="cb242-49"><a href="#cb242-49" aria-hidden="true"></a>       clause clauses ...)</span>
<span id="cb242-50"><a href="#cb242-50" aria-hidden="true"></a>     (<span class="kw">if</span> (<span class="kw">memv</span> key &#39;(atoms ...))</span>
<span id="cb242-51"><a href="#cb242-51" aria-hidden="true"></a>         (result key)</span>
<span id="cb242-52"><a href="#cb242-52" aria-hidden="true"></a>         (<span class="kw">case</span> key clause clauses ...)))</span>
<span id="cb242-53"><a href="#cb242-53" aria-hidden="true"></a>    ((<span class="kw">case</span> key</span>
<span id="cb242-54"><a href="#cb242-54" aria-hidden="true"></a>       ((atoms ...) result1 result2 ...)</span>
<span id="cb242-55"><a href="#cb242-55" aria-hidden="true"></a>       clause clauses ...)</span>
<span id="cb242-56"><a href="#cb242-56" aria-hidden="true"></a>     (<span class="kw">if</span> (<span class="kw">memv</span> key &#39;(atoms ...))</span>
<span id="cb242-57"><a href="#cb242-57" aria-hidden="true"></a>         (<span class="kw">begin</span> result1 result2 ...)</span>
<span id="cb242-58"><a href="#cb242-58" aria-hidden="true"></a>         (<span class="kw">case</span> key clause clauses ...)))))</span>
<span id="cb242-59"><a href="#cb242-59" aria-hidden="true"></a></span>
<span id="cb242-60"><a href="#cb242-60" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> and</span></span>
<span id="cb242-61"><a href="#cb242-61" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb242-62"><a href="#cb242-62" aria-hidden="true"></a>    ((<span class="kw">and</span>) <span class="dv">#t</span>)</span>
<span id="cb242-63"><a href="#cb242-63" aria-hidden="true"></a>    ((<span class="kw">and</span> test) test)</span>
<span id="cb242-64"><a href="#cb242-64" aria-hidden="true"></a>    ((<span class="kw">and</span> test1 test2 ...)</span>
<span id="cb242-65"><a href="#cb242-65" aria-hidden="true"></a>     (<span class="kw">if</span> test1 (<span class="kw">and</span> test2 ...) <span class="dv">#f</span>))))</span>
<span id="cb242-66"><a href="#cb242-66" aria-hidden="true"></a></span>
<span id="cb242-67"><a href="#cb242-67" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> or</span></span>
<span id="cb242-68"><a href="#cb242-68" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb242-69"><a href="#cb242-69" aria-hidden="true"></a>    ((<span class="kw">or</span>) <span class="dv">#f</span>)</span>
<span id="cb242-70"><a href="#cb242-70" aria-hidden="true"></a>    ((<span class="kw">or</span> test) test)</span>
<span id="cb242-71"><a href="#cb242-71" aria-hidden="true"></a>    ((<span class="kw">or</span> test1 test2 ...)</span>
<span id="cb242-72"><a href="#cb242-72" aria-hidden="true"></a>     (<span class="kw">let</span> ((x test1))</span>
<span id="cb242-73"><a href="#cb242-73" aria-hidden="true"></a>       (<span class="kw">if</span> x x (<span class="kw">or</span> test2 ...))))))</span>
<span id="cb242-74"><a href="#cb242-74" aria-hidden="true"></a></span>
<span id="cb242-75"><a href="#cb242-75" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> when</span></span>
<span id="cb242-76"><a href="#cb242-76" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb242-77"><a href="#cb242-77" aria-hidden="true"></a>    ((when test result1 result2 ...)</span>
<span id="cb242-78"><a href="#cb242-78" aria-hidden="true"></a>     (<span class="kw">if</span> test</span>
<span id="cb242-79"><a href="#cb242-79" aria-hidden="true"></a>         (<span class="kw">begin</span> result1 result2 ...)))))</span>
<span id="cb242-80"><a href="#cb242-80" aria-hidden="true"></a></span>
<span id="cb242-81"><a href="#cb242-81" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> unless</span></span>
<span id="cb242-82"><a href="#cb242-82" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb242-83"><a href="#cb242-83" aria-hidden="true"></a>    ((unless test result1 result2 ...)</span>
<span id="cb242-84"><a href="#cb242-84" aria-hidden="true"></a>     (<span class="kw">if</span> (<span class="kw">not</span> test)</span>
<span id="cb242-85"><a href="#cb242-85" aria-hidden="true"></a>         (<span class="kw">begin</span> result1 result2 ...)))))</span></code></pre></div>
<p>Binding constructs:</p>
<div class="sourceCode" id="cb243"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> let</span></span>
<span id="cb243-2"><a href="#cb243-2" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb243-3"><a href="#cb243-3" aria-hidden="true"></a>    ((<span class="kw">let</span> ((name val) ...) body1 body2 ...)</span>
<span id="cb243-4"><a href="#cb243-4" aria-hidden="true"></a>     ((<span class="kw">lambda</span> (name ...) body1 body2 ...)</span>
<span id="cb243-5"><a href="#cb243-5" aria-hidden="true"></a>      val ...))</span>
<span id="cb243-6"><a href="#cb243-6" aria-hidden="true"></a>    ((<span class="kw">let</span> tag ((name val) ...) body1 body2 ...)</span>
<span id="cb243-7"><a href="#cb243-7" aria-hidden="true"></a>     ((<span class="kw">letrec</span> ((tag (<span class="kw">lambda</span> (name ...)</span>
<span id="cb243-8"><a href="#cb243-8" aria-hidden="true"></a>                      body1 body2 ...)))</span>
<span id="cb243-9"><a href="#cb243-9" aria-hidden="true"></a>        tag)</span>
<span id="cb243-10"><a href="#cb243-10" aria-hidden="true"></a>      val ...))))</span>
<span id="cb243-11"><a href="#cb243-11" aria-hidden="true"></a></span>
<span id="cb243-12"><a href="#cb243-12" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> let*</span></span>
<span id="cb243-13"><a href="#cb243-13" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb243-14"><a href="#cb243-14" aria-hidden="true"></a>    ((<span class="kw">let*</span> () body1 body2 ...)</span>
<span id="cb243-15"><a href="#cb243-15" aria-hidden="true"></a>     (<span class="kw">let</span> () body1 body2 ...))</span>
<span id="cb243-16"><a href="#cb243-16" aria-hidden="true"></a>    ((<span class="kw">let*</span> ((name1 val1) (name2 val2) ...)</span>
<span id="cb243-17"><a href="#cb243-17" aria-hidden="true"></a>       body1 body2 ...)</span>
<span id="cb243-18"><a href="#cb243-18" aria-hidden="true"></a>     (<span class="kw">let</span> ((name1 val1))</span>
<span id="cb243-19"><a href="#cb243-19" aria-hidden="true"></a>       (<span class="kw">let*</span> ((name2 val2) ...)</span>
<span id="cb243-20"><a href="#cb243-20" aria-hidden="true"></a>         body1 body2 ...)))))</span></code></pre></div>
<p>The following letrec macro uses the symbol &lt;undefined&gt; in place of an expression which returns something that when stored in a location makes it an error to try to obtain the value stored in the location. (No such expression is defined in Verbatim.) A trick is used to generate the temporary names needed to avoid specifying the order in which the values are evaluated. This could also be accomplished by using an auxiliary macro.</p>
<div class="sourceCode" id="cb244"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> letrec</span></span>
<span id="cb244-2"><a href="#cb244-2" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb244-3"><a href="#cb244-3" aria-hidden="true"></a>    ((<span class="kw">letrec</span> ((var1 init1) ...) body ...)</span>
<span id="cb244-4"><a href="#cb244-4" aria-hidden="true"></a>     (<span class="kw">letrec</span> <span class="st">&quot;generate_temp_names&quot;</span></span>
<span id="cb244-5"><a href="#cb244-5" aria-hidden="true"></a>       (var1 ...)</span>
<span id="cb244-6"><a href="#cb244-6" aria-hidden="true"></a>       ()</span>
<span id="cb244-7"><a href="#cb244-7" aria-hidden="true"></a>       ((var1 init1) ...)</span>
<span id="cb244-8"><a href="#cb244-8" aria-hidden="true"></a>       body ...))</span>
<span id="cb244-9"><a href="#cb244-9" aria-hidden="true"></a>    ((<span class="kw">letrec</span> <span class="st">&quot;generate_temp_names&quot;</span></span>
<span id="cb244-10"><a href="#cb244-10" aria-hidden="true"></a>       ()</span>
<span id="cb244-11"><a href="#cb244-11" aria-hidden="true"></a>       (temp1 ...)</span>
<span id="cb244-12"><a href="#cb244-12" aria-hidden="true"></a>       ((var1 init1) ...)</span>
<span id="cb244-13"><a href="#cb244-13" aria-hidden="true"></a>       body ...)</span>
<span id="cb244-14"><a href="#cb244-14" aria-hidden="true"></a>     (<span class="kw">let</span> ((var1 &lt;undefined&gt;) ...)</span>
<span id="cb244-15"><a href="#cb244-15" aria-hidden="true"></a>       (<span class="kw">let</span> ((temp1 init1) ...)</span>
<span id="cb244-16"><a href="#cb244-16" aria-hidden="true"></a>         (set! var1 temp1)</span>
<span id="cb244-17"><a href="#cb244-17" aria-hidden="true"></a>         ...</span>
<span id="cb244-18"><a href="#cb244-18" aria-hidden="true"></a>         body ...)))</span>
<span id="cb244-19"><a href="#cb244-19" aria-hidden="true"></a>    ((<span class="kw">letrec</span> <span class="st">&quot;generate_temp_names&quot;</span></span>
<span id="cb244-20"><a href="#cb244-20" aria-hidden="true"></a>       (x y ...)</span>
<span id="cb244-21"><a href="#cb244-21" aria-hidden="true"></a>       (temp ...)</span>
<span id="cb244-22"><a href="#cb244-22" aria-hidden="true"></a>       ((var1 init1) ...)</span>
<span id="cb244-23"><a href="#cb244-23" aria-hidden="true"></a>       body ...)</span>
<span id="cb244-24"><a href="#cb244-24" aria-hidden="true"></a>     (<span class="kw">letrec</span> <span class="st">&quot;generate_temp_names&quot;</span></span>
<span id="cb244-25"><a href="#cb244-25" aria-hidden="true"></a>       (y ...)</span>
<span id="cb244-26"><a href="#cb244-26" aria-hidden="true"></a>       (newtemp temp ...)</span>
<span id="cb244-27"><a href="#cb244-27" aria-hidden="true"></a>       ((var1 init1) ...)</span>
<span id="cb244-28"><a href="#cb244-28" aria-hidden="true"></a>       body ...))))</span>
<span id="cb244-29"><a href="#cb244-29" aria-hidden="true"></a></span>
<span id="cb244-30"><a href="#cb244-30" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> letrec*</span></span>
<span id="cb244-31"><a href="#cb244-31" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb244-32"><a href="#cb244-32" aria-hidden="true"></a>    ((letrec* ((var1 init1) ...) body1 body2 ...)</span>
<span id="cb244-33"><a href="#cb244-33" aria-hidden="true"></a>     (<span class="kw">let</span> ((var1 &lt;undefined&gt;) ...)</span>
<span id="cb244-34"><a href="#cb244-34" aria-hidden="true"></a>       (set! var1 init1)</span>
<span id="cb244-35"><a href="#cb244-35" aria-hidden="true"></a>       ...</span>
<span id="cb244-36"><a href="#cb244-36" aria-hidden="true"></a>       (<span class="kw">let</span> () body1 body2 ...)))))</span>
<span id="cb244-37"><a href="#cb244-37" aria-hidden="true"></a></span>
<span id="cb244-38"><a href="#cb244-38" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> let-values</span></span>
<span id="cb244-39"><a href="#cb244-39" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb244-40"><a href="#cb244-40" aria-hidden="true"></a>    ((let-values (binding ...) body0 body1 ...)</span>
<span id="cb244-41"><a href="#cb244-41" aria-hidden="true"></a>     (let-values <span class="st">&quot;bind&quot;</span></span>
<span id="cb244-42"><a href="#cb244-42" aria-hidden="true"></a>       (binding ...) () (<span class="kw">begin</span> body0 body1 ...)))</span>
<span id="cb244-43"><a href="#cb244-43" aria-hidden="true"></a></span>
<span id="cb244-44"><a href="#cb244-44" aria-hidden="true"></a>    ((let-values <span class="st">&quot;bind&quot;</span> () tmps body)</span>
<span id="cb244-45"><a href="#cb244-45" aria-hidden="true"></a>     (<span class="kw">let</span> tmps body))</span>
<span id="cb244-46"><a href="#cb244-46" aria-hidden="true"></a></span>
<span id="cb244-47"><a href="#cb244-47" aria-hidden="true"></a>    ((let-values <span class="st">&quot;bind&quot;</span> ((b0 e0)</span>
<span id="cb244-48"><a href="#cb244-48" aria-hidden="true"></a>                         binding ...) tmps body)</span>
<span id="cb244-49"><a href="#cb244-49" aria-hidden="true"></a>     (let-values <span class="st">&quot;mktmp&quot;</span> b0 e0 ()</span>
<span id="cb244-50"><a href="#cb244-50" aria-hidden="true"></a>                 (binding ...) tmps body))</span>
<span id="cb244-51"><a href="#cb244-51" aria-hidden="true"></a></span>
<span id="cb244-52"><a href="#cb244-52" aria-hidden="true"></a>    ((let-values <span class="st">&quot;mktmp&quot;</span> () e0 args</span>
<span id="cb244-53"><a href="#cb244-53" aria-hidden="true"></a>                 bindings tmps body)</span>
<span id="cb244-54"><a href="#cb244-54" aria-hidden="true"></a>     (<span class="kw">call-with-values</span></span>
<span id="cb244-55"><a href="#cb244-55" aria-hidden="true"></a>         (<span class="kw">lambda</span> () e0)</span>
<span id="cb244-56"><a href="#cb244-56" aria-hidden="true"></a>       (<span class="kw">lambda</span> args</span>
<span id="cb244-57"><a href="#cb244-57" aria-hidden="true"></a>         (let-values <span class="st">&quot;bind&quot;</span></span>
<span id="cb244-58"><a href="#cb244-58" aria-hidden="true"></a>           bindings tmps body))))</span>
<span id="cb244-59"><a href="#cb244-59" aria-hidden="true"></a></span>
<span id="cb244-60"><a href="#cb244-60" aria-hidden="true"></a>    ((let-values <span class="st">&quot;mktmp&quot;</span> (a . b) e0 (arg ...)</span>
<span id="cb244-61"><a href="#cb244-61" aria-hidden="true"></a>                 bindings (tmp ...) body)</span>
<span id="cb244-62"><a href="#cb244-62" aria-hidden="true"></a>     (let-values <span class="st">&quot;mktmp&quot;</span> b e0 (arg ... x)</span>
<span id="cb244-63"><a href="#cb244-63" aria-hidden="true"></a>                 bindings (tmp ... (a x)) body))</span>
<span id="cb244-64"><a href="#cb244-64" aria-hidden="true"></a></span>
<span id="cb244-65"><a href="#cb244-65" aria-hidden="true"></a>    ((let-values <span class="st">&quot;mktmp&quot;</span> a e0 (arg ...)</span>
<span id="cb244-66"><a href="#cb244-66" aria-hidden="true"></a>                 bindings (tmp ...) body)</span>
<span id="cb244-67"><a href="#cb244-67" aria-hidden="true"></a>     (<span class="kw">call-with-values</span></span>
<span id="cb244-68"><a href="#cb244-68" aria-hidden="true"></a>         (<span class="kw">lambda</span> () e0)</span>
<span id="cb244-69"><a href="#cb244-69" aria-hidden="true"></a>       (<span class="kw">lambda</span> (arg ... . x)</span>
<span id="cb244-70"><a href="#cb244-70" aria-hidden="true"></a>         (let-values <span class="st">&quot;bind&quot;</span></span>
<span id="cb244-71"><a href="#cb244-71" aria-hidden="true"></a>           bindings (tmp ... (a x)) body))))))</span>
<span id="cb244-72"><a href="#cb244-72" aria-hidden="true"></a></span>
<span id="cb244-73"><a href="#cb244-73" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> let*-values</span></span>
<span id="cb244-74"><a href="#cb244-74" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb244-75"><a href="#cb244-75" aria-hidden="true"></a>    ((let*-values () body0 body1 ...)</span>
<span id="cb244-76"><a href="#cb244-76" aria-hidden="true"></a>     (<span class="kw">let</span> () body0 body1 ...))</span>
<span id="cb244-77"><a href="#cb244-77" aria-hidden="true"></a></span>
<span id="cb244-78"><a href="#cb244-78" aria-hidden="true"></a>    ((let*-values (binding0 binding1 ...)</span>
<span id="cb244-79"><a href="#cb244-79" aria-hidden="true"></a>       body0 body1 ...)</span>
<span id="cb244-80"><a href="#cb244-80" aria-hidden="true"></a>     (let-values (binding0)</span>
<span id="cb244-81"><a href="#cb244-81" aria-hidden="true"></a>       (let*-values (binding1 ...)</span>
<span id="cb244-82"><a href="#cb244-82" aria-hidden="true"></a>         body0 body1 ...)))))</span>
<span id="cb244-83"><a href="#cb244-83" aria-hidden="true"></a></span>
<span id="cb244-84"><a href="#cb244-84" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> define-values</span></span>
<span id="cb244-85"><a href="#cb244-85" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb244-86"><a href="#cb244-86" aria-hidden="true"></a>    ((define-values () expr)</span>
<span id="cb244-87"><a href="#cb244-87" aria-hidden="true"></a>     (<span class="ex">define</span><span class="fu"> dummy</span></span>
<span id="cb244-88"><a href="#cb244-88" aria-hidden="true"></a>       (<span class="kw">call-with-values</span> (<span class="kw">lambda</span> () expr)</span>
<span id="cb244-89"><a href="#cb244-89" aria-hidden="true"></a>         (<span class="kw">lambda</span> args <span class="dv">#f</span>))))</span>
<span id="cb244-90"><a href="#cb244-90" aria-hidden="true"></a>    ((define-values (var) expr)</span>
<span id="cb244-91"><a href="#cb244-91" aria-hidden="true"></a>     (<span class="ex">define</span><span class="fu"> var </span>expr))</span>
<span id="cb244-92"><a href="#cb244-92" aria-hidden="true"></a>    ((define-values (var0 var1 ... varn) expr)</span>
<span id="cb244-93"><a href="#cb244-93" aria-hidden="true"></a>     (<span class="kw">begin</span></span>
<span id="cb244-94"><a href="#cb244-94" aria-hidden="true"></a>       (<span class="ex">define</span><span class="fu"> var0</span></span>
<span id="cb244-95"><a href="#cb244-95" aria-hidden="true"></a>         (<span class="kw">call-with-values</span> (<span class="kw">lambda</span> () expr)</span>
<span id="cb244-96"><a href="#cb244-96" aria-hidden="true"></a>           <span class="kw">list</span>))</span>
<span id="cb244-97"><a href="#cb244-97" aria-hidden="true"></a>       (<span class="ex">define</span><span class="fu"> var1</span></span>
<span id="cb244-98"><a href="#cb244-98" aria-hidden="true"></a>         (<span class="kw">let</span> ((v (<span class="kw">cadr</span> var0)))</span>
<span id="cb244-99"><a href="#cb244-99" aria-hidden="true"></a>           (<span class="kw">set-cdr!</span> var0 (<span class="kw">cddr</span> var0))</span>
<span id="cb244-100"><a href="#cb244-100" aria-hidden="true"></a>           v)) ...</span>
<span id="cb244-101"><a href="#cb244-101" aria-hidden="true"></a>           (<span class="ex">define</span><span class="fu"> varn</span></span>
<span id="cb244-102"><a href="#cb244-102" aria-hidden="true"></a>             (<span class="kw">let</span> ((v (<span class="kw">cadr</span> var0)))</span>
<span id="cb244-103"><a href="#cb244-103" aria-hidden="true"></a>               (set! var0 (<span class="kw">car</span> var0))</span>
<span id="cb244-104"><a href="#cb244-104" aria-hidden="true"></a>               v))))</span>
<span id="cb244-105"><a href="#cb244-105" aria-hidden="true"></a>    ((define-values (var0 var1 ... . varn) expr)</span>
<span id="cb244-106"><a href="#cb244-106" aria-hidden="true"></a>     (<span class="kw">begin</span></span>
<span id="cb244-107"><a href="#cb244-107" aria-hidden="true"></a>       (<span class="ex">define</span><span class="fu"> var0</span></span>
<span id="cb244-108"><a href="#cb244-108" aria-hidden="true"></a>         (<span class="kw">call-with-values</span> (<span class="kw">lambda</span> () expr)</span>
<span id="cb244-109"><a href="#cb244-109" aria-hidden="true"></a>           <span class="kw">list</span>))</span>
<span id="cb244-110"><a href="#cb244-110" aria-hidden="true"></a>       (<span class="ex">define</span><span class="fu"> var1</span></span>
<span id="cb244-111"><a href="#cb244-111" aria-hidden="true"></a>         (<span class="kw">let</span> ((v (<span class="kw">cadr</span> var0)))</span>
<span id="cb244-112"><a href="#cb244-112" aria-hidden="true"></a>           (<span class="kw">set-cdr!</span> var0 (<span class="kw">cddr</span> var0))</span>
<span id="cb244-113"><a href="#cb244-113" aria-hidden="true"></a>           v)) ...</span>
<span id="cb244-114"><a href="#cb244-114" aria-hidden="true"></a>           (<span class="ex">define</span><span class="fu"> varn</span></span>
<span id="cb244-115"><a href="#cb244-115" aria-hidden="true"></a>             (<span class="kw">let</span> ((v (<span class="kw">cdr</span> var0)))</span>
<span id="cb244-116"><a href="#cb244-116" aria-hidden="true"></a>               (set! var0 (<span class="kw">car</span> var0))</span>
<span id="cb244-117"><a href="#cb244-117" aria-hidden="true"></a>               v))))</span>
<span id="cb244-118"><a href="#cb244-118" aria-hidden="true"></a>    ((define-values var expr)</span>
<span id="cb244-119"><a href="#cb244-119" aria-hidden="true"></a>     (<span class="ex">define</span><span class="fu"> var</span></span>
<span id="cb244-120"><a href="#cb244-120" aria-hidden="true"></a>       (<span class="kw">call-with-values</span> (<span class="kw">lambda</span> () expr)</span>
<span id="cb244-121"><a href="#cb244-121" aria-hidden="true"></a>         <span class="kw">list</span>)))))</span>
<span id="cb244-122"><a href="#cb244-122" aria-hidden="true"></a></span>
<span id="cb244-123"><a href="#cb244-123" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> begin</span></span>
<span id="cb244-124"><a href="#cb244-124" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb244-125"><a href="#cb244-125" aria-hidden="true"></a>    ((<span class="kw">begin</span> <span class="kw">exp</span> ...)</span>
<span id="cb244-126"><a href="#cb244-126" aria-hidden="true"></a>     ((<span class="kw">lambda</span> () <span class="kw">exp</span> ...)))))</span></code></pre></div>
<p>The following alternative expansion for begin does not make use of the ability to write more than one expression in the body of a lambda expression. In any case, note that these rules apply only if the body of the begin contains no definitions.</p>
<div class="sourceCode" id="cb245"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> begin</span></span>
<span id="cb245-2"><a href="#cb245-2" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb245-3"><a href="#cb245-3" aria-hidden="true"></a>    ((<span class="kw">begin</span> <span class="kw">exp</span>)</span>
<span id="cb245-4"><a href="#cb245-4" aria-hidden="true"></a>     <span class="kw">exp</span>)</span>
<span id="cb245-5"><a href="#cb245-5" aria-hidden="true"></a>    ((<span class="kw">begin</span> exp1 exp2 ...)</span>
<span id="cb245-6"><a href="#cb245-6" aria-hidden="true"></a>     (<span class="kw">call-with-values</span></span>
<span id="cb245-7"><a href="#cb245-7" aria-hidden="true"></a>         (<span class="kw">lambda</span> () exp1)</span>
<span id="cb245-8"><a href="#cb245-8" aria-hidden="true"></a>       (<span class="kw">lambda</span> args</span>
<span id="cb245-9"><a href="#cb245-9" aria-hidden="true"></a>         (<span class="kw">begin</span> exp2 ...))))))</span></code></pre></div>
<p>The following syntax definition of do uses a trick to expand the variable clauses. As with letrec above, an auxiliary macro would also work. The expression (if <code>#f</code> #f) is used to obtain an unspecific value.</p>
<div class="sourceCode" id="cb246"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> do</span></span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb246-3"><a href="#cb246-3" aria-hidden="true"></a>    ((<span class="kw">do</span> ((var init step ...) ...)</span>
<span id="cb246-4"><a href="#cb246-4" aria-hidden="true"></a>         (test expr ...)</span>
<span id="cb246-5"><a href="#cb246-5" aria-hidden="true"></a>       command ...)</span>
<span id="cb246-6"><a href="#cb246-6" aria-hidden="true"></a>     (<span class="kw">letrec</span></span>
<span id="cb246-7"><a href="#cb246-7" aria-hidden="true"></a>         ((loop</span>
<span id="cb246-8"><a href="#cb246-8" aria-hidden="true"></a>           (<span class="kw">lambda</span> (var ...)</span>
<span id="cb246-9"><a href="#cb246-9" aria-hidden="true"></a>             (<span class="kw">if</span> test</span>
<span id="cb246-10"><a href="#cb246-10" aria-hidden="true"></a>                 (<span class="kw">begin</span></span>
<span id="cb246-11"><a href="#cb246-11" aria-hidden="true"></a>                   (<span class="kw">if</span> <span class="dv">#f</span> <span class="dv">#f</span>)</span>
<span id="cb246-12"><a href="#cb246-12" aria-hidden="true"></a>                   expr ...)</span>
<span id="cb246-13"><a href="#cb246-13" aria-hidden="true"></a>                 (<span class="kw">begin</span></span>
<span id="cb246-14"><a href="#cb246-14" aria-hidden="true"></a>                   command</span>
<span id="cb246-15"><a href="#cb246-15" aria-hidden="true"></a>                   ...</span>
<span id="cb246-16"><a href="#cb246-16" aria-hidden="true"></a>                   (loop (<span class="kw">do</span> <span class="st">&quot;step&quot;</span> var step ...)</span>
<span id="cb246-17"><a href="#cb246-17" aria-hidden="true"></a>                         ...))))))</span>
<span id="cb246-18"><a href="#cb246-18" aria-hidden="true"></a>       (loop init ...)))</span>
<span id="cb246-19"><a href="#cb246-19" aria-hidden="true"></a>    ((<span class="kw">do</span> <span class="st">&quot;step&quot;</span> x)</span>
<span id="cb246-20"><a href="#cb246-20" aria-hidden="true"></a>     x)</span>
<span id="cb246-21"><a href="#cb246-21" aria-hidden="true"></a>    ((<span class="kw">do</span> <span class="st">&quot;step&quot;</span> x y)</span>
<span id="cb246-22"><a href="#cb246-22" aria-hidden="true"></a>     y)))</span></code></pre></div>
<p>Here is a possible implementation of delay, force and delay-force. We define the expression</p>
<div class="sourceCode" id="cb247"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true"></a>(delay-force &lt;expression&gt;)</span></code></pre></div>
<p>to have the same meaning as the procedure call</p>
<div class="sourceCode" id="cb248"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true"></a>(make-promise <span class="dv">#f</span> (<span class="kw">lambda</span> () &lt;expression&gt;))</span></code></pre></div>
<p>as follows</p>
<div class="sourceCode" id="cb249"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb249-1"><a href="#cb249-1" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> delay-force</span></span>
<span id="cb249-2"><a href="#cb249-2" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb249-3"><a href="#cb249-3" aria-hidden="true"></a>    ((delay-force expression)</span>
<span id="cb249-4"><a href="#cb249-4" aria-hidden="true"></a>     (make-promise <span class="dv">#f</span> (<span class="kw">lambda</span> () expression)))))</span></code></pre></div>
<p>and we define the expression</p>
<div class="sourceCode" id="cb250"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true"></a>(delay &lt;expression&gt;)</span></code></pre></div>
<p>to have the same meaning as:</p>
<div class="sourceCode" id="cb251"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true"></a>(delay-force (make-promise <span class="dv">#t</span> &lt;expression&gt;))</span></code></pre></div>
<p>as follows</p>
<div class="sourceCode" id="cb252"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> delay</span></span>
<span id="cb252-2"><a href="#cb252-2" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb252-3"><a href="#cb252-3" aria-hidden="true"></a>    ((delay expression)</span>
<span id="cb252-4"><a href="#cb252-4" aria-hidden="true"></a>     (delay-force (make-promise <span class="dv">#t</span> expression)))))</span></code></pre></div>
<p>where make-promise is defined as follows:</p>
<div class="sourceCode" id="cb253"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> make-promise</span></span>
<span id="cb253-2"><a href="#cb253-2" aria-hidden="true"></a>  (<span class="kw">lambda</span> (done? proc)</span>
<span id="cb253-3"><a href="#cb253-3" aria-hidden="true"></a>    (<span class="kw">list</span> (<span class="kw">cons</span> done? proc))))</span></code></pre></div>
<p>Finally, we define force to call the procedure expressions in promises iteratively using a trampoline technique following <span class="citation" data-cites="srfi45"></span> until a non-lazy result (i.e. a value created by delay instead of delay-force) is returned, as follows:</p>
<div class="sourceCode" id="cb254"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">force</span> promise)</span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true"></a>  (<span class="kw">if</span> (promise-done? promise)</span>
<span id="cb254-3"><a href="#cb254-3" aria-hidden="true"></a>      (promise-value promise)</span>
<span id="cb254-4"><a href="#cb254-4" aria-hidden="true"></a>      (<span class="kw">let</span> ((promise* ((promise-value promise))))</span>
<span id="cb254-5"><a href="#cb254-5" aria-hidden="true"></a>        (unless (promise-done? promise)</span>
<span id="cb254-6"><a href="#cb254-6" aria-hidden="true"></a>          (promise-update! promise* promise))</span>
<span id="cb254-7"><a href="#cb254-7" aria-hidden="true"></a>        (<span class="kw">force</span> promise))))</span></code></pre></div>
<p>with the following promise accessors:</p>
<div class="sourceCode" id="cb255"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> promise-done</span>?</span>
<span id="cb255-2"><a href="#cb255-2" aria-hidden="true"></a>  (<span class="kw">lambda</span> (x) (<span class="kw">car</span> (<span class="kw">car</span> x))))</span>
<span id="cb255-3"><a href="#cb255-3" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> promise-value</span></span>
<span id="cb255-4"><a href="#cb255-4" aria-hidden="true"></a>  (<span class="kw">lambda</span> (x) (<span class="kw">cdr</span> (<span class="kw">car</span> x))))</span>
<span id="cb255-5"><a href="#cb255-5" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> promise-update</span>!</span>
<span id="cb255-6"><a href="#cb255-6" aria-hidden="true"></a>  (<span class="kw">lambda</span> (new old)</span>
<span id="cb255-7"><a href="#cb255-7" aria-hidden="true"></a>    (<span class="kw">set-car!</span> (<span class="kw">car</span> old) (promise-done? new))</span>
<span id="cb255-8"><a href="#cb255-8" aria-hidden="true"></a>    (<span class="kw">set-cdr!</span> (<span class="kw">car</span> old) (promise-value new))</span>
<span id="cb255-9"><a href="#cb255-9" aria-hidden="true"></a>    (<span class="kw">set-car!</span> new (<span class="kw">car</span> old))))</span></code></pre></div>
<p>The following implementation of make-parameter and parameterize is suitable for an implementation with no threads. Parameter objects are implemented here as procedures, using two arbitrary unique objects &lt;param-set!&gt; and &lt;param-convert&gt;:</p>
<div class="sourceCode" id="cb256"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(make-parameter init . o)</span>
<span id="cb256-2"><a href="#cb256-2" aria-hidden="true"></a>  (<span class="kw">let*</span> ((converter</span>
<span id="cb256-3"><a href="#cb256-3" aria-hidden="true"></a>          (<span class="kw">if</span> (<span class="kw">pair?</span> o) (<span class="kw">car</span> o) (<span class="kw">lambda</span> (x) x)))</span>
<span id="cb256-4"><a href="#cb256-4" aria-hidden="true"></a>         (value (converter init)))</span>
<span id="cb256-5"><a href="#cb256-5" aria-hidden="true"></a>    (<span class="kw">lambda</span> args</span>
<span id="cb256-6"><a href="#cb256-6" aria-hidden="true"></a>      (<span class="kw">cond</span></span>
<span id="cb256-7"><a href="#cb256-7" aria-hidden="true"></a>       ((<span class="kw">null?</span> args)</span>
<span id="cb256-8"><a href="#cb256-8" aria-hidden="true"></a>        value)</span>
<span id="cb256-9"><a href="#cb256-9" aria-hidden="true"></a>       ((<span class="kw">eq?</span> (<span class="kw">car</span> args) &lt;param-set!&gt;)</span>
<span id="cb256-10"><a href="#cb256-10" aria-hidden="true"></a>        (set! value (<span class="kw">cadr</span> args)))</span>
<span id="cb256-11"><a href="#cb256-11" aria-hidden="true"></a>       ((<span class="kw">eq?</span> (<span class="kw">car</span> args) &lt;param-convert&gt;)</span>
<span id="cb256-12"><a href="#cb256-12" aria-hidden="true"></a>        converter)</span>
<span id="cb256-13"><a href="#cb256-13" aria-hidden="true"></a>       (<span class="kw">else</span></span>
<span id="cb256-14"><a href="#cb256-14" aria-hidden="true"></a>        (error <span class="st">&quot;bad parameter syntax&quot;</span>))))))</span></code></pre></div>
<p>Then parameterize uses dynamic-wind to dynamically rebind the associated value:</p>
<div class="sourceCode" id="cb257"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> parameterize</span></span>
<span id="cb257-2"><a href="#cb257-2" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb257-3"><a href="#cb257-3" aria-hidden="true"></a>    ((parameterize (<span class="st">&quot;step&quot;</span>)</span>
<span id="cb257-4"><a href="#cb257-4" aria-hidden="true"></a>       ((param value p old new) ...)</span>
<span id="cb257-5"><a href="#cb257-5" aria-hidden="true"></a>       ()</span>
<span id="cb257-6"><a href="#cb257-6" aria-hidden="true"></a>       body)</span>
<span id="cb257-7"><a href="#cb257-7" aria-hidden="true"></a>     (<span class="kw">let</span> ((p param) ...)</span>
<span id="cb257-8"><a href="#cb257-8" aria-hidden="true"></a>       (<span class="kw">let</span> ((old (p)) ...</span>
<span id="cb257-9"><a href="#cb257-9" aria-hidden="true"></a>             (new ((p &lt;param-convert&gt;) value)) ...)</span>
<span id="cb257-10"><a href="#cb257-10" aria-hidden="true"></a>         (<span class="kw">dynamic-wind</span></span>
<span id="cb257-11"><a href="#cb257-11" aria-hidden="true"></a>             (<span class="kw">lambda</span> () (p &lt;param-set!&gt; new) ...)</span>
<span id="cb257-12"><a href="#cb257-12" aria-hidden="true"></a>             (<span class="kw">lambda</span> () . body)</span>
<span id="cb257-13"><a href="#cb257-13" aria-hidden="true"></a>             (<span class="kw">lambda</span> () (p &lt;param-set!&gt; old) ...)))))</span>
<span id="cb257-14"><a href="#cb257-14" aria-hidden="true"></a>    ((parameterize (<span class="st">&quot;step&quot;</span>)</span>
<span id="cb257-15"><a href="#cb257-15" aria-hidden="true"></a>       args</span>
<span id="cb257-16"><a href="#cb257-16" aria-hidden="true"></a>       ((param value) . rest)</span>
<span id="cb257-17"><a href="#cb257-17" aria-hidden="true"></a>       body)</span>
<span id="cb257-18"><a href="#cb257-18" aria-hidden="true"></a>     (parameterize (<span class="st">&quot;step&quot;</span>)</span>
<span id="cb257-19"><a href="#cb257-19" aria-hidden="true"></a>       ((param value p old new) . args)</span>
<span id="cb257-20"><a href="#cb257-20" aria-hidden="true"></a>       rest</span>
<span id="cb257-21"><a href="#cb257-21" aria-hidden="true"></a>       body))</span>
<span id="cb257-22"><a href="#cb257-22" aria-hidden="true"></a>    ((parameterize ((param value) ...) . body)</span>
<span id="cb257-23"><a href="#cb257-23" aria-hidden="true"></a>     (parameterize (<span class="st">&quot;step&quot;</span>)</span>
<span id="cb257-24"><a href="#cb257-24" aria-hidden="true"></a>       ()</span>
<span id="cb257-25"><a href="#cb257-25" aria-hidden="true"></a>       ((param value) ...)</span>
<span id="cb257-26"><a href="#cb257-26" aria-hidden="true"></a>       body))))</span></code></pre></div>
<p>The following implementation of guard depends on an auxiliary macro, here called guard-aux.</p>
<div class="sourceCode" id="cb258"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> guard</span></span>
<span id="cb258-2"><a href="#cb258-2" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb258-3"><a href="#cb258-3" aria-hidden="true"></a>    ((guard (var clause ...) e1 e2 ...)</span>
<span id="cb258-4"><a href="#cb258-4" aria-hidden="true"></a>     ((<span class="kw">call/cc</span></span>
<span id="cb258-5"><a href="#cb258-5" aria-hidden="true"></a>       (<span class="kw">lambda</span> (guard-k)</span>
<span id="cb258-6"><a href="#cb258-6" aria-hidden="true"></a>         (with-exception-handler</span>
<span id="cb258-7"><a href="#cb258-7" aria-hidden="true"></a>          (<span class="kw">lambda</span> (condition)</span>
<span id="cb258-8"><a href="#cb258-8" aria-hidden="true"></a>            ((<span class="kw">call/cc</span></span>
<span id="cb258-9"><a href="#cb258-9" aria-hidden="true"></a>              (<span class="kw">lambda</span> (handler-k)</span>
<span id="cb258-10"><a href="#cb258-10" aria-hidden="true"></a>                (guard-k</span>
<span id="cb258-11"><a href="#cb258-11" aria-hidden="true"></a>                 (<span class="kw">lambda</span> ()</span>
<span id="cb258-12"><a href="#cb258-12" aria-hidden="true"></a>                   (<span class="kw">let</span> ((var condition))</span>
<span id="cb258-13"><a href="#cb258-13" aria-hidden="true"></a>                     (guard-aux</span>
<span id="cb258-14"><a href="#cb258-14" aria-hidden="true"></a>                      (handler-k</span>
<span id="cb258-15"><a href="#cb258-15" aria-hidden="true"></a>                       (<span class="kw">lambda</span> ()</span>
<span id="cb258-16"><a href="#cb258-16" aria-hidden="true"></a>                         (raise-continuable condition)))</span>
<span id="cb258-17"><a href="#cb258-17" aria-hidden="true"></a>                      clause ...))))))))</span>
<span id="cb258-18"><a href="#cb258-18" aria-hidden="true"></a>          (<span class="kw">lambda</span> ()</span>
<span id="cb258-19"><a href="#cb258-19" aria-hidden="true"></a>            (<span class="kw">call-with-values</span></span>
<span id="cb258-20"><a href="#cb258-20" aria-hidden="true"></a>                (<span class="kw">lambda</span> () e1 e2 ...)</span>
<span id="cb258-21"><a href="#cb258-21" aria-hidden="true"></a>              (<span class="kw">lambda</span> args</span>
<span id="cb258-22"><a href="#cb258-22" aria-hidden="true"></a>                (guard-k</span>
<span id="cb258-23"><a href="#cb258-23" aria-hidden="true"></a>                 (<span class="kw">lambda</span> ()</span>
<span id="cb258-24"><a href="#cb258-24" aria-hidden="true"></a>                   (apply <span class="kw">values</span> args)))))))))))))</span>
<span id="cb258-25"><a href="#cb258-25" aria-hidden="true"></a></span>
<span id="cb258-26"><a href="#cb258-26" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> guard-aux</span></span>
<span id="cb258-27"><a href="#cb258-27" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> (<span class="kw">else</span> <span class="op">=&gt;</span>)</span>
<span id="cb258-28"><a href="#cb258-28" aria-hidden="true"></a>    ((guard-aux reraise (<span class="kw">else</span> result1 result2 ...))</span>
<span id="cb258-29"><a href="#cb258-29" aria-hidden="true"></a>     (<span class="kw">begin</span> result1 result2 ...))</span>
<span id="cb258-30"><a href="#cb258-30" aria-hidden="true"></a>    ((guard-aux reraise (test <span class="op">=&gt;</span> result))</span>
<span id="cb258-31"><a href="#cb258-31" aria-hidden="true"></a>     (<span class="kw">let</span> ((temp test))</span>
<span id="cb258-32"><a href="#cb258-32" aria-hidden="true"></a>       (<span class="kw">if</span> temp</span>
<span id="cb258-33"><a href="#cb258-33" aria-hidden="true"></a>           (result temp)</span>
<span id="cb258-34"><a href="#cb258-34" aria-hidden="true"></a>           reraise)))</span>
<span id="cb258-35"><a href="#cb258-35" aria-hidden="true"></a>    ((guard-aux reraise (test <span class="op">=&gt;</span> result)</span>
<span id="cb258-36"><a href="#cb258-36" aria-hidden="true"></a>                clause1 clause2 ...)</span>
<span id="cb258-37"><a href="#cb258-37" aria-hidden="true"></a>     (<span class="kw">let</span> ((temp test))</span>
<span id="cb258-38"><a href="#cb258-38" aria-hidden="true"></a>       (<span class="kw">if</span> temp</span>
<span id="cb258-39"><a href="#cb258-39" aria-hidden="true"></a>           (result temp)</span>
<span id="cb258-40"><a href="#cb258-40" aria-hidden="true"></a>           (guard-aux reraise clause1 clause2 ...))))</span>
<span id="cb258-41"><a href="#cb258-41" aria-hidden="true"></a>    ((guard-aux reraise (test))</span>
<span id="cb258-42"><a href="#cb258-42" aria-hidden="true"></a>     (<span class="kw">or</span> test reraise))</span>
<span id="cb258-43"><a href="#cb258-43" aria-hidden="true"></a>    ((guard-aux reraise (test) clause1 clause2 ...)</span>
<span id="cb258-44"><a href="#cb258-44" aria-hidden="true"></a>     (<span class="kw">let</span> ((temp test))</span>
<span id="cb258-45"><a href="#cb258-45" aria-hidden="true"></a>       (<span class="kw">if</span> temp</span>
<span id="cb258-46"><a href="#cb258-46" aria-hidden="true"></a>           temp</span>
<span id="cb258-47"><a href="#cb258-47" aria-hidden="true"></a>           (guard-aux reraise clause1 clause2 ...))))</span>
<span id="cb258-48"><a href="#cb258-48" aria-hidden="true"></a>    ((guard-aux reraise (test result1 result2 ...))</span>
<span id="cb258-49"><a href="#cb258-49" aria-hidden="true"></a>     (<span class="kw">if</span> test</span>
<span id="cb258-50"><a href="#cb258-50" aria-hidden="true"></a>         (<span class="kw">begin</span> result1 result2 ...)</span>
<span id="cb258-51"><a href="#cb258-51" aria-hidden="true"></a>         reraise))</span>
<span id="cb258-52"><a href="#cb258-52" aria-hidden="true"></a>    ((guard-aux reraise</span>
<span id="cb258-53"><a href="#cb258-53" aria-hidden="true"></a>                (test result1 result2 ...)</span>
<span id="cb258-54"><a href="#cb258-54" aria-hidden="true"></a>                clause1 clause2 ...)</span>
<span id="cb258-55"><a href="#cb258-55" aria-hidden="true"></a>     (<span class="kw">if</span> test</span>
<span id="cb258-56"><a href="#cb258-56" aria-hidden="true"></a>         (<span class="kw">begin</span> result1 result2 ...)</span>
<span id="cb258-57"><a href="#cb258-57" aria-hidden="true"></a>         (guard-aux reraise clause1 clause2 ...)))))</span>
<span id="cb258-58"><a href="#cb258-58" aria-hidden="true"></a></span>
<span id="cb258-59"><a href="#cb258-59" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> case-lambda</span></span>
<span id="cb258-60"><a href="#cb258-60" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> ()</span>
<span id="cb258-61"><a href="#cb258-61" aria-hidden="true"></a>    ((case-lambda (params body0 ...) ...)</span>
<span id="cb258-62"><a href="#cb258-62" aria-hidden="true"></a>     (<span class="kw">lambda</span> args</span>
<span id="cb258-63"><a href="#cb258-63" aria-hidden="true"></a>       (<span class="kw">let</span> ((len (<span class="kw">length</span> args)))</span>
<span id="cb258-64"><a href="#cb258-64" aria-hidden="true"></a>         (<span class="kw">letrec-syntax</span></span>
<span id="cb258-65"><a href="#cb258-65" aria-hidden="true"></a>             ((cl (<span class="kw">syntax-rules</span> ::: ()</span>
<span id="cb258-66"><a href="#cb258-66" aria-hidden="true"></a>                                ((cl)</span>
<span id="cb258-67"><a href="#cb258-67" aria-hidden="true"></a>                                 (error <span class="st">&quot;no matching clause&quot;</span>))</span>
<span id="cb258-68"><a href="#cb258-68" aria-hidden="true"></a>                                ((cl ((p :::) . body) . rest)</span>
<span id="cb258-69"><a href="#cb258-69" aria-hidden="true"></a>                                 (<span class="kw">if</span> (<span class="op">=</span> len (<span class="kw">length</span> &#39;(p :::)))</span>
<span id="cb258-70"><a href="#cb258-70" aria-hidden="true"></a>                                     (apply (<span class="kw">lambda</span> (p :::)</span>
<span id="cb258-71"><a href="#cb258-71" aria-hidden="true"></a>                                              . body)</span>
<span id="cb258-72"><a href="#cb258-72" aria-hidden="true"></a>                                            args)</span>
<span id="cb258-73"><a href="#cb258-73" aria-hidden="true"></a>                                     (cl . rest)))</span>
<span id="cb258-74"><a href="#cb258-74" aria-hidden="true"></a>                                ((cl ((p ::: . tail) . body)</span>
<span id="cb258-75"><a href="#cb258-75" aria-hidden="true"></a>                                     . rest)</span>
<span id="cb258-76"><a href="#cb258-76" aria-hidden="true"></a>                                 (<span class="kw">if</span> (<span class="op">&gt;=</span> len (<span class="kw">length</span> &#39;(p :::)))</span>
<span id="cb258-77"><a href="#cb258-77" aria-hidden="true"></a>                                     (apply</span>
<span id="cb258-78"><a href="#cb258-78" aria-hidden="true"></a>                                      (<span class="kw">lambda</span> (p ::: . tail)</span>
<span id="cb258-79"><a href="#cb258-79" aria-hidden="true"></a>                                        . body)</span>
<span id="cb258-80"><a href="#cb258-80" aria-hidden="true"></a>                                      args)</span>
<span id="cb258-81"><a href="#cb258-81" aria-hidden="true"></a>                                     (cl . rest))))))</span>
<span id="cb258-82"><a href="#cb258-82" aria-hidden="true"></a>           (cl (params body0 ...) ...)))))))</span></code></pre></div>
<p>This definition of cond-expand does not interact with the features procedure. It requires that each feature identifier provided by the implementation be explicitly mentioned.</p>
<div class="sourceCode" id="cb259"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> cond-expand</span></span>
<span id="cb259-2"><a href="#cb259-2" aria-hidden="true"></a>  <span class="co">;; Extend this to mention all feature ids and libraries</span></span>
<span id="cb259-3"><a href="#cb259-3" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> (<span class="kw">and</span> <span class="kw">or</span> <span class="kw">not</span> <span class="kw">else</span> r7rs library verbatim base)</span>
<span id="cb259-4"><a href="#cb259-4" aria-hidden="true"></a>    ((cond-expand)</span>
<span id="cb259-5"><a href="#cb259-5" aria-hidden="true"></a>     (syntax-error <span class="st">&quot;Unfulfilled cond-expand&quot;</span>))</span>
<span id="cb259-6"><a href="#cb259-6" aria-hidden="true"></a>    ((cond-expand (<span class="kw">else</span> body ...))</span>
<span id="cb259-7"><a href="#cb259-7" aria-hidden="true"></a>     (<span class="kw">begin</span> body ...))</span>
<span id="cb259-8"><a href="#cb259-8" aria-hidden="true"></a>    ((cond-expand ((<span class="kw">and</span>) body ...) more-clauses ...)</span>
<span id="cb259-9"><a href="#cb259-9" aria-hidden="true"></a>     (<span class="kw">begin</span> body ...))</span>
<span id="cb259-10"><a href="#cb259-10" aria-hidden="true"></a>    ((cond-expand ((<span class="kw">and</span> req1 req2 ...) body ...)</span>
<span id="cb259-11"><a href="#cb259-11" aria-hidden="true"></a>                  more-clauses ...)</span>
<span id="cb259-12"><a href="#cb259-12" aria-hidden="true"></a>     (cond-expand</span>
<span id="cb259-13"><a href="#cb259-13" aria-hidden="true"></a>      (req1</span>
<span id="cb259-14"><a href="#cb259-14" aria-hidden="true"></a>       (cond-expand</span>
<span id="cb259-15"><a href="#cb259-15" aria-hidden="true"></a>        ((<span class="kw">and</span> req2 ...) body ...)</span>
<span id="cb259-16"><a href="#cb259-16" aria-hidden="true"></a>        more-clauses ...))</span>
<span id="cb259-17"><a href="#cb259-17" aria-hidden="true"></a>      more-clauses ...))</span>
<span id="cb259-18"><a href="#cb259-18" aria-hidden="true"></a>    ((cond-expand ((<span class="kw">or</span>) body ...) more-clauses ...)</span>
<span id="cb259-19"><a href="#cb259-19" aria-hidden="true"></a>     (cond-expand more-clauses ...))</span>
<span id="cb259-20"><a href="#cb259-20" aria-hidden="true"></a>    ((cond-expand ((<span class="kw">or</span> req1 req2 ...) body ...)</span>
<span id="cb259-21"><a href="#cb259-21" aria-hidden="true"></a>                  more-clauses ...)</span>
<span id="cb259-22"><a href="#cb259-22" aria-hidden="true"></a>     (cond-expand</span>
<span id="cb259-23"><a href="#cb259-23" aria-hidden="true"></a>      (req1</span>
<span id="cb259-24"><a href="#cb259-24" aria-hidden="true"></a>       (<span class="kw">begin</span> body ...))</span>
<span id="cb259-25"><a href="#cb259-25" aria-hidden="true"></a>      (<span class="kw">else</span></span>
<span id="cb259-26"><a href="#cb259-26" aria-hidden="true"></a>       (cond-expand</span>
<span id="cb259-27"><a href="#cb259-27" aria-hidden="true"></a>        ((<span class="kw">or</span> req2 ...) body ...)</span>
<span id="cb259-28"><a href="#cb259-28" aria-hidden="true"></a>        more-clauses ...))))</span>
<span id="cb259-29"><a href="#cb259-29" aria-hidden="true"></a>    ((cond-expand ((<span class="kw">not</span> req) body ...)</span>
<span id="cb259-30"><a href="#cb259-30" aria-hidden="true"></a>                  more-clauses ...)</span>
<span id="cb259-31"><a href="#cb259-31" aria-hidden="true"></a>     (cond-expand</span>
<span id="cb259-32"><a href="#cb259-32" aria-hidden="true"></a>      (req</span>
<span id="cb259-33"><a href="#cb259-33" aria-hidden="true"></a>       (cond-expand more-clauses ...))</span>
<span id="cb259-34"><a href="#cb259-34" aria-hidden="true"></a>      (<span class="kw">else</span> body ...)))</span>
<span id="cb259-35"><a href="#cb259-35" aria-hidden="true"></a>    ((cond-expand (r7rs body ...)</span>
<span id="cb259-36"><a href="#cb259-36" aria-hidden="true"></a>                  more-clauses ...)</span>
<span id="cb259-37"><a href="#cb259-37" aria-hidden="true"></a>     (<span class="kw">begin</span> body ...))</span>
<span id="cb259-38"><a href="#cb259-38" aria-hidden="true"></a>    <span class="co">;; Add clauses here for each</span></span>
<span id="cb259-39"><a href="#cb259-39" aria-hidden="true"></a>    <span class="co">;; supported feature identifier.</span></span>
<span id="cb259-40"><a href="#cb259-40" aria-hidden="true"></a>    <span class="co">;; Samples:</span></span>
<span id="cb259-41"><a href="#cb259-41" aria-hidden="true"></a>    <span class="co">;; ((cond-expand (exact-closed body ...)</span></span>
<span id="cb259-42"><a href="#cb259-42" aria-hidden="true"></a>    <span class="co">;;               more-clauses ...)</span></span>
<span id="cb259-43"><a href="#cb259-43" aria-hidden="true"></a>    <span class="co">;;   (begin body ...))</span></span>
<span id="cb259-44"><a href="#cb259-44" aria-hidden="true"></a>    <span class="co">;; ((cond-expand (ieee-float body ...)</span></span>
<span id="cb259-45"><a href="#cb259-45" aria-hidden="true"></a>    <span class="co">;;               more-clauses ...)</span></span>
<span id="cb259-46"><a href="#cb259-46" aria-hidden="true"></a>    <span class="co">;;   (begin body ...))</span></span>
<span id="cb259-47"><a href="#cb259-47" aria-hidden="true"></a>    ((cond-expand ((library (verbatim base))</span>
<span id="cb259-48"><a href="#cb259-48" aria-hidden="true"></a>                   body ...)</span>
<span id="cb259-49"><a href="#cb259-49" aria-hidden="true"></a>                  more-clauses ...)</span>
<span id="cb259-50"><a href="#cb259-50" aria-hidden="true"></a>     (<span class="kw">begin</span> body ...))</span>
<span id="cb259-51"><a href="#cb259-51" aria-hidden="true"></a>    <span class="co">;; Add clauses here for each library</span></span>
<span id="cb259-52"><a href="#cb259-52" aria-hidden="true"></a>    ((cond-expand (feature-id body ...)</span>
<span id="cb259-53"><a href="#cb259-53" aria-hidden="true"></a>                  more-clauses ...)</span>
<span id="cb259-54"><a href="#cb259-54" aria-hidden="true"></a>     (cond-expand more-clauses ...))</span>
<span id="cb259-55"><a href="#cb259-55" aria-hidden="true"></a>    ((cond-expand ((library (name ...))</span>
<span id="cb259-56"><a href="#cb259-56" aria-hidden="true"></a>                   body ...)</span>
<span id="cb259-57"><a href="#cb259-57" aria-hidden="true"></a>                  more-clauses ...)</span>
<span id="cb259-58"><a href="#cb259-58" aria-hidden="true"></a>     (cond-expand more-clauses ...))))</span></code></pre></div>
<h2 id="standard-libraries-1">Standard Libraries</h2>
<p>This section lists the exports provided by the standard libraries. The libraries are factored so as to separate features which might not be supported by all implementations, or which might be expensive to load.</p>
<p>The scheme library prefix is used for all standard libraries, and is reserved for use by future standards.</p>
<h3 id="base-library">Base Library</h3>
<p>The <code>(scheme base)</code> library exports many of the procedures and syntax bindings that are traditionally associated with Scheme. The division between the base library and the other standard libraries is based on use, not on construction. In particular, some facilities that are typically implemented as primitives by a compiler or the run-time system rather than in terms of other standard procedures or syntax are not part of the base library, but are defined in separate libraries. By the same token, some exports of the base library are implementable in terms of other exports. They are redundant in the strict sense of the word, but they capture common patterns of usage, and are therefore provided as convenient abbreviations.</p>
<div class="sourceCode" id="cb260"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true"></a>*</span>
<span id="cb260-2"><a href="#cb260-2" aria-hidden="true"></a><span class="op">+</span></span>
<span id="cb260-3"><a href="#cb260-3" aria-hidden="true"></a><span class="op">-</span></span>
<span id="cb260-4"><a href="#cb260-4" aria-hidden="true"></a>...</span>
<span id="cb260-5"><a href="#cb260-5" aria-hidden="true"></a><span class="op">/</span></span>
<span id="cb260-6"><a href="#cb260-6" aria-hidden="true"></a><span class="op">&lt;</span></span>
<span id="cb260-7"><a href="#cb260-7" aria-hidden="true"></a><span class="op">&lt;=</span></span>
<span id="cb260-8"><a href="#cb260-8" aria-hidden="true"></a><span class="op">=</span></span>
<span id="cb260-9"><a href="#cb260-9" aria-hidden="true"></a><span class="op">=&gt;</span></span>
<span id="cb260-10"><a href="#cb260-10" aria-hidden="true"></a><span class="op">&gt;</span></span>
<span id="cb260-11"><a href="#cb260-11" aria-hidden="true"></a><span class="op">&gt;=</span></span>
<span id="cb260-12"><a href="#cb260-12" aria-hidden="true"></a>_</span>
<span id="cb260-13"><a href="#cb260-13" aria-hidden="true"></a><span class="kw">abs</span></span>
<span id="cb260-14"><a href="#cb260-14" aria-hidden="true"></a><span class="kw">and</span></span>
<span id="cb260-15"><a href="#cb260-15" aria-hidden="true"></a><span class="kw">append</span></span>
<span id="cb260-16"><a href="#cb260-16" aria-hidden="true"></a>apply</span>
<span id="cb260-17"><a href="#cb260-17" aria-hidden="true"></a><span class="kw">assoc</span></span>
<span id="cb260-18"><a href="#cb260-18" aria-hidden="true"></a><span class="kw">assq</span></span>
<span id="cb260-19"><a href="#cb260-19" aria-hidden="true"></a><span class="kw">assv</span></span>
<span id="cb260-20"><a href="#cb260-20" aria-hidden="true"></a><span class="kw">begin</span></span>
<span id="cb260-21"><a href="#cb260-21" aria-hidden="true"></a>binary-port?</span>
<span id="cb260-22"><a href="#cb260-22" aria-hidden="true"></a>boolean=?</span>
<span id="cb260-23"><a href="#cb260-23" aria-hidden="true"></a><span class="kw">boolean?</span></span>
<span id="cb260-24"><a href="#cb260-24" aria-hidden="true"></a>bytevector</span>
<span id="cb260-25"><a href="#cb260-25" aria-hidden="true"></a>bytevector-append</span>
<span id="cb260-26"><a href="#cb260-26" aria-hidden="true"></a>bytevector-copy</span>
<span id="cb260-27"><a href="#cb260-27" aria-hidden="true"></a>bytevector-copy!</span>
<span id="cb260-28"><a href="#cb260-28" aria-hidden="true"></a>bytevector-length</span>
<span id="cb260-29"><a href="#cb260-29" aria-hidden="true"></a>bytevector-u8-ref</span>
<span id="cb260-30"><a href="#cb260-30" aria-hidden="true"></a>bytevector-u8-set!</span>
<span id="cb260-31"><a href="#cb260-31" aria-hidden="true"></a>bytevector?</span>
<span id="cb260-32"><a href="#cb260-32" aria-hidden="true"></a><span class="kw">caar</span></span>
<span id="cb260-33"><a href="#cb260-33" aria-hidden="true"></a><span class="kw">cadr</span></span>
<span id="cb260-34"><a href="#cb260-34" aria-hidden="true"></a><span class="kw">call-with-current-continuation</span></span>
<span id="cb260-35"><a href="#cb260-35" aria-hidden="true"></a>call-with-port</span>
<span id="cb260-36"><a href="#cb260-36" aria-hidden="true"></a><span class="kw">call-with-values</span></span>
<span id="cb260-37"><a href="#cb260-37" aria-hidden="true"></a><span class="kw">call/cc</span></span>
<span id="cb260-38"><a href="#cb260-38" aria-hidden="true"></a><span class="kw">car</span></span>
<span id="cb260-39"><a href="#cb260-39" aria-hidden="true"></a><span class="kw">case</span></span>
<span id="cb260-40"><a href="#cb260-40" aria-hidden="true"></a><span class="kw">cdar</span></span>
<span id="cb260-41"><a href="#cb260-41" aria-hidden="true"></a><span class="kw">cddr</span></span>
<span id="cb260-42"><a href="#cb260-42" aria-hidden="true"></a><span class="kw">cdr</span></span>
<span id="cb260-43"><a href="#cb260-43" aria-hidden="true"></a><span class="kw">ceiling</span></span>
<span id="cb260-44"><a href="#cb260-44" aria-hidden="true"></a><span class="kw">char-&gt;integer</span></span>
<span id="cb260-45"><a href="#cb260-45" aria-hidden="true"></a><span class="kw">char-ready?</span></span>
<span id="cb260-46"><a href="#cb260-46" aria-hidden="true"></a><span class="kw">char&lt;=?</span></span>
<span id="cb260-47"><a href="#cb260-47" aria-hidden="true"></a>char&lt;?</span>
<span id="cb260-48"><a href="#cb260-48" aria-hidden="true"></a><span class="kw">char=?</span></span>
<span id="cb260-49"><a href="#cb260-49" aria-hidden="true"></a><span class="kw">char&gt;=?</span></span>
<span id="cb260-50"><a href="#cb260-50" aria-hidden="true"></a><span class="kw">char&gt;?</span></span>
<span id="cb260-51"><a href="#cb260-51" aria-hidden="true"></a><span class="kw">char?</span></span>
<span id="cb260-52"><a href="#cb260-52" aria-hidden="true"></a><span class="kw">close-input-port</span></span>
<span id="cb260-53"><a href="#cb260-53" aria-hidden="true"></a><span class="kw">close-output-port</span></span>
<span id="cb260-54"><a href="#cb260-54" aria-hidden="true"></a>close-port</span>
<span id="cb260-55"><a href="#cb260-55" aria-hidden="true"></a><span class="kw">complex?</span></span>
<span id="cb260-56"><a href="#cb260-56" aria-hidden="true"></a><span class="kw">cond</span></span>
<span id="cb260-57"><a href="#cb260-57" aria-hidden="true"></a>cond-expand</span>
<span id="cb260-58"><a href="#cb260-58" aria-hidden="true"></a><span class="kw">cons</span></span>
<span id="cb260-59"><a href="#cb260-59" aria-hidden="true"></a>current-error-port</span>
<span id="cb260-60"><a href="#cb260-60" aria-hidden="true"></a><span class="kw">current-input-port</span></span>
<span id="cb260-61"><a href="#cb260-61" aria-hidden="true"></a><span class="kw">current-output-port</span></span>
<span id="cb260-62"><a href="#cb260-62" aria-hidden="true"></a><span class="ex">define</span></span>
<span id="cb260-63"><a href="#cb260-63" aria-hidden="true"></a><span class="fu">define-record-type</span></span>
<span id="cb260-64"><a href="#cb260-64" aria-hidden="true"></a><span class="ex">define-syntax</span></span>
<span id="cb260-65"><a href="#cb260-65" aria-hidden="true"></a><span class="fu">define-values</span></span>
<span id="cb260-66"><a href="#cb260-66" aria-hidden="true"></a><span class="kw">denominator</span></span>
<span id="cb260-67"><a href="#cb260-67" aria-hidden="true"></a><span class="kw">do</span></span>
<span id="cb260-68"><a href="#cb260-68" aria-hidden="true"></a><span class="kw">dynamic-wind</span></span>
<span id="cb260-69"><a href="#cb260-69" aria-hidden="true"></a><span class="kw">else</span></span>
<span id="cb260-70"><a href="#cb260-70" aria-hidden="true"></a>eof-object</span>
<span id="cb260-71"><a href="#cb260-71" aria-hidden="true"></a><span class="kw">eof-object?</span></span>
<span id="cb260-72"><a href="#cb260-72" aria-hidden="true"></a><span class="kw">eq?</span></span>
<span id="cb260-73"><a href="#cb260-73" aria-hidden="true"></a><span class="kw">equal?</span></span>
<span id="cb260-74"><a href="#cb260-74" aria-hidden="true"></a><span class="kw">eqv?</span></span>
<span id="cb260-75"><a href="#cb260-75" aria-hidden="true"></a>error</span>
<span id="cb260-76"><a href="#cb260-76" aria-hidden="true"></a>error-object-irritants</span>
<span id="cb260-77"><a href="#cb260-77" aria-hidden="true"></a>error-object-message</span>
<span id="cb260-78"><a href="#cb260-78" aria-hidden="true"></a>error-object?</span>
<span id="cb260-79"><a href="#cb260-79" aria-hidden="true"></a><span class="kw">even?</span></span>
<span id="cb260-80"><a href="#cb260-80" aria-hidden="true"></a>exact</span>
<span id="cb260-81"><a href="#cb260-81" aria-hidden="true"></a>exact-integer-sqrt</span>
<span id="cb260-82"><a href="#cb260-82" aria-hidden="true"></a>exact-integer?</span>
<span id="cb260-83"><a href="#cb260-83" aria-hidden="true"></a><span class="kw">exact?</span></span>
<span id="cb260-84"><a href="#cb260-84" aria-hidden="true"></a><span class="kw">expt</span></span>
<span id="cb260-85"><a href="#cb260-85" aria-hidden="true"></a>features</span>
<span id="cb260-86"><a href="#cb260-86" aria-hidden="true"></a>file-error?</span>
<span id="cb260-87"><a href="#cb260-87" aria-hidden="true"></a><span class="kw">floor</span></span>
<span id="cb260-88"><a href="#cb260-88" aria-hidden="true"></a>floor-quotient</span>
<span id="cb260-89"><a href="#cb260-89" aria-hidden="true"></a>floor-remainder</span>
<span id="cb260-90"><a href="#cb260-90" aria-hidden="true"></a>floor/</span>
<span id="cb260-91"><a href="#cb260-91" aria-hidden="true"></a>flush-output-port</span>
<span id="cb260-92"><a href="#cb260-92" aria-hidden="true"></a><span class="kw">for-each</span></span>
<span id="cb260-93"><a href="#cb260-93" aria-hidden="true"></a><span class="kw">gcd</span></span>
<span id="cb260-94"><a href="#cb260-94" aria-hidden="true"></a>get-output-bytevector</span>
<span id="cb260-95"><a href="#cb260-95" aria-hidden="true"></a>get-output-string</span>
<span id="cb260-96"><a href="#cb260-96" aria-hidden="true"></a>guard</span>
<span id="cb260-97"><a href="#cb260-97" aria-hidden="true"></a><span class="kw">if</span></span>
<span id="cb260-98"><a href="#cb260-98" aria-hidden="true"></a>include</span>
<span id="cb260-99"><a href="#cb260-99" aria-hidden="true"></a>include-ci</span>
<span id="cb260-100"><a href="#cb260-100" aria-hidden="true"></a>inexact</span>
<span id="cb260-101"><a href="#cb260-101" aria-hidden="true"></a><span class="kw">inexact?</span></span>
<span id="cb260-102"><a href="#cb260-102" aria-hidden="true"></a>input-port-open?</span>
<span id="cb260-103"><a href="#cb260-103" aria-hidden="true"></a><span class="kw">input-port?</span></span>
<span id="cb260-104"><a href="#cb260-104" aria-hidden="true"></a><span class="kw">integer-&gt;char</span></span>
<span id="cb260-105"><a href="#cb260-105" aria-hidden="true"></a><span class="kw">integer?</span></span>
<span id="cb260-106"><a href="#cb260-106" aria-hidden="true"></a><span class="kw">lambda</span></span>
<span id="cb260-107"><a href="#cb260-107" aria-hidden="true"></a><span class="kw">lcm</span></span>
<span id="cb260-108"><a href="#cb260-108" aria-hidden="true"></a><span class="kw">length</span></span>
<span id="cb260-109"><a href="#cb260-109" aria-hidden="true"></a><span class="kw">let</span></span>
<span id="cb260-110"><a href="#cb260-110" aria-hidden="true"></a><span class="kw">let*</span></span>
<span id="cb260-111"><a href="#cb260-111" aria-hidden="true"></a>let*-values</span>
<span id="cb260-112"><a href="#cb260-112" aria-hidden="true"></a><span class="kw">let-syntax</span></span>
<span id="cb260-113"><a href="#cb260-113" aria-hidden="true"></a>let-values</span>
<span id="cb260-114"><a href="#cb260-114" aria-hidden="true"></a><span class="kw">letrec</span></span>
<span id="cb260-115"><a href="#cb260-115" aria-hidden="true"></a>letrec*</span>
<span id="cb260-116"><a href="#cb260-116" aria-hidden="true"></a><span class="kw">letrec-syntax</span></span>
<span id="cb260-117"><a href="#cb260-117" aria-hidden="true"></a><span class="kw">list</span></span>
<span id="cb260-118"><a href="#cb260-118" aria-hidden="true"></a><span class="kw">list-&gt;string</span></span>
<span id="cb260-119"><a href="#cb260-119" aria-hidden="true"></a>list-&gt;vector</span>
<span id="cb260-120"><a href="#cb260-120" aria-hidden="true"></a>list-copy</span>
<span id="cb260-121"><a href="#cb260-121" aria-hidden="true"></a><span class="kw">list-ref</span></span>
<span id="cb260-122"><a href="#cb260-122" aria-hidden="true"></a>list-set!</span>
<span id="cb260-123"><a href="#cb260-123" aria-hidden="true"></a><span class="kw">list-tail</span></span>
<span id="cb260-124"><a href="#cb260-124" aria-hidden="true"></a><span class="kw">list?</span></span>
<span id="cb260-125"><a href="#cb260-125" aria-hidden="true"></a>make-bytevector</span>
<span id="cb260-126"><a href="#cb260-126" aria-hidden="true"></a>make-list</span>
<span id="cb260-127"><a href="#cb260-127" aria-hidden="true"></a>make-parameter</span>
<span id="cb260-128"><a href="#cb260-128" aria-hidden="true"></a><span class="kw">make-string</span></span>
<span id="cb260-129"><a href="#cb260-129" aria-hidden="true"></a><span class="kw">make-vector</span></span>
<span id="cb260-130"><a href="#cb260-130" aria-hidden="true"></a>map</span>
<span id="cb260-131"><a href="#cb260-131" aria-hidden="true"></a><span class="kw">max</span></span>
<span id="cb260-132"><a href="#cb260-132" aria-hidden="true"></a><span class="kw">member</span></span>
<span id="cb260-133"><a href="#cb260-133" aria-hidden="true"></a><span class="kw">memq</span></span>
<span id="cb260-134"><a href="#cb260-134" aria-hidden="true"></a><span class="kw">memv</span></span>
<span id="cb260-135"><a href="#cb260-135" aria-hidden="true"></a><span class="kw">min</span></span>
<span id="cb260-136"><a href="#cb260-136" aria-hidden="true"></a><span class="kw">modulo</span></span>
<span id="cb260-137"><a href="#cb260-137" aria-hidden="true"></a><span class="kw">negative?</span></span>
<span id="cb260-138"><a href="#cb260-138" aria-hidden="true"></a><span class="kw">newline</span></span>
<span id="cb260-139"><a href="#cb260-139" aria-hidden="true"></a><span class="kw">not</span></span>
<span id="cb260-140"><a href="#cb260-140" aria-hidden="true"></a><span class="kw">null?</span></span>
<span id="cb260-141"><a href="#cb260-141" aria-hidden="true"></a><span class="kw">number-&gt;string</span></span>
<span id="cb260-142"><a href="#cb260-142" aria-hidden="true"></a><span class="kw">number?</span></span>
<span id="cb260-143"><a href="#cb260-143" aria-hidden="true"></a><span class="kw">numerator</span></span>
<span id="cb260-144"><a href="#cb260-144" aria-hidden="true"></a><span class="kw">odd?</span></span>
<span id="cb260-145"><a href="#cb260-145" aria-hidden="true"></a>open-input-bytevector</span>
<span id="cb260-146"><a href="#cb260-146" aria-hidden="true"></a>open-input-string</span>
<span id="cb260-147"><a href="#cb260-147" aria-hidden="true"></a>open-output-bytevector</span>
<span id="cb260-148"><a href="#cb260-148" aria-hidden="true"></a>open-output-string</span>
<span id="cb260-149"><a href="#cb260-149" aria-hidden="true"></a><span class="kw">or</span></span>
<span id="cb260-150"><a href="#cb260-150" aria-hidden="true"></a>output-port-open?</span>
<span id="cb260-151"><a href="#cb260-151" aria-hidden="true"></a><span class="kw">output-port?</span></span>
<span id="cb260-152"><a href="#cb260-152" aria-hidden="true"></a><span class="kw">pair?</span></span>
<span id="cb260-153"><a href="#cb260-153" aria-hidden="true"></a>parameterize</span>
<span id="cb260-154"><a href="#cb260-154" aria-hidden="true"></a><span class="kw">peek-char</span></span>
<span id="cb260-155"><a href="#cb260-155" aria-hidden="true"></a>peek-u8</span>
<span id="cb260-156"><a href="#cb260-156" aria-hidden="true"></a><span class="kw">port?</span></span>
<span id="cb260-157"><a href="#cb260-157" aria-hidden="true"></a><span class="kw">positive?</span></span>
<span id="cb260-158"><a href="#cb260-158" aria-hidden="true"></a><span class="kw">procedure?</span></span>
<span id="cb260-159"><a href="#cb260-159" aria-hidden="true"></a>quasiquote</span>
<span id="cb260-160"><a href="#cb260-160" aria-hidden="true"></a>quote</span>
<span id="cb260-161"><a href="#cb260-161" aria-hidden="true"></a><span class="kw">quotient</span></span>
<span id="cb260-162"><a href="#cb260-162" aria-hidden="true"></a>raise</span>
<span id="cb260-163"><a href="#cb260-163" aria-hidden="true"></a>raise-continuable</span>
<span id="cb260-164"><a href="#cb260-164" aria-hidden="true"></a><span class="kw">rational?</span></span>
<span id="cb260-165"><a href="#cb260-165" aria-hidden="true"></a><span class="kw">rationalize</span></span>
<span id="cb260-166"><a href="#cb260-166" aria-hidden="true"></a>read-bytevector</span>
<span id="cb260-167"><a href="#cb260-167" aria-hidden="true"></a>read-bytevector!</span>
<span id="cb260-168"><a href="#cb260-168" aria-hidden="true"></a><span class="kw">read-char</span></span>
<span id="cb260-169"><a href="#cb260-169" aria-hidden="true"></a>read-error?</span>
<span id="cb260-170"><a href="#cb260-170" aria-hidden="true"></a>read-line</span>
<span id="cb260-171"><a href="#cb260-171" aria-hidden="true"></a>read-string</span>
<span id="cb260-172"><a href="#cb260-172" aria-hidden="true"></a>read-u8</span>
<span id="cb260-173"><a href="#cb260-173" aria-hidden="true"></a><span class="kw">real?</span></span>
<span id="cb260-174"><a href="#cb260-174" aria-hidden="true"></a><span class="kw">remainder</span></span>
<span id="cb260-175"><a href="#cb260-175" aria-hidden="true"></a><span class="kw">reverse</span></span>
<span id="cb260-176"><a href="#cb260-176" aria-hidden="true"></a><span class="kw">round</span></span>
<span id="cb260-177"><a href="#cb260-177" aria-hidden="true"></a>set!</span>
<span id="cb260-178"><a href="#cb260-178" aria-hidden="true"></a><span class="kw">set-car!</span></span>
<span id="cb260-179"><a href="#cb260-179" aria-hidden="true"></a><span class="kw">set-cdr!</span></span>
<span id="cb260-180"><a href="#cb260-180" aria-hidden="true"></a>square</span>
<span id="cb260-181"><a href="#cb260-181" aria-hidden="true"></a><span class="kw">string</span></span>
<span id="cb260-182"><a href="#cb260-182" aria-hidden="true"></a><span class="kw">string-&gt;list</span></span>
<span id="cb260-183"><a href="#cb260-183" aria-hidden="true"></a><span class="kw">string-&gt;number</span></span>
<span id="cb260-184"><a href="#cb260-184" aria-hidden="true"></a><span class="kw">string-&gt;symbol</span></span>
<span id="cb260-185"><a href="#cb260-185" aria-hidden="true"></a>string-&gt;utf8</span>
<span id="cb260-186"><a href="#cb260-186" aria-hidden="true"></a>string-&gt;vector</span>
<span id="cb260-187"><a href="#cb260-187" aria-hidden="true"></a><span class="kw">string-append</span></span>
<span id="cb260-188"><a href="#cb260-188" aria-hidden="true"></a><span class="kw">string-copy</span></span>
<span id="cb260-189"><a href="#cb260-189" aria-hidden="true"></a>string-copy!</span>
<span id="cb260-190"><a href="#cb260-190" aria-hidden="true"></a><span class="kw">string-fill!</span></span>
<span id="cb260-191"><a href="#cb260-191" aria-hidden="true"></a>string-for-each</span>
<span id="cb260-192"><a href="#cb260-192" aria-hidden="true"></a><span class="kw">string-length</span></span>
<span id="cb260-193"><a href="#cb260-193" aria-hidden="true"></a>string-map</span>
<span id="cb260-194"><a href="#cb260-194" aria-hidden="true"></a><span class="kw">string-ref</span></span>
<span id="cb260-195"><a href="#cb260-195" aria-hidden="true"></a><span class="kw">string-set!</span></span>
<span id="cb260-196"><a href="#cb260-196" aria-hidden="true"></a><span class="kw">string&lt;=?</span></span>
<span id="cb260-197"><a href="#cb260-197" aria-hidden="true"></a><span class="kw">string&lt;?</span></span>
<span id="cb260-198"><a href="#cb260-198" aria-hidden="true"></a><span class="kw">string=?</span></span>
<span id="cb260-199"><a href="#cb260-199" aria-hidden="true"></a><span class="kw">string&gt;=?</span></span>
<span id="cb260-200"><a href="#cb260-200" aria-hidden="true"></a><span class="kw">string&gt;?</span></span>
<span id="cb260-201"><a href="#cb260-201" aria-hidden="true"></a><span class="kw">string?</span></span>
<span id="cb260-202"><a href="#cb260-202" aria-hidden="true"></a><span class="kw">substring</span></span>
<span id="cb260-203"><a href="#cb260-203" aria-hidden="true"></a><span class="kw">symbol-&gt;string</span></span>
<span id="cb260-204"><a href="#cb260-204" aria-hidden="true"></a>symbol=?</span>
<span id="cb260-205"><a href="#cb260-205" aria-hidden="true"></a><span class="kw">symbol?</span></span>
<span id="cb260-206"><a href="#cb260-206" aria-hidden="true"></a>syntax-error</span>
<span id="cb260-207"><a href="#cb260-207" aria-hidden="true"></a><span class="kw">syntax-rules</span></span>
<span id="cb260-208"><a href="#cb260-208" aria-hidden="true"></a>textual-port?</span>
<span id="cb260-209"><a href="#cb260-209" aria-hidden="true"></a><span class="kw">truncate</span></span>
<span id="cb260-210"><a href="#cb260-210" aria-hidden="true"></a>truncate-quotient</span>
<span id="cb260-211"><a href="#cb260-211" aria-hidden="true"></a>truncate-remainder</span>
<span id="cb260-212"><a href="#cb260-212" aria-hidden="true"></a>truncate/</span>
<span id="cb260-213"><a href="#cb260-213" aria-hidden="true"></a>u8-ready?</span>
<span id="cb260-214"><a href="#cb260-214" aria-hidden="true"></a>unless</span>
<span id="cb260-215"><a href="#cb260-215" aria-hidden="true"></a>unquote</span>
<span id="cb260-216"><a href="#cb260-216" aria-hidden="true"></a>unquote-splicing</span>
<span id="cb260-217"><a href="#cb260-217" aria-hidden="true"></a>utf8-&gt;string</span>
<span id="cb260-218"><a href="#cb260-218" aria-hidden="true"></a><span class="kw">values</span></span>
<span id="cb260-219"><a href="#cb260-219" aria-hidden="true"></a><span class="kw">vector</span></span>
<span id="cb260-220"><a href="#cb260-220" aria-hidden="true"></a>vector-&gt;list</span>
<span id="cb260-221"><a href="#cb260-221" aria-hidden="true"></a>vector-&gt;string</span>
<span id="cb260-222"><a href="#cb260-222" aria-hidden="true"></a>vector-append</span>
<span id="cb260-223"><a href="#cb260-223" aria-hidden="true"></a>vector-copy</span>
<span id="cb260-224"><a href="#cb260-224" aria-hidden="true"></a>vector-copy!</span>
<span id="cb260-225"><a href="#cb260-225" aria-hidden="true"></a><span class="kw">vector-fill!</span></span>
<span id="cb260-226"><a href="#cb260-226" aria-hidden="true"></a>vector-for-each</span>
<span id="cb260-227"><a href="#cb260-227" aria-hidden="true"></a><span class="kw">vector-length</span></span>
<span id="cb260-228"><a href="#cb260-228" aria-hidden="true"></a>vector-map</span>
<span id="cb260-229"><a href="#cb260-229" aria-hidden="true"></a><span class="kw">vector-ref</span></span>
<span id="cb260-230"><a href="#cb260-230" aria-hidden="true"></a><span class="kw">vector-set!</span></span>
<span id="cb260-231"><a href="#cb260-231" aria-hidden="true"></a><span class="kw">vector?</span></span>
<span id="cb260-232"><a href="#cb260-232" aria-hidden="true"></a>when</span>
<span id="cb260-233"><a href="#cb260-233" aria-hidden="true"></a>with-exception-handler</span>
<span id="cb260-234"><a href="#cb260-234" aria-hidden="true"></a>write-bytevector</span>
<span id="cb260-235"><a href="#cb260-235" aria-hidden="true"></a><span class="kw">write-char</span></span>
<span id="cb260-236"><a href="#cb260-236" aria-hidden="true"></a>write-string</span>
<span id="cb260-237"><a href="#cb260-237" aria-hidden="true"></a>write-u8</span>
<span id="cb260-238"><a href="#cb260-238" aria-hidden="true"></a><span class="kw">zero?</span></span></code></pre></div>
<h3 id="case-lambda-library">Case-Lambda Library</h3>
<p>The <code>(scheme case-lambda)</code> library exports the <code>case-lambda</code> syntax.</p>
<div class="sourceCode" id="cb261"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb261-1"><a href="#cb261-1" aria-hidden="true"></a>case-lambda</span></code></pre></div>
<h3 id="char-library">Char Library</h3>
<p>The <code>(scheme char)</code> library provides the procedures for dealing with characters that involve potentially large tables when supporting all of Unicode.</p>
<div class="sourceCode" id="cb262"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true"></a><span class="kw">char-alphabetic?</span></span>
<span id="cb262-2"><a href="#cb262-2" aria-hidden="true"></a><span class="kw">char-ci&lt;=?</span></span>
<span id="cb262-3"><a href="#cb262-3" aria-hidden="true"></a>char-ci&lt;?</span>
<span id="cb262-4"><a href="#cb262-4" aria-hidden="true"></a><span class="kw">char-ci=?</span></span>
<span id="cb262-5"><a href="#cb262-5" aria-hidden="true"></a><span class="kw">char-ci&gt;=?</span></span>
<span id="cb262-6"><a href="#cb262-6" aria-hidden="true"></a><span class="kw">char-ci&gt;?</span></span>
<span id="cb262-7"><a href="#cb262-7" aria-hidden="true"></a><span class="kw">char-downcase</span></span>
<span id="cb262-8"><a href="#cb262-8" aria-hidden="true"></a>char-foldcase</span>
<span id="cb262-9"><a href="#cb262-9" aria-hidden="true"></a><span class="kw">char-lower-case?</span></span>
<span id="cb262-10"><a href="#cb262-10" aria-hidden="true"></a><span class="kw">char-numeric?</span></span>
<span id="cb262-11"><a href="#cb262-11" aria-hidden="true"></a><span class="kw">char-upcase</span></span>
<span id="cb262-12"><a href="#cb262-12" aria-hidden="true"></a><span class="kw">char-upper-case?</span></span>
<span id="cb262-13"><a href="#cb262-13" aria-hidden="true"></a><span class="kw">char-whitespace?</span></span>
<span id="cb262-14"><a href="#cb262-14" aria-hidden="true"></a>digit-value</span>
<span id="cb262-15"><a href="#cb262-15" aria-hidden="true"></a><span class="kw">string-ci&lt;=?</span></span>
<span id="cb262-16"><a href="#cb262-16" aria-hidden="true"></a><span class="kw">string-ci&lt;?</span></span>
<span id="cb262-17"><a href="#cb262-17" aria-hidden="true"></a><span class="kw">string-ci=?</span></span>
<span id="cb262-18"><a href="#cb262-18" aria-hidden="true"></a><span class="kw">string-ci&gt;=?</span></span>
<span id="cb262-19"><a href="#cb262-19" aria-hidden="true"></a><span class="kw">string-ci&gt;?</span></span>
<span id="cb262-20"><a href="#cb262-20" aria-hidden="true"></a>string-downcase</span>
<span id="cb262-21"><a href="#cb262-21" aria-hidden="true"></a>string-foldcase</span>
<span id="cb262-22"><a href="#cb262-22" aria-hidden="true"></a>string-upcase</span></code></pre></div>
<h3 id="complex-library">Complex Library</h3>
<p>The <code>(scheme complex)</code> library exports procedures which are typically only useful with non-real numbers.</p>
<div class="sourceCode" id="cb263"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true"></a><span class="kw">angle</span>                   <span class="kw">imag-part</span></span>
<span id="cb263-2"><a href="#cb263-2" aria-hidden="true"></a><span class="kw">magnitude</span>               <span class="kw">make-polar</span></span>
<span id="cb263-3"><a href="#cb263-3" aria-hidden="true"></a><span class="kw">make-rectangular</span>        <span class="kw">real-part</span></span></code></pre></div>
<h3 id="cxr-library">CxR Library</h3>
<p>The <code>(scheme cxr)</code> library exports twenty-four procedures which are the compositions of from three to four car and cdr operations. For example caddar could be defined by</p>
<div class="sourceCode" id="cb264"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> caddar</span></span>
<span id="cb264-2"><a href="#cb264-2" aria-hidden="true"></a>  (<span class="kw">lambda</span> (x) (<span class="kw">car</span> (<span class="kw">cdr</span> (<span class="kw">cdr</span> (<span class="kw">car</span> x))))))</span></code></pre></div>
<p>The procedures car and cdr themselves and the four two-level compositions are included in the base library. See section <a href="#listsection">[listsection]</a>.</p>
<div class="sourceCode" id="cb265"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb265-1"><a href="#cb265-1" aria-hidden="true"></a><span class="kw">caaaar</span>                  <span class="kw">caaadr</span></span>
<span id="cb265-2"><a href="#cb265-2" aria-hidden="true"></a><span class="kw">caaar</span>                   <span class="kw">caadar</span></span>
<span id="cb265-3"><a href="#cb265-3" aria-hidden="true"></a><span class="kw">caaddr</span>                  <span class="kw">caadr</span></span>
<span id="cb265-4"><a href="#cb265-4" aria-hidden="true"></a><span class="kw">cadaar</span>                  <span class="kw">cadadr</span></span>
<span id="cb265-5"><a href="#cb265-5" aria-hidden="true"></a><span class="kw">cadar</span>                   <span class="kw">caddar</span></span>
<span id="cb265-6"><a href="#cb265-6" aria-hidden="true"></a><span class="kw">cadddr</span>                  <span class="kw">caddr</span></span>
<span id="cb265-7"><a href="#cb265-7" aria-hidden="true"></a><span class="kw">cdaaar</span>                  <span class="kw">cdaadr</span></span>
<span id="cb265-8"><a href="#cb265-8" aria-hidden="true"></a><span class="kw">cdaar</span>                   <span class="kw">cdadar</span></span>
<span id="cb265-9"><a href="#cb265-9" aria-hidden="true"></a><span class="kw">cdaddr</span>                  <span class="kw">cdadr</span></span>
<span id="cb265-10"><a href="#cb265-10" aria-hidden="true"></a><span class="kw">cddaar</span>                  <span class="kw">cddadr</span></span>
<span id="cb265-11"><a href="#cb265-11" aria-hidden="true"></a><span class="kw">cddar</span>                   <span class="kw">cdddar</span></span>
<span id="cb265-12"><a href="#cb265-12" aria-hidden="true"></a><span class="kw">cddddr</span>                  <span class="kw">cdddr</span></span></code></pre></div>
<h3 id="eval-library">Eval Library</h3>
<p>The <code>(scheme eval)</code> library exports procedures for evaluating Scheme data as programs.</p>
<pre><code>environment
eval</code></pre>
<h3 id="file-library">File Library</h3>
<p>The <code>(scheme file)</code> library provides procedures for accessing files.</p>
<pre><code>call-with-input-file
call-with-output-file
delete-file
file-exists?
open-binary-input-file
open-binary-output-file
open-input-file
open-output-file
with-input-from-file
with-output-to-file</code></pre>
<h3 id="inexact-library">Inexact Library</h3>
<p>The <code>(scheme inexact)</code> library exports procedures which are typically only useful with inexact values.</p>
<div class="sourceCode" id="cb268"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb268-1"><a href="#cb268-1" aria-hidden="true"></a><span class="kw">acos</span></span>
<span id="cb268-2"><a href="#cb268-2" aria-hidden="true"></a><span class="kw">asin</span></span>
<span id="cb268-3"><a href="#cb268-3" aria-hidden="true"></a><span class="kw">atan</span></span>
<span id="cb268-4"><a href="#cb268-4" aria-hidden="true"></a><span class="kw">cos</span></span>
<span id="cb268-5"><a href="#cb268-5" aria-hidden="true"></a><span class="kw">exp</span></span>
<span id="cb268-6"><a href="#cb268-6" aria-hidden="true"></a>finite?</span>
<span id="cb268-7"><a href="#cb268-7" aria-hidden="true"></a>infinite?</span>
<span id="cb268-8"><a href="#cb268-8" aria-hidden="true"></a><span class="kw">log</span></span>
<span id="cb268-9"><a href="#cb268-9" aria-hidden="true"></a>nan?</span>
<span id="cb268-10"><a href="#cb268-10" aria-hidden="true"></a><span class="kw">sin</span></span>
<span id="cb268-11"><a href="#cb268-11" aria-hidden="true"></a><span class="kw">sqrt</span></span>
<span id="cb268-12"><a href="#cb268-12" aria-hidden="true"></a><span class="kw">tan</span></span></code></pre></div>
<h3 id="lazy-library">Lazy Library</h3>
<p>The <code>(scheme lazy)</code> library exports procedures and syntax keywords for lazy evaluation.</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb269-1"><a href="#cb269-1" aria-hidden="true"></a>delay                   delay-force</span>
<span id="cb269-2"><a href="#cb269-2" aria-hidden="true"></a><span class="kw">force</span>                   make-promise</span>
<span id="cb269-3"><a href="#cb269-3" aria-hidden="true"></a>promise?</span></code></pre></div>
<h3 id="load-library">Load Library</h3>
<p>The <code>(scheme load)</code> library exports procedures for loading Scheme expressions from files.</p>
<div class="sourceCode" id="cb270"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true"></a><span class="kw">load</span></span></code></pre></div>
<h3 id="process-context-library">Process-Context Library</h3>
<p>The <code>(scheme process-context)</code> library exports procedures for accessing with the program’s calling context.</p>
<div class="sourceCode" id="cb271"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb271-1"><a href="#cb271-1" aria-hidden="true"></a>command-line            emergency-exit</span>
<span id="cb271-2"><a href="#cb271-2" aria-hidden="true"></a>exit</span>
<span id="cb271-3"><a href="#cb271-3" aria-hidden="true"></a>get-environment-variable</span>
<span id="cb271-4"><a href="#cb271-4" aria-hidden="true"></a>get-environment-variables</span></code></pre></div>
<h3 id="read-library">Read Library</h3>
<p>The <code>(scheme read)</code> library provides procedures for reading Scheme objects.</p>
<div class="sourceCode" id="cb272"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb272-1"><a href="#cb272-1" aria-hidden="true"></a><span class="kw">read</span></span></code></pre></div>
<h3 id="repl-library">Repl Library</h3>
<p>The <code>(scheme repl)</code> library exports the interaction-environment procedure.</p>
<pre><code>interaction-environment</code></pre>
<h3 id="time-library">Time Library</h3>
<p>The <code>(scheme time)</code> library provides access to time-related values.</p>
<pre><code>current-jiffy           current-second
jiffies-per-second</code></pre>
<h3 id="write-library">Write Library</h3>
<p>The <code>(scheme write)</code> library provides procedures for writing Scheme objects.</p>
<pre><code>display                 write
write-shared            write-simple</code></pre>
<h3 id="r5rs-library">R5RS Library</h3>
<p>The <code>(scheme r5rs)</code> library provides the identifiers defined by R<sup><small>5</small></sup>RS, except that transcript-on and transcript-off are not present. Note that the exact and inexact procedures appear under their R<sup><small>5</small></sup>RS names inexact-&gt;exact and exact-&gt;inexact respectively. However, if an implementation does not provide a particular library such as the complex library, the corresponding identifiers will not appear in this library either.</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb276-1"><a href="#cb276-1" aria-hidden="true"></a>\* <span class="op">+</span> <span class="op">-</span> ... <span class="op">/</span> \&lt; \&lt;= <span class="op">=</span> <span class="op">=&gt;</span> \&gt; \&gt;= _ <span class="kw">abs</span> <span class="kw">acos</span> <span class="kw">and</span> <span class="kw">angle</span> <span class="kw">append</span> apply <span class="kw">asin</span></span>
<span id="cb276-2"><a href="#cb276-2" aria-hidden="true"></a><span class="kw">assoc</span> <span class="kw">assq</span> <span class="kw">assv</span> <span class="kw">atan</span> <span class="kw">begin</span> boolean?  <span class="kw">caaaar</span> <span class="kw">caaadr</span> <span class="kw">caaar</span> <span class="kw">caadar</span> <span class="kw">caaddr</span></span>
<span id="cb276-3"><a href="#cb276-3" aria-hidden="true"></a><span class="kw">caadr</span> <span class="kw">caar</span> <span class="kw">cadaar</span> <span class="kw">cadadr</span> <span class="kw">cadar</span> <span class="kw">caddar</span> <span class="kw">cadddr</span> <span class="kw">caddr</span> <span class="kw">cadr</span></span>
<span id="cb276-4"><a href="#cb276-4" aria-hidden="true"></a><span class="kw">call-with-current-continuation</span> <span class="kw">call-with-input-file</span></span>
<span id="cb276-5"><a href="#cb276-5" aria-hidden="true"></a><span class="kw">call-with-output-file</span> <span class="kw">call-with-values</span> <span class="kw">car</span> <span class="kw">case</span> <span class="kw">cdaaar</span> <span class="kw">cdaadr</span> <span class="kw">cdaar</span></span>
<span id="cb276-6"><a href="#cb276-6" aria-hidden="true"></a><span class="kw">cdadar</span> <span class="kw">cdaddr</span> <span class="kw">cdadr</span> <span class="kw">cdar</span> <span class="kw">cddaar</span> <span class="kw">cddadr</span> <span class="kw">cddar</span> <span class="kw">cdddar</span> <span class="kw">cddddr</span> <span class="kw">cdddr</span> <span class="kw">cddr</span></span>
<span id="cb276-7"><a href="#cb276-7" aria-hidden="true"></a><span class="kw">cdr</span> <span class="kw">ceiling</span> <span class="kw">char-&gt;integer</span> char-alphabetic?  char-ci\&lt;=? char-ci\&lt;?</span>
<span id="cb276-8"><a href="#cb276-8" aria-hidden="true"></a><span class="kw">char-ci=?</span> char-ci&gt;=?  <span class="kw">char-ci&gt;?</span> <span class="kw">char-downcase</span> <span class="kw">char-lower-case?</span></span>
<span id="cb276-9"><a href="#cb276-9" aria-hidden="true"></a>char-numeric?  <span class="kw">char-ready?</span> <span class="kw">char-upcase</span> <span class="kw">char-upper-case?</span></span>
<span id="cb276-10"><a href="#cb276-10" aria-hidden="true"></a>char-whitespace?  char\&lt;=? char\&lt;?  <span class="kw">char=?</span> char&gt;=?  <span class="kw">char&gt;?</span> <span class="kw">char?</span></span>
<span id="cb276-11"><a href="#cb276-11" aria-hidden="true"></a><span class="kw">close-input-port</span> <span class="kw">close-output-port</span> <span class="kw">complex?</span> <span class="kw">cond</span> <span class="kw">cons</span> <span class="kw">cos</span></span>
<span id="cb276-12"><a href="#cb276-12" aria-hidden="true"></a><span class="kw">current-input-port</span> <span class="kw">current-output-port</span> <span class="ex">define</span><span class="fu"> define-syntax </span>delay</span>
<span id="cb276-13"><a href="#cb276-13" aria-hidden="true"></a><span class="kw">denominator</span> <span class="kw">display</span> <span class="kw">do</span> <span class="kw">dynamic-wind</span> <span class="kw">else</span> <span class="kw">eof-object?</span> eq?  <span class="kw">equal?</span> <span class="kw">eqv?</span></span>
<span id="cb276-14"><a href="#cb276-14" aria-hidden="true"></a><span class="kw">eval</span> even?  <span class="kw">exact-&gt;inexact</span> exact?  <span class="kw">exp</span> <span class="kw">expt</span> <span class="kw">floor</span> <span class="kw">for-each</span> <span class="kw">force</span> <span class="kw">gcd</span> <span class="kw">if</span></span>
<span id="cb276-15"><a href="#cb276-15" aria-hidden="true"></a><span class="kw">imag-part</span> <span class="kw">inexact-&gt;exact</span> inexact?  <span class="kw">input-port?</span> <span class="kw">integer-&gt;char</span> <span class="kw">integer?</span></span>
<span id="cb276-16"><a href="#cb276-16" aria-hidden="true"></a><span class="kw">interaction-environment</span> <span class="kw">lambda</span> <span class="kw">lcm</span> <span class="kw">length</span> <span class="kw">let</span> let\* <span class="kw">let-syntax</span> <span class="kw">letrec</span></span>
<span id="cb276-17"><a href="#cb276-17" aria-hidden="true"></a><span class="kw">letrec-syntax</span> <span class="kw">list</span> <span class="kw">list-&gt;string</span> list-&gt;vector <span class="kw">list-ref</span> <span class="kw">list-tail</span> <span class="kw">list?</span></span>
<span id="cb276-18"><a href="#cb276-18" aria-hidden="true"></a><span class="kw">load</span> <span class="kw">log</span> <span class="kw">magnitude</span> <span class="kw">make-polar</span> <span class="kw">make-rectangular</span> <span class="kw">make-string</span> <span class="kw">make-vector</span></span>
<span id="cb276-19"><a href="#cb276-19" aria-hidden="true"></a>map <span class="kw">max</span> <span class="kw">member</span> <span class="kw">memq</span> <span class="kw">memv</span> <span class="kw">min</span> <span class="kw">modulo</span> <span class="kw">negative?</span> <span class="kw">newline</span> <span class="kw">not</span></span>
<span id="cb276-20"><a href="#cb276-20" aria-hidden="true"></a><span class="kw">null-environment</span> <span class="kw">null?</span> <span class="kw">number-&gt;string</span> <span class="kw">number?</span> <span class="kw">numerator</span> <span class="kw">odd?</span></span>
<span id="cb276-21"><a href="#cb276-21" aria-hidden="true"></a><span class="kw">open-input-file</span> <span class="kw">open-output-file</span> <span class="kw">or</span> <span class="kw">output-port?</span> pair?  <span class="kw">peek-char</span></span>
<span id="cb276-22"><a href="#cb276-22" aria-hidden="true"></a>positive?  <span class="kw">procedure?</span> quasiquote quote <span class="kw">quotient</span> <span class="kw">rational?</span> <span class="kw">rationalize</span></span>
<span id="cb276-23"><a href="#cb276-23" aria-hidden="true"></a><span class="kw">read</span> <span class="kw">read-char</span> <span class="kw">real-part</span> real?  <span class="kw">remainder</span> <span class="kw">reverse</span> <span class="kw">round</span></span>
<span id="cb276-24"><a href="#cb276-24" aria-hidden="true"></a><span class="kw">scheme-report-environment</span> set! <span class="kw">set-car!</span> <span class="kw">set-cdr!</span> <span class="kw">sin</span> <span class="kw">sqrt</span> <span class="kw">string</span></span>
<span id="cb276-25"><a href="#cb276-25" aria-hidden="true"></a><span class="kw">string-&gt;list</span> <span class="kw">string-&gt;number</span> <span class="kw">string-&gt;symbol</span> <span class="kw">string-append</span> string-ci\&lt;=?</span>
<span id="cb276-26"><a href="#cb276-26" aria-hidden="true"></a>string-ci\&lt;? string-ci=?  <span class="kw">string-ci&gt;=?</span> string-ci&gt;?  <span class="kw">string-copy</span></span>
<span id="cb276-27"><a href="#cb276-27" aria-hidden="true"></a><span class="kw">string-fill!</span> <span class="kw">string-length</span> <span class="kw">string-ref</span> <span class="kw">string-set!</span> string\&lt;=?  string\&lt;?</span>
<span id="cb276-28"><a href="#cb276-28" aria-hidden="true"></a>string=?  <span class="kw">string&gt;=?</span> string&gt;?  <span class="kw">string?</span> <span class="kw">substring</span> <span class="kw">symbol-&gt;string</span> <span class="kw">symbol?</span></span>
<span id="cb276-29"><a href="#cb276-29" aria-hidden="true"></a><span class="kw">syntax-rules</span> <span class="kw">tan</span> <span class="kw">truncate</span> <span class="kw">values</span> <span class="kw">vector</span> vector-&gt;list <span class="kw">vector-fill!</span></span>
<span id="cb276-30"><a href="#cb276-30" aria-hidden="true"></a><span class="kw">vector-length</span> <span class="kw">vector-ref</span> <span class="kw">vector-set!</span> <span class="kw">vector?</span> <span class="kw">with-input-from-file</span></span>
<span id="cb276-31"><a href="#cb276-31" aria-hidden="true"></a><span class="kw">with-output-to-file</span> <span class="kw">write</span> <span class="kw">write-char</span> <span class="kw">zero?</span></span></code></pre></div>
<h3 id="standard-feature-identifiers">Standard Feature Identifiers</h3>
<p>An implementation may provide any or all of the feature identifiers listed below for use by cond-expand and features, but must not provide a feature identifier if it does not provide the corresponding feature.</p>
<blockquote>
<p><code>r7rs</code></p>
</blockquote>
<p>All R<sup><small>7</small></sup>RS Scheme implementations have this feature.</p>
<blockquote>
<p><code>exact-closed</code></p>
</blockquote>
<p>The algebraic operations +, -, *, and expt where the second argument is a non-negative integer produce exact values given exact inputs.</p>
<blockquote>
<p><code>exact-complex</code></p>
</blockquote>
<p>Exact complex numbers are provided.</p>
<blockquote>
<p><code>ieee-float</code></p>
</blockquote>
<p>Inexact numbers are IEEE 754 binary floating point values.</p>
<blockquote>
<p><code>full-unicode</code></p>
</blockquote>
<p>All Unicode characters present in Unicode version 6.0 are supported as Scheme characters.</p>
<blockquote>
<p><code>ratios</code></p>
</blockquote>
<p>/ with exact arguments produces an exact result when the divisor is nonzero.</p>
<blockquote>
<p><code>posix</code></p>
</blockquote>
<p>This implementation is running on a POSIX system.</p>
<blockquote>
<p><code>windows</code></p>
</blockquote>
<p>This implementation is running on Windows.</p>
<blockquote>
<p><code>unix</code>, <code>darwin</code>, <code>gnu-linux</code>, <code>bsd</code>, <code>freebsd</code>, <code>solaris</code>, …</p>
</blockquote>
<p>Operating system flags (perhaps more than one).</p>
<blockquote>
<p><code>i386</code>, <code>x86-64</code>, <code>ppc</code>, <code>sparc</code>, <code>jvm</code>, <code>clr</code>, <code>llvm</code>, …</p>
</blockquote>
<p>CPU architecture flags.</p>
<blockquote>
<p><code>ilp32</code>, <code>lp64</code>, <code>ilp64</code>, …</p>
</blockquote>
<p>C memory model flags.</p>
<blockquote>
<p><code>big-endian</code>, <code>little-endian</code></p>
</blockquote>
<p>Byte order flags.</p>
<p>The name of this implementation.</p>
<p>The name and version of this implementation.</p>
<h2 id="language-changes">Language changes</h2>
<h4 id="incompatibilities-with-r5rs">Incompatibilities with R<sup><small>5</small></sup>RS</h4>
<p>This section enumerates the incompatibilities between this report and the “Revised<sup><small>5</small></sup> report” <span class="citation" data-cites="R5RS"></span>.</p>
<p><em>This list is not authoritative, but is believed to be correct and complete.</em></p>
<ul>
<li><p>Case sensitivity is now the default in symbols and character names. This means that code written under the assumption that symbols could be written FOO or Foo in some contexts and foo in other contexts can either be changed, be marked with the new #!fold-case directive, or be included in a library using the include-ci library declaration. All standard identifiers are entirely in lower case.</p></li>
<li><p>The syntax-rules construct now recognizes *_* (underscore) as a wildcard, which means it cannot be used as a syntax variable. It can still be used as a literal.</p></li>
<li><p>The R<sup><small>5</small></sup>RS procedures exact-&gt;inexact and inexact-&gt;exact have been renamed to their R<sup><small>6</small></sup>RS names, inexact and exact, respectively, as these names are shorter and more correct. The former names are still available in the R<sup><small>5</small></sup>RS library.</p></li>
<li><p>The guarantee that string comparison (with string&lt;? and the related predicates) is a lexicographical extension of character comparison (with char&lt;? and the related predicates) has been removed.</p></li>
<li><p>Support for the # character in numeric literals is no longer required.</p></li>
<li><p>Support for the letters s, f, d, and l as exponent markers is no longer required.</p></li>
<li><p>Implementations of stringnumber are no longer permitted to return #f when the argument contains an explicit radix prefix, and must be compatible with read and the syntax of numbers in programs.</p></li>
<li><p>The procedures transcript-on and transcript-off have been removed.</p></li>
</ul>
<h4 id="other-language-changes-since-r5rs">Other language changes since R<sup><small>5</small></sup>RS</h4>
<p>This section enumerates the additional differences between this report and the “Revised<sup><small>5</small></sup> report” <span class="citation" data-cites="R5RS"></span>.</p>
<p><em>This list is not authoritative, but is believed to be correct and complete.</em></p>
<ul>
<li><p>Various minor ambiguities and unclarities in R<sup><small>5</small></sup>RS have been cleaned up.</p></li>
<li><p>Libraries have been added as a new program structure to improve encapsulation and sharing of code. Some existing and new identifiers have been factored out into separate libraries. Libraries can be imported into other libraries or main programs, with controlled exposure and renaming of identifiers. The contents of a library can be made conditional on the features of the implementation on which it is to be used. There is an R<sup><small>5</small></sup>RS compatibility library.</p></li>
<li><p>The expressions types include, include-ci, and cond-expand have been added to the base library; they have the same semantics as the corresponding library declarations.</p></li>
<li><p>Exceptions can now be signaled explicitly with raise, raise-continuable or error, and can be handled with with-exception-handler and the guard syntax. Any object can specify an error condition; the implementation-defined conditions signaled by error have a predicate to detect them and accessor functions to retrieve the arguments passed to error. Conditions signaled by read and by file-related procedures also have predicates to detect them.</p></li>
<li><p>New disjoint types supporting access to multiple fields can be generated with the define-record-type of SRFI 9 <span class="citation" data-cites="srfi9"></span></p></li>
<li><p>Parameter objects can be created with make-parameter, and dynamically rebound with parameterize. The procedures current-input-port and current-output-port are now parameter objects, as is the newly introduced current-error-port.</p></li>
<li><p>Support for promises has been enhanced based on SRFI 45 <span class="citation" data-cites="srfi45"></span>.</p></li>
<li><p><em>Bytevectors</em>, vectors of exact integers in the range from 0 to 255 inclusive, have been added as a new disjoint type. A subset of the vector procedures is provided. Bytevectors can be converted to and from strings in accordance with the UTF-8 character encoding. Bytevectors have a datum representation and evaluate to themselves.</p></li>
<li><p>Vector constants evaluate to themselves.</p></li>
<li><p>The procedure read-line is provided to make line-oriented textual input simpler.</p></li>
<li><p>The procedure flush-output-port is provided to allow minimal control of output port buffering.</p></li>
<li><p><em>Ports</em> can now be designated as <em>textual</em> or <em>binary</em> ports, with new procedures for reading and writing binary data. The new predicates input-port-open? and output-port-open? return whether a port is open or closed. The new procedure close-port now closes a port; if the port has both input and output sides, both are closed.</p></li>
<li><p><em>String ports</em> have been added as a way to read and write characters to and from strings, and <em>bytevector ports</em> to read and write bytes to and from bytevectors.</p></li>
<li><p>There are now I/O procedures specific to strings and bytevectors.</p></li>
<li><p>The write procedure now generates datum labels when applied to circular objects. The new procedure write-simple never generates labels; write-shared generates labels for all shared and circular structure. The display procedure must not loop on circular objects.</p></li>
<li><p>The R<sup><small>6</small></sup>RS procedure eof-object has been added. Eof-objects are now required to be a disjoint type.</p></li>
<li><p>Syntax definitions are now allowed wherever variable definitions are.</p></li>
<li><p>The syntax-rules construct now allows the ellipsis symbol to be specified explicitly instead of the default …, allows template escapes with an ellipsis-prefixed list, and allows tail patterns to follow an ellipsis pattern.</p></li>
<li><p>The syntax-error syntax has been added as a way to signal immediate and more informative errors when a macro is expanded.</p></li>
<li><p>The letrec* binding construct has been added, and internal define is specified in terms of it.</p></li>
<li><p>Support for capturing multiple values has been enhanced with define-values, let-values, and let*-values. Standard expression types which contain a sequence of expressions now permit passing zero or more than one value to the continuations of all non-final expressions of the sequence.</p></li>
<li><p>The case conditional now supports <code>=&gt;</code> syntax analogous to cond not only in regular clauses but in the else clause as well.</p></li>
<li><p>To support dispatching on the number of arguments passed to a procedure, case-lambda has been added in its own library.</p></li>
<li><p>The convenience conditionals when and unless have been added.</p></li>
<li><p>The behavior of eqv? on inexact numbers now conforms to the R<sup><small>6</small></sup>RS definition.</p></li>
<li><p>When applied to procedures, eq? and eqv? are permitted to return different answers.</p></li>
<li><p>The R<sup><small>6</small></sup>RS procedures boolean=? and symbol=? have been added.</p></li>
<li><p>Positive infinity, negative infinity, NaN, and negative inexact zero have been added to the numeric tower as inexact values with the written representations <code>+inf.0</code>, <code>-inf.0</code>, <code>+nan.0</code>, and -0.0 respectively. Support for them is not required. The representation <code>-nan.0</code> is synonymous with <code>+nan.0</code>.</p></li>
<li><p>The log procedure now accepts a second argument specifying the logarithm base.</p></li>
<li><p>The procedures map and for-each are now required to terminate on the shortest argument list.</p></li>
<li><p>The procedures member and assoc now take an optional third argument specifying the equality predicate to be used.</p></li>
<li><p>The numeric procedures finite?, infinite?, nan?, exact-integer?, square, and exact-integer-sqrt have been added.</p></li>
<li><p>The - and / procedures and the character and string comparison predicates are now required to support more than two arguments.</p></li>
<li><p>The forms <code>#true</code> and <code>#false</code> are now supported as well as <code>#t</code> and <code>#f</code>.</p></li>
<li><p>The procedures make-list, list-copy, list-set!, string-map, string-for-each, string-&gt;vector, vector-append, vector-copy, vector-map, vector-for-each, vector-&gt;string, vector-copy!, and string-copy! have been added to round out the sequence operations.</p></li>
<li><p>Some string and vector procedures support processing of part of a string or vector using optional <em>start</em> and <em>end</em> arguments.</p></li>
<li><p>Some list procedures are now defined on circular lists.</p></li>
<li><p>Implementations may provide any subset of the full Unicode repertoire that includes ASCII, but implementations must support any such subset in a way consistent with Unicode. Various character and string procedures have been extended accordingly, and case conversion procedures added for strings. String comparison is no longer required to be consistent with character comparison, which is based solely on Unicode scalar values. The new digit-value procedure has been added to obtain the numerical value of a numeric character.</p></li>
<li><p>There are now two additional comment syntaxes: <code>#;</code> to skip the next datum, and <code>#| ... |#</code> for nestable block comments.</p></li>
<li><p>Data prefixed with datum labels <code>#&lt;n&gt;=</code> can be referenced with <code>#&lt;n&gt;#</code>, allowing for reading and writing of data with shared structure.</p></li>
<li><p>Strings and symbols now allow mnemonic and numeric escape sequences, and the list of named characters has been extended.</p></li>
<li><p>The procedures file-exists? and delete-file are available in the <code>(scheme file)</code> library.</p></li>
<li><p>An interface to the system environment, command line, and process exit status is available in the <code>(scheme process-context)</code> library.</p></li>
<li><p>Procedures for accessing time-related values are available in the <code>(scheme time)</code> library.</p></li>
<li><p>A less irregular set of integer division operators is provided with new and clearer names.</p></li>
<li><p>The load procedure now accepts a second argument specifying the environment to load into.</p></li>
<li><p>The call-with-current-continuation procedure now has the synonym call/cc.</p></li>
<li><p>The semantics of read-eval-print loops are now partly prescribed, requiring the redefinition of procedures, but not syntax keywords, to have retroactive effect.</p></li>
<li><p>The formal semantics now handles dynamic-wind.</p></li>
</ul>
<h4 id="incompatibilities-with-r6rs">Incompatibilities with R<sup><small>6</small></sup>RS</h4>
<p>This section enumerates the incompatibilities between R<sup><small>7</small></sup>RS and the “Revised<sup><small>6</small></sup> report” <span class="citation" data-cites="R6RS"></span> and its accompanying Standard Libraries document.</p>
<p><em>This list is not authoritative, and is possibly incomplete.</em></p>
<ul>
<li><p>R<sup><small>7</small></sup>RS libraries begin with the keyword define-library rather than library in order to make them syntactically distinguishable from R<sup><small>6</small></sup>RS libraries. In R<sup><small>7</small></sup>RS terms, the body of an R<sup><small>6</small></sup>RS library consists of a single export declaration followed by a single import declaration, followed by commands and definitions. In R<sup><small>7</small></sup>RS, commands and definitions are not permitted directly within the body: they have to be wrapped in a begin library declaration.</p></li>
<li><p>There is no direct R<sup><small>6</small></sup>RS equivalent of the include, include-ci, include-library-declarations, or cond-expand library declarations. On the other hand, the R<sup><small>7</small></sup>RS library syntax does not support phase or version specifications.</p></li>
<li><p>The grouping of standardized identifiers into libraries is different from the R<sup><small>6</small></sup>RS approach. In particular, procedures which are optional in R<sup><small>5</small></sup>RS  either expressly or by implication, have been removed from the base library. Only the base library itself is an absolute requirement.</p></li>
<li><p>No form of identifier syntax is provided.</p></li>
<li><p>Internal syntax definitions are allowed, but uses of a syntax form cannot appear before its definition; the even/odd example given in R<sup><small>6</small></sup>RS is not allowed.</p></li>
<li><p>The R<sup><small>6</small></sup>RS exception system was incorporated as-is, but the condition types have been left unspecified. In particular, where R<sup><small>6</small></sup>RS requires a condition of a specified type to be signaled, R<sup><small>7</small></sup>RS says only “it is an error”, leaving the question of signaling open.</p></li>
<li><p>Full Unicode support is not required. Normalization is not provided. Character comparisons are defined by Unicode, but string comparisons are implementation-dependent. Non-Unicode characters are permitted.</p></li>
<li><p>The full numeric tower is optional as in R<sup><small>5</small></sup>RS, but optional support for IEEE infinities, NaN, and -0.0 was adopted from R<sup><small>6</small></sup>RS. Most clarifications on numeric results were also adopted, but the semantics of the R<sup><small>6</small></sup>RS procedures real?, rational?, and integer? were not adopted. (Note that the R<sup><small>5</small></sup>RS/R<sup><small>7</small></sup>RS semantics are available in R<sup><small>6</small></sup>RS using real-valued?, rational-valued?, and integer-valued?). The R<sup><small>6</small></sup>RS division operators div, mod, div-and-mod, div0, mod0 and div0-and-mod0 are not provided.</p></li>
<li><p>When a result is unspecified, it is still required to be a single value. However, non-final expressions in a body can return any number of values.</p></li>
<li><p>The semantics of map and for-each have been changed to use the SRFI 1 <span class="citation" data-cites="srfi1"></span> early termination behavior. Likewise, assoc and member take an optional equal? argument as in SRFI 1, instead of the separate assp and memp procedures of R<sup><small>6</small></sup>RS.</p></li>
<li><p>The R<sup><small>6</small></sup>RS quasiquote clarifications have been adopted, with the exception of multiple-argument unquote and unquote-splicing.</p></li>
<li><p>The R<sup><small>6</small></sup>RS method of specifying mantissa widths was not adopted.</p></li>
<li><p>String ports are compatible with SRFI 6 <span class="citation" data-cites="srfi6"></span> rather than R<sup><small>6</small></sup>RS.</p></li>
<li><p>R<sup><small>6</small></sup>RS-style bytevectors are included, but only the unsigned byte (u8) procedures have been provided. The lexical syntax uses #u8 for compatibility with SRFI 4 <span class="citation" data-cites="srfi4"></span>, rather than the R<sup><small>6</small></sup>RS #vu8 style.</p></li>
<li><p>The utility macros when and unless are provided, but their result is left unspecified.</p></li>
<li><p>The remaining features of the Standard Libraries document were left to future standardization efforts.</p></li>
</ul>
<h2 id="additional-material">Additional material</h2>
<p>The Scheme community website at http://schemers.org contains additional resources for learning and programming, job and event postings, and Scheme user group information.</p>
<p>A bibliography of Scheme-related research at http://library.readscheme.org links to technical papers and theses related to the Scheme language, including both classic papers and recent research.</p>
<p>On-line Scheme discussions are held using IRC on the #scheme channel at irc.freenode.net and on the Usenet discussion group comp.lang.scheme.</p>
<h2 id="example">Example</h2>
<p>The procedure integrate-system integrates the system <em>y</em><sub><em>k</em></sub><sup>′</sup> = <em>f</em><sub><em>k</em></sub>(<em>y</em><sub>1</sub>,<em>y</em><sub>2</sub>,…,<em>y</em><sub><em>n</em></sub>), <em>k</em> = 1, …, <em>n</em> of differential equations with the method of Runge-Kutta.</p>
<p>The parameter <code>system-derivative</code> is a function that takes a system state (a vector of values for the state variables <em>y</em><sub>1</sub>, …, <em>y</em><sub><em>n</em></sub>) and produces a system derivative (the values <em>y</em><sub>1</sub><sup>′</sup>, …, <em>y</em><sub><em>n</em></sub><sup>′</sup>). The parameter <code>initial-state</code> provides an initial system state, and <code>h</code> is an initial guess for the length of the integration step.</p>
<p>The value returned by integrate-system is an infinite stream of system states.</p>
<div class="sourceCode" id="cb277"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb277-1"><a href="#cb277-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(integrate-system system-derivative</span>
<span id="cb277-2"><a href="#cb277-2" aria-hidden="true"></a>                          initial-state</span>
<span id="cb277-3"><a href="#cb277-3" aria-hidden="true"></a>                          h)</span>
<span id="cb277-4"><a href="#cb277-4" aria-hidden="true"></a>  (<span class="kw">let</span> ((next (runge-kutta<span class="dv">-4</span> system-derivative h)))</span>
<span id="cb277-5"><a href="#cb277-5" aria-hidden="true"></a>    (<span class="kw">letrec</span> ((states</span>
<span id="cb277-6"><a href="#cb277-6" aria-hidden="true"></a>              (<span class="kw">cons</span> initial-state</span>
<span id="cb277-7"><a href="#cb277-7" aria-hidden="true"></a>                    (delay (map-streams next</span>
<span id="cb277-8"><a href="#cb277-8" aria-hidden="true"></a>                                        states)))))</span>
<span id="cb277-9"><a href="#cb277-9" aria-hidden="true"></a>      states)))</span></code></pre></div>
<p>The procedure runge-kutta-4 takes a function, <code>f</code>, that produces a system derivative from a system state. It produces a function that takes a system state and produces a new system state.</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb278-1"><a href="#cb278-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(runge-kutta<span class="dv">-4</span> f h)</span>
<span id="cb278-2"><a href="#cb278-2" aria-hidden="true"></a>  (<span class="kw">let</span> ((*h (scale-vector h))</span>
<span id="cb278-3"><a href="#cb278-3" aria-hidden="true"></a>        (*<span class="dv">2</span> (scale-vector <span class="dv">2</span>))</span>
<span id="cb278-4"><a href="#cb278-4" aria-hidden="true"></a>        (*<span class="dv">1</span>/<span class="dv">2</span> (scale-vector (<span class="op">/</span> <span class="dv">1</span> <span class="dv">2</span>)))</span>
<span id="cb278-5"><a href="#cb278-5" aria-hidden="true"></a>        (*<span class="dv">1</span>/<span class="dv">6</span> (scale-vector (<span class="op">/</span> <span class="dv">1</span> <span class="dv">6</span>))))</span>
<span id="cb278-6"><a href="#cb278-6" aria-hidden="true"></a>    (<span class="kw">lambda</span> (y)</span>
<span id="cb278-7"><a href="#cb278-7" aria-hidden="true"></a>      <span class="co">;; y is a system state</span></span>
<span id="cb278-8"><a href="#cb278-8" aria-hidden="true"></a>      (<span class="kw">let*</span> ((k0 (*h (f y)))</span>
<span id="cb278-9"><a href="#cb278-9" aria-hidden="true"></a>             (k1 (*h (f (add-vectors y (*<span class="dv">1</span>/<span class="dv">2</span> k0)))))</span>
<span id="cb278-10"><a href="#cb278-10" aria-hidden="true"></a>             (k2 (*h (f (add-vectors y (*<span class="dv">1</span>/<span class="dv">2</span> k1)))))</span>
<span id="cb278-11"><a href="#cb278-11" aria-hidden="true"></a>             (k3 (*h (f (add-vectors y k2)))))</span>
<span id="cb278-12"><a href="#cb278-12" aria-hidden="true"></a>        (add-vectors y</span>
<span id="cb278-13"><a href="#cb278-13" aria-hidden="true"></a>                     (*<span class="dv">1</span>/<span class="dv">6</span> (add-vectors k0</span>
<span id="cb278-14"><a href="#cb278-14" aria-hidden="true"></a>                                        (*<span class="dv">2</span> k1)</span>
<span id="cb278-15"><a href="#cb278-15" aria-hidden="true"></a>                                        (*<span class="dv">2</span> k2)</span>
<span id="cb278-16"><a href="#cb278-16" aria-hidden="true"></a>                                        k3)))))))</span>
<span id="cb278-17"><a href="#cb278-17" aria-hidden="true"></a></span>
<span id="cb278-18"><a href="#cb278-18" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(elementwise f)</span>
<span id="cb278-19"><a href="#cb278-19" aria-hidden="true"></a>  (<span class="kw">lambda</span> vectors</span>
<span id="cb278-20"><a href="#cb278-20" aria-hidden="true"></a>    (generate-vector</span>
<span id="cb278-21"><a href="#cb278-21" aria-hidden="true"></a>     (<span class="kw">vector-length</span> (<span class="kw">car</span> vectors))</span>
<span id="cb278-22"><a href="#cb278-22" aria-hidden="true"></a>     (<span class="kw">lambda</span> (i)</span>
<span id="cb278-23"><a href="#cb278-23" aria-hidden="true"></a>       (apply f</span>
<span id="cb278-24"><a href="#cb278-24" aria-hidden="true"></a>              (map (<span class="kw">lambda</span> (v) (<span class="kw">vector-ref</span>  v i))</span>
<span id="cb278-25"><a href="#cb278-25" aria-hidden="true"></a>                   vectors))))))</span>
<span id="cb278-26"><a href="#cb278-26" aria-hidden="true"></a></span>
<span id="cb278-27"><a href="#cb278-27" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(generate-vector size proc)</span>
<span id="cb278-28"><a href="#cb278-28" aria-hidden="true"></a>  (<span class="kw">let</span> ((ans (<span class="kw">make-vector</span> size)))</span>
<span id="cb278-29"><a href="#cb278-29" aria-hidden="true"></a>    (<span class="kw">letrec</span> ((loop</span>
<span id="cb278-30"><a href="#cb278-30" aria-hidden="true"></a>              (<span class="kw">lambda</span> (i)</span>
<span id="cb278-31"><a href="#cb278-31" aria-hidden="true"></a>                (<span class="kw">cond</span> ((<span class="op">=</span> i size) ans)</span>
<span id="cb278-32"><a href="#cb278-32" aria-hidden="true"></a>                      (<span class="kw">else</span></span>
<span id="cb278-33"><a href="#cb278-33" aria-hidden="true"></a>                       (<span class="kw">vector-set!</span> ans i (proc i))</span>
<span id="cb278-34"><a href="#cb278-34" aria-hidden="true"></a>                       (loop (<span class="op">+</span> i <span class="dv">1</span>)))))))</span>
<span id="cb278-35"><a href="#cb278-35" aria-hidden="true"></a>      (loop <span class="dv">0</span>))))</span>
<span id="cb278-36"><a href="#cb278-36" aria-hidden="true"></a></span>
<span id="cb278-37"><a href="#cb278-37" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> add-vectors </span>(elementwise <span class="op">+</span>))</span>
<span id="cb278-38"><a href="#cb278-38" aria-hidden="true"></a></span>
<span id="cb278-39"><a href="#cb278-39" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(scale-vector s)</span>
<span id="cb278-40"><a href="#cb278-40" aria-hidden="true"></a>  (elementwise (<span class="kw">lambda</span> (x) (* x s))))</span></code></pre></div>
<p>The map-streams procedure is analogous to map: it applies its first argument (a procedure) to all the elements of its second argument (a stream).</p>
<div class="sourceCode" id="cb279"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb279-1"><a href="#cb279-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(map-streams f s)</span>
<span id="cb279-2"><a href="#cb279-2" aria-hidden="true"></a>  (<span class="kw">cons</span> (f (head s))</span>
<span id="cb279-3"><a href="#cb279-3" aria-hidden="true"></a>        (delay (map-streams f (tail s)))))</span></code></pre></div>
<p>Infinite streams are implemented as pairs whose car holds the first element of the stream and whose cdr holds a promise to deliver the rest of the stream.</p>
<div class="sourceCode" id="cb280"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb280-1"><a href="#cb280-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> head </span><span class="kw">car</span>)</span>
<span id="cb280-2"><a href="#cb280-2" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(tail stream)</span>
<span id="cb280-3"><a href="#cb280-3" aria-hidden="true"></a>  (<span class="kw">force</span> (<span class="kw">cdr</span> stream)))</span></code></pre></div>
<p>The following illustrates the use of integrate-system in integrating the system <span class="math display"><span class="math display">$$C {dv_C \\over dt} = -i_L - {v_C
\\over R}$$</span></span> <span class="math display"><span class="math display">$$L {di_L \\over dt} =
v_C$$</span></span> which models a damped oscillator.</p>
<div class="sourceCode" id="cb281"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb281-1"><a href="#cb281-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(damped-oscillator R L C)</span>
<span id="cb281-2"><a href="#cb281-2" aria-hidden="true"></a>  (<span class="kw">lambda</span> (state)</span>
<span id="cb281-3"><a href="#cb281-3" aria-hidden="true"></a>    (<span class="kw">let</span> ((Vc (<span class="kw">vector-ref</span> state <span class="dv">0</span>))</span>
<span id="cb281-4"><a href="#cb281-4" aria-hidden="true"></a>          (Il (<span class="kw">vector-ref</span> state <span class="dv">1</span>)))</span>
<span id="cb281-5"><a href="#cb281-5" aria-hidden="true"></a>      (<span class="kw">vector</span> (<span class="op">-</span> <span class="dv">0</span> (<span class="op">+</span> (<span class="op">/</span> Vc (* R C)) (<span class="op">/</span> Il C)))</span>
<span id="cb281-6"><a href="#cb281-6" aria-hidden="true"></a>              (<span class="op">/</span> Vc L)))))</span>
<span id="cb281-7"><a href="#cb281-7" aria-hidden="true"></a></span>
<span id="cb281-8"><a href="#cb281-8" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> the-states</span></span>
<span id="cb281-9"><a href="#cb281-9" aria-hidden="true"></a>  (integrate-system</span>
<span id="cb281-10"><a href="#cb281-10" aria-hidden="true"></a>   (damped-oscillator <span class="dv">10000</span> <span class="dv">1000</span> <span class="fl">.001</span>)</span>
<span id="cb281-11"><a href="#cb281-11" aria-hidden="true"></a>   &#39;#(<span class="dv">1</span> <span class="dv">0</span>)</span>
<span id="cb281-12"><a href="#cb281-12" aria-hidden="true"></a>   <span class="fl">.01</span>))</span></code></pre></div>
<h2 id="bibliography">Bibliography</h2>
<p>Harold Abelson and Gerald Jay Sussman with Julie Sussman. <em>Structure and Interpretation of Computer Programs, second edition.</em> MIT Press, Cambridge, 1996.</p>
<p>Alan Bawden and Jonathan Rees. Syntactic closures. In <em>Proceedings of the 1988 ACM Symposium on Lisp and Functional Programming</em>, pages 86–95.</p>
<p>S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. <a href="http://www.ietf.org/rfc/rfc2119.txt" class="uri">http://www.ietf.org/rfc/rfc2119.txt</a>, 1997.</p>
<p>Robert G. Burger and R. Kent Dybvig. Printing floating-point numbers quickly and accurately. In <em>Proceedings of the ACM SIGPLAN ’96 Conference on Programming Language Design and Implementation</em>, pages 108–116.</p>
<p>William Clinger. How to read floating point numbers accurately. In <em>Proceedings of the ACM SIGPLAN ’90 Conference on Programming Language Design and Implementation</em>, pages 92–101. Proceedings published as <em>SIGPLAN Notices</em> 25(6), June 1990.</p>
<p>William Clinger. Proper Tail Recursion and Space Efficiency. In <em>Proceedings of the 1998 ACM Conference on Programming Language Design and Implementation</em>, June 1998.</p>
<p>William Clinger. SRFI 6: Basic String Ports. <a href="http://srfi.schemers.org/srfi-6/" class="uri">http://srfi.schemers.org/srfi-6/</a>, 1999.</p>
<p>William Clinger, editor. The revised revised report on Scheme, or an uncommon Lisp. MIT Artificial Intelligence Memo 848, August 1985. Also published as Computer Science Department Technical Report 174, Indiana University, June 1985.</p>
<p>William Clinger and Jonathan Rees. Macros that work. In <em>Proceedings of the 1991 ACM Conference on Principles of Programming Languages</em>, pages 155–162.</p>
<p>William Clinger and Jonathan Rees, editors. The revised<sup><small>4</small></sup> report on the algorithmic language Scheme. In <em>ACM Lisp Pointers</em> 4(3), pages 1–55, 1991.</p>
<p>Mark Davis. Unicode Standard Annex #44, Unicode Character Database. <a href="http://unicode.org/reports/tr44/" class="uri">http://unicode.org/reports/tr44/</a>, 2010.</p>
<p>R. Kent Dybvig, Robert Hieb, and Carl Bruggeman. Syntactic abstraction in Scheme. <em>Lisp and Symbolic Computation</em> 5(4):295–326, 1993.</p>
<p>Marc Feeley. SRFI 4: Homogeneous Numeric Vector Datatypes. <a href="http://srfi.schemers.org/srfi-4/" class="uri">http://srfi.schemers.org/srfi-4/</a>, 1999.</p>
<p>Carol Fessenden, William Clinger, Daniel P. Friedman, and Christopher Haynes. Scheme 311 version 4 reference manual. Indiana University Computer Science Technical Report 137, February 1983. Superseded by <span class="citation" data-cites="Scheme84"></span>.</p>
<p>D. Friedman, C. Haynes, E. Kohlbecker, and M. Wand. Scheme 84 interim reference manual. Indiana University Computer Science Technical Report 153, January 1985.</p>
<p>Martin Gardner. Mathematical Games: The fantastic combinations of John Conway’s new solitaire game “Life.” In <em>Scientific American</em>, 223:120–123, October 1970.</p>
<p><em>IEEE Standard 754-2008. IEEE Standard for Floating-Point Arithmetic.</em> IEEE, New York, 2008.</p>
<p><em>IEEE Standard 1178-1990. IEEE Standard for the Scheme Programming Language.</em> IEEE, New York, 1991.</p>
<p>Richard Kelsey. SRFI 9: Defining Record Types. <a href="http://srfi.schemers.org/srfi-9/" class="uri">http://srfi.schemers.org/srfi-9/</a>, 1999.</p>
<p>Richard Kelsey, William Clinger, and Jonathan Rees, editors. The revised<sup><small>5</small></sup> report on the algorithmic language Scheme. <em>Higher-Order and Symbolic Computation</em>, 11(1):7-105, 1998.</p>
<p>Eugene E. Kohlbecker Jr. <em>Syntactic Extensions in the Programming Language Lisp.</em> PhD thesis, Indiana University, August 1986.</p>
<p>Eugene E. Kohlbecker Jr., Daniel P. Friedman, Matthias Felleisen, and Bruce Duba. Hygienic macro expansion. In <em>Proceedings of the 1986 ACM Conference on Lisp and Functional Programming</em>, pages 151–161.</p>
<p>John McCarthy. Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I. <em>Communications of the ACM</em> 3(4):184–195, April 1960.</p>
<p>MIT Department of Electrical Engineering and Computer Science. Scheme manual, seventh edition. September 1984.</p>
<p>Peter Naur et al. Revised report on the algorithmic language Algol 60. <em>Communications of the ACM</em> 6(1):1–17, January 1963.</p>
<p>Paul Penfield, Jr. Principal values and branch cuts in complex APL. In <em>APL ’81 Conference Proceedings,</em> pages 248–256. ACM SIGAPL, San Francisco, September 1981. Proceedings published as <em>APL Quote Quad</em> 12(1), ACM, September 1981.</p>
<p>Jonathan A. Rees and Norman I. Adams IV. T: A dialect of Lisp or, lambda: The ultimate software tool. In <em>Conference Record of the 1982 ACM Symposium on Lisp and Functional Programming</em>, pages 114–122.</p>
<p>Jonathan A. Rees, Norman I. Adams IV, and James R. Meehan. The T manual, fourth edition. Yale University Computer Science Department, January 1984.</p>
<p>Jonathan Rees and William Clinger, editors. The revised<sup><small>3</small></sup> report on the algorithmic language Scheme. In <em>ACM SIGPLAN Notices</em> 21(12), pages 37–79, December 1986.</p>
<p>Olin Shivers. SRFI 1: List Library. <a href="http://srfi.schemers.org/srfi-1/" class="uri">http://srfi.schemers.org/srfi-1/</a>, 1999.</p>
<p>Guy Lewis Steele Jr. and Gerald Jay Sussman. The revised report on Scheme, a dialect of Lisp. MIT Artificial Intelligence Memo 452, January 1978.</p>
<p>Guy Lewis Steele Jr. Rabbit: a compiler for Scheme. MIT Artificial Intelligence Laboratory Technical Report 474, May 1978.</p>
<p>Michael Sperber, R. Kent Dybvig, Mathew Flatt, and Anton van Straaten, editors. <em>The revised<sup><small>6</small></sup> report on the algorithmic language Scheme.</em> Cambridge University Press, 2010.</p>
<p>Guy Lewis Steele Jr. <em>Common Lisp: The Language, second edition.</em> Digital Press, Burlington MA, 1990.</p>
<p>Gerald Jay Sussman and Guy Lewis Steele Jr. Scheme: an interpreter for extended lambda calculus. MIT Artificial Intelligence Memo 349, December 1975.</p>
<p>Joseph E. Stoy. <em>Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory.</em> MIT Press, Cambridge, 1977.</p>
<p>Texas Instruments, Inc. TI Scheme Language Reference Manual. Preliminary version 1.0, November 1985.</p>
<p>Andre van Tonder. SRFI 45: Primitives for Expressing Iterative Lazy Algorithms. <a href="http://srfi.schemers.org/srfi-45/" class="uri">http://srfi.schemers.org/srfi-45/</a>, 2002.</p>
<p>Martin Gasbichler, Eric Knauel, Michael Sperber and Richard Kelsey. How to Add Threads to a Sequential Language Without Getting Tangled Up. <em>Proceedings of the Fourth Workshop on Scheme and Functional Programming</em>, November 2003.</p>
<p>International Earth Rotation Service. Historical table of TAI-UTC offsets. <a href="http://maia.usno.navy.mil/ser7/tai-utc.dat" class="uri">http://maia.usno.navy.mil/ser7/tai-utc.dat</a> # <code>(scheme list)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-1/">SRFI-1</a>.</p>
<h2 id="cons-a-d"><code>(cons a d)</code></h2>
<p>The primitive constructor. Returns a newly allocated pair whose <code>car</code> is <code>a</code> and whose <code>cdr</code> is <code>d</code>. The pair is guaranteed to be different (in the sense of <code>eqv?</code>) from every existing object.</p>
<h2 id="list-object-..."><code>(list object ...)</code></h2>
<p>Returns a newly allocated list of its arguments.</p>
<h2 id="xcons-d-a"><code>(xcons d a)</code></h2>
<div class="sourceCode" id="cb282"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb282-1"><a href="#cb282-1" aria-hidden="true"></a>(<span class="kw">lambda</span> (d a) (<span class="kw">cons</span> a d))</span></code></pre></div>
<p>Of utility only as a value to be conveniently passed to higher-order procedures.</p>
<div class="sourceCode" id="cb283"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb283-1"><a href="#cb283-1" aria-hidden="true"></a>(xcons &#39;(b c) &#39;a) <span class="co">;; =&gt; (a b c)</span></span></code></pre></div>
<p>The name stands for “eXchanged CONS.”</p>
<h2 id="cons-obj-...-tail"><code>(cons* obj ... tail)</code></h2>
<p>Like list, but the last argument provides the tail of the constructed list.</p>
<h2 id="make-list-n-fill"><code>(make-list n [fill])</code></h2>
<p>Returns an n-element list, whose elements are all the value fill. If the fill argument is not given, the elements of the list may be arbitrary values.</p>
<div class="sourceCode" id="cb284"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb284-1"><a href="#cb284-1" aria-hidden="true"></a>(make-list <span class="dv">4</span> &#39;c) <span class="op">=&gt;</span> (c c c c)</span></code></pre></div>
<h2 id="list-tabulate-n-init-proc"><code>(list-tabulate n init-proc)</code></h2>
<p>Returns an n-element list. Element i of the list, where 0 &lt;= i &lt; n, is produced by (init-proc i). No guarantee is made about the dynamic order in which init-proc is applied to these indices.</p>
<div class="sourceCode" id="cb285"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb285-1"><a href="#cb285-1" aria-hidden="true"></a>(list-tabulate <span class="dv">4</span> <span class="kw">values</span>) <span class="op">=&gt;</span> (<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</span></code></pre></div>
<h2 id="list-copy-flist"><code>(list-copy flist)</code></h2>
<p>Copies the spine of the argument.</p>
<h2 id="circular-list-elt1-elt2-..."><code>(circular-list elt1 elt2 ...)</code></h2>
<p>Constructs a circular list of the elements.</p>
<div class="sourceCode" id="cb286"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb286-1"><a href="#cb286-1" aria-hidden="true"></a>(circular-list &#39;z &#39;q) <span class="op">=&gt;</span> (z q z q z q ...)</span></code></pre></div>
<h2 id="iota-count-start-step"><code>(iota count [start step])</code></h2>
<p>Returns a list containing the elements:</p>
<div class="sourceCode" id="cb287"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb287-1"><a href="#cb287-1" aria-hidden="true"></a>(start start+step ... start+(count<span class="dv">-1</span>)*step)</span></code></pre></div>
<p>The start and step parameters default to 0 and 1, respectively.</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb288-1"><a href="#cb288-1" aria-hidden="true"></a>(iota <span class="dv">5</span>) <span class="op">=&gt;</span> (<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)</span>
<span id="cb288-2"><a href="#cb288-2" aria-hidden="true"></a>(iota <span class="dv">5</span> <span class="dv">0</span> <span class="fl">-0.1</span>) <span class="op">=&gt;</span> (<span class="dv">0</span> <span class="fl">-0.1</span> <span class="fl">-0.2</span> <span class="fl">-0.3</span> <span class="fl">-0.4</span>)</span></code></pre></div>
<h2 id="proper-list-x"><code>(proper-list? x)</code></h2>
<p>Returns true iff x is a proper list – a finite, nil-terminated list.</p>
<p>More carefully: The empty list is a proper list. A pair whose cdr is a proper list is also a proper list. The opposite of proper is improper.</p>
<h2 id="circular-list-x"><code>(circular-list? x)</code></h2>
<p>True if x is a circular list. A circular list is a value such that for every n &gt;= 0, cdrn(x) is a pair.</p>
<p>Terminology: The opposite of circular is finite.</p>
<h2 id="dotted-list-x"><code>(dotted-list? x)</code></h2>
<p>True if x is a finite, non-nil-terminated list. That is, there exists an n &gt;= 0 such that cdrn(x) is neither a pair nor (). This includes non-pair, non-() values (e.g. symbols, numbers), which are considered to be dotted lists of length 0.</p>
<h2 id="pair-obj"><code>(pair? obj)</code></h2>
<p>Returns #t if object is a pair; otherwise, #f.</p>
<h2 id="null-obj"><code>(null? obj)</code></h2>
<p>Returns #t if object is the empty list; otherwise, #f.</p>
<h2 id="null-list-list"><code>(null-list? list)</code></h2>
<p>List is a proper or circular list. This procedure returns true if the argument is the empty list (), and false otherwise. It is an error to pass this procedure a value which is not a proper or circular list. This procedure is recommended as the termination condition for list-processing procedures that are not defined on dotted lists.</p>
<h2 id="not-pair-x"><code>(not-pair? x)</code></h2>
<p>Provided as a procedure as it can be useful as the termination condition for list-processing procedures that wish to handle all finite lists, both proper and dotted.</p>
<h2 id="list-elt-list1-..."><code>(list= elt= list1 ...)</code></h2>
<p>Determines list equality, given an element-equality procedure.</p>
<h2 id="car-pair"><code>(car pair)</code></h2>
<h2 id="cdr-pair"><code>(cdr pair)</code></h2>
<p>These functions return the contents of the car and cdr field of their argument, respectively. Note that it is an error to apply them to the empty list.</p>
<p>Also the following selectors are defined:</p>
<ul>
<li><code>caar</code></li>
<li><code>cadr</code></li>
<li><code>cdar</code></li>
<li><code>cddr</code></li>
<li><code>caaar</code></li>
<li><code>caadr</code></li>
<li><code>cadar</code></li>
<li><code>caddr</code></li>
<li><code>cdaar</code></li>
<li><code>cdadr</code></li>
<li><code>cddar</code></li>
<li><code>cdddr</code></li>
<li><code>caaaar</code></li>
<li><code>caaadr</code></li>
<li><code>caadar</code></li>
<li><code>caaddr</code></li>
<li><code>cadaar</code></li>
<li><code>cadadr</code></li>
<li><code>caddar</code></li>
<li><code>cadddr</code></li>
<li><code>cdaaar</code></li>
<li><code>cdaadr</code></li>
<li><code>cdadar</code></li>
<li><code>cdaddr</code></li>
<li><code>cddaar</code></li>
<li><code>cddadr</code></li>
<li><code>cdddar</code></li>
<li><code>cddddr</code></li>
</ul>
<h2 id="list-ref-clist-i"><code>(list-ref clist i)</code></h2>
<p>Returns the ith element of clist. (This is the same as the car of (drop clist i).) It is an error if i &gt;= n, where n is the length of clist.</p>
<div class="sourceCode" id="cb289"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb289-1"><a href="#cb289-1" aria-hidden="true"></a>(<span class="kw">list-ref</span> &#39;(a b c d) <span class="dv">2</span>) <span class="op">=&gt;</span> c</span></code></pre></div>
<h2 id="first-pair"><code>(first pair)</code></h2>
<h2 id="second-pair"><code>(second pair)</code></h2>
<h2 id="third-pair"><code>(third pair)</code></h2>
<h2 id="fourth-pair"><code>(fourth pair)</code></h2>
<h2 id="fifth-pair"><code>(fifth pair)</code></h2>
<h2 id="sixth-pair"><code>(sixth pair)</code></h2>
<h2 id="seventh-pair"><code>(seventh pair)</code></h2>
<h2 id="eighth-pair"><code>(eighth pair)</code></h2>
<h2 id="ninth-pair"><code>(ninth pair)</code></h2>
<h2 id="tenth-pair"><code>(tenth pair)</code></h2>
<p>Synonyms for <code>car</code>, <code>cadr</code>, <code>caddr</code>, …</p>
<h2 id="carcdr-pair"><code>(car+cdr pair)</code></h2>
<p>The fundamental pair deconstructor:</p>
<pre><code>(lambda (p) (values (car p) (cdr p)))</code></pre>
<p>This can, of course, be implemented more efficiently by a compiler.</p>
<h2 id="take-lst-i"><code>(take lst i)</code></h2>
<h2 id="drop-lst-i"><code>(drop lst i)</code></h2>
<p><code>take</code> returns the first <code>I</code> elements of list <code>LST</code>. <code>drop</code> returns all but the first i elements of list <code>LST</code>.</p>
<div class="sourceCode" id="cb291"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb291-1"><a href="#cb291-1" aria-hidden="true"></a>(take &#39;(a b c d e) <span class="dv">2</span>) <span class="co">;; =&gt; (a b)</span></span>
<span id="cb291-2"><a href="#cb291-2" aria-hidden="true"></a>(drop &#39;(a b c d e) <span class="dv">2</span>) <span class="co">;; =&gt; (c d e)</span></span></code></pre></div>
<p><code>LST</code> may be any value – a proper, circular, or dotted list:</p>
<div class="sourceCode" id="cb292"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true"></a>(take &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">2</span>) <span class="co">;; =&gt; (1 2)</span></span>
<span id="cb292-2"><a href="#cb292-2" aria-hidden="true"></a>(drop &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">2</span>) <span class="co">;; =&gt; (3 . d)</span></span>
<span id="cb292-3"><a href="#cb292-3" aria-hidden="true"></a>(take &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">3</span>) <span class="co">;; =&gt; (1 2 3)</span></span>
<span id="cb292-4"><a href="#cb292-4" aria-hidden="true"></a>(drop &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">3</span>) <span class="co">;; =&gt; d</span></span></code></pre></div>
<p>For a legal <code>I</code>, <code>take</code> and <code>drop</code> partition the list in a manner which can be inverted with append:</p>
<div class="sourceCode" id="cb293"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb293-1"><a href="#cb293-1" aria-hidden="true"></a>(<span class="kw">equal?</span> (<span class="kw">append</span> (take lst i) (drop x i)) lst)</span></code></pre></div>
<p><code>drop</code> is exactly equivalent to performing <code>i</code> <code>cdr</code> operations on <code>LST</code>; the returned value shares a common tail with <code>LST</code>. If the argument is a list of non-zero length, <code>take</code> is guaranteed to return a freshly-allocated list, even in the case where the entire list is taken, e.g. <code>(take lst (length lst))</code>.</p>
<h2 id="take-right-flist-i"><code>(take-right flist i)</code></h2>
<h2 id="drop-right-flist-i"><code>(drop-right flist i)</code></h2>
<p><code>take-right</code> returns the last <code>I</code> elements of <code>FLIST</code>. <code>drop-right</code> returns all but the last <code>I</code> elements of <code>FLIST</code>.</p>
<div class="sourceCode" id="cb294"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb294-1"><a href="#cb294-1" aria-hidden="true"></a>(take-right &#39;(a b c d e) <span class="dv">2</span>) <span class="op">=&gt;</span> (d e)</span>
<span id="cb294-2"><a href="#cb294-2" aria-hidden="true"></a>(drop-right &#39;(a b c d e) <span class="dv">2</span>) <span class="op">=&gt;</span> (a b c)</span></code></pre></div>
<p>The returned list may share a common tail with the argument list.</p>
<p><code>FLIST</code> may be any finite list, either proper or dotted:</p>
<div class="sourceCode" id="cb295"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb295-1"><a href="#cb295-1" aria-hidden="true"></a>(take-right &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">2</span>) <span class="op">=&gt;</span> (<span class="dv">2</span> <span class="dv">3</span> . d)</span>
<span id="cb295-2"><a href="#cb295-2" aria-hidden="true"></a>(drop-right &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">2</span>) <span class="op">=&gt;</span> (<span class="dv">1</span>)</span>
<span id="cb295-3"><a href="#cb295-3" aria-hidden="true"></a>(take-right &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">0</span>) <span class="op">=&gt;</span> d</span>
<span id="cb295-4"><a href="#cb295-4" aria-hidden="true"></a>(drop-right &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">0</span>) <span class="op">=&gt;</span> (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</span></code></pre></div>
<p>For a legal <code>I</code>, <code>take-right</code> and <code>drop-right</code> partition the list in a manner which can be inverted with <code>append</code>:</p>
<div class="sourceCode" id="cb296"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb296-1"><a href="#cb296-1" aria-hidden="true"></a>(<span class="kw">equal?</span> (<span class="kw">append</span> (take flist i) (drop flist i)) flist)</span></code></pre></div>
<p><code>take-right</code>’s return value is guaranteed to share a common tail with <code>FLIST</code>. If the argument is a list of non-zero length, <code>drop-right</code> is guaranteed to return a freshly-allocated list, even in the case where nothing is dropped, e.g. <code>(drop-right flist 0)</code>.</p>
<h2 id="take-x-i"><code>(take! x i)</code></h2>
<h2 id="drop-right-flist-i-1"><code>(drop-right! flist i)</code></h2>
<p><code>take!</code> and <code>drop-right!</code> are “linear-update” variants of <code>take</code> and <code>drop-right</code>: the procedure is allowed, but not required, to alter the argument list to produce the result.</p>
<p>If <code>x</code> is circular, <code>take!</code> may return a shorter-than-expected list:</p>
<div class="sourceCode" id="cb297"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb297-1"><a href="#cb297-1" aria-hidden="true"></a>(take! (circular-list <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span>) <span class="dv">8</span>) <span class="op">=&gt;</span> (<span class="dv">1</span> <span class="dv">3</span>)</span>
<span id="cb297-2"><a href="#cb297-2" aria-hidden="true"></a>(take! (circular-list <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span>) <span class="dv">8</span>) <span class="op">=&gt;</span> (<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">1</span> <span class="dv">3</span>)</span></code></pre></div>
<h2 id="split-at-x-i"><code>(split-at  x i)</code></h2>
<h2 id="split-at-x-i-1"><code>(split-at! x i)</code></h2>
<p><code>split-at</code> splits the list <code>x</code> at index <code>i</code>, returning a list of the first <code>i</code> elements, and the remaining tail. It is equivalent to:</p>
<div class="sourceCode" id="cb298"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb298-1"><a href="#cb298-1" aria-hidden="true"></a>(<span class="kw">values</span> (take x i) (drop x i))</span></code></pre></div>
<p><code>split-at!</code> is the linear-update variant. It is allowed, but not required, to alter the argument list to produce the result.</p>
<div class="sourceCode" id="cb299"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb299-1"><a href="#cb299-1" aria-hidden="true"></a>(split-at &#39;(a b c d e f g h) <span class="dv">3</span>) <span class="co">;; =&gt; (a b c) and (d e f g h)</span></span></code></pre></div>
<h2 id="last-pair"><code>(last pair)</code></h2>
<h2 id="last-pair-pair"><code>(last-pair pair)</code></h2>
<p><code>last</code> returns the last element of the non-empty, finite list <code>pair</code>. <code>last-pair</code> returns the last pair in the non-empty, finite list <code>pair</code>:</p>
<div class="sourceCode" id="cb300"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb300-1"><a href="#cb300-1" aria-hidden="true"></a>(last &#39;(a b c)) <span class="co">;; =&gt; c</span></span>
<span id="cb300-2"><a href="#cb300-2" aria-hidden="true"></a>(last-pair &#39;(a b c)) <span class="co">;; =&gt; (c)</span></span></code></pre></div>
<h2 id="length-list"><code>(length list)</code></h2>
<h2 id="length-clist"><code>(length+ clist)</code></h2>
<p>Both <code>length</code> and <code>length+</code> return the length of the argument. It is an error to pass a value to length which is not a proper list (finite and nil-terminated). In particular, this means an implementation may diverge or signal an error when length is applied to a circular list.</p>
<p><code>length+</code>, on the other hand, returns <code>#f</code> when applied to a circular list.</p>
<p>The length of a proper list is a non-negative integer <code>n</code> such that <code>cdr</code> applied <code>n</code> times to the list produces the empty list.</p>
<h2 id="append-list1-..."><code>(append  list1 ...)</code></h2>
<h2 id="append-list1-...-1"><code>(append! list1 ...)</code></h2>
<p><code>append</code> returns a list consisting of the elements of <code>list1</code> followed by the elements of the other list parameters.</p>
<div class="sourceCode" id="cb301"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb301-1"><a href="#cb301-1" aria-hidden="true"></a>(<span class="kw">append</span> &#39;(x) &#39;(y))        <span class="op">=&gt;</span>  (x y)</span>
<span id="cb301-2"><a href="#cb301-2" aria-hidden="true"></a>(<span class="kw">append</span> &#39;(a) &#39;(b c d))    <span class="op">=&gt;</span>  (a b c d)</span>
<span id="cb301-3"><a href="#cb301-3" aria-hidden="true"></a>(<span class="kw">append</span> &#39;(a (b)) &#39;((c)))  <span class="op">=&gt;</span>  (a (b) (c))</span></code></pre></div>
<p>The resulting list is always newly allocated, except that it shares structure with the final list argument. This last argument may be any value at all; an improper list results if it is not a proper list. All other arguments must be proper lists.</p>
<div class="sourceCode" id="cb302"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb302-1"><a href="#cb302-1" aria-hidden="true"></a>(<span class="kw">append</span> &#39;(a b) &#39;(c . d))  <span class="op">=&gt;</span>  (a b c . d)</span>
<span id="cb302-2"><a href="#cb302-2" aria-hidden="true"></a>(<span class="kw">append</span> &#39;() &#39;a)           <span class="op">=&gt;</span>  a</span>
<span id="cb302-3"><a href="#cb302-3" aria-hidden="true"></a>(<span class="kw">append</span> &#39;(x y))           <span class="op">=&gt;</span>  (x y)</span>
<span id="cb302-4"><a href="#cb302-4" aria-hidden="true"></a>(<span class="kw">append</span>)                  <span class="op">=&gt;</span>  ()</span></code></pre></div>
<p><code>append!</code> is the “linear-update” variant of append – it is allowed, but not required, to alter <code>cons</code> cells in the argument lists to construct the result list. The last argument is never altered; the result list shares structure with this parameter.</p>
<h2 id="concatenate-list-of-lists"><code>(concatenate  list-of-lists)</code></h2>
<h2 id="concatenate-list-of-lists-1"><code>(concatenate! list-of-lists)</code></h2>
<p>These functions append the elements of their argument together. That is, <code>concatenate</code> returns:</p>
<div class="sourceCode" id="cb303"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb303-1"><a href="#cb303-1" aria-hidden="true"></a>(apply <span class="kw">append</span> list-of-lists)</span></code></pre></div>
<p>Or, equivalently,</p>
<div class="sourceCode" id="cb304"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb304-1"><a href="#cb304-1" aria-hidden="true"></a>(reduce-right <span class="kw">append</span> &#39;() list-of-lists)</span></code></pre></div>
<p><code>concatenate!</code> is the linear-update variant, defined in terms of <code>append!</code> instead of <code>append</code>.</p>
<p>As with <code>append</code> and <code>append!</code>, the last element of the input list may be any value at all.</p>
<h2 id="reverse-list"><code>(reverse list)</code></h2>
<h2 id="reverse-list-1"><code>(reverse! list)</code></h2>
<p><code>reverse</code> returns a newly allocated list consisting of the elements of list in reverse order.</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb305-1"><a href="#cb305-1" aria-hidden="true"></a>(<span class="kw">reverse</span> &#39;(a b c)) <span class="co">;; =&gt;  (c b a)</span></span>
<span id="cb305-2"><a href="#cb305-2" aria-hidden="true"></a>(<span class="kw">reverse</span> &#39;(a (b c) d (e (f)))) <span class="co">;; =&gt;  ((e (f)) d (b c) a)</span></span></code></pre></div>
<p><code>reverse!</code> is the linear-update variant of reverse. It is permitted, but not required, to alter the argument’s <code>cons</code> cells to produce the reversed list.</p>
<h2 id="append-reverse-rev-head-tail"><code>(append-reverse rev-head tail)</code></h2>
<h2 id="append-reverse-rev-head-tail-1"><code>(append-reverse! rev-head tail)</code></h2>
<p><code>append-reverse</code> returns <code>(append (reverse rev-head) tail)</code>. It is provided because it is a common operation – a common list-processing style calls for this exact operation to transfer values accumulated in reverse order onto the front of another list, and because the implementation is significantly more efficient than the simple composition it replaces. (But note that this pattern of iterative computation followed by a <code>reverse</code> can frequently be rewritten as a recursion, dispensing with the <code>reverse</code> and <code>append-reverse</code> steps, and shifting temporary, intermediate storage from the heap to the stack, which is typically a win for reasons of cache locality and eager storage reclamation.)</p>
<p><code>append-reverse!</code> is just the linear-update variant – it is allowed, but not required, to alter rev-head’s <code>cons</code> cells to construct the result.</p>
<h2 id="zip-clist1-clist2-..."><code>(zip clist1 clist2 ...)</code></h2>
<div class="sourceCode" id="cb306"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb306-1"><a href="#cb306-1" aria-hidden="true"></a>(<span class="kw">lambda</span> lists (apply map <span class="kw">list</span> lists))</span></code></pre></div>
<p>If <code>zip</code> is passed n lists, it returns a list as long as the shortest of these lists, each element of which is an n-element list comprised of the corresponding elements from the parameter lists.</p>
<div class="sourceCode" id="cb307"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb307-1"><a href="#cb307-1" aria-hidden="true"></a>(zip &#39;(one two three)</span>
<span id="cb307-2"><a href="#cb307-2" aria-hidden="true"></a>     &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</span>
<span id="cb307-3"><a href="#cb307-3" aria-hidden="true"></a>     &#39;(odd even odd even odd even odd even))</span>
<span id="cb307-4"><a href="#cb307-4" aria-hidden="true"></a>     <span class="co">;; =&gt; ((one 1 odd) (two 2 even) (three 3 odd))</span></span>
<span id="cb307-5"><a href="#cb307-5" aria-hidden="true"></a></span>
<span id="cb307-6"><a href="#cb307-6" aria-hidden="true"></a>(zip &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)) <span class="op">=&gt;</span> ((<span class="dv">1</span>) (<span class="dv">2</span>) (<span class="dv">3</span>))</span></code></pre></div>
<h2 id="unzip1-list"><code>(unzip1 list)</code></h2>
<h2 id="unzip2-list"><code>(unzip2 list)</code></h2>
<h2 id="unzip3-list"><code>(unzip3 list)</code></h2>
<h2 id="unzip4-list"><code>(unzip4 list)</code></h2>
<h2 id="unzip5-list"><code>(unzip5 list)</code></h2>
<p><code>unzip1</code> takes a list of lists, where every list must contain at least one element, and returns a list containing the initial element of each such list. That is, it returns <code>(map car lists)</code>. <code>unzip2</code> takes a list of lists, where every list must contain at least two elements, and returns two values: a list of the first elements, and a list of the second elements. <code>unzip3</code> does the same for the first three elements of the lists, and so forth.</p>
<div class="sourceCode" id="cb308"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb308-1"><a href="#cb308-1" aria-hidden="true"></a>(unzip2 &#39;((<span class="dv">1</span> one) (<span class="dv">2</span> two) (<span class="dv">3</span> three))) <span class="co">;; =&gt; &#39;((1 2 3) (one two three))</span></span></code></pre></div>
<h2 id="count-pred-clist1-..."><code>(count pred clist1 ...)</code></h2>
<p><code>pred</code> is a procedure taking as many arguments as there are lists and returning a single value. It is applied element-wise to the elements of the lists, and a count is tallied of the number of elements that produce a true value. This count is returned. <code>count</code> is “iterative” in that it is guaranteed to apply <code>pred</code> to the list elements in a left-to-right order. The counting stops when the shortest list expires.</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb309-1"><a href="#cb309-1" aria-hidden="true"></a>(count <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>)) <span class="op">=&gt;</span> <span class="dv">3</span></span>
<span id="cb309-2"><a href="#cb309-2" aria-hidden="true"></a>(count <span class="op">&lt;</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span> <span class="dv">8</span>) &#39;(<span class="dv">2</span> <span class="dv">4</span> <span class="dv">6</span> <span class="dv">8</span> <span class="dv">10</span> <span class="dv">12</span> <span class="dv">14</span> <span class="dv">16</span>)) <span class="op">=&gt;</span> <span class="dv">3</span></span></code></pre></div>
<p>At least one of the argument lists must be finite:</p>
<pre><code>(count &lt; &#39;(3 1 4 1) (circular-list 1 10)) =&gt; 2</code></pre>
<h2 id="fold-kons-knil-list1-..."><code>(fold kons knil list1 ...)</code></h2>
<p>TODO</p>
<h2 id="fold-right-kons-knil-list1-..."><code>(fold-right kons knil list1 ...)</code></h2>
<p>TODO</p>
<h2 id="pair-fold-kons-knil-list1-..."><code>(pair-fold kons knil list1 ...)</code></h2>
<p>TODO</p>
<h2 id="pair-fold-right-kons-knil-list1-..."><code>(pair-fold-right kons knil list1 ...)</code></h2>
<p>TODO</p>
<h2 id="reduce-f-ridentity-list"><code>(reduce f ridentity list)</code></h2>
<p><code>reduce</code> is a variant of <code>fold</code>.</p>
<p><code>ridentity</code> should be a “right identity” of the procedure <code>f</code> – that is, for any value <code>x</code> acceptable to <code>f</code>:</p>
<div class="sourceCode" id="cb311"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb311-1"><a href="#cb311-1" aria-hidden="true"></a>(f x ridentity) <span class="co">;; =&gt; x</span></span></code></pre></div>
<p>Note: that <code>ridentity</code> is used only in the empty-list case. You typically use reduce when applying <code>f</code> is expensive and you’d like to avoid the extra application incurred when fold applies <code>f</code> to the head of list and the identity value, redundantly producing the same value passed in to <code>f</code>. For example, if <code>f</code> involves searching a file directory or performing a database query, this can be significant. In general, however, <code>fold</code> is useful in many contexts where <code>reduce</code> is not (consider the examples given in the <code>fold</code> definition – only one of the five folds uses a function with a right identity. The other four may not be performed with reduce).</p>
<h2 id="reducse-right-f-ridentity-list"><code>(reducse-right f ridentity list)</code></h2>
<p><code>reduce-right</code> is the <code>fold-right</code> variant of reduce. It obeys the following definition:</p>
<div class="sourceCode" id="cb312"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb312-1"><a href="#cb312-1" aria-hidden="true"></a>(reduce-right f ridentity &#39;()) <span class="op">=</span> ridentity</span>
<span id="cb312-2"><a href="#cb312-2" aria-hidden="true"></a>(reduce-right f ridentity &#39;(e1)) <span class="op">=</span> (f e1 ridentity) <span class="op">=</span> e1</span>
<span id="cb312-3"><a href="#cb312-3" aria-hidden="true"></a>(reduce-right f ridentity &#39;(e1 e2 ...)) <span class="op">=</span></span>
<span id="cb312-4"><a href="#cb312-4" aria-hidden="true"></a>    (f e1 (reduce f ridentity (e2 ...)))</span></code></pre></div>
<p>… in other words, we compute <code>(fold-right f ridentity list)</code>.</p>
<div class="sourceCode" id="cb313"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb313-1"><a href="#cb313-1" aria-hidden="true"></a><span class="co">;; Append a bunch of lists together.</span></span>
<span id="cb313-2"><a href="#cb313-2" aria-hidden="true"></a><span class="co">;; I.e., (apply append list-of-lists)</span></span>
<span id="cb313-3"><a href="#cb313-3" aria-hidden="true"></a>(reduce-right <span class="kw">append</span> &#39;() list-of-lists)</span></code></pre></div>
<h2 id="unfold-p-f-g-seed-tail-gen"><code>(unfold p f g seed [tail-gen])</code></h2>
<p>TODO</p>
<h2 id="unfold-right-p-f-g-seed-tail-gen"><code>(unfold-right p f g seed [tail-gen])</code></h2>
<p>TODO</p>
<h2 id="map-proc-list1-..."><code>(map proc list1 ...)</code></h2>
<p><code>proc</code> is a procedure taking as many arguments as there are list arguments and returning a single value. map applies <code>proc</code> element-wise to the elements of the lists and returns a list of the results, in order. The dynamic order in which proc is applied to the elements of the lists is unspecified.</p>
<div class="sourceCode" id="cb314"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb314-1"><a href="#cb314-1" aria-hidden="true"></a>(map <span class="kw">cadr</span> &#39;((a b) (d e) (g h))) <span class="op">=&gt;</span>  (b e h)</span>
<span id="cb314-2"><a href="#cb314-2" aria-hidden="true"></a></span>
<span id="cb314-3"><a href="#cb314-3" aria-hidden="true"></a>(map (<span class="kw">lambda</span> (n) (<span class="kw">expt</span> n n))</span>
<span id="cb314-4"><a href="#cb314-4" aria-hidden="true"></a>     &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>))</span>
<span id="cb314-5"><a href="#cb314-5" aria-hidden="true"></a>    <span class="op">=&gt;</span>  (<span class="dv">1</span> <span class="dv">4</span> <span class="dv">27</span> <span class="dv">256</span> <span class="dv">3125</span>)</span>
<span id="cb314-6"><a href="#cb314-6" aria-hidden="true"></a></span>
<span id="cb314-7"><a href="#cb314-7" aria-hidden="true"></a>(map <span class="op">+</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) &#39;(<span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>)) <span class="op">=&gt;</span>  (<span class="dv">5</span> <span class="dv">7</span> <span class="dv">9</span>)</span>
<span id="cb314-8"><a href="#cb314-8" aria-hidden="true"></a></span>
<span id="cb314-9"><a href="#cb314-9" aria-hidden="true"></a>(<span class="kw">let</span> ((count <span class="dv">0</span>))</span>
<span id="cb314-10"><a href="#cb314-10" aria-hidden="true"></a>  (map (<span class="kw">lambda</span> (ignored)</span>
<span id="cb314-11"><a href="#cb314-11" aria-hidden="true"></a>         (set! count (<span class="op">+</span> count <span class="dv">1</span>))</span>
<span id="cb314-12"><a href="#cb314-12" aria-hidden="true"></a>         count)</span>
<span id="cb314-13"><a href="#cb314-13" aria-hidden="true"></a>       &#39;(a b))) <span class="op">=&gt;</span>  (<span class="dv">1</span> <span class="dv">2</span>) <span class="kw">or</span> (<span class="dv">2</span> <span class="dv">1</span>)</span></code></pre></div>
<p>At least one of the argument lists must be finite:</p>
<div class="sourceCode" id="cb315"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb315-1"><a href="#cb315-1" aria-hidden="true"></a>(map <span class="op">+</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span>) (circular-list <span class="dv">1</span> <span class="dv">0</span>)) <span class="co">;; =&gt; (4 1 5 1)</span></span></code></pre></div>
<h2 id="for-each-proc-clist1-..."><code>(for-each proc clist1 ...)</code></h2>
<p>The arguments to <code>for-each</code> are like the arguments to <code>map</code>, but <code>for-each</code> calls <code>proc</code> for its side effects rather than for its values. Unlike <code>map</code>, <code>for-each</code> is guaranteed to call <code>proc</code> on the elements of the lists in order from the first element(s) to the last, and the value returned by for-each is unspecified.</p>
<div class="sourceCode" id="cb316"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb316-1"><a href="#cb316-1" aria-hidden="true"></a>(<span class="kw">let</span> ((v (<span class="kw">make-vector</span> <span class="dv">5</span>)))</span>
<span id="cb316-2"><a href="#cb316-2" aria-hidden="true"></a>  (<span class="kw">for-each</span> (<span class="kw">lambda</span> (i)</span>
<span id="cb316-3"><a href="#cb316-3" aria-hidden="true"></a>              (<span class="kw">vector-set!</span> v i (* i i)))</span>
<span id="cb316-4"><a href="#cb316-4" aria-hidden="true"></a>            &#39;(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))</span>
<span id="cb316-5"><a href="#cb316-5" aria-hidden="true"></a>  v)  <span class="op">=&gt;</span>  #(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">9</span> <span class="dv">16</span>)</span></code></pre></div>
<p>At least one of the argument lists must be finite.</p>
<h2 id="append-map-f-list-..."><code>(append-map f list ...)</code></h2>
<h2 id="append-map-f-list-...-1"><code>(append-map! f list ...)</code></h2>
<p>Equivalent to:</p>
<div class="sourceCode" id="cb317"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb317-1"><a href="#cb317-1" aria-hidden="true"></a>(apply <span class="kw">append</span> (map f clist1 clist2 ...))</span></code></pre></div>
<p>And:</p>
<div class="sourceCode" id="cb318"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb318-1"><a href="#cb318-1" aria-hidden="true"></a>(apply append! (map f clist1 clist2 ...))</span></code></pre></div>
<p>Map <code>f</code> over the elements of the lists, just as in the <code>map</code> function. However, the results of the applications are appended together to make the final result. <code>append-map</code> uses <code>append</code> to append the results together; <code>append-map!</code> uses <code>append!</code>.</p>
<p>The dynamic order in which the various applications of <code>f</code> are made is not specified.</p>
<p>Example:</p>
<div class="sourceCode" id="cb319"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb319-1"><a href="#cb319-1" aria-hidden="true"></a>(append-map! (<span class="kw">lambda</span> (x) (<span class="kw">list</span> x (<span class="op">-</span> x))) &#39;(<span class="dv">1</span> <span class="dv">3</span> <span class="dv">8</span>)) <span class="co">;; =&gt; (1 -1 3 -3 8 -8)</span></span></code></pre></div>
<p>At least one of the list arguments must be finite.</p>
<h2 id="map-f-list1-..."><code>(map! f list1 ...)</code></h2>
<p>Linear-update variant of <code>map</code> – <code>map!</code> is allowed, but not required, to alter the cons cells of <code>list1</code> to construct the result list.</p>
<p>The dynamic order in which the various applications of <code>f</code> are made is not specified. In the n-ary case, <code>clist2</code>, <code>clist3</code>, … must have at least as many elements as <code>list1</code>.</p>
<h2 id="map-in-order-f-clist1-..."><code>(map-in-order f clist1 ...)</code></h2>
<p>A variant of the map procedure that guarantees to apply <code>f</code> across the elements of the <code>clisti</code> arguments in a left-to-right order. This is useful for mapping procedures that both have side effects and return useful values.</p>
<p>At least one of the list arguments must be finite.</p>
<h2 id="pair-for-each-f-clist1-..."><code>(pair-for-each f clist1 ...)</code></h2>
<p>Like for-each, but <code>f</code> is applied to successive sublists of the argument lists. That is, <code>f</code> is applied to the <code>cons</code> cells of the lists, rather than the lists’ elements. These applications occur in left-to-right order.</p>
<p>The f procedure may reliably apply <code>set-cdr!</code> to the pairs it is given without altering the sequence of execution.</p>
<div class="sourceCode" id="cb320"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb320-1"><a href="#cb320-1" aria-hidden="true"></a>(pair-for-each (<span class="kw">lambda</span> (pair) (<span class="kw">display</span> pair) (<span class="kw">newline</span>)) &#39;(a b c))</span>
<span id="cb320-2"><a href="#cb320-2" aria-hidden="true"></a> <span class="co">;; =&gt; (a b c)</span></span>
<span id="cb320-3"><a href="#cb320-3" aria-hidden="true"></a> <span class="co">;; =&gt; (b c)</span></span>
<span id="cb320-4"><a href="#cb320-4" aria-hidden="true"></a> <span class="co">;; =&gt; (c)</span></span></code></pre></div>
<p>At least one of the list arguments must be finite.</p>
<h2 id="filter-map-f-clist1-..."><code>(filter-map f clist1 ...)</code></h2>
<p>Like <code>map</code>, but only true values are saved.</p>
<div class="sourceCode" id="cb321"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb321-1"><a href="#cb321-1" aria-hidden="true"></a>(filter-map (<span class="kw">lambda</span> (x) (<span class="kw">and</span> (<span class="kw">number?</span> x) (* x x))) &#39;(a <span class="dv">1</span> b <span class="dv">3</span> c <span class="dv">7</span>))</span>
<span id="cb321-2"><a href="#cb321-2" aria-hidden="true"></a>    <span class="co">;; =&gt; (1 9 49)</span></span></code></pre></div>
<p>The dynamic order in which the various applications of <code>f</code> are made is not specified.</p>
<p>At least one of the list arguments must be finite.</p>
<h2 id="filter-pred-list"><code>(filter pred list)</code></h2>
<p>Return all the elements of list that satisfy predicate <code>pred</code>. The list is not disordered – elements that appear in the result list occur in the same order as they occur in the argument list. The returned list may share a common tail with the argument list. The dynamic order in which the various applications of <code>pred</code> are made is not specified.</p>
<div class="sourceCode" id="cb322"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb322-1"><a href="#cb322-1" aria-hidden="true"></a>(filter <span class="kw">even?</span> &#39;(<span class="dv">0</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">8</span> <span class="dv">43</span> <span class="dv">-4</span>)) <span class="op">=&gt;</span> (<span class="dv">0</span> <span class="dv">8</span> <span class="dv">8</span> <span class="dv">-4</span>)</span></code></pre></div>
<h2 id="partition-pred-list"><code>(partition pred list)</code></h2>
<p>Partitions the elements of list with predicate <code>pred</code>, and returns two values: the list of in-elements and the list of out-elements. The list is not disordered – elements occur in the result lists in the same order as they occur in the argument list. The dynamic order in which the various applications of pred are made is not specified. One of the returned lists may share a common tail with the argument list.</p>
<div class="sourceCode" id="cb323"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb323-1"><a href="#cb323-1" aria-hidden="true"></a>(partition <span class="kw">symbol?</span> &#39;(one <span class="dv">2</span> <span class="dv">3</span> four five <span class="dv">6</span>)) <span class="op">=&gt;</span></span>
<span id="cb323-2"><a href="#cb323-2" aria-hidden="true"></a>    (one four five)</span>
<span id="cb323-3"><a href="#cb323-3" aria-hidden="true"></a>    (<span class="dv">2</span> <span class="dv">3</span> <span class="dv">6</span>)</span></code></pre></div>
<h2 id="remove-pred-list"><code>(remove pred list)</code></h2>
<p>Returns <code>list</code> without the elements that satisfy predicate <code>pred</code>:</p>
<div class="sourceCode" id="cb324"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb324-1"><a href="#cb324-1" aria-hidden="true"></a>(<span class="kw">lambda</span> (pred <span class="kw">list</span>) (filter (<span class="kw">lambda</span> (x) (<span class="kw">not</span> (pred x))) <span class="kw">list</span>))</span></code></pre></div>
<p>The <code>list</code> is not disordered – elements that appear in the result list occur in the same order as they occur in the argument list. The returned list may share a common tail with the argument list. The dynamic order in which the various applications of <code>pred</code> are made is not specified.</p>
<div class="sourceCode" id="cb325"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb325-1"><a href="#cb325-1" aria-hidden="true"></a>(remove <span class="kw">even?</span> &#39;(<span class="dv">0</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">8</span> <span class="dv">43</span> <span class="dv">-4</span>)) <span class="op">=&gt;</span> (<span class="dv">7</span> <span class="dv">43</span>)</span></code></pre></div>
<h2 id="filter-pred-list-1"><code>(filter! pred list)</code></h2>
<h2 id="partition-pred-list-1"><code>(partition! pred list)</code></h2>
<h2 id="remove-pred-list-1"><code>(remove! pred list)</code></h2>
<p>Linear-update variants of <code>filter</code>, <code>partition</code> and <code>remove</code>. These procedures are allowed, but not required, to alter the cons cells in the argument list to construct the result lists.</p>
<h2 id="find-pred-clist"><code>(find pred clist)</code></h2>
<p>Return the first element of clist that satisfies predicate <code>pred</code>; false if no element does.</p>
<div class="sourceCode" id="cb326"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb326-1"><a href="#cb326-1" aria-hidden="true"></a>(find <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> <span class="dv">4</span></span></code></pre></div>
<p>Note that <code>find</code> has an ambiguity in its lookup semantics – if <code>find</code> returns <code>#f</code>, you cannot tell (in general) if it found a #f element that satisfied <code>pred</code>, or if it did not find any element at all. In many situations, this ambiguity cannot arise – either the list being searched is known not to contain any <code>#f</code> elements, or the list is guaranteed to have an element satisfying <code>pred</code>. However, in cases where this ambiguity can arise, you should use <code>find-tail</code> instead of find – <code>find-tail</code> has no such ambiguity.</p>
<h2 id="find-tail-pred-clist"><code>(find-tail pred clist)</code></h2>
<p>Return the first pair of <code>clist</code> whose <code>car</code> satisfies <code>pred</code>. If no pair does, return false.</p>
<p><code>find-tail</code> can be viewed as a general-predicate variant of the member function.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb327"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb327-1"><a href="#cb327-1" aria-hidden="true"></a>(find-tail <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">37</span> <span class="dv">-8</span> <span class="dv">-5</span> <span class="dv">0</span> <span class="dv">0</span>)) <span class="op">=&gt;</span> (-<span class="dv">8</span> <span class="dv">-5</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb327-2"><a href="#cb327-2" aria-hidden="true"></a>(find-tail <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">37</span> <span class="dv">-5</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb327-3"><a href="#cb327-3" aria-hidden="true"></a></span>
<span id="cb327-4"><a href="#cb327-4" aria-hidden="true"></a><span class="co">;; MEMBER X LIS:</span></span>
<span id="cb327-5"><a href="#cb327-5" aria-hidden="true"></a>(find-tail (<span class="kw">lambda</span> (elt) (<span class="kw">equal?</span> x elt)) lis)</span></code></pre></div>
<p>In the circular-list case, this procedure “rotates” the list.</p>
<p><code>find-tail</code> is essentially drop-while, where the sense of the predicate is inverted: <code>find-tail</code> searches until it finds an element satisfying the predicate; drop-while searches until it finds an element that doesn’t satisfy the predicate.</p>
<h2 id="take-while-pred-clist"><code>(take-while  pred clist)</code></h2>
<h2 id="take-while-pred-clist-1"><code>(take-while! pred clist)</code></h2>
<p>Returns the longest initial prefix of <code>clist</code> whose elements all satisfy the predicate <code>pred</code>.</p>
<p><code>take-while!</code> is the linear-update variant. It is allowed, but not required, to alter the argument list to produce the result.</p>
<div class="sourceCode" id="cb328"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb328-1"><a href="#cb328-1" aria-hidden="true"></a>(take-while <span class="kw">even?</span> &#39;(<span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> (<span class="dv">2</span> <span class="dv">18</span>)</span></code></pre></div>
<h2 id="drop-while-pred-clist"><code>(drop-while pred clist)</code></h2>
<p>Drops the longest initial prefix of <code>clist</code> whose elements all satisfy the predicate <code>pred</code>, and returns the rest of the list.</p>
<div class="sourceCode" id="cb329"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb329-1"><a href="#cb329-1" aria-hidden="true"></a>(drop-while <span class="kw">even?</span> &#39;(<span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> (<span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)</span></code></pre></div>
<p>The circular-list case may be viewed as “rotating” the list.</p>
<h2 id="span-pred-clist"><code>(span pred clist)</code></h2>
<h2 id="span-pred-list"><code>(span!  pred list)</code></h2>
<h2 id="break-pred-clist"><code>(break  pred clist)</code></h2>
<h2 id="break-pred-list">`(break! pred list)</h2>
<p>Span splits the list into the longest initial prefix whose elements all satisfy <code>pred</code>, and the remaining tail. Break inverts the sense of the predicate: the tail commences with the first element of the input list that satisfies the predicate.</p>
<p>In other words: <code>span</code> finds the intial span of elements satisfying <code>pred</code>, and break breaks the list at the first element satisfying <code>pred</code>.</p>
<p>Span is equivalent to:</p>
<div class="sourceCode" id="cb330"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb330-1"><a href="#cb330-1" aria-hidden="true"></a>(<span class="kw">values</span> (take-while pred clist)</span>
<span id="cb330-2"><a href="#cb330-2" aria-hidden="true"></a>        (drop-while pred clist))</span></code></pre></div>
<p><code>span!</code> and <code>break!</code> are the linear-update variants. They are allowed, but not required, to alter the argument list to produce the result.</p>
<div class="sourceCode" id="cb331"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb331-1"><a href="#cb331-1" aria-hidden="true"></a>(span <span class="kw">even?</span> &#39;(<span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span></span>
<span id="cb331-2"><a href="#cb331-2" aria-hidden="true"></a>      (<span class="dv">2</span> <span class="dv">18</span>)</span>
<span id="cb331-3"><a href="#cb331-3" aria-hidden="true"></a>      (<span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)</span>
<span id="cb331-4"><a href="#cb331-4" aria-hidden="true"></a></span>
<span id="cb331-5"><a href="#cb331-5" aria-hidden="true"></a>(<span class="kw">break</span> <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="op">=&gt;</span></span>
<span id="cb331-6"><a href="#cb331-6" aria-hidden="true"></a>      (<span class="dv">3</span> <span class="dv">1</span>)</span>
<span id="cb331-7"><a href="#cb331-7" aria-hidden="true"></a>      (<span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)</span></code></pre></div>
<h2 id="any-pred-clist1-..."><code>(any pred clist1 ...)</code></h2>
<p>Applies the predicate across the lists, returning true if the predicate returns true on any application.</p>
<p>If there are n list arguments <code>clist1 ... clistn</code>, then <code>pred</code> must be a procedure taking n arguments and returning a single value, interpreted as a boolean (that is, <code>#f</code> means false, and any other value means true).</p>
<p><code>any</code> applies <code>pred</code> to the first elements of the <code>clisti</code> parameters. If this application returns a true value, any immediately returns that value. Otherwise, it iterates, applying <code>pred</code> to the second elements of the <code>clisti</code> parameters, then the third, and so forth. The iteration stops when a true value is produced or one of the lists runs out of values; in the latter case, any returns <code>#f</code>. The application of pred to the last element of the lists is a tail call.</p>
<p>Note the difference between <code>find</code> and <code>any</code> – <code>find</code> returns the element that satisfied the predicate; <code>any</code> returns the true value that the predicate produced.</p>
<p>Like <code>every</code>, <code>any</code>’s name does not end with a question mark – this is to indicate that it does not return a simple boolean (#t or #f), but a general value.</p>
<div class="sourceCode" id="cb332"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb332-1"><a href="#cb332-1" aria-hidden="true"></a>(any <span class="kw">integer?</span> &#39;(a <span class="dv">3</span> b <span class="fl">2.7</span>))   <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb332-2"><a href="#cb332-2" aria-hidden="true"></a>(any <span class="kw">integer?</span> &#39;(a <span class="fl">3.1</span> b <span class="fl">2.7</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb332-3"><a href="#cb332-3" aria-hidden="true"></a>(any <span class="op">&lt;</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span>)</span>
<span id="cb332-4"><a href="#cb332-4" aria-hidden="true"></a>           &#39;(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">#t</span></span></code></pre></div>
<h2 id="every-pred-clist1-..."><code>(every pred clist1 ...)</code></h2>
<p>Applies the predicate across the lists, returning true if the predicate returns true on every application.</p>
<p>If there are n list arguments <code>clist1 ... clistn</code>, then <code>pred</code> must be a procedure taking n arguments and returning a single value, interpreted as a boolean (that is, #f means false, and any other value means true).</p>
<p><code>every</code> applies <code>pred</code> to the first elements of the <code>clisti</code> parameters. If this application returns false, every immediately returns false. Otherwise, it iterates, applying <code>pred</code> to the second elements of the <code>clisti</code> parameters, then the third, and so forth. The iteration stops when a false value is produced or one of the lists runs out of values. In the latter case, <code>every</code> returns the true value produced by its final application of pred. The application of <code>pred</code> to the last element of the lists is a tail call.</p>
<p>If one of the <code>clisti</code> has no elements, <code>every</code> simply returns #t.</p>
<p>Like <code>any</code>, <code>every</code>’s name does not end with a question mark – this is to indicate that it does not return a simple boolean (<code>#t</code> or <code>#f</code>), but a general value.</p>
<h2 id="list-index-pred-clist1-..."><code>(list-index pred clist1 ...)</code></h2>
<p>Return the index of the leftmost element that satisfies <code>pred</code>.</p>
<p>If there are n list arguments <code>clist1 ... clistn</code>, then <code>pred</code> must be a function taking n arguments and returning a single value, interpreted as a boolean (that is, <code>#f</code> means false, and any other value means true).</p>
<p><code>list-index</code> applies <code>pred</code> to the first elements of the <code>clisti</code> parameters. If this application returns true, <code>list-index</code> immediately returns zero. Otherwise, it iterates, applying <code>pred</code> to the second elements of the <code>clisti</code> parameters, then the third, and so forth. When it finds a tuple of list elements that cause <code>pred</code> to return true, it stops and returns the zero-based index of that position in the lists.</p>
<p>The iteration stops when one of the lists runs out of values; in this case, <code>list-index</code> returns <code>#f</code>.</p>
<div class="sourceCode" id="cb333"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb333-1"><a href="#cb333-1" aria-hidden="true"></a>(list-index <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> <span class="dv">2</span></span>
<span id="cb333-2"><a href="#cb333-2" aria-hidden="true"></a>(list-index <span class="op">&lt;</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) &#39;(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">1</span></span>
<span id="cb333-3"><a href="#cb333-3" aria-hidden="true"></a>(list-index <span class="op">=</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) &#39;(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="member-x-list"><code>(member x list [=])</code></h2>
<h2 id="memq-x-list"><code>(memq x list)</code></h2>
<h2 id="memv-x-list"><code>(memv x list)</code></h2>
<p>These procedures return the first sublist of <code>list</code> whose <code>car</code> is <code>x</code>, where the sublists of <code>list</code> are the non-empty lists returned by <code>(drop list i)</code> for <code>i</code> less than the length of list. If <code>x</code> does not occur in list, then <code>#f</code> is returned. <code>memq</code> uses <code>eq?</code> to compare <code>x</code> with the elements of list, while <code>memv</code> uses <code>eqv?</code>, and <code>member</code> uses <code>equal?</code>.</p>
<div class="sourceCode" id="cb334"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb334-1"><a href="#cb334-1" aria-hidden="true"></a>(<span class="kw">memq</span> &#39;a &#39;(a b c))          <span class="op">=&gt;</span>  (a b c)</span>
<span id="cb334-2"><a href="#cb334-2" aria-hidden="true"></a>(<span class="kw">memq</span> &#39;b &#39;(a b c))          <span class="op">=&gt;</span>  (b c)</span>
<span id="cb334-3"><a href="#cb334-3" aria-hidden="true"></a>(<span class="kw">memq</span> &#39;a &#39;(b c d))          <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb334-4"><a href="#cb334-4" aria-hidden="true"></a>(<span class="kw">memq</span> (<span class="kw">list</span> &#39;a) &#39;(b (a) c)) <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb334-5"><a href="#cb334-5" aria-hidden="true"></a>(<span class="kw">member</span> (<span class="kw">list</span> &#39;a) &#39;(b (a) c))         <span class="op">=&gt;</span>  ((a) c)</span>
<span id="cb334-6"><a href="#cb334-6" aria-hidden="true"></a>(<span class="kw">memq</span> <span class="dv">101</span> &#39;(<span class="dv">100</span> <span class="dv">101</span> <span class="dv">102</span>))   <span class="op">=&gt;</span>  *unspecified*</span>
<span id="cb334-7"><a href="#cb334-7" aria-hidden="true"></a>(<span class="kw">memv</span> <span class="dv">101</span> &#39;(<span class="dv">100</span> <span class="dv">101</span> <span class="dv">102</span>))   <span class="op">=&gt;</span>  (<span class="dv">101</span> <span class="dv">102</span>)</span></code></pre></div>
<p>The comparison procedure is used to compare the elements <code>ei</code> of list to the key <code>x</code> in this way:</p>
<div class="sourceCode" id="cb335"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb335-1"><a href="#cb335-1" aria-hidden="true"></a>(<span class="op">=</span> x ei) <span class="co">; list is (e1 ... en)</span></span></code></pre></div>
<p>That is, the first argument is always <code>x</code>, and the second argument is one of the list elements. Thus one can reliably find the first element of list that is greater than five with <code>(member 5 list &lt;)</code></p>
<p>Note that fully general list searching may be performed with the <code>find-tail</code> and <code>find</code> procedures, e.g.</p>
<div class="sourceCode" id="cb336"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb336-1"><a href="#cb336-1" aria-hidden="true"></a>(find-tail <span class="kw">even?</span> <span class="kw">list</span>) <span class="co">; Find the first elt with an even key.</span></span></code></pre></div>
<h2 id="delete-x-list"><code>(delete x list)</code></h2>
<h2 id="delete-x-list-1"><code>(delete! x list)</code></h2>
<p><code>delete</code> uses the comparison procedure <code>=</code>, which defaults to <code>equal?</code>, to find all elements of list that are equal to <code>x</code>, and deletes them from list. The dynamic order in which the various applications of <code>=</code> are made is not specified.</p>
<p>The list is not disordered – elements that appear in the result list occur in the same order as they occur in the argument list. The result may share a common tail with the argument list.</p>
<p>Note that fully general element deletion can be performed with the <code>remove</code> and <code>remove!</code> procedures, e.g.:</p>
<div class="sourceCode" id="cb337"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb337-1"><a href="#cb337-1" aria-hidden="true"></a><span class="co">;; Delete all the even elements from LIS:</span></span>
<span id="cb337-2"><a href="#cb337-2" aria-hidden="true"></a>(remove <span class="kw">even?</span> lis)</span></code></pre></div>
<p>The comparison procedure is used in this way: <code>(= x ei)</code>. That is, <code>x</code> is always the first argument, and a list element is always the second argument. The comparison procedure will be used to compare each element of list exactly once; the order in which it is applied to the various <code>ei</code> is not specified. Thus, one can reliably remove all the numbers greater than five from a list with <code>(delete 5 list &lt;)</code>.</p>
<p><code>delete!</code> is the linear-update variant of <code>delete</code>. It is allowed, but not required, to alter the cons cells in its argument list to construct the result.</p>
<h2 id="delete-duplicates-list"><code>(delete-duplicates  list [=])</code></h2>
<h2 id="delete-duplicates-list-1"><code>(delete-duplicates! list [=])</code></h2>
<p><code>delete-duplicates</code> removes duplicate elements from the list argument. If there are multiple equal elements in the argument list, the result list only contains the first or leftmost of these elements in the result. The order of these surviving elements is the same as in the original list – delete-duplicates does not disorder the list (hence it is useful for “cleaning up” association lists).</p>
<p>The <code>=</code> parameter is used to compare the elements of the list; it defaults to equal?. If x comes before y in list, then the comparison is performed (= x y). The comparison procedure will be used to compare each pair of elements in list no more than once; the order in which it is applied to the various pairs is not specified.</p>
<p>Implementations of <code>delete-duplicates</code> are allowed to share common tails between argument and result lists – for example, if the list argument contains only unique elements, it may simply return exactly this list.</p>
<p>Be aware that, in general, delete-duplicates runs in time O(n2) for n-element lists. Uniquifying long lists can be accomplished in O(n lg n) time by sorting the list to bring equal elements together, then using a linear-time algorithm to remove equal elements. Alternatively, one can use algorithms based on element-marking, with linear-time results.</p>
<p><code>delete-duplicates!</code> is the linear-update variant of <code>delete-duplicates</code>; it is allowed, but not required, to alter the cons cells in its argument list to construct the result.</p>
<div class="sourceCode" id="cb338"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb338-1"><a href="#cb338-1" aria-hidden="true"></a>(delete-duplicates &#39;(a b a c a b c z)) <span class="op">=&gt;</span> (a b c z)</span>
<span id="cb338-2"><a href="#cb338-2" aria-hidden="true"></a></span>
<span id="cb338-3"><a href="#cb338-3" aria-hidden="true"></a><span class="co">;; Clean up an alist:</span></span>
<span id="cb338-4"><a href="#cb338-4" aria-hidden="true"></a>(delete-duplicates &#39;((a . <span class="dv">3</span>) (b . <span class="dv">7</span>) (a . <span class="dv">9</span>) (c . <span class="dv">1</span>))</span>
<span id="cb338-5"><a href="#cb338-5" aria-hidden="true"></a>                   (<span class="kw">lambda</span> (x y) (<span class="kw">eq?</span> (<span class="kw">car</span> x) (<span class="kw">car</span> y))))</span>
<span id="cb338-6"><a href="#cb338-6" aria-hidden="true"></a><span class="co">;;  =&gt; ((a . 3) (b . 7) (c . 1))</span></span></code></pre></div>
<h2 id="assoc-key-alist"><code>(assoc key alist [=])</code></h2>
<h2 id="assq-key-alist"><code>(assq key alist)</code></h2>
<h2 id="assv-key-alist"><code>(assv key alist)</code></h2>
<p><code>alist</code> must be an association list – a list of pairs. These procedures find the first pair in <code>alist</code> whose <code>car</code> field is <code>key</code>, and returns that pair. If no pair in <code>alist</code> has <code>key</code> as its <code>car</code>, then <code>#f</code> is returned. <code>assq</code> uses <code>eq?</code> to compare <code>key</code> with the <code>car</code> fields of the pairs in <code>alist</code>, while <code>assv</code> uses <code>eqv?</code> and <code>assoc</code> uses <code>equal?</code>.</p>
<div class="sourceCode" id="cb339"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb339-1"><a href="#cb339-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> e </span>&#39;((a <span class="dv">1</span>) (b <span class="dv">2</span>) (c <span class="dv">3</span>)))</span>
<span id="cb339-2"><a href="#cb339-2" aria-hidden="true"></a>(<span class="kw">assq</span> &#39;a e)                            <span class="op">=&gt;</span>  (a <span class="dv">1</span>)</span>
<span id="cb339-3"><a href="#cb339-3" aria-hidden="true"></a>(<span class="kw">assq</span> &#39;b e)                            <span class="op">=&gt;</span>  (b <span class="dv">2</span>)</span>
<span id="cb339-4"><a href="#cb339-4" aria-hidden="true"></a>(<span class="kw">assq</span> &#39;d e)                            <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb339-5"><a href="#cb339-5" aria-hidden="true"></a>(<span class="kw">assq</span> (<span class="kw">list</span> &#39;a) &#39;(((a)) ((b)) ((c))))  <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb339-6"><a href="#cb339-6" aria-hidden="true"></a>(<span class="kw">assoc</span> (<span class="kw">list</span> &#39;a) &#39;(((a)) ((b)) ((c)))) <span class="op">=&gt;</span>  ((a))</span>
<span id="cb339-7"><a href="#cb339-7" aria-hidden="true"></a>(<span class="kw">assq</span> <span class="dv">5</span> &#39;((<span class="dv">2</span> <span class="dv">3</span>) (<span class="dv">5</span> <span class="dv">7</span>) (<span class="dv">11</span> <span class="dv">13</span>)))    <span class="op">=&gt;</span>  *unspecified*</span>
<span id="cb339-8"><a href="#cb339-8" aria-hidden="true"></a>(<span class="kw">assv</span> <span class="dv">5</span> &#39;((<span class="dv">2</span> <span class="dv">3</span>) (<span class="dv">5</span> <span class="dv">7</span>) (<span class="dv">11</span> <span class="dv">13</span>)))    <span class="op">=&gt;</span>  (<span class="dv">5</span> <span class="dv">7</span>)</span></code></pre></div>
<p>The comparison procedure is used to compare the elements <code>ei</code> of list to the <code>key</code> parameter in this way:</p>
<div class="sourceCode" id="cb340"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb340-1"><a href="#cb340-1" aria-hidden="true"></a>(<span class="op">=</span> key (<span class="kw">car</span> ei)) <span class="co">; list is (E1 ... En)</span></span></code></pre></div>
<p>That is, the first argument is always <code>key</code>, and the second argument is one of the list elements. Thus one can reliably find the first entry of alist whose key is greater than five with <code>(assoc 5 alist &lt;)</code></p>
<p>Note that fully general <code>alist</code> searching may be performed with the <code>find-tail</code> and <code>find</code> procedures, e.g.</p>
<div class="sourceCode" id="cb341"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb341-1"><a href="#cb341-1" aria-hidden="true"></a><span class="co">;; Look up the first association in alist with an even key:</span></span>
<span id="cb341-2"><a href="#cb341-2" aria-hidden="true"></a>(find (<span class="kw">lambda</span> (a) (<span class="kw">even?</span> (<span class="kw">car</span> a))) alist)</span></code></pre></div>
<h2 id="alist-cons-key-datum-alist"><code>(alist-cons key datum alist)</code></h2>
<div class="sourceCode" id="cb342"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb342-1"><a href="#cb342-1" aria-hidden="true"></a>(<span class="kw">lambda</span> (key datum alist) (<span class="kw">cons</span> (<span class="kw">cons</span> key datum) alist))</span></code></pre></div>
<p><code>cons</code> a new entry mapping <code>key</code> to <code>datum</code> onto <code>alist</code>.</p>
<h2 id="alist-copy-alist"><code>(alist-copy alist)</code></h2>
<p>Make a fresh copy of <code>alist</code>. This means copying each pair that forms an association as well as the spine of the list, i.e.</p>
<div class="sourceCode" id="cb343"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb343-1"><a href="#cb343-1" aria-hidden="true"></a>(<span class="kw">lambda</span> (a) (map (<span class="kw">lambda</span> (elt) (<span class="kw">cons</span> (<span class="kw">car</span> elt) (<span class="kw">cdr</span> elt))) a))</span></code></pre></div>
<h2 id="alist-delete-key-alist"><code>(alist-delete  key alist [=])</code></h2>
<h2 id="alist-delete-key-alist-1"><code>(alist-delete! key alist [=])</code></h2>
<p><code>alist-delete</code> deletes all associations from alist with the given key, using key-comparison procedure <code>=</code>, which defaults to equal?. The dynamic order in which the various applications of = are made is not specified.</p>
<p>Return values may share common tails with the alist argument. The alist is not disordered – elements that appear in the result alist occur in the same order as they occur in the argument alist.</p>
<p>The comparison procedure is used to compare the element keys ki of alist’s entries to the key parameter in this way: (= key ki). Thus, one can reliably remove all entries of alist whose key is greater than five with (alist-delete 5 alist &lt;)</p>
<p>alist-delete! is the linear-update variant of alist-delete. It is allowed, but not required, to alter cons cells from the alist parameter to construct the result.</p>
<h2 id="lset-list1-..."><code>(lset&lt;= = list1 ...)</code></h2>
<p>Returns true iff every listi is a subset of listi+1, using = for the element-equality procedure. List A is a subset of list B if every element in A is equal to some element of B. When performing an element comparison, the = procedure’s first argument is an element of A; its second, an element of B.</p>
<div class="sourceCode" id="cb344"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb344-1"><a href="#cb344-1" aria-hidden="true"></a>(lset&lt;= <span class="kw">eq?</span> &#39;(a) &#39;(a b a) &#39;(a b c c)) <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb344-2"><a href="#cb344-2" aria-hidden="true"></a></span>
<span id="cb344-3"><a href="#cb344-3" aria-hidden="true"></a>(lset&lt;= <span class="kw">eq?</span>) <span class="op">=&gt;</span> <span class="dv">#t</span>             <span class="co">; Trivial cases</span></span>
<span id="cb344-4"><a href="#cb344-4" aria-hidden="true"></a>(lset&lt;= <span class="kw">eq?</span> &#39;(a)) <span class="op">=&gt;</span> <span class="dv">#t</span></span></code></pre></div>
<h2 id="lset-list1-...-1"><code>(lset= = list1 ...)</code></h2>
<p>Returns true iff every listi is set-equal to listi+1, using = for the element-equality procedure. “Set-equal” simply means that listi is a subset of listi+1, and listi+1 is a subset of listi. The = procedure’s first argument is an element of listi; its second is an element of listi+1.</p>
<div class="sourceCode" id="cb345"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb345-1"><a href="#cb345-1" aria-hidden="true"></a>(lset= <span class="kw">eq?</span> &#39;(b e a) &#39;(a e b) &#39;(e e b a)) <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb345-2"><a href="#cb345-2" aria-hidden="true"></a></span>
<span id="cb345-3"><a href="#cb345-3" aria-hidden="true"></a>(lset= <span class="kw">eq?</span>) <span class="op">=&gt;</span> <span class="dv">#t</span>               <span class="co">; Trivial cases</span></span>
<span id="cb345-4"><a href="#cb345-4" aria-hidden="true"></a>(lset= <span class="kw">eq?</span> &#39;(a)) <span class="op">=&gt;</span> <span class="dv">#t</span></span></code></pre></div>
<h2 id="lset-adjoin-list-elt1-..."><code>(lset-adjoin = list elt1 ...)</code></h2>
<p>Adds the elti elements not already in the list parameter to the result list. The result shares a common tail with the list parameter. The new elements are added to the front of the list, but no guarantees are made about their order. The = parameter is an equality procedure used to determine if an elti is already a member of list. Its first argument is an element of list; its second is one of the elti.</p>
<p>The list parameter is always a suffix of the result – even if the list parameter contains repeated elements, these are not reduced.</p>
<div class="sourceCode" id="cb346"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb346-1"><a href="#cb346-1" aria-hidden="true"></a>(lset-adjoin <span class="kw">eq?</span> &#39;(a b c d c e) &#39;a &#39;e &#39;i &#39;o &#39;u) <span class="op">=&gt;</span> (u o i a b c d c e)</span></code></pre></div>
<h2 id="lset-union-list1-..."><code>(lset-union = list1 ...)</code></h2>
<p>Returns the union of the lists, using = for the element-equality procedure.</p>
<p>The union of lists A and B is constructed as follows:</p>
<ul>
<li>If A is the empty list, the answer is B (or a copy of B).</li>
<li>Otherwise, the result is initialised to be list A (or a copy of A).</li>
<li>Proceed through the elements of list B in a left-to-right order. If b is such an element of B, compare every element r of the current result list to b: (= r b). If all comparisons fail, b is consed onto the front of the result.</li>
</ul>
<p>However, there is no guarantee that = will be applied to every pair of arguments from A and B. In particular, if A is eq? to B, the operation may immediately terminate.</p>
<p>In the n-ary case, the two-argument list-union operation is simply folded across the argument lists.</p>
<div class="sourceCode" id="cb347"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb347-1"><a href="#cb347-1" aria-hidden="true"></a>(lset-union <span class="kw">eq?</span> &#39;(a b c d e) &#39;(a e i o u)) <span class="op">=&gt;</span></span>
<span id="cb347-2"><a href="#cb347-2" aria-hidden="true"></a>        (u o i a b c d e)</span>
<span id="cb347-3"><a href="#cb347-3" aria-hidden="true"></a></span>
<span id="cb347-4"><a href="#cb347-4" aria-hidden="true"></a><span class="co">;; Repeated elements in LIST1 are preserved.</span></span>
<span id="cb347-5"><a href="#cb347-5" aria-hidden="true"></a>(lset-union <span class="kw">eq?</span> &#39;(a a c) &#39;(x a x)) <span class="op">=&gt;</span> (x a a c)</span>
<span id="cb347-6"><a href="#cb347-6" aria-hidden="true"></a></span>
<span id="cb347-7"><a href="#cb347-7" aria-hidden="true"></a><span class="co">;; Trivial cases</span></span>
<span id="cb347-8"><a href="#cb347-8" aria-hidden="true"></a>(lset-union <span class="kw">eq?</span>) <span class="op">=&gt;</span> ()</span>
<span id="cb347-9"><a href="#cb347-9" aria-hidden="true"></a>(lset-union <span class="kw">eq?</span> &#39;(a b c)) <span class="op">=&gt;</span> (a b c)</span></code></pre></div>
<h2 id="lset-intersection-list1-list2-..."><code>(lset-intersection = list1 list2 ...)</code></h2>
<p>Returns the intersection of the lists, using = for the element-equality procedure.</p>
<p>The intersection of lists A and B is comprised of every element of A that is = to some element of B: (= a b), for a in A, and b in B. Note this implies that an element which appears in B and multiple times in list A will also appear multiple times in the result.</p>
<p>The order in which elements appear in the result is the same as they appear in list1 – that is, lset-intersection essentially filters list1, without disarranging element order. The result may share a common tail with list1.</p>
<p>In the n-ary case, the two-argument list-intersection operation is simply folded across the argument lists. However, the dynamic order in which the applications of = are made is not specified. The procedure may check an element of list1 for membership in every other list before proceeding to consider the next element of list1, or it may completely intersect list1 and list2 before proceeding to list3, or it may go about its work in some third order.</p>
<div class="sourceCode" id="cb348"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb348-1"><a href="#cb348-1" aria-hidden="true"></a>(lset-intersection <span class="kw">eq?</span> &#39;(a b c d e) &#39;(a e i o u)) <span class="op">=&gt;</span> (a e)</span>
<span id="cb348-2"><a href="#cb348-2" aria-hidden="true"></a></span>
<span id="cb348-3"><a href="#cb348-3" aria-hidden="true"></a><span class="co">;; Repeated elements in LIST1 are preserved.</span></span>
<span id="cb348-4"><a href="#cb348-4" aria-hidden="true"></a>(lset-intersection <span class="kw">eq?</span> &#39;(a x y a) &#39;(x a x z)) <span class="op">=&gt;</span> &#39;(a x a)</span>
<span id="cb348-5"><a href="#cb348-5" aria-hidden="true"></a></span>
<span id="cb348-6"><a href="#cb348-6" aria-hidden="true"></a>(lset-intersection <span class="kw">eq?</span> &#39;(a b c)) <span class="op">=&gt;</span> (a b c)     <span class="co">; Trivial case</span></span></code></pre></div>
<h2 id="lset-difference-list1-list2-..."><code>(lset-difference = list1 list2 ...)</code></h2>
<p>Returns the difference of the lists, using = for the element-equality procedure – all the elements of list1 that are not = to any element from one of the other listi parameters.</p>
<p>The = procedure’s first argument is always an element of list1; its second is an element of one of the other listi. Elements that are repeated multiple times in the list1 parameter will occur multiple times in the result. The order in which elements appear in the result is the same as they appear in list1 – that is, lset-difference essentially filters list1, without disarranging element order. The result may share a common tail with list1. The dynamic order in which the applications of = are made is not specified. The procedure may check an element of list1 for membership in every other list before proceeding to consider the next element of list1, or it may completely compute the difference of list1 and list2 before proceeding to list3, or it may go about its work in some third order.</p>
<div class="sourceCode" id="cb349"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb349-1"><a href="#cb349-1" aria-hidden="true"></a>(lset-difference <span class="kw">eq?</span> &#39;(a b c d e) &#39;(a e i o u)) <span class="op">=&gt;</span> (b c d)</span>
<span id="cb349-2"><a href="#cb349-2" aria-hidden="true"></a></span>
<span id="cb349-3"><a href="#cb349-3" aria-hidden="true"></a>(lset-difference <span class="kw">eq?</span> &#39;(a b c)) <span class="op">=&gt;</span> (a b c) <span class="co">; Trivial case</span></span></code></pre></div>
<h2 id="lset-xor-list1">`(lset-xor = list1 …)</h2>
<p>Returns the exclusive-or of the sets, using = for the element-equality procedure. If there are exactly two lists, this is all the elements that appear in exactly one of the two lists. The operation is associative, and thus extends to the n-ary case – the elements that appear in an odd number of the lists. The result may share a common tail with any of the listi parameters.</p>
<p>More precisely, for two lists A and B, A xor B is a list of:</p>
<ul>
<li>every element a of A such that there is no element b of B such that (= a b), and</li>
<li>every element b of B such that there is no element a of A such that (= b a).</li>
</ul>
<p>However, an implementation is allowed to assume that = is symmetric – that is, that</p>
<div class="sourceCode" id="cb350"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb350-1"><a href="#cb350-1" aria-hidden="true"></a>(<span class="op">=</span> a b) <span class="op">=&gt;</span> (<span class="op">=</span> b a).</span></code></pre></div>
<p>This means, for example, that if a comparison (= a b) produces true for some a in A and b in B, both a and b may be removed from inclusion in the result.</p>
<p>In the n-ary case, the binary-xor operation is simply folded across the lists.</p>
<div class="sourceCode" id="cb351"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb351-1"><a href="#cb351-1" aria-hidden="true"></a>(lset-xor <span class="kw">eq?</span> &#39;(a b c d e) &#39;(a e i o u)) <span class="op">=&gt;</span> (d c b i o u)</span>
<span id="cb351-2"><a href="#cb351-2" aria-hidden="true"></a></span>
<span id="cb351-3"><a href="#cb351-3" aria-hidden="true"></a><span class="co">;; Trivial cases.</span></span>
<span id="cb351-4"><a href="#cb351-4" aria-hidden="true"></a>(lset-xor <span class="kw">eq?</span>) <span class="op">=&gt;</span> ()</span>
<span id="cb351-5"><a href="#cb351-5" aria-hidden="true"></a>(lset-xor <span class="kw">eq?</span> &#39;(a b c d e)) <span class="op">=&gt;</span> (a b c d e)</span></code></pre></div>
<h2 id="lset-diffintersection-list1-list2-..."><code>(lset-diff+intersection = list1 list2 ...)</code></h2>
<p>Returns two values – the difference and the intersection of the lists. Is equivalent to:</p>
<pre><code>(values (lset-difference = list1 list2 ...)
        (lset-intersection = list1
                             (lset-union = list2 ...)))</code></pre>
<p>But can be implemented more efficiently.</p>
<p>The = procedure’s first argument is an element of list1; its second is an element of one of the other listi.</p>
<p>Either of the answer lists may share a common tail with list1. This operation essentially partitions list1.</p>
<h2 id="lset-union-list1-...-1"><code>(lset-union! list1 ...)</code></h2>
<h2 id="lset-intersection-list1-..."><code>(lset-intersection! list1 ...)</code></h2>
<h2 id="lset-difference-list1-..."><code>(lset-difference! list1 ...)</code></h2>
<h2 id="lset-xor-list1-..."><code>(lset-xor! list1 ...)</code></h2>
<h2 id="lset-diffintersection-list1-..."><code>(lset-diff+intersection! list1 ...)</code></h2>
<p>These are linear-update variants. They are allowed, but not required, to use the cons cells in their first list parameter to construct their answer. lset-union! is permitted to recycle cons cells from any of its list arguments.</p>
<h2 id="set-car-pair-object"><code>(set-car! pair object)</code></h2>
<h2 id="set-cdr-pair-object"><code>(set-cdr! pair object)</code></h2>
<p>These procedures store object in the car and cdr field of pair, respectively. The value returned is unspecified.</p>
<div class="sourceCode" id="cb353"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb353-1"><a href="#cb353-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(f) (<span class="kw">list</span> &#39;not-a-constant-list))</span>
<span id="cb353-2"><a href="#cb353-2" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(g) &#39;(constant-list))</span>
<span id="cb353-3"><a href="#cb353-3" aria-hidden="true"></a>(<span class="kw">set-car!</span> (f) <span class="dv">3</span>) <span class="op">=&gt;</span>  *unspecified*</span>
<span id="cb353-4"><a href="#cb353-4" aria-hidden="true"></a>(<span class="kw">set-car!</span> (g) <span class="dv">3</span>) <span class="op">=&gt;</span>  *error*</span></code></pre></div>
<h1 id="scheme-inexact"><code>(scheme inexact)</code></h1>
<h2 id="acos-z"><code>(acos z)</code></h2>
<p>TODO</p>
<h2 id="asin-z"><code>(asin z)</code></h2>
<p>TODO</p>
<h2 id="atan-z"><code>(atan z)</code></h2>
<p>TODO</p>
<h2 id="cos-z"><code>(cos z)</code></h2>
<p>TODO</p>
<h2 id="exp-z-t"><code>(exp z t)</code></h2>
<p>TODO</p>
<h2 id="finite-z"><code>(finite? z)</code></h2>
<p>TODO</p>
<h2 id="infinite-z"><code>(infinite? z)</code></h2>
<p>TODO</p>
<h2 id="log-z"><code>(log z)</code></h2>
<p>TODO</p>
<h2 id="nan-z"><code>(nan? z)</code></h2>
<p>TODO</p>
<h2 id="sin">sin</h2>
<p>TODO</p>
<h2 id="sqrt">sqrt</h2>
<p>TODO</p>
<h2 id="tan">tan</h2>
<p>TODO # <code>(scheme set)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-113/">SRFI-113</a>.</p>
<p>Sets and bags (also known as multisets) are unordered collections that can contain any Scheme object. Sets enforce the constraint that no two elements can be the same in the sense of the set’s associated equality predicate; bags do not.</p>
<h2 id="set-comparator-element-..."><code>(set comparator element ... )</code></h2>
<p>Returns a newly allocated empty set. The comparator argument is a SRFI 114 comparator, which is used to control and distinguish the elements of the set. The elements are used to initialize the set.</p>
<h2 id="set-unfold-comparator-stop-mapper-successor-seed"><code>(set-unfold comparator stop? mapper successor seed)</code></h2>
<p>Create a newly allocated set as if by set using comparator. If the result of applying the predicate stop? to seed is true, return the set. Otherwise, apply the procedure mapper to seed. The value that mapper returns is added to the set. Then get a new seed by applying the procedure successor to seed, and repeat this algorithm. Predicates</p>
<h2 id="set-obj"><code>(set? obj)</code></h2>
<p>Returns #t if obj is a set, and #f otherwise.</p>
<h2 id="set-contains-set-element"><code>(set-contains? set element)</code></h2>
<p>Returns #t if element is a member of set and #f otherwise.</p>
<h2 id="set-empty-set"><code>(set-empty? set)</code></h2>
<p>Returns #t if set has no elements and #f otherwise.</p>
<h2 id="set-disjoint-set1-set2"><code>(set-disjoint? set1 set2)</code></h2>
<p>Returns #t if set1 and set2 have no elements in common and #f otherwise.</p>
<h2 id="set-member-set-element-default"><code>(set-member set element default)</code></h2>
<p>Returns the element of set that is equal, in the sense of set’s equality predicate, to element. If element is not a member of set, default is returned.</p>
<h2 id="set-element-comparator-set"><code>(set-element-comparator set)</code></h2>
<p>Returns the comparator used to compare the elements of set.</p>
<h2 id="set-adjoin-set-element-..."><code>(set-adjoin set element ...)</code></h2>
<p>The set-adjoin procedure returns a newly allocated set that uses the same comparator as set and contains all the values of set, and in addition each element unless it is already equal (in the sense of the comparator) to one of the existing or newly added members. It is an error to add an element to set that does not return #t when passed to the type test procedure of the comparator.</p>
<h2 id="set-adjoin-set-element-...-1"><code>(set-adjoin! set element ...)</code></h2>
<p>The set-adjoin! procedure is the same as set-adjoin, except that it is permitted to mutate and return the set argument rather than allocating a new set.</p>
<h2 id="set-replace-set-element"><code>(set-replace set element)</code></h2>
<p>The set-replace procedure returns a newly allocated set that uses the same comparator as set and contains all the values of set except as follows: If element is equal (in the sense of set’s comparator) to an existing member of set, then that member is omitted and replaced by element. If there is no such element in set, then set is returned unchanged.</p>
<h2 id="set-replace-set-element-1"><code>(set-replace! set element)</code></h2>
<p>The set-replace! procedure is the same asset-replace, except that it is permitted to mutate and return the set argument rather than allocating a new set.</p>
<h2 id="set-delete-set-element-..."><code>(set-delete set element ...)</code></h2>
<h2 id="set-delete-set-element-...-1"><code>(set-delete! set element ...)</code></h2>
<h2 id="set-delete-all-set-element-list"><code>(set-delete-all set element-list)</code></h2>
<h2 id="set-delete-all-set-element-list-1"><code>(set-delete-all! set element-list)</code></h2>
<p>The set-delete procedure returns a newly allocated set containing all the values of set except for any that are equal (in the sense of set’s comparator) to one or more of the elements. Any element that is not equal to some member of the set is ignored.</p>
<p>The set-delete! procedure is the same as set-delete, except that it is permitted to mutate and return the set argument rather than allocating a new set.</p>
<p>The set-delete-all and set-delete-all! procedures are the same as set-delete and set-delete!, except that they accept a single argument which is a list of elements to be deleted.</p>
<h2 id="set-search-set-element-failure-success"><code>(set-search! set element failure success)</code></h2>
<p>The set is searched for element. If it is not found, then the failure procedure is tail-called with two continuation arguments, insert and ignore, and is expected to tail-call one of them. If element is found, then the success procedure is tail-called with the matching element of set and two continuations, update and remove, and is expected to tail-call one of them.</p>
<p>The effects of the continuations are as follows (where obj is any Scheme object):</p>
<ul>
<li><p>Invoking (insert obj) causes element to be inserted into set.</p></li>
<li><p>Invoking (ignore obj) causes set to remain unchanged.</p></li>
<li><p>Invoking (update new-element obj) causes new-element to be inserted into set in place of element.</p></li>
<li><p>Invoking (remove obj) causes the matching element of set to be removed from it.</p></li>
</ul>
<p>In all cases, two values are returned: the possibly updated set and obj.</p>
<h2 id="set-size-set"><code>(set-size set)</code></h2>
<p>Returns the number of elements in set as an exact integer.</p>
<h2 id="set-find-predicate-set-failure"><code>(set-find predicate set failure)</code></h2>
<p>Returns an arbitrarily chosen element of set that satisfies predicate, or the result of invoking failure with no arguments if there is none.</p>
<h2 id="set-count-predicate-set"><code>(set-count predicate set)</code></h2>
<p>Returns the number of elements of set that satisfy predicate as an exact integer.</p>
<h2 id="set-any-predicate-set"><code>(set-any? predicate set)</code></h2>
<p>Returns #t if any element of set satisfies predicate, or #f otherwise. Note that this differs from the SRFI 1 analogue because it does not return an element of the set.</p>
<h2 id="set-every-predicate-set"><code>(set-every? predicate set)</code></h2>
<p>Returns #t if every element of set satisfies predicate, or #f otherwise. Note that this differs from the SRFI 1 analogue because it does not return an element of the set.</p>
<h2 id="set-map-comparator-proc-set"><code>(set-map comparator proc set)</code></h2>
<p>Applies proc to each element of set in arbitrary order and returns a newly allocated set, created as if by (set comparator), which contains the results of the applications. For example:</p>
<div class="sourceCode" id="cb354"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb354-1"><a href="#cb354-1" aria-hidden="true"></a>        (set-map string-ci-comparator <span class="kw">symbol-&gt;string</span> (set <span class="kw">eq?</span> &#39;foo &#39;bar &#39;baz))</span>
<span id="cb354-2"><a href="#cb354-2" aria-hidden="true"></a>             <span class="op">=&gt;</span> (set string-ci-comparator <span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span> <span class="st">&quot;baz&quot;</span>)</span></code></pre></div>
<p>Note that, when proc defines a mapping that is not 1:1, some of the mapped objects may be equivalent in the sense of comparator’s equality predicate, and in this case duplicate elements are omitted as in the set constructor. For example:</p>
<div class="sourceCode" id="cb355"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb355-1"><a href="#cb355-1" aria-hidden="true"></a>(set-map (<span class="kw">lambda</span> (x) (<span class="kw">quotient</span> x <span class="dv">2</span>))</span>
<span id="cb355-2"><a href="#cb355-2" aria-hidden="true"></a>         integer-comparator</span>
<span id="cb355-3"><a href="#cb355-3" aria-hidden="true"></a>         (set integer-comparator <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>))</span>
<span id="cb355-4"><a href="#cb355-4" aria-hidden="true"></a> <span class="op">=&gt;</span> (set integer-comparator <span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span>)</span></code></pre></div>
<p>If the elements are the same in the sense of eqv?, it is unpredictable which one will be preserved in the result.</p>
<h2 id="set-for-each-proc-set"><code>(set-for-each proc set)</code></h2>
<p>Applies proc to set in arbitrary order, discarding the returned values. Returns an unspecified result.</p>
<h2 id="set-fold-proc-nil-set"><code>(set-fold proc nil set)</code></h2>
<p>Invokes proc on each member of set in arbitrary order, passing the result of the previous invocation as a second argument. For the first invocation, nil is used as the second argument. Returns the result of the last invocation, or nil if there was no invocation.</p>
<h2 id="set-filter-predicate-set"><code>(set-filter predicate set)</code></h2>
<p>Returns a newly allocated set with the same comparator as set, containing just the elements of set that satisfy predicate.</p>
<h2 id="set-filter-predicate-set-1"><code>(set-filter! predicate set)</code></h2>
<p>A linear update procedure that returns a set containing just the elements of set that satisfy predicate.</p>
<h2 id="set-remove-predicate-set"><code>(set-remove predicate set)</code></h2>
<p>Returns a newly allocated set with the same comparator as set, containing just the elements of set that do not satisfy predicate.</p>
<h2 id="set-remove-predicate-set-1"><code>(set-remove! predicate set)</code></h2>
<p>A linear update procedure that returns a set containing just the elements of set that do not satisfy predicate.</p>
<h2 id="set-partition-predicate-set"><code>(set-partition predicate set)</code></h2>
<p>Returns two values: a newly allocated set with the same comparator as set that contains just the elements of set that satisfy predicate, and another newly allocated set, also with the same comparator, that contains just the elements of set that do not satisfy predicate.</p>
<h2 id="set-partition-predicate-set-1"><code>(set-partition! predicate set)</code></h2>
<p>A linear update procedure that returns two sets containing the elements of set that do and do not, respectively, not satisfy predicate.</p>
<h2 id="set-copy-set"><code>(set-copy set)</code></h2>
<p>Returns a newly allocated set containing the elements of set, and using the same comparator.</p>
<h2 id="set-list-set"><code>(set-&gt;list set)</code></h2>
<p>Returns a newly allocated list containing the members of set in unspecified order.</p>
<h2 id="list-set-comparator-list"><code>(list-&gt;set comparator list)</code></h2>
<p>Returns a newly allocated set, created as if by set using comparator, that contains the elements of list. Duplicate elements (in the sense of the equality predicate) are omitted.</p>
<h2 id="list-set-set-list"><code>(list-&gt;set! set list)</code></h2>
<p>Returns a set that contains the elements of both set and list. Duplicate elements (in the sense of the equality predicate) are omitted.</p>
<h2 id="set-set1-set2-..."><code>(set=? set1 set2 ...)</code></h2>
<p>Returns #t if each set contains the same elements.</p>
<h2 id="set-set1-set2-...-1"><code>(set&lt;? set1 set2 ...)</code></h2>
<p>Returns #t if each set other than the last is a proper subset of the following set, and #f otherwise.</p>
<h2 id="set-set1-set2-...-2"><code>(set&gt;? set1 set2 ...)</code></h2>
<p>Returns #t if each set other than the last is a proper superset of the following set, and #f otherwise.</p>
<h2 id="set-set1-set2-...-3"><code>(set&lt;=? set1 set2 ...)</code></h2>
<p>Returns #t if each set other than the last is a subset of the following set, and #f otherwise.</p>
<h2 id="set-set1-set2-...-4"><code>(set&gt;=? set1 set2 ...)</code></h2>
<p>Returns #t if each set other than the last is a superset of the following set, and #f otherwise.</p>
<h2 id="set-union-set1-set2-..."><code>(set-union set1 set2 ...)</code></h2>
<h2 id="set-intersection-set1-set2-..."><code>(set-intersection set1 set2 ...)</code></h2>
<h2 id="set-difference-set1-set2-..."><code>(set-difference set1 set2 ...)</code></h2>
<h2 id="set-xor-set1-set2"><code>(set-xor set1 set2)</code></h2>
<p>Return a newly allocated set that is the union, intersection, asymmetric difference, or symmetric difference of the sets. Asymmetric difference is extended to more than two sets by taking the difference between the first set and the union of the others. Symmetric difference is not extended beyond two sets. Elements in the result set are drawn from the first set in which they appear.</p>
<h2 id="set-union-set1-set2-...-1"><code>(set-union! set1 set2 ...)</code></h2>
<h2 id="set-intersection-set1-set2-...-1"><code>(set-intersection! set1 set2 ...)</code></h2>
<h2 id="set-difference-set1-set2-...-1"><code>(set-difference! set1 set2 ...)</code></h2>
<h2 id="set-xor-set1-set2-1"><code>(set-xor! set1 set2)</code></h2>
<p>Linear update procedures returning a set that is the union, intersection, asymmetric difference, or symmetric difference of the sets. Asymmetric difference is extended to more than two sets by taking the difference between the first set and the union of the others. Symmetric difference is not extended beyond two sets. Elements in the result set are drawn from the first set in which they appear.</p>
<h2 id="bag-comparator-element-..."><code>(bag comparator element ...)</code></h2>
<h2 id="bag-unfold-..."><code>(bag-unfold ...)</code></h2>
<h2 id="bag-obj"><code>(bag? obj)</code></h2>
<h2 id="bag-contains-..."><code>(bag-contains? ...)</code></h2>
<h2 id="bag-empty-obj">(bag-empty? obj)`</h2>
<h2 id="bag-disjoint">(bag-disjoint? …)</h2>
<h2 id="bag-member-..."><code>(bag-member ...)</code></h2>
<h2 id="bag-element-comparator">`(bag-element-comparator …)</h2>
<h2 id="bag-adjoin-..."><code>(bag-adjoin ...)</code></h2>
<h2 id="bag-adjoin-...-1"><code>(bag-adjoin! ...)</code></h2>
<h2 id="bag-replace-..."><code>(bag-replace ...)</code></h2>
<h2 id="bag-replace-...-1"><code>(bag-replace! ...)</code></h2>
<h2 id="bag-delete-..."><code>(bag-delete ...)</code></h2>
<h2 id="bag-delete-...-1"><code>(bag-delete! ...)</code></h2>
<h2 id="bag-delete-all-..."><code>(bag-delete-all ...)</code></h2>
<h2 id="bag-delete-all-...-1"><code>(bag-delete-all! ...)</code></h2>
<h2 id="bag-search-..."><code>(bag-search! ...)</code></h2>
<h2 id="bag-size-..."><code>(bag-size ...)</code></h2>
<h2 id="bag-find-..."><code>(bag-find ...)</code></h2>
<h2 id="bag-count-..."><code>(bag-count ...)</code></h2>
<h2 id="bag-any-..."><code>(bag-any? ...)</code></h2>
<h2 id="bag-every-..."><code>(bag-every? ...)</code></h2>
<h2 id="bag-map-..."><code>(bag-map ...)</code></h2>
<h2 id="bag-for-each-..."><code>(bag-for-each ...)</code></h2>
<h2 id="bag-fold-..."><code>(bag-fold ...)</code></h2>
<h2 id="bag-filter-..."><code>(bag-filter ...)</code></h2>
<h2 id="bag-remove-..."><code>(bag-remove ...)</code></h2>
<h2 id="bag-partition-..."><code>(bag-partition ...)</code></h2>
<h2 id="bag-filter-...-1"><code>(bag-filter! ...)</code></h2>
<h2 id="bag-remove-...-1"><code>(bag-remove! ...)</code></h2>
<h2 id="bag-partition-...-1"><code>(bag-partition! ...)</code></h2>
<h2 id="bag-copy-..."><code>(bag-copy ...)</code></h2>
<h2 id="bag-list-..."><code>(bag-&gt;list ...)</code></h2>
<h2 id="list-bag-..."><code>(list-&gt;bag ...)</code></h2>
<h2 id="list-bag-...-1"><code>(list-&gt;bag! ...)</code></h2>
<h2 id="bag-..."><code>(bag=? ...)</code></h2>
<h2 id="bag-...-1"><code>(bag&lt;? ...)</code></h2>
<h2 id="bag-...-2"><code>(bag&gt;? ...)</code></h2>
<h2 id="bag-...-3"><code>(bag&lt;=? ...)</code></h2>
<h2 id="bag-...-4"><code>(bag&gt;=? ...)</code></h2>
<h2 id="bag-union-..."><code>(bag-union ...)</code></h2>
<h2 id="bag-intersection-..."><code>(bag-intersection ...)</code></h2>
<h2 id="bag-difference-..."><code>(bag-difference ...)</code></h2>
<h2 id="bag-xor-..."><code>(bag-xor ...)</code></h2>
<h2 id="bag-union-...-1"><code>(bag-union! ...)</code></h2>
<h2 id="bag-intersection-...-1"><code>(bag-intersection! ...)</code></h2>
<h2 id="bag-difference-...-1"><code>(bag-difference! ...)</code></h2>
<h2 id="bag-xor-...-1"><code>(bag-xor! ...)</code></h2>
<h2 id="bag-sum-set1-set2-..."><code>(bag-sum set1 set2 ... )</code></h2>
<h2 id="bag-sum-bag1-bag2-..."><code>(bag-sum! bag1 bag2 ... )</code></h2>
<p>The bag-sum procedure returns a newly allocated bag containing all the unique elements in all the bags, such that the count of each unique element in the result is equal to the sum of the counts of that element in the arguments. It differs from bag-union by treating identical elements as potentially distinct rather than attempting to match them up.</p>
<p>The bag-sum! procedure is equivalent except that it is linear-update.</p>
<h2 id="bag-product-n-bag"><code>(bag-product n bag)</code></h2>
<h2 id="bag-product-n-bag-1"><code>(bag-product! n bag)</code></h2>
<p>The bag-product procedure returns a newly allocated bag containing all the unique elements in bag, where the count of each unique element in the bag is equal to the count of that element in bag multiplied by n.</p>
<p>The bag-product! procedure is equivalent except that it is linear-update.</p>
<h2 id="bag-unique-size-bag"><code>(bag-unique-size bag)</code></h2>
<p>Returns the number of unique elements of bag.</p>
<h2 id="bag-element-count-bag-element"><code>(bag-element-count bag element)</code></h2>
<p>Returns an exact integer representing the number of times that element appears in bag.</p>
<h2 id="bag-for-each-unique-proc-bag"><code>(bag-for-each-unique proc bag)</code></h2>
<p>Applies proc to each unique element of bag in arbitrary order, passing the element and the number of times it occurs in bag, and discarding the returned values. Returns an unspecified result.</p>
<h2 id="bag-fold-unique-proc-nil-bag"><code>(bag-fold-unique proc nil bag)</code></h2>
<p>Invokes proc on each unique element of bag in arbitrary order, passing the number of occurrences as a second argument and the result of the previous invocation as a third argument. For the first invocation, nil is used as the third argument. Returns the result of the last invocation.</p>
<h2 id="bag-increment-bag-element-count"><code>(bag-increment! bag element count)</code></h2>
<h2 id="bag-decrement-bag-element-count"><code>(bag-decrement! bag element count)</code></h2>
<p>Linear update procedures that return a bag with the same elements as bag, but with the element count of element in bag increased or decreased by the exact integer count (but not less than zero).</p>
<h2 id="bag-set-bag"><code>(bag-&gt;set bag)</code></h2>
<h2 id="set-bag-set"><code>(set-&gt;bag set)</code></h2>
<h2 id="set-bag-bag-set"><code>(set-&gt;bag! bag set)</code></h2>
<p>The bag-&gt;set procedure returns a newly allocated set containing the unique elements (in the sense of the equality predicate) of bag. The set-&gt;bag procedure returns a newly allocated bag containing the elements of set. The set-&gt;bag! procedure returns a bag containing the elements of both bag and set. In all cases, the comparator of the result is the same as the comparator of the argument or arguments.</p>
<h2 id="bag-alist-bag"><code>(bag-&gt;alist bag)</code></h2>
<h2 id="alist-bag-comparator-alist"><code>(alist-&gt;bag comparator alist)</code></h2>
<p>The bag-&gt;alist procedure returns a newly allocated alist whose keys are the unique elements of bag and whose values are the number of occurrences of each element. The alist-&gt;bag returning a newly allocated bag based on comparator, where the keys of alist specify the elements and the corresponding values of alist specify how many times they occur. Comparators</p>
<h2 id="set-comparator"><code>set-comparator</code></h2>
<h2 id="bag-comparator"><code>bag-comparator</code></h2>
<p>Note that these comparators do not provide comparison procedures, as there is no ordering between sets or bags. It is an error to compare sets or bags with different element comparators. # <code>(scheme load)</code></p>
<h2 id="load-filename-environment"><code>(load filename [environment])</code></h2>
<p>It is an error if <code>filename</code> is not a string.</p>
<p>An implementation-dependent operation is used to transform <code>filename</code> into the name of an existing file containing Scheme source code. The <code>load</code> procedure reads expressions and definitions from the file and evaluates them sequentially in the environment specified by <code>environment</code>. If <code>environment</code> is omitted, <code>(interaction-environment)</code> is assumed.</p>
<p>qIt is unspecified whether the results of the expressions are printed. The <code>load</code> procedure does not affect the values returned by <code>current-input-port</code> and <code>current-output-port</code>. It returns an unspecified value. # <code>(scheme text)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-135/">SRFI-135</a>.</p>
<p>In Scheme, strings are a mutable data type. Although it “is an error” (R5RS and R7RS) to use string-set! on literal strings or on strings returned by symbol-&gt;string, and any attempt to do so “should raise an exception” (R6RS), all other strings are mutable.</p>
<p>Although many mutable strings are never actually mutated, the mere possibility of mutation complicates specifications of libraries that use strings, encourages precautionary copying of strings, and precludes structure sharing that could otherwise be used to make procedures such as substring and string-append faster and more space-efficient.</p>
<p>This SRFI specifies a new data type of immutable texts. It comes with efficient and portable sample implementations that guarantee O(1) indexing for both sequential and random access, even in systems whose string-ref procedure takes linear time.</p>
<p>The operations of this new data type include analogues for all of the non-mutating operations on strings specified by the R7RS and most of those specified by SRFI 130, but the immutability of texts and uniformity of character-based indexing simplify the specification of those operations while avoiding several inefficiencies associated with the mutability of Scheme’s strings.</p>
<h2 id="text-obj"><code>(text? obj)</code></h2>
<p>Is obj an immutable text? In particular, (text? obj) returns false if (string? obj) returns true, which implies string? returns false if text? returns true. Must execute in O(1) time.</p>
<h2 id="textual-obj"><code>(textual? obj)</code></h2>
<p>Returns true if and only obj is an immutable text or a string. Must execute in O(1) time.</p>
<h2 id="textual-null-text"><code>(textual-null? text)</code></h2>
<p>Is text the empty text? Must execute in O(1) time.</p>
<h2 id="textual-every-pred-textual-start-end"><code>(textual-every pred textual [start end])</code></h2>
<h2 id="textual-any-pred-textual-start-end"><code>(textual-any   pred textual [start end])</code></h2>
<p>Checks to see if every/any character in textual satisfies pred, proceeding from left (index start) to right (index end). textual-every These procedures are short-circuiting: if pred returns false, textual-every does not call pred on subsequent characters; if pred returns true, textual-any does not call pred on subsequent characters; Both procedures are “witness-generating”:</p>
<ul>
<li><p>If textual-every is given an empty interval (with start = end), it returns #t.</p></li>
<li><p>If textual-every returns true for a non-empty interval (with start &lt; end), the returned true value is the one returned by the final call to the predicate on (text-ref (textual-copy text) (- end 1)).</p></li>
<li><p>If textual-any returns true, the returned true value is the one returned by the predicate.</p></li>
</ul>
<p>Note: The names of these procedures do not end with a question mark. This indicates a general value is returned instead of a simple boolean (#t or #f).</p>
<h2 id="make-text-len-char"><code>(make-text len char)</code></h2>
<p>Returns a text of the given length filled with the given character.</p>
<h2 id="text-char-..."><code>(text char ...)</code></h2>
<p>Returns a text consisting of the given characters.</p>
<h2 id="text-tabulate-proc-len"><code>(text-tabulate proc len)</code></h2>
<p>Proc is a procedure that accepts an exact integer as its argument and returns a character. Constructs a text of size len by calling proc on each value from 0 (inclusive) to len (exclusive) to produce the corresponding element of the text. The order in which proc is called on those indexes is not specified.</p>
<p>Rationale: Although text-unfold is more general, text-tabulate is likely to run faster for the common special case it implements.</p>
<h2 id="text-unfold-stop-mapper-successor-seed-base-make-final"><code>(text-unfold stop? mapper successor seed [base make-final])</code></h2>
<p>This is a fundamental constructor for texts.</p>
<ul>
<li><p>successor is used to generate a series of “seed” values from the initial seed:</p></li>
<li><p>seed, (successor seed), (successor2 seed), (successor3 seed), …</p></li>
<li><p>stop? tells us when to stop — when it returns true when applied to one of these seed values.</p></li>
<li><p>mapper maps each seed value to the corresponding character(s) in the result text, which are assembled into that text in left-to-right order. It is an error for mapper to return anything other than a character, string, or text.</p></li>
<li><p>base is the optional initial/leftmost portion of the constructed text, which defaults to the empty text (text). It is an error if base is anything other than a character, string, or text.</p></li>
<li><p>make-final is applied to the terminal seed value (on which stop? returns true) to produce the final/rightmost portion of the constructed text. It defaults to (lambda (x) (text)). It is an error for make-final to return anything other than a character, string, or text.</p></li>
</ul>
<p>text-unfold is a fairly powerful text constructor. You can use it to convert a list to a text, read a port into a text, reverse a text, copy a text, and so forth. Examples:</p>
<div class="sourceCode" id="cb356"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb356-1"><a href="#cb356-1" aria-hidden="true"></a>    (port-&gt;text p) <span class="op">=</span> (text-unfold <span class="kw">eof-object?</span></span>
<span id="cb356-2"><a href="#cb356-2" aria-hidden="true"></a>                               <span class="kw">values</span></span>
<span id="cb356-3"><a href="#cb356-3" aria-hidden="true"></a>                               (<span class="kw">lambda</span> (x) (<span class="kw">read-char</span> p))</span>
<span id="cb356-4"><a href="#cb356-4" aria-hidden="true"></a>                               (<span class="kw">read-char</span> p))</span>
<span id="cb356-5"><a href="#cb356-5" aria-hidden="true"></a></span>
<span id="cb356-6"><a href="#cb356-6" aria-hidden="true"></a>    (list-&gt;text lis) <span class="op">=</span> (text-unfold <span class="kw">null?</span> <span class="kw">car</span> <span class="kw">cdr</span> lis)</span>
<span id="cb356-7"><a href="#cb356-7" aria-hidden="true"></a></span>
<span id="cb356-8"><a href="#cb356-8" aria-hidden="true"></a>    (text-tabulate f size) <span class="op">=</span> (text-unfold (<span class="kw">lambda</span> (i) (<span class="op">=</span> i size)) f add1 <span class="dv">0</span>)</span>
<span id="cb356-9"><a href="#cb356-9" aria-hidden="true"></a></span>
<span id="cb356-10"><a href="#cb356-10" aria-hidden="true"></a>    To map f over a <span class="kw">list</span> lis, producing a text:</span>
<span id="cb356-11"><a href="#cb356-11" aria-hidden="true"></a></span>
<span id="cb356-12"><a href="#cb356-12" aria-hidden="true"></a>    (text-unfold <span class="kw">null?</span> (compose f <span class="kw">car</span>) <span class="kw">cdr</span> lis)</span></code></pre></div>
<p>Interested functional programmers may enjoy noting that textual-fold-right and text-unfold are in some sense inverses. That is, given operations knull?, kar, kdr, kons, and knil satisfying</p>
<div class="sourceCode" id="cb357"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb357-1"><a href="#cb357-1" aria-hidden="true"></a>(kons (kar x) (kdr x)) <span class="op">=</span> x  <span class="kw">and</span>  (knull? knil) <span class="op">=</span> <span class="dv">#t</span></span></code></pre></div>
<p>then</p>
<div class="sourceCode" id="cb358"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb358-1"><a href="#cb358-1" aria-hidden="true"></a>(textual-fold-right kons knil (text-unfold knull? kar kdr x)) <span class="op">=</span> x</span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb359"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb359-1"><a href="#cb359-1" aria-hidden="true"></a>(text-unfold knull? kar kdr (textual-fold-right kons knil text)) <span class="op">=</span> text.</span></code></pre></div>
<p>This combinator pattern is sometimes called an “anamorphism.”</p>
<p>Note: Implementations should not allow the size of texts created by text-unfold to be limited by limits on stack size.</p>
<h2 id="text-unfold-right-stop-mapper-successor-seed-base-make-final"><code>(text-unfold-right stop? mapper successor seed [base make-final])</code></h2>
<p>This is a fundamental constructor for texts. It is the same as text-unfold except the results of mapper are assembled into the text in right-to-left order, base is the optional rightmost portion of the constructed text, and make-final produces the leftmost portion of the constructed text.</p>
<div class="sourceCode" id="cb360"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb360-1"><a href="#cb360-1" aria-hidden="true"></a>    (text-unfold-right (<span class="kw">lambda</span> (n) (<span class="op">&lt;</span> n (<span class="kw">char-&gt;integer</span> <span class="ch">#\A</span>)))</span>
<span id="cb360-2"><a href="#cb360-2" aria-hidden="true"></a>                       (<span class="kw">lambda</span> (n) (<span class="kw">char-downcase</span> (<span class="kw">integer-&gt;char</span> n)))</span>
<span id="cb360-3"><a href="#cb360-3" aria-hidden="true"></a>                       (<span class="kw">lambda</span> (n) (<span class="op">-</span> n <span class="dv">1</span>))</span>
<span id="cb360-4"><a href="#cb360-4" aria-hidden="true"></a>                       (<span class="kw">char-&gt;integer</span> <span class="ch">#\Z</span>)</span>
<span id="cb360-5"><a href="#cb360-5" aria-hidden="true"></a>                       <span class="ch">#\space</span></span>
<span id="cb360-6"><a href="#cb360-6" aria-hidden="true"></a>                       (<span class="kw">lambda</span> (n) <span class="st">&quot; The English alphabet: &quot;</span>))</span>
<span id="cb360-7"><a href="#cb360-7" aria-hidden="true"></a>        <span class="op">=&gt;</span> « The English alphabet: abcdefghijklmnopqrstuvwxyz »</span></code></pre></div>
<h2 id="textual-text-textual"><code>(textual-&gt;text textual)</code></h2>
<p>When given a text, textual-&gt;text just returns that text. When given a string, textual-&gt;text returns the result of calling string-&gt;text on that string. Signals an error when its argument is neither string nor text.</p>
<h2 id="textual-string-textual-start-end"><code>(textual-&gt;string textual [start end])</code></h2>
<h2 id="textual-vector-textual-start-end"><code>(textual-&gt;vector textual [start end])</code></h2>
<h2 id="textual-list-textual-start-end"><code>(textual-&gt;list   textual [start end])</code></h2>
<p>textual-&gt;string, textual-&gt;vector, and textual-&gt;list return a newly allocated (unless empty) mutable string, vector, or list of the characters that make up the given subtext or substring.</p>
<h2 id="string-text-string-start-end"><code>(string-&gt;text string [start end])</code></h2>
<h2 id="vector-text-char-vector-start-end"><code>(vector-&gt;text char-vector [start end])</code></h2>
<h2 id="list-text-char-list-start-end"><code>(list-&gt;text   char-list [start end])</code></h2>
<p>These procedures return a text containing the characters of the given substring, subvector, or sublist. The behavior of the text will not be affected by subsequent mutation of the given string, vector, or list.</p>
<h2 id="reverse-list-text-char-list"><code>(reverse-list-&gt;text char-list)</code></h2>
<p>An efficient implementation of (compose list-&gt;text reverse):</p>
<div class="sourceCode" id="cb361"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb361-1"><a href="#cb361-1" aria-hidden="true"></a>(reverse-list-&gt;text &#39;(<span class="ch">#\a</span> <span class="ch">#\B</span> <span class="ch">#\c</span>)) → «cBa»</span></code></pre></div>
<p>This is a common idiom in the epilogue of text-processing loops that accumulate their result using a list in reverse order. (See also textual-concatenate-reverse for the “chunked” variant.)</p>
<h2 id="textual-utf8-textual-start-end"><code>(textual-&gt;utf8    textual [start end])</code></h2>
<h2 id="textual-utf16-textual-start-end"><code>(textual-&gt;utf16   textual [start end])</code></h2>
<h2 id="textual-utf16be-textual-start-end"><code>(textual-&gt;utf16be textual [start end])</code></h2>
<h2 id="textual-utf16le-textual-start-end"><code>(textual-&gt;utf16le textual [start end])</code></h2>
<p>These procedures return a newly allocated (unless empty) bytevector containing a UTF-8 or UTF-16 encoding of the given subtext or substring.</p>
<p>The bytevectors returned by textual-&gt;utf8, textual-&gt;utf16be, and textual-&gt;utf16le do not contain a byte-order mark (BOM). textual-&gt;utf16be returns a big-endian encoding, while textual-&gt;utf16le returns a little-endian encoding.</p>
<p>The bytevectors returned by textual-&gt;utf16 begin with a BOM that declares an implementation-dependent endianness, and the bytevector elements following that BOM encode the given subtext or substring using that endianness.</p>
<p>Rationale: These procedures are consistent with the Unicode standard. Unicode suggests UTF-16 should default to big-endian, but Microsoft prefers little-endian.</p>
<h2 id="utf8-text-bytevector-start-end"><code>(utf8-&gt;text    bytevector [start end])</code></h2>
<h2 id="utf16-text-bytevector-start-end"><code>(utf16-&gt;text   bytevector [start end])</code></h2>
<h2 id="utf16be-text-bytevector-start-end"><code>(utf16be-&gt;text bytevector [start end])</code></h2>
<h2 id="utf16le-text-bytevector-start-end"><code>(utf16le-&gt;text bytevector [start end])</code></h2>
<p>These procedures interpret their bytevector argument as a UTF-8 or UTF-16 encoding of a sequence of characters, and return a text containing that sequence.</p>
<p>The bytevector subrange given to utf16-&gt;text may begin with a byte order mark (BOM); if so, that BOM determines whether the rest of the subrange is to be interpreted as big-endian or little-endian; in either case, the BOM will not become a character in the returned text. If the subrange does not begin with a BOM, it is decoded using the same implementation-dependent endianness used by textual-&gt;utf16.</p>
<p>The utf16be-&gt;text and utf16le-&gt;text procedures interpret their inputs as big-endian or little-endian, respectively. If a BOM is present, it is treated as a normal character and will become part of the result.</p>
<p>It is an error if the bytevector subrange given to utf8-&gt;text contains invalid UTF-8 byte sequences. For the other three procedures, it is an error if start or end are odd, or if the bytevector subrange contains invalid UTF-16 byte sequences.</p>
<h2 id="text-length-text"><code>(text-length text)</code></h2>
<p>Returns the number of characters within the given text. Must execute in O(1) time.</p>
<h2 id="text-ref-text-idx"><code>(text-ref text idx)</code></h2>
<p>Returns character text[idx], using 0-origin indexing. Must execute in O(1) time.</p>
<h2 id="textual-length-textual"><code>(textual-length textual)</code></h2>
<h2 id="textual-ref-textual-idx"><code>(textual-ref textual idx)</code></h2>
<p>textual-length returns the number of characters in textual, and textual-ref returns the character at character index idx, using 0-origin indexing. These procedures are the generalizations of text-length and text-ref to accept strings as well as texts. If textual is a text, they must execute in O(1) time, but there is no such requirement if textual is a string.</p>
<p>Rationale: These procedures may be more convenient than the text-only versions, but compilers may generate faster code for calls to the text-only versions.</p>
<h2 id="subtext-text-start-end"><code>(subtext    text start end)</code></h2>
<h2 id="subtextual-textual-start-end"><code>(subtextual textual start end)</code></h2>
<p>These procedures return a text containing the characters of text or textual beginning with index start (inclusive) and ending with index end (exclusive).</p>
<p>If textual is a string, then that string does not share any storage with the result, so subsequent mutation of that string will not affect the text returned by subtextual. When the first argument is a text, as is required by subtext, implementations are encouraged to return a result that shares storage with that text, to whatever extent sharing is possible while maintaining some small fixed bound on the ratio of storage used by the shared representation divided by the storage that would be used by an unshared representation. In particular, these procedures should just return their first argument when that argument is a text, start is 0, and end is the length of that text.</p>
<h2 id="textual-copy-textual-start-end"><code>(textual-copy textual [start end])</code></h2>
<p>Returns a text containing the characters of textual beginning with index start (inclusive) and ending with index end (exclusive).</p>
<p>Unlike subtext and subtextual, the result of textual-copy never shares substructures that would retain characters or sequences of characters that are substructures of its first argument or previously allocated objects.</p>
<p>If textual-copy returns an empty text, that empty text may be eq? or eqv? to the text returned by (text). If the text returned by textual-copy is non-empty, then it is not eqv? to any previously extant object.</p>
<h2 id="textual-take-textual-nchars"><code>(textual-take       textual nchars)</code></h2>
<h2 id="textual-drop-textual-nchars"><code>(textual-drop       textual nchars)</code></h2>
<h2 id="textual-take-right-textual-nchars"><code>(textual-take-right textual nchars)</code></h2>
<h2 id="textual-drop-right-textual-nchars"><code>(textual-drop-right textual nchars)</code></h2>
<p>textual-take returns a text containing the first nchars of textual; textual-drop returns a text containing all but the first nchars of textual. textual-take-right returns a text containing the last nchars of textual; textual-drop-right returns a text containing all but the last nchars of textual.</p>
<p>If textual is a string, then that string does not share any storage with the result, so subsequent mutation of that string will not affect the text returned by these procedures. If textual is a text, implementations are encouraged to return a result that shares storage with that text (which is easily accomplished by using subtext to create the result).</p>
<div class="sourceCode" id="cb362"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb362-1"><a href="#cb362-1" aria-hidden="true"></a>(textual-take <span class="st">&quot;Pete Szilagyi&quot;</span> <span class="dv">6</span>) <span class="op">=&gt;</span> «Pete S»</span>
<span id="cb362-2"><a href="#cb362-2" aria-hidden="true"></a>(textual-drop <span class="st">&quot;Pete Szilagyi&quot;</span> <span class="dv">6</span>) <span class="op">=&gt;</span> «zilagyi»</span>
<span id="cb362-3"><a href="#cb362-3" aria-hidden="true"></a></span>
<span id="cb362-4"><a href="#cb362-4" aria-hidden="true"></a>(textual-take-right <span class="st">&quot;Beta rules&quot;</span> <span class="dv">5</span>) <span class="op">=&gt;</span> «rules»</span>
<span id="cb362-5"><a href="#cb362-5" aria-hidden="true"></a>(textual-drop-right <span class="st">&quot;Beta rules&quot;</span> <span class="dv">5</span>) <span class="op">=&gt;</span> «Beta »</span></code></pre></div>
<p>It is an error to take or drop more characters than are in the text:</p>
<div class="sourceCode" id="cb363"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb363-1"><a href="#cb363-1" aria-hidden="true"></a>(textual-take <span class="st">&quot;foo&quot;</span> <span class="dv">37</span>) <span class="op">=&gt;</span> error</span></code></pre></div>
<h2 id="textual-pad-textual-len-char-start-end"><code>(textual-pad       textual len [char start end])</code></h2>
<h2 id="textual-pad-right-textual-len-char-start-end"><code>(textual-pad-right textual len [char start end])</code></h2>
<p>Returns a text of length len comprised of the characters drawn from the given subrange of textual, padded on the left (right) by as many occurrences of the character char as needed. If textual has more than len chars, it is truncated on the left (right) to length len. char defaults to #.</p>
<p>If textual is a string, then that string does not share any storage with the result, so subsequent mutation of that string will not affect the text returned by these procedures. If textual is a text, implementations are encouraged to return a result that shares storage with that text whenever sharing would be space-efficient.</p>
<div class="sourceCode" id="cb364"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb364-1"><a href="#cb364-1" aria-hidden="true"></a>(textual-pad     <span class="st">&quot;325&quot;</span> <span class="dv">5</span>) <span class="op">=&gt;</span> «  325»</span>
<span id="cb364-2"><a href="#cb364-2" aria-hidden="true"></a>(textual-pad   <span class="st">&quot;71325&quot;</span> <span class="dv">5</span>) <span class="op">=&gt;</span> «71325»</span>
<span id="cb364-3"><a href="#cb364-3" aria-hidden="true"></a>(textual-pad <span class="st">&quot;8871325&quot;</span> <span class="dv">5</span>) <span class="op">=&gt;</span> «71325»</span></code></pre></div>
<h2 id="textual-trim-textual-pred-start-end"><code>(textual-trim       textual [pred start end])</code></h2>
<h2 id="textual-trim-right-textual-pred-start-end"><code>(textual-trim-right textual [pred start end])</code></h2>
<h2 id="textual-trim-both-textual-pred-start-end"><code>(textual-trim-both  textual [pred start end])</code></h2>
<p>Returns a text obtained from the given subrange of textual by skipping over all characters on the left / on the right / on both sides that satisfy the second argument pred: pred defaults to char-whitespace?.</p>
<p>If textual is a string, then that string does not share any storage with the result, so subsequent mutation of that string will not affect the text returned by these procedures. If textual is a text, implementations are encouraged to return a result that shares storage with that text whenever sharing would be space-efficient.</p>
<div class="sourceCode" id="cb365"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb365-1"><a href="#cb365-1" aria-hidden="true"></a>(textual-trim-both <span class="st">&quot;  The outlook wasn&#39;t brilliant,  \n\r&quot;</span>)</span>
<span id="cb365-2"><a href="#cb365-2" aria-hidden="true"></a><span class="op">=&gt;</span> «The outlook wasn&#39;t brilliant,»</span></code></pre></div>
<h2 id="textual-replace-textual1-textual2-start1-end1-start2-end2"><code>(textual-replace textual1 textual2 start1 end1 [start2 end2])</code></h2>
<p>Returns</p>
<div class="sourceCode" id="cb366"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb366-1"><a href="#cb366-1" aria-hidden="true"></a>    (textual-append (subtextual textual1 <span class="dv">0</span> start1)</span>
<span id="cb366-2"><a href="#cb366-2" aria-hidden="true"></a>                    (subtextual textual2 start2 end2)</span>
<span id="cb366-3"><a href="#cb366-3" aria-hidden="true"></a>                    (subtextual textual1 end1 (textual-length textual1)))</span></code></pre></div>
<p>That is, the segment of characters in textual1 from start1 to end1 is replaced by the segment of characters in textual2 from start2 to end2. If start1=end1, this simply splices the characters drawn from textual2 into textual1 at that position.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb367"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb367-1"><a href="#cb367-1" aria-hidden="true"></a>    (textual-replace <span class="st">&quot;The TCL programmer endured daily ridicule.&quot;</span></span>
<span id="cb367-2"><a href="#cb367-2" aria-hidden="true"></a>                     <span class="st">&quot;another miserable perl drone&quot;</span> <span class="dv">4</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">22</span>)</span>
<span id="cb367-3"><a href="#cb367-3" aria-hidden="true"></a>        <span class="op">=&gt;</span> «The miserable perl programmer endured daily ridicule.»</span>
<span id="cb367-4"><a href="#cb367-4" aria-hidden="true"></a></span>
<span id="cb367-5"><a href="#cb367-5" aria-hidden="true"></a>    (textual-replace <span class="st">&quot;It&#39;s easy to code it up in Scheme.&quot;</span> <span class="st">&quot;lots of fun&quot;</span> <span class="dv">5</span> <span class="dv">9</span>)</span>
<span id="cb367-6"><a href="#cb367-6" aria-hidden="true"></a>        <span class="op">=&gt;</span> «It&#39;s lots of fun to code it up in Scheme.»</span>
<span id="cb367-7"><a href="#cb367-7" aria-hidden="true"></a></span>
<span id="cb367-8"><a href="#cb367-8" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> </span>(textual-insert s i t) (textual-replace s t i i))</span>
<span id="cb367-9"><a href="#cb367-9" aria-hidden="true"></a></span>
<span id="cb367-10"><a href="#cb367-10" aria-hidden="true"></a>    (textual-insert <span class="st">&quot;It&#39;s easy to code it up in Scheme.&quot;</span> <span class="dv">5</span> <span class="st">&quot;really &quot;</span>)</span>
<span id="cb367-11"><a href="#cb367-11" aria-hidden="true"></a>        <span class="op">=&gt;</span> «It&#39;s really easy to code it up in Scheme.»</span>
<span id="cb367-12"><a href="#cb367-12" aria-hidden="true"></a></span>
<span id="cb367-13"><a href="#cb367-13" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> </span>(textual-set s i c) (textual-replace s (text c) i (<span class="op">+</span> i <span class="dv">1</span>)))</span>
<span id="cb367-14"><a href="#cb367-14" aria-hidden="true"></a></span>
<span id="cb367-15"><a href="#cb367-15" aria-hidden="true"></a>    (textual-set <span class="st">&quot;Text-ref runs in O(n) time.&quot;</span> <span class="dv">19</span> <span class="ch">#\1</span>)</span>
<span id="cb367-16"><a href="#cb367-16" aria-hidden="true"></a>        <span class="op">=&gt;</span> «Text-ref runs in O(<span class="dv">1</span>) time.»</span></code></pre></div>
<h2 id="textual-textual1-textual2-textual3-..."><code>(textual=? textual1 textual2 textual3 ...)</code></h2>
<p>Returns #t if all the texts have the same length and contain exactly the same characters in the same positions; otherwise returns #f.</p>
<h2 id="textual-textual1-textual2-textual3-...-1"><code>(textual&lt;?  textual1 textual2 textual3 ...)</code></h2>
<h2 id="textual-textual1-textual2-textual3-...-2"><code>(textual&gt;?  textual1 textual2 textual3 ...)</code></h2>
<h2 id="textual-textual1-textual2-textual3-...-3"><code>(textual&lt;=? textual1 textual2 textual3 ...)</code></h2>
<h2 id="textual-textual1-textual2-textual3-...-4"><code>(textual&gt;=? textual1 textual2 textual3 ...)</code></h2>
<p>These procedures return #t if their arguments are (respectively): monotonically increasing, monotonically decreasing, monotonically non-decreasing, or monotonically non-increasing.</p>
<p>These comparison predicates are required to be transitive.</p>
<p>These procedures compare texts in an implementation-defined way. One approach is to make them the lexicographic extensions to texts of the corresponding orderings on characters. In that case, text&lt;? would be the lexicographic ordering on texts induced by the ordering char&lt;? on characters, and if two texts differ in length but are the same up to the length of the shorter text, the shorter text would be considered to be lexicographically less than the longer string. However, implementations are also allowed to use more sophisticated locale-specific orderings.</p>
<p>In all cases, a pair of texts must satisfy exactly one of textual&lt;?, textual=?, and textual&gt;?, must satisfy textual&lt;=? if and only if they do not satisfy textual&gt;?, and must satisfy textual&gt;=? if and only if they do not satisfy textual&lt;?.</p>
<p>Note: Implementations are encouraged to use the same orderings for texts as are used by the corresponding comparisons on strings, but are allowed to use different orderings.</p>
<p>Rationale: The only portable way to ensure these comparison predicates use the same orderings used by the corresponding comparisons on strings is to convert all texts to strings, which would be unacceptably inefficient.</p>
<h2 id="textual-ci-textual1-textual2-textual3-..."><code>(textual-ci=? textual1 textual2 textual3 ...)</code></h2>
<p>Returns #t if, after calling textual-foldcase on each of the arguments, all of the case-folded texts would have the same length and contain the same characters in the same positions; otherwise returns #f.</p>
<h2 id="textual-ci-textual1-textual2-textual3-...-1"><code>(textual-ci&lt;?  textual1 textual2 textual3 ...)</code></h2>
<h2 id="textual-ci-textual1-textual2-textual3-...-2"><code>(textual-ci&gt;?  textual1 textual2 textual3 ...)</code></h2>
<h2 id="textual-ci-textual1-textual2-textual3-...-3"><code>(textual-ci&lt;=? textual1 textual2 textual3 ...)</code></h2>
<h2 id="textual-ci-textual1-textual2-textual3-...-4"><code>(textual-ci&gt;=? textual1 textual2 textual3 ...)</code></h2>
<p>These procedures behave as though they had called textual-foldcase on their arguments before applying the corresponding procedures without “-ci”.</p>
<h2 id="textual-prefix-length-textual1-textual2-start1-end1-start2-end2"><code>(textual-prefix-length textual1 textual2 [start1 end1 start2 end2])</code></h2>
<h2 id="textual-suffix-length-textual1-textual2-start1-end1-start2-end2"><code>(textual-suffix-length textual1 textual2 [start1 end1 start2 end2])</code></h2>
<p>Return the length of the longest common prefix/suffix of textual1 and textual2. For prefixes, this is equivalent to their “mismatch index” (relative to the start indexes).</p>
<p>The optional start/end indexes restrict the comparison to the indicated subtexts of textual1 and textual2.</p>
<h2 id="textual-prefix-textual1-textual2-start1-end1-start2-end2"><code>(textual-prefix? textual1 textual2 [start1 end1 start2 end2])</code></h2>
<h2 id="textual-suffix-textual1-textual2-start1-end1-start2-end2"><code>(textual-suffix? textual1 textual2 [start1 end1 start2 end2])</code></h2>
<p>Is textual1 a prefix/suffix of textual2?</p>
<p>The optional start/end indexes restrict the comparison to the indicated subtexts of textual1 and textual2.</p>
<h2 id="textual-index-textual-pred-start-end"><code>(textual-index       textual pred [start end])</code></h2>
<h2 id="textual-index-right-textual-pred-start-end"><code>(textual-index-right textual pred [start end])</code></h2>
<h2 id="textual-skip-textual-pred-start-end"><code>(textual-skip        textual pred [start end])</code></h2>
<h2 id="textual-skip-right-textual-pred-start-end"><code>(textual-skip-right  textual pred [start end])</code></h2>
<p>textual-index searches through the given subtext or substring from the left, returning the index of the leftmost character satisfying the predicate pred. textual-index-right searches from the right, returning the index of the rightmost character satisfying the predicate pred. If no match is found, these procedures return #f.</p>
<p>Rationale: The SRFI 130 analogues of these procedures return cursors, even when no match is found, and SRFI 130’s string-index-right returns the successor of the cursor for the first character that satisfies the predicate. As there are no cursors in this SRFI, it seems best to follow the more intuitive and long-standing precedent set by SRFI 13.</p>
<p>The start and end arguments specify the beginning and end of the search; the valid indexes relevant to the search include start but exclude end. Beware of “fencepost” errors: when searching right-to-left, the first index considered is (- end 1), whereas when searching left-to-right, the first index considered is start. That is, the start/end indexes describe the same half-open interval [start,end) in these procedures that they do in all other procedures specified by this SRFI.</p>
<p>The skip functions are similar, but use the complement of the criterion: they search for the first char that doesn’t satisfy pred. To skip over initial whitespace, for example, say</p>
<div class="sourceCode" id="cb368"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb368-1"><a href="#cb368-1" aria-hidden="true"></a>    (subtextual text</span>
<span id="cb368-2"><a href="#cb368-2" aria-hidden="true"></a>                (<span class="kw">or</span> (textual-skip text <span class="kw">char-whitespace?</span>)</span>
<span id="cb368-3"><a href="#cb368-3" aria-hidden="true"></a>                    (textual-length text))</span>
<span id="cb368-4"><a href="#cb368-4" aria-hidden="true"></a>                (textual-length text))</span></code></pre></div>
<p>These functions can be trivially composed with textual-take and textual-drop to produce take-while, drop-while, span, and break procedures without loss of efficiency.</p>
<h2 id="textual-contains-textual1-textual2-start1-end1-start2-end2"><code>(textual-contains       textual1 textual2 [start1 end1 start2 end2])</code></h2>
<h2 id="textual-contains-right-textual1-textual2-start1-end1-start2-end2"><code>(textual-contains-right textual1 textual2 [start1 end1 start2 end2])</code></h2>
<p>Does the subtext of textual1 specified by start1 and end1 contain the sequence of characters given by the subtext of textual2 specified by start2 and end2?</p>
<p>Returns #f if there is no match. If start2 = end2, textual-contains returns start1 but textual-contains-right returns end1. Otherwise returns the index in textual1 for the first character of the first/last match; that index lies within the half-open interval [start1,end1), and the match lies entirely within the [start1,end1) range of textual1.</p>
<div class="sourceCode" id="cb369"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb369-1"><a href="#cb369-1" aria-hidden="true"></a>(textual-contains <span class="st">&quot;eek -- what a geek.&quot;</span> <span class="st">&quot;ee&quot;</span> <span class="dv">12</span> <span class="dv">18</span>) <span class="co">; Searches &quot;a geek&quot;</span></span>
<span id="cb369-2"><a href="#cb369-2" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="dv">15</span></span></code></pre></div>
<p>Note: The names of these procedures do not end with a question mark. This indicates a useful value is returned when there is a match.</p>
<h2 id="textual-upcase-textual"><code>(textual-upcase   textual)</code></h2>
<h2 id="textual-downcase-textual"><code>(textual-downcase textual)</code></h2>
<h2 id="textual-foldcase-textual"><code>(textual-foldcase textual)</code></h2>
<h2 id="textual-titlecase-textual"><code>(textual-titlecase textual)</code></h2>
<p>These procedures return the text obtained by applying Unicode’s full uppercasing, lowercasing, case-folding, or title-casing algorithms to their argument. In some cases, the length of the result may be different from the length of the argument. Note that language-sensitive mappings and foldings are not used.</p>
<h2 id="textual-append-textual-..."><code>(textual-append textual ...)</code></h2>
<p>Returns a text whose sequence of characters is the concatenation of the sequences of characters in the given arguments.</p>
<h2 id="textual-concatenate-textual-list"><code>(textual-concatenate textual-list)</code></h2>
<p>Concatenates the elements of textual-list together into a single text.</p>
<p>If any elements of textual-list are strings, then those strings do not share any storage with the result, so subsequent mutation of those string will not affect the text returned by this procedure. Implementations are encouraged to return a result that shares storage with some of the texts in the list if that sharing would be space-efficient.</p>
<p>Rationale: Some implementations of Scheme limit the number of arguments that may be passed to an n-ary procedure, so the (apply textual-append textual-list) idiom, which is otherwise equivalent to using this procedure, is not as portable.</p>
<h2 id="textual-concatenate-reverse-textual-list-final-textual-end"><code>(textual-concatenate-reverse textual-list [final-textual end])</code></h2>
<p>With no optional arguments, calling this procedure is equivalent to</p>
<div class="sourceCode" id="cb370"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb370-1"><a href="#cb370-1" aria-hidden="true"></a>(textual-concatenate (<span class="kw">reverse</span> textual-list))</span></code></pre></div>
<p>If the optional argument final-textual is specified, it is effectively consed onto the beginning of textual-list before performing the list-reverse and textual-concatenate operations.</p>
<p>If the optional argument end is given, only the characters up to but not including end in final-textual are added to the result, thus producing</p>
<div class="sourceCode" id="cb371"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb371-1"><a href="#cb371-1" aria-hidden="true"></a>    (textual-concatenate</span>
<span id="cb371-2"><a href="#cb371-2" aria-hidden="true"></a>      (<span class="kw">reverse</span> (<span class="kw">cons</span> (subtext final-textual <span class="dv">0</span> end)</span>
<span id="cb371-3"><a href="#cb371-3" aria-hidden="true"></a>                     textual-list)))</span></code></pre></div>
<p>For example:</p>
<div class="sourceCode" id="cb372"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb372-1"><a href="#cb372-1" aria-hidden="true"></a>(textual-concatenate-reverse &#39;(<span class="st">&quot; must be&quot;</span> <span class="st">&quot;Hello, I&quot;</span>) <span class="st">&quot;</span></span>
<span id="cb372-2"><a href="#cb372-2" aria-hidden="true"></a><span class="st">    going.XXXX&quot;</span> <span class="dv">7</span>) <span class="op">=&gt;</span> «Hello, I must be going.» `` Rationale: This</span>
<span id="cb372-3"><a href="#cb372-3" aria-hidden="true"></a>    procedure is useful when constructing procedures that accumulate</span>
<span id="cb372-4"><a href="#cb372-4" aria-hidden="true"></a>    character data into lists of textual buffers, <span class="kw">and</span> wish to convert</span>
<span id="cb372-5"><a href="#cb372-5" aria-hidden="true"></a>    the accumulated data into a single text when done. The optional</span>
<span id="cb372-6"><a href="#cb372-6" aria-hidden="true"></a>    end argument accommodates that use <span class="kw">case</span> when final-textual is a</span>
<span id="cb372-7"><a href="#cb372-7" aria-hidden="true"></a>    mutable <span class="kw">string</span>, <span class="kw">and</span> is allowed (for uniformity) when final-textual</span>
<span id="cb372-8"><a href="#cb372-8" aria-hidden="true"></a>    is an immutable text.</span></code></pre></div>
<h2 id="textual-join-textual-list-delimiter-grammar"><code>(textual-join textual-list [delimiter grammar])</code></h2>
<p>This procedure is a simple unparser; it pastes texts together using the delimiter text.</p>
<p>textual-list is a list of texts and/or strings. delimiter is a text or a string. The grammar argument is a symbol that determines how the delimiter is used, and defaults to ’infix. It is an error for grammar to be any symbol other than these four:</p>
<ul>
<li><p>’infix means an infix or separator grammar: insert the delimiter between list elements. An empty list will produce an empty text.</p></li>
<li><p>’strict-infix means the same as ’infix if the textual-list is non-empty, but will signal an error if given an empty list. (This avoids an ambiguity shown in the examples below.)</p></li>
<li><p>’suffix means a suffix or terminator grammar: insert the delimiter after every list element.</p></li>
<li><p>’prefix means a prefix grammar: insert the delimiter before every list element.</p></li>
</ul>
<p>The delimiter is the text used to delimit elements; it defaults to a single space " ".</p>
<div class="sourceCode" id="cb373"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb373-1"><a href="#cb373-1" aria-hidden="true"></a>    (textual-join &#39;(<span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span> <span class="st">&quot;baz&quot;</span>))</span>
<span id="cb373-2"><a href="#cb373-2" aria-hidden="true"></a>             <span class="op">=&gt;</span> «foo bar baz»</span>
<span id="cb373-3"><a href="#cb373-3" aria-hidden="true"></a>    (textual-join &#39;(<span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span> <span class="st">&quot;baz&quot;</span>) <span class="st">&quot;&quot;</span>)</span>
<span id="cb373-4"><a href="#cb373-4" aria-hidden="true"></a>             <span class="op">=&gt;</span> «foobarbaz»</span>
<span id="cb373-5"><a href="#cb373-5" aria-hidden="true"></a>    (textual-join &#39;(<span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span> <span class="st">&quot;baz&quot;</span>) «:»)</span>
<span id="cb373-6"><a href="#cb373-6" aria-hidden="true"></a>             <span class="op">=&gt;</span> «foo:bar:baz»</span>
<span id="cb373-7"><a href="#cb373-7" aria-hidden="true"></a>    (textual-join &#39;(<span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span> <span class="st">&quot;baz&quot;</span>) <span class="st">&quot;:&quot;</span> &#39;suffix)</span>
<span id="cb373-8"><a href="#cb373-8" aria-hidden="true"></a>             <span class="op">=&gt;</span> «foo:bar:baz:»</span>
<span id="cb373-9"><a href="#cb373-9" aria-hidden="true"></a></span>
<span id="cb373-10"><a href="#cb373-10" aria-hidden="true"></a>    <span class="co">;; Infix grammar is ambiguous wrt empty list vs. empty text:</span></span>
<span id="cb373-11"><a href="#cb373-11" aria-hidden="true"></a>    (textual-join &#39;()   <span class="st">&quot;:&quot;</span>) <span class="op">=&gt;</span> «»</span>
<span id="cb373-12"><a href="#cb373-12" aria-hidden="true"></a>    (textual-join &#39;(<span class="st">&quot;&quot;</span>) <span class="st">&quot;:&quot;</span>) <span class="op">=&gt;</span> «»</span>
<span id="cb373-13"><a href="#cb373-13" aria-hidden="true"></a></span>
<span id="cb373-14"><a href="#cb373-14" aria-hidden="true"></a>    <span class="co">;; Suffix and prefix grammars are not:</span></span>
<span id="cb373-15"><a href="#cb373-15" aria-hidden="true"></a>    (textual-join &#39;()   <span class="st">&quot;:&quot;</span> &#39;suffix)) <span class="op">=&gt;</span> «»</span>
<span id="cb373-16"><a href="#cb373-16" aria-hidden="true"></a>    (textual-join &#39;(<span class="st">&quot;&quot;</span>) <span class="st">&quot;:&quot;</span> &#39;suffix)) <span class="op">=&gt;</span> «:»</span></code></pre></div>
<h2 id="textual-fold-kons-knil-textual-start-end"><code>(textual-fold       kons knil textual [start end])</code></h2>
<h2 id="textual-fold-right-kons-knil-textual-start-end"><code>(textual-fold-right kons knil textual [start end])</code></h2>
<p>These are the fundamental iterators for texts.</p>
<p>The textual-fold procedure maps the kons procedure across the given text or string from left to right:</p>
<div class="sourceCode" id="cb374"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb374-1"><a href="#cb374-1" aria-hidden="true"></a>(... (kons textual[<span class="dv">2</span>] (kons textual[<span class="dv">1</span>] (kons textual[<span class="dv">0</span>] knil))))</span></code></pre></div>
<p>In other words, textual-fold obeys the (tail) recursion</p>
<div class="sourceCode" id="cb375"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb375-1"><a href="#cb375-1" aria-hidden="true"></a>(textual-fold kons knil textual start end)</span>
<span id="cb375-2"><a href="#cb375-2" aria-hidden="true"></a><span class="op">=</span> (textual-fold kons (kons textual[start] knil) start+<span class="dv">1</span> end)</span></code></pre></div>
<p>The textual-fold-right procedure maps kons across the given text or string from right to left:</p>
<div class="sourceCode" id="cb376"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb376-1"><a href="#cb376-1" aria-hidden="true"></a>    (kons textual[<span class="dv">0</span>]</span>
<span id="cb376-2"><a href="#cb376-2" aria-hidden="true"></a>          (... (kons textual[end<span class="dv">-3</span>]</span>
<span id="cb376-3"><a href="#cb376-3" aria-hidden="true"></a>                     (kons textual[end<span class="dv">-2</span>]</span>
<span id="cb376-4"><a href="#cb376-4" aria-hidden="true"></a>                           (kons textual[end<span class="dv">-1</span>]</span>
<span id="cb376-5"><a href="#cb376-5" aria-hidden="true"></a>                                 knil)))))</span></code></pre></div>
<p>obeying the (tail) recursion</p>
<div class="sourceCode" id="cb377"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb377-1"><a href="#cb377-1" aria-hidden="true"></a>      (textual-fold-right kons knil textual start end)</span>
<span id="cb377-2"><a href="#cb377-2" aria-hidden="true"></a>    <span class="op">=</span> (textual-fold-right kons (kons textual[end<span class="dv">-1</span>] knil) start end<span class="dv">-1</span>)</span></code></pre></div>
<p>Examples:</p>
<div class="sourceCode" id="cb378"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb378-1"><a href="#cb378-1" aria-hidden="true"></a>    <span class="co">;;; Convert a text or string to a list of chars.</span></span>
<span id="cb378-2"><a href="#cb378-2" aria-hidden="true"></a>    (textual-fold-right <span class="kw">cons</span> &#39;() textual)</span>
<span id="cb378-3"><a href="#cb378-3" aria-hidden="true"></a></span>
<span id="cb378-4"><a href="#cb378-4" aria-hidden="true"></a>    <span class="co">;;; Count the number of lower-case characters in a text or string.</span></span>
<span id="cb378-5"><a href="#cb378-5" aria-hidden="true"></a>    (textual-fold (<span class="kw">lambda</span> (c count)</span>
<span id="cb378-6"><a href="#cb378-6" aria-hidden="true"></a>                    (<span class="kw">if</span> (<span class="kw">char-lower-case?</span> c)</span>
<span id="cb378-7"><a href="#cb378-7" aria-hidden="true"></a>                        (<span class="op">+</span> count <span class="dv">1</span>)</span>
<span id="cb378-8"><a href="#cb378-8" aria-hidden="true"></a>                        count))</span>
<span id="cb378-9"><a href="#cb378-9" aria-hidden="true"></a>                  <span class="dv">0</span></span>
<span id="cb378-10"><a href="#cb378-10" aria-hidden="true"></a>                  textual)</span></code></pre></div>
<p>The textual-fold-right combinator is sometimes called a “catamorphism.”</p>
<h2 id="textual-map-proc-textual1-textual2-..."><code>(textual-map proc textual1 textual2 ...)</code></h2>
<p>It is an error if proc does not accept as many arguments as the number of textual arguments passed to textual-map, does not accept characters as arguments, or returns a value that is not a character, string, or text.</p>
<p>The textual-map procedure applies proc element-wise to the characters of the textual arguments, converts each value returned by proc to a text, and returns the concatenation of those texts. If more than one textual argument is given and not all have the same length, then textual-map terminates when the shortest textual argument runs out. The dynamic order in which proc is called on the characters of the textual arguments is unspecified, as is the dynamic order in which the coercions are performed. If any strings returned by proc are mutated after they have been returned and before the call to textual-map has returned, then textual-map returns a text with unspecified contents; the textual-map procedure itself does not mutate those strings.</p>
<p>Example:</p>
<div class="sourceCode" id="cb379"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb379-1"><a href="#cb379-1" aria-hidden="true"></a>    (textual-map (<span class="kw">lambda</span> (c0 c1 c2)</span>
<span id="cb379-2"><a href="#cb379-2" aria-hidden="true"></a>                   (<span class="kw">case</span> c0</span>
<span id="cb379-3"><a href="#cb379-3" aria-hidden="true"></a>                    ((<span class="ch">#\1</span>) c1)</span>
<span id="cb379-4"><a href="#cb379-4" aria-hidden="true"></a>                    ((<span class="ch">#\2</span>) (<span class="kw">string</span> c2))</span>
<span id="cb379-5"><a href="#cb379-5" aria-hidden="true"></a>                    ((<span class="ch">#\-</span>) (text <span class="ch">#\-</span> c1))))</span>
<span id="cb379-6"><a href="#cb379-6" aria-hidden="true"></a>                 (string-&gt;text <span class="st">&quot;1222-1111-2222&quot;</span>)</span>
<span id="cb379-7"><a href="#cb379-7" aria-hidden="true"></a>                 (string-&gt;text <span class="st">&quot;Hi There!&quot;</span>)</span>
<span id="cb379-8"><a href="#cb379-8" aria-hidden="true"></a>                 (string-&gt;text <span class="st">&quot;Dear John&quot;</span>))</span>
<span id="cb379-9"><a href="#cb379-9" aria-hidden="true"></a>         <span class="op">=&gt;</span> «Hear-here!»</span></code></pre></div>
<h2 id="textual-for-each-proc-textual1-textual2-..."><code>(textual-for-each proc textual1 textual2 ...)</code></h2>
<p>It is an error if proc does not accept as many arguments as the number of textual arguments passed to textual-map or does not accept characters as arguments.</p>
<p>The textual-for-each procedure applies proc element-wise to the characters of the textual arguments, going from left to right. If more than one textual argument is given and not all have the same length, then textual-for-each terminates when the shortest textual argument runs out.</p>
<h2 id="textual-map-index-proc-textual-start-end"><code>(textual-map-index proc textual [start end])</code></h2>
<p>Calls proc on each valid index of the specified subtext or substring, converts the results of those calls into texts, and returns the concatenation of those texts. It is an error for proc to return anything other than a character, string, or text. The dynamic order in which proc is called on the indexes is unspecified, as is the dynamic order in which the coercions are performed. If any strings returned by proc are mutated after they have been returned and before the call to textual-map-index has returned, then textual-map-index returns a text with unspecified contents; the textual-map-index procedure itself does not mutate those strings.</p>
<h2 id="textual-for-each-index-proc-textual-start-end"><code>(textual-for-each-index proc textual [start end])</code></h2>
<p>Calls proc on each valid index of the specified subtext or substring, in increasing order, discarding the results of those calls. This is simply a safe and correct way to loop over a subtext or substring.</p>
<p>Example:</p>
<div class="sourceCode" id="cb380"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb380-1"><a href="#cb380-1" aria-hidden="true"></a>    (<span class="kw">let</span> ((txt (string-&gt;text <span class="st">&quot;abcde&quot;</span>))</span>
<span id="cb380-2"><a href="#cb380-2" aria-hidden="true"></a>          (v &#39;()))</span>
<span id="cb380-3"><a href="#cb380-3" aria-hidden="true"></a>      (textual-for-each-index</span>
<span id="cb380-4"><a href="#cb380-4" aria-hidden="true"></a>        (<span class="kw">lambda</span> (cur) (set! v (<span class="kw">cons</span> (<span class="kw">char-&gt;integer</span> (text-ref txt cur)) v)))</span>
<span id="cb380-5"><a href="#cb380-5" aria-hidden="true"></a>        txt)</span>
<span id="cb380-6"><a href="#cb380-6" aria-hidden="true"></a>      v) <span class="op">=&gt;</span> (<span class="dv">101</span> <span class="dv">100</span> <span class="dv">99</span> <span class="dv">98</span> <span class="dv">97</span>)</span></code></pre></div>
<h2 id="textual-count-textual-pred-start-end"><code>(textual-count textual pred [start end])</code></h2>
<p>Returns a count of the number of characters in the specified subtext of textual that satisfy the given predicate.</p>
<h2 id="textual-filter-pred-textual-start-end"><code>(textual-filter pred textual [start end])</code></h2>
<h2 id="textual-remove-pred-textual-start-end"><code>(textual-remove pred textual [start end])</code></h2>
<p>Filter the given subtext of textual, retaining only those characters that satisfy / do not satisfy pred.</p>
<p>If textual is a string, then that string does not share any storage with the result, so subsequent mutation of that string will not affect the text returned by these procedures. If textual is a text, implementations are encouraged to return a result that shares storage with that text whenever sharing would be space-efficient.</p>
<h2 id="textual-replicate-textual-from-to-start-end"><code>(textual-replicate textual from to [start end])</code></h2>
<p>This is an “extended subtext” procedure that implements replicated copying of a subtext or substring.</p>
<p>textual is a text or string; start and end are optional arguments that specify a subtext of textual, defaulting to 0 and the length of textual. This subtext is conceptually replicated both up and down the index space, in both the positive and negative directions. For example, if textual is “abcdefg”, start is 3, and end is6, then we have the conceptual bidirectionally-infinite text</p>
<div class="sourceCode" id="cb381"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb381-1"><a href="#cb381-1" aria-hidden="true"></a>        ...  d  e  f  d  e  f  d  e  f  d  e  f  d  e  f  d  e  f  d ...</span>
<span id="cb381-2"><a href="#cb381-2" aria-hidden="true"></a>            <span class="dv">-9</span> <span class="dv">-8</span> <span class="dv">-7</span> <span class="dv">-6</span> <span class="dv">-5</span> <span class="dv">-4</span> <span class="dv">-3</span> <span class="dv">-2</span> <span class="dv">-1</span>  <span class="dv">0</span> +<span class="dv">1</span> +<span class="dv">2</span> +<span class="dv">3</span> +<span class="dv">4</span> +<span class="dv">5</span> +<span class="dv">6</span> +<span class="dv">7</span> +<span class="dv">8</span> +<span class="dv">9</span></span></code></pre></div>
<p>textual-replicate returns the subtext of this text beginning at index from, and ending at to. It is an error if from is greater than to.</p>
<p>You can use textual-replicate to perform a variety of tasks:</p>
<ul>
<li><p>To rotate a text left: (textual-replicate “abcdef” 2 8) =&gt; «cdefab»</p></li>
<li><p>To rotate a text right: (textual-replicate “abcdef” -2 4) =&gt; «efabcd»</p></li>
<li><p>To replicate a text: (textual-replicate “abc” 0 7) =&gt; «abcabca»</p></li>
</ul>
<p>Note that</p>
<ul>
<li><p>The from/to arguments give a half-open range containing the characters from index from up to, but not including, index to.</p></li>
<li><p>The from/to indexes are not expressed in the index space of textual. They refer instead to the replicated index space of the subtext defined by textual, start, and end.</p></li>
</ul>
<p>It is an error if start=end, unless from=to, which is allowed as a special case.</p>
<h2 id="textual-split-textual-delimiter-grammar-limit-start-end"><code>(textual-split textual delimiter [grammar limit start end])</code></h2>
<p>Returns a list of texts representing the words contained in the subtext of textual from start (inclusive) to end (exclusive). The delimiter is a text or string to be used as the word separator. This will often be a single character, but multiple characters are allowed for use cases such as splitting on “”. The returned list will have one more item than the number of non-overlapping occurrences of the delimiter in the text. If delimiter is an empty text, then the returned list contains a list of texts, each of which contains a single character.</p>
<p>The grammar is a symbol with the same meaning as in the textual-join procedure. If it is infix, which is the default, processing is done as described above, except an empty textual produces the empty list; if grammar is strict-infix, then an empty textual signals an error. The values prefix and suffix cause a leading/trailing empty text in the result to be suppressed.</p>
<p>If limit is a non-negative exact integer, at most that many splits occur, and the remainder of textual is returned as the final element of the list (so the result will have at most limit+1 elements). If limit is not specified or is #f, then as many splits as possible are made. It is an error if limit is any other value.</p>
<p>To split on a regular expression re, use SRFI 115’s regexp-split procedure:</p>
<div class="sourceCode" id="cb382"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb382-1"><a href="#cb382-1" aria-hidden="true"></a>(map string-&gt;text (regexp-split re (textual-&gt;string txt)))</span></code></pre></div>
<p>Rationale: Although it would be more efficient to have a version of regexp-split that operates on texts directly, the scope of this SRFI is limited to specifying operations on texts analogous to those specified for strings by R7RS and SRFI 130. # <code>(scheme process-context)</code></p>
<h2 id="command-line"><code>(command-line)</code></h2>
<p>Returns the command line passed to the process as a list of strings. The first string corresponds to the command name, and is implementation-dependent. It is an error to mutate any of these .</p>
<h2 id="emergency-exit-obj"><code>(emergency-exit [obj])</code></h2>
<p>Terminates the program without running any outstanding dynamic-wind after procedures and communicates an exit value to the operating sstem the same manner as exit.</p>
<h2 id="exit-obj"><code>(exit [obj])</code></h2>
<p>Runs all outstanding dynamic-wind after procedures, terminates the running program, and communicates an exit value to the operating system. If no argument is supplied, or if obj is #t, the exit procedure should communicate to the operating system that the program exited normally. If obj is #f, the exit procedure should communicate to the operating system that the program exited abnormally. Otherwise, exit should translate obj into an appropriate exit value for the oerating , if possible.</p>
<h2 id="get-environment-variable-name"><code>(get-environment-variable name)</code></h2>
<p>Many operating systems provide each running process with an environment consisting of environment variables. Both the name and value of an environment variable are strings. The procedure get-environment-variable returns the value of the environment variable name, or #f if the named environment variable is not found. It may use locale information to encode the name and decode the value of the environment variable. It is an error if get-environment-variable canâ€™t decode the value. It is also an error to mutate the resulting .</p>
<h2 id="get-environment-variables"><code>(get-environment-variables)</code></h2>
<p>Returns the names and values of all the environment variables as an alist, where the car of each entry is the name of an environment variable and the cdr is its value, both as strings. The order of the list is unspecified. It is an error to mutate any of these strings or the alist itself. # <code>(scheme r5rs)</code></p>
<p>Thie library export<a href="https://bitbucket.org/cowan/r7rs/src/draft-10/rnrs/">R5RS</a> forms. It is based on the following libraries:</p>
<ul>
<li><code>(scheme base)</code></li>
<li><code>(scheme inexact)</code></li>
<li><code>(scheme complex)</code></li>
<li><code>(scheme cxr)</code></li>
<li><code>(scheme file)</code></li>
<li><code>(scheme char)</code></li>
<li><code>(scheme read)</code></li>
<li><code>(scheme write)</code></li>
<li><code>(scheme eval)</code></li>
<li><code>(scheme repl)</code></li>
<li><code>(scheme load)</code></li>
<li><code>(scheme lazy)</code>t</li>
</ul>
<p>It exports the following forms:</p>
<ul>
<li><code>*</code></li>
<li><code>+</code></li>
<li><code>-</code></li>
<li><code>/</code></li>
<li><code>&lt;</code></li>
<li><code>&lt;=</code></li>
<li><code>=</code></li>
<li><code>&gt;</code></li>
<li><code>&gt;=</code></li>
<li><code>abs</code></li>
<li><code>acos</code></li>
<li><code>and</code></li>
<li><code>angle</code></li>
<li><code>append</code></li>
<li><code>apply</code></li>
<li><code>asin</code></li>
<li><code>assoc</code></li>
<li><code>assq</code></li>
<li><code>assv</code></li>
<li><code>atan</code></li>
<li><code>begin</code></li>
<li><code>boolean?</code></li>
<li><code>caaaar</code></li>
<li><code>caaadr</code></li>
<li><code>caaar</code></li>
<li><code>caadar</code></li>
<li><code>caaddr</code></li>
<li><code>caadr</code></li>
<li><code>caar</code></li>
<li><code>cadaar</code></li>
<li><code>cadadr</code></li>
<li><code>cadar</code></li>
<li><code>caddar</code></li>
<li><code>cadddr</code></li>
<li><code>caddr</code></li>
<li><code>cadr</code></li>
<li><code>call-with-current-continuation</code></li>
<li><code>call-with-input-file</code></li>
<li><code>call-with-output-file</code></li>
<li><code>call-with-values</code></li>
<li><code>car</code></li>
<li><code>case</code></li>
<li><code>cdaaar</code></li>
<li><code>cdaadr</code></li>
<li><code>cdaar</code></li>
<li><code>cdadar</code></li>
<li><code>cdaddr</code></li>
<li><code>cdadr</code></li>
<li><code>cdar</code></li>
<li><code>cddaar</code></li>
<li><code>cddadr</code></li>
<li><code>cddar</code></li>
<li><code>cdddar</code></li>
<li><code>cddddr</code></li>
<li><code>cdddr</code></li>
<li><code>cddr</code></li>
<li><code>cdr</code></li>
<li><code>ceiling</code></li>
<li><code>char-&gt;integer</code></li>
<li><code>char-alphabetic?</code></li>
<li><code>char-ci&lt;=?</code></li>
<li><code>char-ci&lt;?</code></li>
<li><code>char-ci=?</code></li>
<li><code>char-ci&gt;=?</code></li>
<li><code>char-ci&gt;?</code></li>
<li><code>char-downcase</code></li>
<li><code>char-lower-case?</code></li>
<li><code>char-numeric?</code></li>
<li><code>char-ready?</code></li>
<li><code>char-upcase</code></li>
<li><code>char-upper-case?</code></li>
<li><code>char-whitespace?</code></li>
<li><code>char&lt;=?</code></li>
<li><code>char&lt;?</code></li>
<li><code>char=?</code></li>
<li><code>char&gt;=?</code></li>
<li><code>char&gt;?</code></li>
<li><code>char?</code></li>
<li><code>close-input-port</code></li>
<li><code>close-output-port</code></li>
<li><code>complex?</code></li>
<li><code>cond</code></li>
<li><code>cons</code></li>
<li><code>cos</code></li>
<li><code>current-input-port</code></li>
<li><code>current-output-port</code></li>
<li><code>define</code></li>
<li><code>define-syntax</code></li>
<li><code>delay</code></li>
<li><code>denominator</code></li>
<li><code>display</code></li>
<li><code>do</code></li>
<li><code>dynamic-wind</code></li>
<li><code>eof-object?</code></li>
<li><code>eq?</code></li>
<li><code>equal?</code></li>
<li><code>eqv?</code></li>
<li><code>eval</code></li>
<li><code>even?</code></li>
<li><code>exact-&gt;inexact</code></li>
<li><code>exact?</code></li>
<li><code>exp</code></li>
<li><code>expt</code></li>
<li><code>floor</code></li>
<li><code>for-each</code></li>
<li><code>force</code></li>
<li><code>gcd</code></li>
<li><code>if</code></li>
<li><code>imag-part</code></li>
<li><code>inexact-&gt;exact</code></li>
<li><code>inexact?</code></li>
<li><code>input-port?</code></li>
<li><code>integer-&gt;char</code></li>
<li><code>integer?</code></li>
<li><code>interaction-environment</code></li>
<li><code>lambda</code></li>
<li><code>lcm</code></li>
<li><code>length</code></li>
<li><code>let</code></li>
<li><code>let*</code></li>
<li><code>let-syntax</code></li>
<li><code>letrec</code></li>
<li><code>letrec-syntax</code></li>
<li><code>list</code></li>
<li><code>list-&gt;string</code></li>
<li><code>list-&gt;vector</code></li>
<li><code>list-ref</code></li>
<li><code>list-tail</code></li>
<li><code>list?</code></li>
<li><code>load</code></li>
<li><code>log</code></li>
<li><code>magnitude</code></li>
<li><code>make-polar</code></li>
<li><code>make-rectangular</code></li>
<li><code>make-string</code></li>
<li><code>make-vector</code></li>
<li><code>map</code></li>
<li><code>max</code></li>
<li><code>member</code></li>
<li><code>memq</code></li>
<li><code>memv</code></li>
<li><code>min</code></li>
<li><code>modulo</code></li>
<li><code>negative?</code></li>
<li><code>newline</code></li>
<li><code>not</code></li>
<li><code>null-environment</code></li>
<li><code>null?</code></li>
<li><code>number-&gt;string</code></li>
<li><code>number?</code></li>
<li><code>numerator</code></li>
<li><code>odd?</code></li>
<li><code>open-input-file</code></li>
<li><code>open-output-file</code></li>
<li><code>or</code></li>
<li><code>output-port?</code></li>
<li><code>pair?</code></li>
<li><code>peek-char</code></li>
<li><code>positive?</code></li>
<li><code>procedure?</code></li>
<li><code>quasiquote</code></li>
<li><code>quote</code></li>
<li><code>quotient</code></li>
<li><code>rational?</code></li>
<li><code>rationalize</code></li>
<li><code>read</code></li>
<li><code>read-char</code></li>
<li><code>real-part</code></li>
<li><code>real?</code></li>
<li><code>remainder</code></li>
<li><code>reverse</code></li>
<li><code>round</code></li>
<li><code>scheme-report-environment</code></li>
<li><code>set!</code></li>
<li><code>set-car!</code></li>
<li><code>set-cdr!</code></li>
<li><code>sin</code></li>
<li><code>sqrt</code></li>
<li><code>string</code></li>
<li><code>string-&gt;list</code></li>
<li><code>string-&gt;number</code></li>
<li><code>string-&gt;symbol</code></li>
<li><code>string-append</code></li>
<li><code>string-ci&lt;=?</code></li>
<li><code>string-ci&lt;?</code></li>
<li><code>string-ci=?</code></li>
<li><code>string-ci&gt;=?</code></li>
<li><code>string-ci&gt;?</code></li>
<li><code>string-copy</code></li>
<li><code>string-fill!</code></li>
<li><code>string-length</code></li>
<li><code>string-ref</code></li>
<li><code>string-set!</code></li>
<li><code>string&lt;=?</code></li>
<li><code>string&lt;?</code></li>
<li><code>string=?</code></li>
<li><code>string&gt;=?</code></li>
<li><code>string&gt;?</code></li>
<li><code>string?</code></li>
<li><code>substring</code></li>
<li><code>symbol-&gt;string</code></li>
<li><code>symbol?</code></li>
<li><code>syntax-rules</code></li>
<li><code>tan</code></li>
<li><code>truncate</code></li>
<li><code>values</code></li>
<li><code>vector</code></li>
<li><code>vector-&gt;list</code></li>
<li><code>vector-fill!</code></li>
<li><code>vector-length</code></li>
<li><code>vector-ref</code></li>
<li><code>vector-set!</code></li>
<li><code>vector?</code></li>
<li><code>with-input-from-file</code></li>
<li><code>with-output-to-file</code></li>
<li><code>write</code></li>
<li><code>write-char</code></li>
<li><code>zero?</code> # <code>(scheme stream)</code></li>
</ul>
<p>This is based on <a href="https://srfi.schemers.org/srfi-41/">SRFI-41</a>.</p>
<p>Streams, sometimes called lazy lists, are a sequential data structure containing elements computed only on demand. A stream is either null or is a pair with a stream in its cdr. Since elements of a stream are computed only when accessed, streams can be infinite. Once computed, the value of a stream element is cached in case it is needed again.</p>
<p>Streams without memoization were first described by Peter Landin in 1965. Memoization became accepted as an essential feature of streams about a decade later. Today, streams are the signature data type of functional programming languages such as Haskell.</p>
<p>This Scheme Request for Implementation describes two libraries for operating on streams: a canonical set of stream primitives and a set of procedures and syntax derived from those primitives that permits convenient expression of stream operations. They rely on facilities provided by R6RS, including libraries, records, and error reporting. To load both stream libraries, say:</p>
<pre><code>(import (scheme stream))</code></pre>
<h2 id="stream-null"><code>stream-null</code></h2>
<p>Stream-null is a promise that, when forced, is a single object, distinguishable from all other objects, that represents the null stream. Stream-null is immutable and unique.</p>
<h2 id="stream-cons-object-stream"><code>(stream-cons object stream)</code></h2>
<p>Stream-cons is a macro that accepts an object and a stream and creates a newly-allocated stream containing a promise that, when forced, is a stream-pair with the object in its stream-car and the stream in its stream-cdr. Stream-cons must be syntactic, not procedural, because neither object nor stream is evaluated when stream-cons is called. Since stream is not evaluated, when the stream-pair is created, it is not an error to call stream-cons with a stream that is not of type stream; however, doing so will cause an error later when the stream-cdr of the stream-pair is accessed. Once created, a stream-pair is immutable; there is no stream-set-car! or stream-set-cdr! that modifies an existing stream-pair. There is no dotted-pair or improper stream as with lists.</p>
<h2 id="stream-object"><code>(stream? object)</code></h2>
<p>Stream? is a procedure that takes an object and returns #t if the object is a stream and #f otherwise. If object is a stream, stream? does not force its promise. If (stream? obj) is #t, then one of (stream-null? obj) and (stream-pair? obj) will be #t and the other will be #f; if (stream? obj) is #f, both (stream-null? obj) and (stream-pair? obj) will be #f.</p>
<h2 id="stream-null-object"><code>(stream-null? object)</code></h2>
<p>Stream-null? is a procedure that takes an object and returns #t if the object is the distinguished null stream and #f otherwise. If object is a stream, stream-null? must force its promise in order to distinguish stream-null from stream-pair.</p>
<h2 id="stream-pair-object"><code>(stream-pair? object)</code></h2>
<p>Stream-pair? is a procedure that takes an object and returns #t if the object is a stream-pair constructed by stream-cons and #f otherwise. If object is a stream, stream-pair? must force its promise in order to distinguish stream-null from stream-pair.</p>
<h2 id="stream-car-stream"><code>(stream-car stream)</code></h2>
<p>Stream-car is a procedure that takes a stream and returns the object stored in the stream-car of the stream. Stream-car signals an error if the object passed to it is not a stream-pair. Calling stream-car causes the object stored there to be evaluated if it has not yet been; the object’s value is cached in case it is needed again.</p>
<h2 id="stream-cdr-stream">`(stream-cdr stream)</h2>
<p>Stream-cdr is a procedure that takes a stream and returns the stream stored in the stream-cdr of the stream. Stream-cdr signals an error if the object passed to it is not a stream-pair. Calling stream-cdr does not force the promise containing the stream stored in the stream-cdr of the stream.</p>
<h2 id="stream-lambda-args-body"><code>(stream-lambda args body)</code></h2>
<p>Stream-lambda creates a procedure that returns a promise to evaluate the body of the procedure. The last body expression to be evaluated must yield a stream. As with normal lambda, args may be a single variable name, in which case all the formal arguments are collected into a single list, or a list of variable names, which may be null if there are no arguments, proper if there are an exact number of arguments, or dotted if a fixed number of arguments is to be followed by zero or more arguments collected into a list. Body must contain at least one expression, and may contain internal definitions preceding any expressions to be evaluated.</p>
<div class="sourceCode" id="cb384"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb384-1"><a href="#cb384-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> strm123</span></span>
<span id="cb384-2"><a href="#cb384-2" aria-hidden="true"></a>  (stream-cons <span class="dv">1</span></span>
<span id="cb384-3"><a href="#cb384-3" aria-hidden="true"></a>    (stream-cons <span class="dv">2</span></span>
<span id="cb384-4"><a href="#cb384-4" aria-hidden="true"></a>      (stream-cons <span class="dv">3</span></span>
<span id="cb384-5"><a href="#cb384-5" aria-hidden="true"></a>        stream-null))))</span>
<span id="cb384-6"><a href="#cb384-6" aria-hidden="true"></a></span>
<span id="cb384-7"><a href="#cb384-7" aria-hidden="true"></a>(stream-car strm123) ⇒ <span class="dv">1</span></span>
<span id="cb384-8"><a href="#cb384-8" aria-hidden="true"></a></span>
<span id="cb384-9"><a href="#cb384-9" aria-hidden="true"></a>(stream-car (stream-cdr strm123) ⇒ <span class="dv">2</span></span>
<span id="cb384-10"><a href="#cb384-10" aria-hidden="true"></a></span>
<span id="cb384-11"><a href="#cb384-11" aria-hidden="true"></a>(stream-pair?</span>
<span id="cb384-12"><a href="#cb384-12" aria-hidden="true"></a>  (stream-cdr</span>
<span id="cb384-13"><a href="#cb384-13" aria-hidden="true"></a>    (stream-cons (<span class="op">/</span> <span class="dv">1</span> <span class="dv">0</span>) stream-null))) ⇒ <span class="dv">#f</span></span>
<span id="cb384-14"><a href="#cb384-14" aria-hidden="true"></a></span>
<span id="cb384-15"><a href="#cb384-15" aria-hidden="true"></a>(stream? (<span class="kw">list</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)) ⇒ <span class="dv">#f</span></span>
<span id="cb384-16"><a href="#cb384-16" aria-hidden="true"></a></span>
<span id="cb384-17"><a href="#cb384-17" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> iter</span></span>
<span id="cb384-18"><a href="#cb384-18" aria-hidden="true"></a>  (stream-lambda (f x)</span>
<span id="cb384-19"><a href="#cb384-19" aria-hidden="true"></a>    (stream-cons x (iter f (f x)))))</span>
<span id="cb384-20"><a href="#cb384-20" aria-hidden="true"></a></span>
<span id="cb384-21"><a href="#cb384-21" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> nats </span>(iter (<span class="kw">lambda</span> (x) (<span class="op">+</span> x <span class="dv">1</span>)) <span class="dv">0</span>))</span>
<span id="cb384-22"><a href="#cb384-22" aria-hidden="true"></a></span>
<span id="cb384-23"><a href="#cb384-23" aria-hidden="true"></a>(stream-car (stream-cdr nats)) ⇒ <span class="dv">1</span></span>
<span id="cb384-24"><a href="#cb384-24" aria-hidden="true"></a></span>
<span id="cb384-25"><a href="#cb384-25" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> stream-add</span></span>
<span id="cb384-26"><a href="#cb384-26" aria-hidden="true"></a>  (stream-lambda (s1 s2)</span>
<span id="cb384-27"><a href="#cb384-27" aria-hidden="true"></a>    (stream-cons</span>
<span id="cb384-28"><a href="#cb384-28" aria-hidden="true"></a>      (<span class="op">+</span> (stream-car s1) (stream-car s2))</span>
<span id="cb384-29"><a href="#cb384-29" aria-hidden="true"></a>      (stream-add (stream-cdr s1)</span>
<span id="cb384-30"><a href="#cb384-30" aria-hidden="true"></a>                  (stream-cdr s2)))))</span>
<span id="cb384-31"><a href="#cb384-31" aria-hidden="true"></a></span>
<span id="cb384-32"><a href="#cb384-32" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> evens </span>(stream-add nats nats))</span>
<span id="cb384-33"><a href="#cb384-33" aria-hidden="true"></a></span>
<span id="cb384-34"><a href="#cb384-34" aria-hidden="true"></a>(stream-car evens) ⇒ <span class="dv">0</span></span>
<span id="cb384-35"><a href="#cb384-35" aria-hidden="true"></a></span>
<span id="cb384-36"><a href="#cb384-36" aria-hidden="true"></a>(stream-car (stream-cdr evens)) ⇒ <span class="dv">2</span></span>
<span id="cb384-37"><a href="#cb384-37" aria-hidden="true"></a></span>
<span id="cb384-38"><a href="#cb384-38" aria-hidden="true"></a>(stream-car (stream-cdr (stream-cdr evens))) ⇒ <span class="dv">4</span></span></code></pre></div>
<h2 id="define-stream-name-args-body-syntax"><code>(define-stream (name args) body)</code> syntax</h2>
<p>Define-stream creates a procedure that returns a stream, and may appear anywhere a normal define may appear, including as an internal definition, and may have internal definitions of its own, including other define-streams. The defined procedure takes arguments in the same way as stream-lambda. Define-stream is syntactic sugar on stream-lambda; see also stream-let, which is also a sugaring of stream-lambda.</p>
<p>A simple version of stream-map that takes only a single input stream calls itself recursively:</p>
<pre><code>(define-stream (stream-map proc strm)
  (if (stream-null? strm)
      stream-null
      (stream-cons
        (proc (stream-car strm))
        (stream-map proc (stream-cdr strm))))))</code></pre>
<h2 id="list-stream-list-of-objects"><code>(list-&gt;stream list-of-objects)</code></h2>
<p>[α] → {α}</p>
<p>List-&gt;stream takes a list of objects and returns a newly-allocated stream containing in its elements the objects in the list. Since the objects are given in a list, they are evaluated when list-&gt;stream is called, before the stream is created. If the list of objects is null, as in (list-&gt;stream ’()), the null stream is returned. See also stream.</p>
<div class="sourceCode" id="cb386"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb386-1"><a href="#cb386-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> strm123 </span>(list-&gt;stream &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)))</span>
<span id="cb386-2"><a href="#cb386-2" aria-hidden="true"></a></span>
<span id="cb386-3"><a href="#cb386-3" aria-hidden="true"></a><span class="co">; fails with divide-by-zero error</span></span>
<span id="cb386-4"><a href="#cb386-4" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> s </span>(list-&gt;stream (<span class="kw">list</span> <span class="dv">1</span> (<span class="op">/</span> <span class="dv">1</span> <span class="dv">0</span>) <span class="dv">-1</span>)))</span></code></pre></div>
<h2 id="port-stream-port"><code>(port-&gt;stream [port])</code></h2>
<p>port → {char}</p>
<p>Port-&gt;stream takes a port and returns a newly-allocated stream containing in its elements the characters on the port. If port is not given it defaults to the current input port. The returned stream has finite length and is terminated by stream-null.</p>
<p>It looks like one use of port-&gt;stream would be this:</p>
<div class="sourceCode" id="cb387"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb387-1"><a href="#cb387-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> s </span><span class="co">;wrong!</span></span>
<span id="cb387-2"><a href="#cb387-2" aria-hidden="true"></a>  (<span class="kw">with-input-from-file</span> filename</span>
<span id="cb387-3"><a href="#cb387-3" aria-hidden="true"></a>    (<span class="kw">lambda</span> () (port-&gt;stream))))</span></code></pre></div>
<p>But that fails, because with-input-from-file is eager, and closes the input port prematurely, before the first character is read. To read a file into a stream, say:</p>
<div class="sourceCode" id="cb388"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb388-1"><a href="#cb388-1" aria-hidden="true"></a>(define-stream (file-&gt;stream filename)</span>
<span id="cb388-2"><a href="#cb388-2" aria-hidden="true"></a>  (<span class="kw">let</span> ((p (<span class="kw">open-input-file</span> filename)))</span>
<span id="cb388-3"><a href="#cb388-3" aria-hidden="true"></a>    (stream-let loop ((c (<span class="kw">read-char</span> p)))</span>
<span id="cb388-4"><a href="#cb388-4" aria-hidden="true"></a>      (<span class="kw">if</span> (<span class="kw">eof-object?</span> c)</span>
<span id="cb388-5"><a href="#cb388-5" aria-hidden="true"></a>          (<span class="kw">begin</span> (<span class="kw">close-input-port</span> p)</span>
<span id="cb388-6"><a href="#cb388-6" aria-hidden="true"></a>                 stream-null)</span>
<span id="cb388-7"><a href="#cb388-7" aria-hidden="true"></a>          (stream-cons c</span>
<span id="cb388-8"><a href="#cb388-8" aria-hidden="true"></a>            (loop (<span class="kw">read-char</span> p)))))))</span></code></pre></div>
<h2 id="stream-object-..."><code>(stream object ...)</code></h2>
<p>Stream is syntax that takes zero or more objects and creates a newly-allocated stream containing in its elements the objects, in order. Since stream is syntactic, the objects are evaluated when they are accessed, not when the stream is created. If no objects are given, as in (stream), the null stream is returned. See also list-&gt;stream.</p>
<div class="sourceCode" id="cb389"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb389-1"><a href="#cb389-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> strm123 </span>(stream <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>))</span>
<span id="cb389-2"><a href="#cb389-2" aria-hidden="true"></a></span>
<span id="cb389-3"><a href="#cb389-3" aria-hidden="true"></a><span class="co">; (/ 1 0) not evaluated when stream is created</span></span>
<span id="cb389-4"><a href="#cb389-4" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> s </span>(stream <span class="dv">1</span> (<span class="op">/</span> <span class="dv">1</span> <span class="dv">0</span>) <span class="dv">-1</span>))</span></code></pre></div>
<h2 id="stream-list-n-stream"><code>(stream-&gt;list [n] stream)</code></h2>
<p>nat × {α} → [α]</p>
<p>Stream-&gt;list takes a natural number n and a stream and returns a newly-allocated list containing in its elements the first n items in the stream. If the stream has less than n items all the items in the stream will be included in the returned list. If n is not given it defaults to infinity, which means that unless stream is finite stream-&gt;list will never return.</p>
<div class="sourceCode" id="cb390"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb390-1"><a href="#cb390-1" aria-hidden="true"></a>(stream-&gt;list <span class="dv">10</span></span>
<span id="cb390-2"><a href="#cb390-2" aria-hidden="true"></a>  (stream-map (<span class="kw">lambda</span> (x) (* x x))</span>
<span id="cb390-3"><a href="#cb390-3" aria-hidden="true"></a>    (stream-from <span class="dv">0</span>)))</span>
<span id="cb390-4"><a href="#cb390-4" aria-hidden="true"></a>  ⇒ (<span class="dv">0</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">9</span> <span class="dv">16</span> <span class="dv">25</span> <span class="dv">36</span> <span class="dv">49</span> <span class="dv">64</span> <span class="dv">81</span>)</span></code></pre></div>
<h2 id="stream-append-stream-..."><code>(stream-append stream ...)</code></h2>
<p>{α} … → {α}</p>
<p>Stream-append returns a newly-allocated stream containing in its elements those elements contained in its input streams, in order of input. If any of the input streams is infinite, no elements of any of the succeeding input streams will appear in the output stream; thus, if x is infinite, (stream-append x y) ≡ x. See also stream-concat.</p>
<p>Quicksort can be used to sort a stream, using stream-append to build the output; the sort is lazy; so if only the beginning of the output stream is needed, the end of the stream is never sorted.</p>
<div class="sourceCode" id="cb391"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb391-1"><a href="#cb391-1" aria-hidden="true"></a>(define-stream (qsort lt? strm)</span>
<span id="cb391-2"><a href="#cb391-2" aria-hidden="true"></a>  (<span class="kw">if</span> (stream-null? strm)</span>
<span id="cb391-3"><a href="#cb391-3" aria-hidden="true"></a>      stream-null</span>
<span id="cb391-4"><a href="#cb391-4" aria-hidden="true"></a>      (<span class="kw">let</span> ((x (stream-car strm))</span>
<span id="cb391-5"><a href="#cb391-5" aria-hidden="true"></a>            (xs (stream-cdr strm)))</span>
<span id="cb391-6"><a href="#cb391-6" aria-hidden="true"></a>        (stream-append</span>
<span id="cb391-7"><a href="#cb391-7" aria-hidden="true"></a>          (qsort lt?</span>
<span id="cb391-8"><a href="#cb391-8" aria-hidden="true"></a>            (stream-filter</span>
<span id="cb391-9"><a href="#cb391-9" aria-hidden="true"></a>              (<span class="kw">lambda</span> (u) (lt? u x))</span>
<span id="cb391-10"><a href="#cb391-10" aria-hidden="true"></a>              xs))</span>
<span id="cb391-11"><a href="#cb391-11" aria-hidden="true"></a>          (stream x)</span>
<span id="cb391-12"><a href="#cb391-12" aria-hidden="true"></a>          (qsort lt?</span>
<span id="cb391-13"><a href="#cb391-13" aria-hidden="true"></a>            (stream-filter</span>
<span id="cb391-14"><a href="#cb391-14" aria-hidden="true"></a>              (<span class="kw">lambda</span> (u) (<span class="kw">not</span> (lt? u x)))</span>
<span id="cb391-15"><a href="#cb391-15" aria-hidden="true"></a>              xs))))))</span></code></pre></div>
<p>Note also that, when used in tail position as in qsort, stream-append does not suffer the poor performance of append on lists. The list version of append requires re-traversal of all its list arguments except the last each time it is called. But stream-append is different. Each recursive call to stream-append is suspended; when it is later forced, the preceding elements of the result have already been traversed, so tail-recursive loops that produce streams are efficient even when each element is appended to the end of the result stream. This also implies that during traversal of the result only one promise needs to be kept in memory at a time.</p>
<h2 id="stream-concat-stream"><code>(stream-concat stream)</code></h2>
<p>{{α}} … → {α}</p>
<p>Stream-concat takes a stream consisting of one or more streams and returns a newly-allocated stream containing all the elements of the input streams. If any of the streams in the input stream is infinite, any remaining streams in the input stream will never appear in the output stream. See also stream-append.</p>
<div class="sourceCode" id="cb392"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb392-1"><a href="#cb392-1" aria-hidden="true"></a>(stream-&gt;list</span>
<span id="cb392-2"><a href="#cb392-2" aria-hidden="true"></a>  (stream-concat</span>
<span id="cb392-3"><a href="#cb392-3" aria-hidden="true"></a>    (stream</span>
<span id="cb392-4"><a href="#cb392-4" aria-hidden="true"></a>      (stream <span class="dv">1</span> <span class="dv">2</span>) (stream) (stream <span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span>))))</span>
<span id="cb392-5"><a href="#cb392-5" aria-hidden="true"></a>  ⇒ (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span>)</span></code></pre></div>
<p>The permutations of a finite stream can be determined by interleaving each element of the stream in all possible positions within each permutation of the other elements of the stream. Interleave returns a stream of streams with x inserted in each possible position of yy:</p>
<div class="sourceCode" id="cb393"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb393-1"><a href="#cb393-1" aria-hidden="true"></a>(define-stream (interleave x yy)</span>
<span id="cb393-2"><a href="#cb393-2" aria-hidden="true"></a>  (stream-match yy</span>
<span id="cb393-3"><a href="#cb393-3" aria-hidden="true"></a>    (() (stream (stream x)))</span>
<span id="cb393-4"><a href="#cb393-4" aria-hidden="true"></a>    ((y . ys)</span>
<span id="cb393-5"><a href="#cb393-5" aria-hidden="true"></a>      (stream-append</span>
<span id="cb393-6"><a href="#cb393-6" aria-hidden="true"></a>        (stream (stream-cons x yy))</span>
<span id="cb393-7"><a href="#cb393-7" aria-hidden="true"></a>        (stream-map</span>
<span id="cb393-8"><a href="#cb393-8" aria-hidden="true"></a>          (<span class="kw">lambda</span> (z) (stream-cons y z))</span>
<span id="cb393-9"><a href="#cb393-9" aria-hidden="true"></a>          (interleave x ys))))))</span>
<span id="cb393-10"><a href="#cb393-10" aria-hidden="true"></a></span>
<span id="cb393-11"><a href="#cb393-11" aria-hidden="true"></a>(define-stream (perms xs)</span>
<span id="cb393-12"><a href="#cb393-12" aria-hidden="true"></a>  (<span class="kw">if</span> (stream-null? xs)</span>
<span id="cb393-13"><a href="#cb393-13" aria-hidden="true"></a>      (stream (stream))</span>
<span id="cb393-14"><a href="#cb393-14" aria-hidden="true"></a>      (stream-concat</span>
<span id="cb393-15"><a href="#cb393-15" aria-hidden="true"></a>        (stream-map</span>
<span id="cb393-16"><a href="#cb393-16" aria-hidden="true"></a>          (<span class="kw">lambda</span> (ys)</span>
<span id="cb393-17"><a href="#cb393-17" aria-hidden="true"></a>            (interleave (stream-car xs) ys))</span>
<span id="cb393-18"><a href="#cb393-18" aria-hidden="true"></a>          (perms (stream-cdr xs))))))</span></code></pre></div>
<h2 id="stream-constant-object-..."><code>(stream-constant object ...)</code></h2>
<p>α … → {α}</p>
<p>Stream-constant takes one or more objects and returns a newly-allocated stream containing in its elements the objects, repeating the objects in succession forever.</p>
<div class="sourceCode" id="cb394"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb394-1"><a href="#cb394-1" aria-hidden="true"></a>(stream-constant <span class="dv">1</span>) ⇒ <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> ...</span>
<span id="cb394-2"><a href="#cb394-2" aria-hidden="true"></a></span>
<span id="cb394-3"><a href="#cb394-3" aria-hidden="true"></a></span>
<span id="cb394-4"><a href="#cb394-4" aria-hidden="true"></a>(stream-constant <span class="dv">#t</span> <span class="dv">#f</span>) ⇒ <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> ...</span></code></pre></div>
<h2 id="stream-drop-n-stream-procedure"><code>(stream-drop n stream) procedure</code></h2>
<p>nat × {α} → {α}</p>
<p>Stream-drop returns the suffix of the input stream that starts at the next element after the first n elements. The output stream shares structure with the input stream; thus, promises forced in one instance of the stream are also forced in the other instance of the stream. If the input stream has less than n elements, stream-drop returns the null stream. See also stream-take.</p>
<div class="sourceCode" id="cb395"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb395-1"><a href="#cb395-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(stream-split n strm)</span>
<span id="cb395-2"><a href="#cb395-2" aria-hidden="true"></a>  (<span class="kw">values</span> (stream-take n strm)</span>
<span id="cb395-3"><a href="#cb395-3" aria-hidden="true"></a>          (stream-drop n strm)))</span></code></pre></div>
<h2 id="stream-drop-while-pred-stream"><code>(stream-drop-while pred? stream)</code></h2>
<p>(α → boolean) × {α} → {α}</p>
<p>Stream-drop-while returns the suffix of the input stream that starts at the first element x for which (pred? x) is #f. The output stream shares structure with the input stream. See also stream-take-while.</p>
<p>Stream-unique creates a new stream that retains only the first of any sub-sequences of repeated elements.</p>
<div class="sourceCode" id="cb396"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb396-1"><a href="#cb396-1" aria-hidden="true"></a>(define-stream (stream-unique eql? strm)</span>
<span id="cb396-2"><a href="#cb396-2" aria-hidden="true"></a>  (<span class="kw">if</span> (stream-null? strm)</span>
<span id="cb396-3"><a href="#cb396-3" aria-hidden="true"></a>      stream-null</span>
<span id="cb396-4"><a href="#cb396-4" aria-hidden="true"></a>      (stream-cons (stream-car strm)</span>
<span id="cb396-5"><a href="#cb396-5" aria-hidden="true"></a>        (stream-unique eql?</span>
<span id="cb396-6"><a href="#cb396-6" aria-hidden="true"></a>          (stream-drop-while</span>
<span id="cb396-7"><a href="#cb396-7" aria-hidden="true"></a>            (<span class="kw">lambda</span> (x)</span>
<span id="cb396-8"><a href="#cb396-8" aria-hidden="true"></a>              (eql? (stream-car strm) x))</span>
<span id="cb396-9"><a href="#cb396-9" aria-hidden="true"></a>            strm)))))</span></code></pre></div>
<h2 id="stream-filter-pred-stream"><code>(stream-filter pred? stream)</code></h2>
<p>(α → boolean) × {α} → {α}</p>
<p>Stream-filter returns a newly-allocated stream that contains only those elements x of the input stream for which (pred? x) is non-#f.</p>
<div class="sourceCode" id="cb397"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb397-1"><a href="#cb397-1" aria-hidden="true"></a>(stream-filter <span class="kw">odd?</span> (stream-from <span class="dv">0</span>))</span>
<span id="cb397-2"><a href="#cb397-2" aria-hidden="true"></a>   ⇒ <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">7</span> <span class="dv">9</span> ...</span></code></pre></div>
<h2 id="stream-fold-proc-base-stream"><code>(stream-fold proc base stream)</code></h2>
<p>(α × β → α) × α × {β} → α</p>
<p>Stream-fold applies a binary procedure to base and the first element of stream to compute a new base, then applies the procedure to the new base and the next element of stream to compute a succeeding base, and so on, accumulating a value that is finally returned as the value of stream-fold when the end of the stream is reached. Stream must be finite, or stream-fold will enter an infinite loop. See also stream-scan, which is similar to stream-fold, but useful for infinite streams. For readers familiar with other functional languages, this is a left-fold; there is no corresponding right-fold, since right-fold relies on finite streams that are fully-evaluated, at which time they may as well be converted to a list.</p>
<p>Stream-fold is often used to summarize a stream in a single value, for instance, to compute the maximum element of a stream.</p>
<div class="sourceCode" id="cb398"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb398-1"><a href="#cb398-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(stream-maximum lt? strm)</span>
<span id="cb398-2"><a href="#cb398-2" aria-hidden="true"></a>  (stream-fold</span>
<span id="cb398-3"><a href="#cb398-3" aria-hidden="true"></a>    (<span class="kw">lambda</span> (x y) (<span class="kw">if</span> (lt? x y) y x))</span>
<span id="cb398-4"><a href="#cb398-4" aria-hidden="true"></a>    (stream-car strm)</span>
<span id="cb398-5"><a href="#cb398-5" aria-hidden="true"></a>    (stream-cdr strm)))</span></code></pre></div>
<p>Sometimes, it is useful to have stream-fold defined only on non-null streams:</p>
<div class="sourceCode" id="cb399"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb399-1"><a href="#cb399-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(stream-fold-one proc strm)</span>
<span id="cb399-2"><a href="#cb399-2" aria-hidden="true"></a>  (stream-fold proc</span>
<span id="cb399-3"><a href="#cb399-3" aria-hidden="true"></a>    (stream-car strm)</span>
<span id="cb399-4"><a href="#cb399-4" aria-hidden="true"></a>    (stream-cdr strm)))</span></code></pre></div>
<p>Stream-minimum can then be defined as:</p>
<div class="sourceCode" id="cb400"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb400-1"><a href="#cb400-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(stream-minimum lt? strm)</span>
<span id="cb400-2"><a href="#cb400-2" aria-hidden="true"></a>  (stream-fold-one</span>
<span id="cb400-3"><a href="#cb400-3" aria-hidden="true"></a>    (<span class="kw">lambda</span> (x y) (<span class="kw">if</span> (lt? x y) x y))</span>
<span id="cb400-4"><a href="#cb400-4" aria-hidden="true"></a>    strm))</span></code></pre></div>
<p>Stream-fold can also be used to build a stream:</p>
<div class="sourceCode" id="cb401"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb401-1"><a href="#cb401-1" aria-hidden="true"></a>(define-stream (isort lt? strm)</span>
<span id="cb401-2"><a href="#cb401-2" aria-hidden="true"></a>    (define-stream (insert strm x)</span>
<span id="cb401-3"><a href="#cb401-3" aria-hidden="true"></a>      (stream-match strm</span>
<span id="cb401-4"><a href="#cb401-4" aria-hidden="true"></a>        (() (stream x))</span>
<span id="cb401-5"><a href="#cb401-5" aria-hidden="true"></a>        ((y . ys)</span>
<span id="cb401-6"><a href="#cb401-6" aria-hidden="true"></a>          (<span class="kw">if</span> (lt? y x)</span>
<span id="cb401-7"><a href="#cb401-7" aria-hidden="true"></a>              (stream-cons y (insert ys x))</span>
<span id="cb401-8"><a href="#cb401-8" aria-hidden="true"></a>              (stream-cons x strm)))))</span>
<span id="cb401-9"><a href="#cb401-9" aria-hidden="true"></a>    (stream-fold insert stream-null strm))</span></code></pre></div>
<h2 id="stream-for-each-proc-stream-..."><code>(stream-for-each proc stream ...)</code></h2>
<p>(α × β × …) × {α} × {β} …</p>
<p>Stream-for-each applies a procedure element-wise to corresponding elements of the input streams for its side-effects; it returns nothing. Stream-for-each stops as soon as any of its input streams is exhausted.</p>
<p>The following procedure displays the contents of a file:</p>
<div class="sourceCode" id="cb402"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb402-1"><a href="#cb402-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(display-file filename)</span>
<span id="cb402-2"><a href="#cb402-2" aria-hidden="true"></a>  (stream-for-each <span class="kw">display</span></span>
<span id="cb402-3"><a href="#cb402-3" aria-hidden="true"></a>    (file-&gt;stream filename)))</span></code></pre></div>
<h2 id="stream-from-first-step"><code>(stream-from first [step])</code></h2>
<p>number × number → {number}</p>
<p>Stream-from creates a newly-allocated stream that contains first as its first element and increments each succeeding element by step. If step is not given it defaults to 1. First and step may be of any numeric type. Stream-from is frequently useful as a generator in stream-of expressions. See also stream-range for a similar procedure that creates finite streams.</p>
<p>Stream-from could be implemented as (stream-iterate (lambda (x) (+ x step)) first).</p>
<div class="sourceCode" id="cb403"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb403-1"><a href="#cb403-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> nats </span>(stream-from <span class="dv">0</span>)) ⇒ <span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> ...</span>
<span id="cb403-2"><a href="#cb403-2" aria-hidden="true"></a></span>
<span id="cb403-3"><a href="#cb403-3" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> odds </span>(stream-from <span class="dv">1</span> <span class="dv">2</span>)) ⇒ <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> ...</span></code></pre></div>
<h2 id="stream-iterate-proc-base"><code>(stream-iterate proc base)</code></h2>
<p>(α → α) × α → {α}</p>
<p>Stream-iterate creates a newly-allocated stream containing base in its first element and applies proc to each element in turn to determine the succeeding element. See also stream-unfold and stream-unfolds.</p>
<div class="sourceCode" id="cb404"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb404-1"><a href="#cb404-1" aria-hidden="true"></a>(stream-iterate (<span class="kw">lambda</span> (x) (<span class="op">+</span> x <span class="dv">1</span>)) <span class="dv">0</span>)</span>
<span id="cb404-2"><a href="#cb404-2" aria-hidden="true"></a>  ⇒ <span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> ...</span>
<span id="cb404-3"><a href="#cb404-3" aria-hidden="true"></a></span>
<span id="cb404-4"><a href="#cb404-4" aria-hidden="true"></a>(stream-iterate (<span class="kw">lambda</span> (x) (* x <span class="dv">2</span>)) <span class="dv">1</span>)</span>
<span id="cb404-5"><a href="#cb404-5" aria-hidden="true"></a>  ⇒ <span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span> <span class="dv">8</span> <span class="dv">16</span> ...</span></code></pre></div>
<p>Given a seed between 0 and 232, exclusive, the following expression creates a stream of pseudo-random integers between 0 and 232, exclusive, beginning with seed, using the method described by Stephen Park and Keith Miller:</p>
<div class="sourceCode" id="cb405"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb405-1"><a href="#cb405-1" aria-hidden="true"></a>(stream-iterate</span>
<span id="cb405-2"><a href="#cb405-2" aria-hidden="true"></a>  (<span class="kw">lambda</span> (x) (<span class="kw">modulo</span> (* x <span class="dv">16807</span>) <span class="dv">2147483647</span>))</span>
<span id="cb405-3"><a href="#cb405-3" aria-hidden="true"></a>  seed)</span></code></pre></div>
<p>Successive values of the continued fraction shown below approach the value of the “golden ratio” φ ≈ 1.618:</p>
<p>Continued fraction</p>
<p>The fractions can be calculated by the stream</p>
<div class="sourceCode" id="cb406"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb406-1"><a href="#cb406-1" aria-hidden="true"></a>(stream-iterate (<span class="kw">lambda</span> (x) (<span class="op">+</span> <span class="dv">1</span> (<span class="op">/</span> x))) <span class="dv">1</span>)</span></code></pre></div>
<h2 id="stream-length-stream"><code>(stream-length stream)</code></h2>
<p>{α} → nat</p>
<p>Stream-length takes an input stream and returns the number of elements in the stream; it does not evaluate its elements. Stream-length may only be used on finite streams; it enters an infinite loop with infinite streams.</p>
<div class="sourceCode" id="cb407"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb407-1"><a href="#cb407-1" aria-hidden="true"></a>(stream-length strm123) ⇒ <span class="dv">3</span></span></code></pre></div>
<h2 id="stream-let-tag-var-expr-...-body-syntax"><code>(stream-let tag ((var expr) ...) body)</code> syntax</h2>
<p>Stream-let creates a local scope that binds each variable to the value of its corresponding expression. It additionally binds tag to a procedure which takes the bound variables as arguments and body as its defining expressions, binding the tag with stream-lambda. Tag is in scope within body, and may be called recursively. When the expanded expression defined by the stream-let is evaluated, stream-let evaluates the expressions in its body in an environment containing the newly-bound variables, returning the value of the last expression evaluated, which must yield a stream.</p>
<p>Stream-let provides syntactic sugar on stream-lambda, in the same manner as normal let provides syntactic sugar on normal lambda. However, unlike normal let, the tag is required, not optional, because unnamed stream-let is meaningless.</p>
<p>Stream-member returns the first stream-pair of the input strm with a stream-car x that satisfies (eql? obj x), or the null stream if x is not present in strm.</p>
<div class="sourceCode" id="cb408"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb408-1"><a href="#cb408-1" aria-hidden="true"></a>(define-stream (stream-member eql? obj strm)</span>
<span id="cb408-2"><a href="#cb408-2" aria-hidden="true"></a>  (stream-let loop ((strm strm))</span>
<span id="cb408-3"><a href="#cb408-3" aria-hidden="true"></a>    (<span class="kw">cond</span> ((stream-null? strm) strm)</span>
<span id="cb408-4"><a href="#cb408-4" aria-hidden="true"></a>          ((eql? obj (stream-car strm)) strm)</span>
<span id="cb408-5"><a href="#cb408-5" aria-hidden="true"></a>          (<span class="kw">else</span> (loop (stream-cdr strm))))))</span></code></pre></div>
<h2 id="stream-map-proc-stream-..."><code>(stream-map proc stream ...)</code></h2>
<p>(α × β … → ω) × {α} × {β} … → {ω}</p>
<p>Stream-map applies a procedure element-wise to corresponding elements of the input streams, returning a newly-allocated stream containing elements that are the results of those procedure applications. The output stream has as many elements as the minimum-length input stream, and may be infinite.</p>
<div class="sourceCode" id="cb409"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb409-1"><a href="#cb409-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(square x) (* x x))</span>
<span id="cb409-2"><a href="#cb409-2" aria-hidden="true"></a></span>
<span id="cb409-3"><a href="#cb409-3" aria-hidden="true"></a>(stream-map square (stream <span class="dv">9</span> <span class="dv">3</span>)) ⇒ <span class="dv">81</span> <span class="dv">9</span></span>
<span id="cb409-4"><a href="#cb409-4" aria-hidden="true"></a></span>
<span id="cb409-5"><a href="#cb409-5" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(sigma f m n)</span>
<span id="cb409-6"><a href="#cb409-6" aria-hidden="true"></a>  (stream-fold <span class="op">+</span> <span class="dv">0</span></span>
<span id="cb409-7"><a href="#cb409-7" aria-hidden="true"></a>    (stream-map f (stream-range m (<span class="op">+</span> n <span class="dv">1</span>)))))</span>
<span id="cb409-8"><a href="#cb409-8" aria-hidden="true"></a></span>
<span id="cb409-9"><a href="#cb409-9" aria-hidden="true"></a>(sigma square <span class="dv">1</span> <span class="dv">100</span>) ⇒ <span class="dv">338350</span></span></code></pre></div>
<p>In some functional languages, stream-map takes only a single input stream, and stream-zipwith provides a companion function that takes multiple input streams.</p>
<h2 id="stream-match-stream-clause-...-syntax"><code>(stream-match stream clause ...)</code> syntax</h2>
<p>Stream-match provides the syntax of pattern-matching for streams. The input stream is an expression that evaluates to a stream. Clauses are of the form (pattern [fender] expr), consisting of a pattern that matches a stream of a particular shape, an optional fender that must succeed if the pattern is to match, and an expression that is evaluated if the pattern matches. There are four types of patterns:</p>
<ul>
<li>() — Matches the null stream.</li>
<li>(pat0 pat1 …) — Matches a finite stream with length exactly equal to the number of pattern elements.</li>
<li>(pat0 pat1 … . patrest) — Matches an infinite stream, or a finite stream with length at least as great as the number of pattern elements before the literal dot.</li>
<li>pat — Matches an entire stream. Should always appear last in the list of clauses; it’s not an error to appear elsewhere, but subsequent clauses could never match.</li>
</ul>
<p>Each pattern element pati may be either:</p>
<ul>
<li>An identifier — Matches any stream element. Additionally, the value of the stream element is bound to the variable named by the identifier, which is in scope in the fender and expression of the corresponding clause. Each identifier in a single pattern must be unique.</li>
<li>A literal underscore — Matches any stream element, but creates no bindings.</li>
</ul>
<p>The patterns are tested in order, left-to-right, until a matching pattern is found; if fender is present, it must evaluate as non-#f for the match to be successful. Pattern variables are bound in the corresponding fender and expression. Once the matching pattern is found, the corresponding expression is evaluated and returned as the result of the match. An error is signaled if no pattern matches the input stream.</p>
<p>Stream-match is often used to distinguish null streams from non-null streams, binding head and tail:</p>
<div class="sourceCode" id="cb410"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb410-1"><a href="#cb410-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(len strm)</span>
<span id="cb410-2"><a href="#cb410-2" aria-hidden="true"></a>  (stream-match strm</span>
<span id="cb410-3"><a href="#cb410-3" aria-hidden="true"></a>    (() <span class="dv">0</span>)</span>
<span id="cb410-4"><a href="#cb410-4" aria-hidden="true"></a>    ((head . tail) (<span class="op">+</span> <span class="dv">1</span> (len tail)))))</span></code></pre></div>
<p>Fenders can test the common case where two stream elements must be identical; the else pattern is an identifier bound to the entire stream, not a keyword as in cond.</p>
<div class="sourceCode" id="cb411"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb411-1"><a href="#cb411-1" aria-hidden="true"></a>(stream-match strm</span>
<span id="cb411-2"><a href="#cb411-2" aria-hidden="true"></a>  ((x y . _) (<span class="kw">equal?</span> x y) &#39;ok)</span>
<span id="cb411-3"><a href="#cb411-3" aria-hidden="true"></a>  (<span class="kw">else</span> &#39;error))</span></code></pre></div>
<p>A more complex example uses two nested matchers to match two different stream arguments; (stream-merge lt? . strms) stably merges two or more streams ordered by the lt? predicate:</p>
<div class="sourceCode" id="cb412"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb412-1"><a href="#cb412-1" aria-hidden="true"></a>(define-stream (stream-merge lt? . strms)</span>
<span id="cb412-2"><a href="#cb412-2" aria-hidden="true"></a>  (define-stream (merge xx yy)</span>
<span id="cb412-3"><a href="#cb412-3" aria-hidden="true"></a>    (stream-match xx (() yy) ((x . xs)</span>
<span id="cb412-4"><a href="#cb412-4" aria-hidden="true"></a>      (stream-match yy (() xx) ((y . ys)</span>
<span id="cb412-5"><a href="#cb412-5" aria-hidden="true"></a>        (<span class="kw">if</span> (lt? y x)</span>
<span id="cb412-6"><a href="#cb412-6" aria-hidden="true"></a>            (stream-cons y (merge xx ys))</span>
<span id="cb412-7"><a href="#cb412-7" aria-hidden="true"></a>            (stream-cons x (merge xs yy))))))))</span>
<span id="cb412-8"><a href="#cb412-8" aria-hidden="true"></a>  (stream-let loop ((strms strms))</span>
<span id="cb412-9"><a href="#cb412-9" aria-hidden="true"></a>    (<span class="kw">cond</span> ((<span class="kw">null?</span> strms) stream-null)</span>
<span id="cb412-10"><a href="#cb412-10" aria-hidden="true"></a>          ((<span class="kw">null?</span> (<span class="kw">cdr</span> strms)) (<span class="kw">car</span> strms))</span>
<span id="cb412-11"><a href="#cb412-11" aria-hidden="true"></a>          (<span class="kw">else</span> (merge (<span class="kw">car</span> strms)</span>
<span id="cb412-12"><a href="#cb412-12" aria-hidden="true"></a>                       (apply stream-merge lt?</span>
<span id="cb412-13"><a href="#cb412-13" aria-hidden="true"></a>                         (<span class="kw">cdr</span> strms)))))))</span></code></pre></div>
<h2 id="stream-of-expr-clause-...-syntax"><code>(stream-of expr clause ...)</code> syntax</h2>
<p>Stream-of provides the syntax of stream comprehensions, which generate streams by means of looping expressions. The result is a stream of objects of the type returned by expr. There are four types of clauses:</p>
<ul>
<li>(var in stream-expr) — Loop over the elements of stream-expr, in order from the start of the stream, binding each element of the stream in turn to var. Stream-from and stream-range are frequently useful as generators for stream-expr.</li>
<li>(var is expr) — Bind var to the value obtained by evaluating expr.</li>
<li>(pred? expr) — Include in the output stream only those elements x for which (pred? x) is non-#f.</li>
</ul>
<p>The scope of variables bound in the stream comprehension is the clauses to the right of the binding clause (but not the binding clause itself) plus the result expression.</p>
<p>When two or more generators are present, the loops are processed as if they are nested from left to right; that is, the rightmost generator varies fastest. A consequence of this is that only the first generator may be infinite and all subsequent generators must be finite. If no generators are present, the result of a stream comprehension is a stream containing the result expression; thus, (stream-of 1) produces a finite stream containing only the element 1.</p>
<div class="sourceCode" id="cb413"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb413-1"><a href="#cb413-1" aria-hidden="true"></a>(stream-of (* x x)</span>
<span id="cb413-2"><a href="#cb413-2" aria-hidden="true"></a>  (x in (stream-range <span class="dv">0</span> <span class="dv">10</span>))</span>
<span id="cb413-3"><a href="#cb413-3" aria-hidden="true"></a>  (<span class="kw">even?</span> x))</span>
<span id="cb413-4"><a href="#cb413-4" aria-hidden="true"></a>  ⇒ <span class="dv">0</span> <span class="dv">4</span> <span class="dv">16</span> <span class="dv">36</span> <span class="dv">64</span></span>
<span id="cb413-5"><a href="#cb413-5" aria-hidden="true"></a></span>
<span id="cb413-6"><a href="#cb413-6" aria-hidden="true"></a>(stream-of (<span class="kw">list</span> a b)</span>
<span id="cb413-7"><a href="#cb413-7" aria-hidden="true"></a>  (a in (stream-range <span class="dv">1</span> <span class="dv">4</span>))</span>
<span id="cb413-8"><a href="#cb413-8" aria-hidden="true"></a>  (b in (stream-range <span class="dv">1</span> <span class="dv">3</span>)))</span>
<span id="cb413-9"><a href="#cb413-9" aria-hidden="true"></a>  ⇒ (<span class="dv">1</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">2</span>) (<span class="dv">2</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">2</span>) (<span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">3</span> <span class="dv">2</span>)</span>
<span id="cb413-10"><a href="#cb413-10" aria-hidden="true"></a></span>
<span id="cb413-11"><a href="#cb413-11" aria-hidden="true"></a>(stream-of (<span class="kw">list</span> i j)</span>
<span id="cb413-12"><a href="#cb413-12" aria-hidden="true"></a>  (i in (stream-range <span class="dv">1</span> <span class="dv">5</span>))</span>
<span id="cb413-13"><a href="#cb413-13" aria-hidden="true"></a>  (j in (stream-range (<span class="op">+</span> i <span class="dv">1</span>) <span class="dv">5</span>)))</span>
<span id="cb413-14"><a href="#cb413-14" aria-hidden="true"></a>  ⇒ (<span class="dv">1</span> <span class="dv">2</span>) (<span class="dv">1</span> <span class="dv">3</span>) (<span class="dv">1</span> <span class="dv">4</span>) (<span class="dv">2</span> <span class="dv">3</span>) (<span class="dv">2</span> <span class="dv">4</span>) (<span class="dv">3</span> <span class="dv">4</span>)</span></code></pre></div>
<h2 id="stream-range-first-past-step"><code>(stream-range first past [step])</code></h2>
<p>number × number × number → {number}</p>
<p>Stream-range creates a newly-allocated stream that contains first as its first element and increments each succeeding element by step. The stream is finite and ends before past, which is not an element of the stream. If step is not given it defaults to 1 if first is less than past and -1 otherwise. First, past and step may be of any numeric type. Stream-range is frequently useful as a generator in stream-of expressions. See also stream-from for a similar procedure that creates infinite streams.</p>
<div class="sourceCode" id="cb414"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb414-1"><a href="#cb414-1" aria-hidden="true"></a>(stream-range <span class="dv">0</span> <span class="dv">10</span>) ⇒ <span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">9</span></span>
<span id="cb414-2"><a href="#cb414-2" aria-hidden="true"></a></span>
<span id="cb414-3"><a href="#cb414-3" aria-hidden="true"></a>(stream-range <span class="dv">0</span> <span class="dv">10</span> <span class="dv">2</span>) → <span class="dv">0</span> <span class="dv">2</span> <span class="dv">4</span> <span class="dv">6</span> <span class="dv">8</span></span></code></pre></div>
<p>Successive elements of the stream are calculated by adding step to first, so if any of first, past or step are inexact, the length of the output stream may differ from (ceiling (- (/ (- past first) step) 1).</p>
<h2 id="stream-ref-stream-n"><code>(stream-ref stream n)</code></h2>
<p>{α} × nat → α</p>
<p>Stream-ref returns the nth element of stream, counting from zero. An error is signaled if n is greater than or equal to the length of stream.</p>
<div class="sourceCode" id="cb415"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb415-1"><a href="#cb415-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(fact n)</span>
<span id="cb415-2"><a href="#cb415-2" aria-hidden="true"></a>  (stream-ref</span>
<span id="cb415-3"><a href="#cb415-3" aria-hidden="true"></a>    (stream-scan * <span class="dv">1</span> (stream-from <span class="dv">1</span>))</span>
<span id="cb415-4"><a href="#cb415-4" aria-hidden="true"></a>    n))</span></code></pre></div>
<h2 id="stream-reverse-stream"><code>(stream-reverse stream)</code></h2>
<p>{α} → {α}</p>
<p>Stream-reverse returns a newly-allocated stream containing the elements of the input stream but in reverse order. Stream-reverse may only be used with finite streams; it enters an infinite loop with infinite streams. Stream-reverse does not force evaluation of the elements of the stream.</p>
<div class="sourceCode" id="cb416"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb416-1"><a href="#cb416-1" aria-hidden="true"></a><span class="op">&gt;</span> (<span class="ex">define</span><span class="fu"> s </span>(stream <span class="dv">1</span> (<span class="op">/</span> <span class="dv">1</span> <span class="dv">0</span>) <span class="dv">-1</span>))</span>
<span id="cb416-2"><a href="#cb416-2" aria-hidden="true"></a><span class="op">&gt;</span> (<span class="ex">define</span><span class="fu"> r </span>(stream-reverse s))</span>
<span id="cb416-3"><a href="#cb416-3" aria-hidden="true"></a><span class="op">&gt;</span> (stream-ref r <span class="dv">0</span>)</span>
<span id="cb416-4"><a href="#cb416-4" aria-hidden="true"></a><span class="op">&gt;</span> (stream-ref r <span class="dv">2</span>)</span>
<span id="cb416-5"><a href="#cb416-5" aria-hidden="true"></a><span class="dv">1</span></span>
<span id="cb416-6"><a href="#cb416-6" aria-hidden="true"></a><span class="op">&gt;</span> (stream-ref r <span class="dv">1</span>)</span>
<span id="cb416-7"><a href="#cb416-7" aria-hidden="true"></a>error: division by zero</span></code></pre></div>
<h2 id="stream-scan-proc-base-stream"><code>(stream-scan proc base stream)</code></h2>
<p>(α × β → α) × α × {β} → {α}</p>
<p>Stream-scan accumulates the partial folds of an input stream into a newly-allocated output stream. The output stream is the base followed by (stream-fold proc base (stream-take i stream)) for each of the first i elements of stream.</p>
<div class="sourceCode" id="cb417"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb417-1"><a href="#cb417-1" aria-hidden="true"></a>(stream-scan <span class="op">+</span> <span class="dv">0</span> (stream-from <span class="dv">1</span>))</span>
<span id="cb417-2"><a href="#cb417-2" aria-hidden="true"></a>  ⇒ (stream <span class="dv">0</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">6</span> <span class="dv">10</span> <span class="dv">15</span> ...)</span>
<span id="cb417-3"><a href="#cb417-3" aria-hidden="true"></a></span>
<span id="cb417-4"><a href="#cb417-4" aria-hidden="true"></a>(stream-scan * <span class="dv">1</span> (stream-from <span class="dv">1</span>))</span>
<span id="cb417-5"><a href="#cb417-5" aria-hidden="true"></a>  ⇒ (stream <span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">6</span> <span class="dv">24</span> <span class="dv">120</span> ...)</span></code></pre></div>
<h2 id="stream-take-n-stream"><code>(stream-take n stream)</code></h2>
<p>nat × {α} → {α}</p>
<p>Stream-take takes a non-negative integer n and a stream and returns a newly-allocated stream containing the first n elements of the input stream. If the input stream has less than n elements, so does the output stream. See also stream-drop.</p>
<p>Mergesort splits a stream into two equal-length pieces, sorts them recursively and merges the results:</p>
<div class="sourceCode" id="cb418"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb418-1"><a href="#cb418-1" aria-hidden="true"></a>(define-stream (msort lt? strm)</span>
<span id="cb418-2"><a href="#cb418-2" aria-hidden="true"></a>  (<span class="kw">let*</span> ((n (<span class="kw">quotient</span> (stream-length strm) <span class="dv">2</span>))</span>
<span id="cb418-3"><a href="#cb418-3" aria-hidden="true"></a>         (ts (stream-take n strm))</span>
<span id="cb418-4"><a href="#cb418-4" aria-hidden="true"></a>         (ds (stream-drop n strm)))</span>
<span id="cb418-5"><a href="#cb418-5" aria-hidden="true"></a>    (<span class="kw">if</span> (<span class="kw">zero?</span> n)</span>
<span id="cb418-6"><a href="#cb418-6" aria-hidden="true"></a>        strm</span>
<span id="cb418-7"><a href="#cb418-7" aria-hidden="true"></a>        (stream-merge lt?</span>
<span id="cb418-8"><a href="#cb418-8" aria-hidden="true"></a>          (msort <span class="op">&lt;</span> ts) (msort <span class="op">&lt;</span> ds)))))</span></code></pre></div>
<h2 id="stream-take-while-pred-stream"><code>(stream-take-while pred? stream)</code></h2>
<p>(α → boolean) × {α} → {α}</p>
<p>Stream-take-while takes a predicate and a stream and returns a newly-allocated stream containing those elements x that form the maximal prefix of the input stream for which (pred? x) is non-#f. See also stream-drop-while.</p>
<div class="sourceCode" id="cb419"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb419-1"><a href="#cb419-1" aria-hidden="true"></a>(stream-car</span>
<span id="cb419-2"><a href="#cb419-2" aria-hidden="true"></a>  (stream-reverse</span>
<span id="cb419-3"><a href="#cb419-3" aria-hidden="true"></a>    (stream-take-while</span>
<span id="cb419-4"><a href="#cb419-4" aria-hidden="true"></a>      (<span class="kw">lambda</span> (x) (<span class="op">&lt;</span> x <span class="dv">1000</span>))</span>
<span id="cb419-5"><a href="#cb419-5" aria-hidden="true"></a>        primes))) ⇒ <span class="dv">997</span></span></code></pre></div>
<h2 id="stream-unfold-map-pred-gen-base"><code>(stream-unfold map pred? gen base)</code></h2>
<p>(α → β) × (α → boolean) × (α → α) × α → {β}</p>
<p>Stream-unfold is the fundamental recursive stream constructor. It constructs a stream by repeatedly applying gen to successive values of base, in the manner of stream-iterate, then applying map to each of the values so generated, appending each of the mapped values to the output stream as long as (pred? base) is non-#f. See also stream-iterate and stream-unfolds.</p>
<p>The expression below creates the finite stream 0 1 4 9 16 25 36 49 64 81. Initially the base is 0, which is less than 10, so map squares the base and the mapped value becomes the first element of the output stream. Then gen increments the base by 1, so it becomes 1; this is less than 10, so map squares the new base and 1 becomes the second element of the output stream. And so on, until the base becomes 10, when pred? stops the recursion and stream-null ends the output stream.</p>
<div class="sourceCode" id="cb420"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb420-1"><a href="#cb420-1" aria-hidden="true"></a>(stream-unfold</span>
<span id="cb420-2"><a href="#cb420-2" aria-hidden="true"></a>  (<span class="kw">lambda</span> (x) (<span class="kw">expt</span> x <span class="dv">2</span>)) <span class="co">; map</span></span>
<span id="cb420-3"><a href="#cb420-3" aria-hidden="true"></a>  (<span class="kw">lambda</span> (x) (<span class="op">&lt;</span> x <span class="dv">10</span>))   <span class="co">; pred?</span></span>
<span id="cb420-4"><a href="#cb420-4" aria-hidden="true"></a>  (<span class="kw">lambda</span> (x) (<span class="op">+</span> x <span class="dv">1</span>))    <span class="co">; gen</span></span>
<span id="cb420-5"><a href="#cb420-5" aria-hidden="true"></a>  <span class="dv">0</span>)                      <span class="co">; base</span></span></code></pre></div>
<h2 id="stream-unfolds-proc-seed"><code>(stream-unfolds proc seed)</code></h2>
<p>(α → (values α × β …)) × α → (values {β} …)</p>
<p>Stream-unfolds returns n newly-allocated streams containing those elements produced by successive calls to the generator proc, which takes the current seed as its argument and returns n+1 values</p>
<div class="sourceCode" id="cb421"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb421-1"><a href="#cb421-1" aria-hidden="true"></a>(proc seed → seed result0 ... resultn<span class="dv">-1</span></span></code></pre></div>
<p>where the returned seed is the input seed to the next call to the generator and resulti indicates how to produce the next element of the ith result stream:</p>
<ul>
<li>(value) — value is the next car of the result stream</li>
<li>#f — no value produced by this iteration of the generator proc for the result stream</li>
<li>() — the end of the result stream</li>
</ul>
<p>It may require multiple calls of proc to produce the next element of any particular result stream. See also stream-iterate and stream-unfold.</p>
<p>Stream-unfolds is especially useful when writing expressions that return multiple streams. For instance, (stream-partition pred? strm) is equivalent to</p>
<div class="sourceCode" id="cb422"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb422-1"><a href="#cb422-1" aria-hidden="true"></a>(<span class="kw">values</span></span>
<span id="cb422-2"><a href="#cb422-2" aria-hidden="true"></a>  (stream-filter pred? strm)</span>
<span id="cb422-3"><a href="#cb422-3" aria-hidden="true"></a>  (stream-filter</span>
<span id="cb422-4"><a href="#cb422-4" aria-hidden="true"></a>    (<span class="kw">lambda</span> (x) (<span class="kw">not</span> (pred? x))) strm))</span></code></pre></div>
<p>but only tests pred? once for each element of strm.</p>
<div class="sourceCode" id="cb423"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb423-1"><a href="#cb423-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(stream-partition pred? strm)</span>
<span id="cb423-2"><a href="#cb423-2" aria-hidden="true"></a>  (stream-unfolds</span>
<span id="cb423-3"><a href="#cb423-3" aria-hidden="true"></a>    (<span class="kw">lambda</span> (s)</span>
<span id="cb423-4"><a href="#cb423-4" aria-hidden="true"></a>      (<span class="kw">if</span> (stream-null? s)</span>
<span id="cb423-5"><a href="#cb423-5" aria-hidden="true"></a>          (<span class="kw">values</span> s &#39;() &#39;())</span>
<span id="cb423-6"><a href="#cb423-6" aria-hidden="true"></a>          (<span class="kw">let</span> ((a (stream-car s))</span>
<span id="cb423-7"><a href="#cb423-7" aria-hidden="true"></a>                (d (stream-cdr s)))</span>
<span id="cb423-8"><a href="#cb423-8" aria-hidden="true"></a>            (<span class="kw">if</span> (pred? a)</span>
<span id="cb423-9"><a href="#cb423-9" aria-hidden="true"></a>                (<span class="kw">values</span> d (<span class="kw">list</span> a) <span class="dv">#f</span>)</span>
<span id="cb423-10"><a href="#cb423-10" aria-hidden="true"></a>                (<span class="kw">values</span> d <span class="dv">#f</span> (<span class="kw">list</span> a))))))</span>
<span id="cb423-11"><a href="#cb423-11" aria-hidden="true"></a>    strm))</span>
<span id="cb423-12"><a href="#cb423-12" aria-hidden="true"></a></span>
<span id="cb423-13"><a href="#cb423-13" aria-hidden="true"></a>(<span class="kw">call-with-values</span></span>
<span id="cb423-14"><a href="#cb423-14" aria-hidden="true"></a>  (<span class="kw">lambda</span> ()</span>
<span id="cb423-15"><a href="#cb423-15" aria-hidden="true"></a>    (stream-partition <span class="kw">odd?</span></span>
<span id="cb423-16"><a href="#cb423-16" aria-hidden="true"></a>      (stream-range <span class="dv">1</span> <span class="dv">6</span>)))</span>
<span id="cb423-17"><a href="#cb423-17" aria-hidden="true"></a>  (<span class="kw">lambda</span> (odds evens)</span>
<span id="cb423-18"><a href="#cb423-18" aria-hidden="true"></a>    (<span class="kw">list</span> (stream-&gt;list odds)</span>
<span id="cb423-19"><a href="#cb423-19" aria-hidden="true"></a>          (stream-&gt;list evens))))</span>
<span id="cb423-20"><a href="#cb423-20" aria-hidden="true"></a>  ⇒ ((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span>) (<span class="dv">2</span> <span class="dv">4</span>))</span></code></pre></div>
<h2 id="stream-zip-stream-..."><code>(stream-zip stream ...)</code></h2>
<p>{α} × {β} × … → {[α β …]}</p>
<p>Stream-zip takes one or more input streams and returns a newly-allocated stream in which each element is a list (not a stream) of the corresponding elements of the input streams. The output stream is as long as the shortest input stream, if any of the input streams is finite, or is infinite if all the input streams are infinite.</p>
<p>A common use of stream-zip is to add an index to a stream, as in (stream-finds eql? obj strm), which returns all the zero-based indices in strm at which obj appears; (stream-find eql? obj strm) returns the first such index, or #f if obj is not in strm.</p>
<div class="sourceCode" id="cb424"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb424-1"><a href="#cb424-1" aria-hidden="true"></a>(define-stream (stream-finds eql? obj strm)</span>
<span id="cb424-2"><a href="#cb424-2" aria-hidden="true"></a>  (stream-of (<span class="kw">car</span> x)</span>
<span id="cb424-3"><a href="#cb424-3" aria-hidden="true"></a>    (x in (stream-zip (stream-from <span class="dv">0</span>) strm))</span>
<span id="cb424-4"><a href="#cb424-4" aria-hidden="true"></a>    (eql? obj (<span class="kw">cadr</span> x))))</span>
<span id="cb424-5"><a href="#cb424-5" aria-hidden="true"></a></span>
<span id="cb424-6"><a href="#cb424-6" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(stream-find eql? obj strm)</span>
<span id="cb424-7"><a href="#cb424-7" aria-hidden="true"></a>  (stream-car</span>
<span id="cb424-8"><a href="#cb424-8" aria-hidden="true"></a>    (stream-append</span>
<span id="cb424-9"><a href="#cb424-9" aria-hidden="true"></a>      (stream-finds eql? obj strm)</span>
<span id="cb424-10"><a href="#cb424-10" aria-hidden="true"></a>      (stream <span class="dv">#f</span>))))</span>
<span id="cb424-11"><a href="#cb424-11" aria-hidden="true"></a></span>
<span id="cb424-12"><a href="#cb424-12" aria-hidden="true"></a>(stream-find <span class="kw">char=?</span> <span class="ch">#\l</span></span>
<span id="cb424-13"><a href="#cb424-13" aria-hidden="true"></a>  (list-&gt;stream</span>
<span id="cb424-14"><a href="#cb424-14" aria-hidden="true"></a>    (<span class="kw">string-&gt;list</span> <span class="st">&quot;hello&quot;</span>))) ⇒ <span class="dv">2</span></span>
<span id="cb424-15"><a href="#cb424-15" aria-hidden="true"></a></span>
<span id="cb424-16"><a href="#cb424-16" aria-hidden="true"></a>(stream-find <span class="kw">char=?</span> <span class="ch">#\l</span></span>
<span id="cb424-17"><a href="#cb424-17" aria-hidden="true"></a>  (list-&gt;stream</span>
<span id="cb424-18"><a href="#cb424-18" aria-hidden="true"></a>    (<span class="kw">string-&gt;list</span> <span class="st">&quot;goodbye&quot;</span>))) ⇒ <span class="dv">#f</span></span></code></pre></div>
<p>Stream-find is not as inefficient as it looks; although it calls stream-finds, which finds all matching indices, the matches are computed lazily, and only the first match is needed for stream-find. # <code>(scheme lseq)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-127/">SRFI-127</a>.</p>
<p>Lazy sequences (or lseqs, pronounced “ell-seeks”) are a generalization of lists. In particular, an lseq is either a proper list or a dotted list whose last cdr is a SRFI 121 generator. A generator is a procedure that can be invoked with no arguments in order to lazily supply additional elements of the lseq. When a generator has no more elements to return, it returns an end-of-file object. Consequently, lazy sequences cannot reliably contain end-of-file objects.</p>
<p>This SRFI provides a set of procedures suitable for operating on lazy sequences based on SRFI 1.</p>
<h2 id="generator-lseq-generator"><code>(generator-&gt;lseq generator)</code></h2>
<p>Returns an lseq whose elements are the values generated by generator. The exact behavior is as follows:</p>
<ul>
<li><p>Generator is invoked with no arguments to produce an object obj.</p></li>
<li><p>If obj is an end-of-file object, the empty list is returned.</p></li>
<li><p>Otherwise, a newly allocated pair whose car is obj and whose cdr is generator is returned.</p></li>
</ul>
<div class="sourceCode" id="cb425"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb425-1"><a href="#cb425-1" aria-hidden="true"></a>(generator-&gt;lseq (make-iota-generator +inf<span class="fl">.0</span> <span class="dv">1</span>))</span></code></pre></div>
<h2 id="lseq-x"><code>(lseq? x)</code></h2>
<p>Returns #t if x is an lseq. This procedure may also return #t if x is an improper list whose last cdr is a procedure that requires arguments, since there is no portable way to examine a procedure to determine how many arguments it requires. Otherwise it returns #f.</p>
<h2 id="lseq-elt-lseq1-lseq2"><code>(lseq=? elt=? lseq1 lseq2)</code></h2>
<p>Determines lseq equality, given an element-equality procedure. Two lseqs are equal if they are of the same length, and their corresponding elements are equal, as determined by elt=?. When elt=? is called, its first argument is always from lseq1 and its second argument is from lseq2.</p>
<p>The dynamic order in which the elt=? procedure is applied to pairs of elements is not specified.</p>
<p>The elt=? procedure must be consistent with eq?. This implies that two lseqs which are eq? are always lseq=?, as well; implementations may exploit this fact to “short-cut” the element-by-element equality tests.</p>
<h2 id="lseq-car-lseq"><code>(lseq-car lseq)</code></h2>
<h2 id="lseq-first-lseq"><code>(lseq-first lseq)</code></h2>
<p>These procedures are synonymous. They return the first element of lseq. They are included for completeness, as they are the same as car. It is an error to apply them to an empty lseq.</p>
<h2 id="lseq-cdr-lseq"><code>(lseq-cdr lseq)</code></h2>
<h2 id="lseq-rest-lseq"><code>(lseq-rest lseq)</code></h2>
<p>These procedures are synonymous. They return an lseq with the contents of lseq except for the first element. The exact behavior is as follows:</p>
<ul>
<li><p>If lseq is a pair whose cdr is a procedure, then the procedure is invoked with no arguments to produce an object obj.</p></li>
<li><p>If obj is an end-of-file object, then the cdr of lseq is set to the empty list, which is returned.</p></li>
<li><p>If obj is any other object, then a new pair is allocated whose car is obj and whose cdr is the cdr of lseq (i.e. the procedure). The cdr of lseq is set to the newly allocated pair, which is returned.</p></li>
<li><p>If lseq is a pair whose cdr is not a procedure, then the cdr is returned.</p></li>
<li><p>If lseq is not a pair, it is an error.</p></li>
</ul>
<p>Implementations that inline cdr are advised to inline lseq-cdr if possible.</p>
<h2 id="lseq-ref-lseq-i"><code>(lseq-ref lseq i)</code></h2>
<p>Returns the ith element of lseq. (This is the same as (lseq-first (lseq-drop lseq i)).) It is an error if i &gt;= n, where n is the length of lseq.</p>
<div class="sourceCode" id="cb426"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb426-1"><a href="#cb426-1" aria-hidden="true"></a>(lseq-ref &#39;(a b c d) <span class="dv">2</span>) <span class="op">=&gt;</span> c</span></code></pre></div>
<h2 id="lseq-take-lseq-i"><code>(lseq-take lseq i)</code></h2>
<h2 id="lseq-drop-lseq-i"><code>(lseq-drop lseq i)</code></h2>
<p>lseq-take lazily returns the first i elements of lseq. lseq-drop returns all but the first i elements of lseq.</p>
<div class="sourceCode" id="cb427"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb427-1"><a href="#cb427-1" aria-hidden="true"></a>(lseq-take &#39;(a b c d e)  <span class="dv">2</span>) <span class="op">=&gt;</span> (a b)</span>
<span id="cb427-2"><a href="#cb427-2" aria-hidden="true"></a>(lseq-drop &#39;(a b c d e)  <span class="dv">2</span>) <span class="op">=&gt;</span> (c d e)</span></code></pre></div>
<p>lseq-drop is exactly equivalent to performing i lseq-rest operations on lseq.</p>
<h2 id="lseq-realize-lseq"><code>(lseq-realize lseq)</code></h2>
<p>Repeatedly applies lseq-cdr to lseq until its generator (if there is one) has been exhausted, and returns lseq, which is now guaranteed to be a proper list. This procedure can be called on an arbitrary lseq before passing it to a procedure which only accepts lists. However, if the generator never returns an end-of-file object, lseq-realize will never return.</p>
<h2 id="lseq-generator-lseq"><code>(lseq-&gt;generator lseq)</code></h2>
<p>Returns a generator which when invoked will return all the elements of lseq, including any that have not yet been realized.</p>
<h2 id="lseq-length-lseq"><code>(lseq-length lseq)</code></h2>
<p>Returns the length of its argument, which is the non-negative integer n such that lseq-rest applied n times to the lseq produces an empty lseq. lseq must be finite, or this procedure will not return.</p>
<h2 id="lseq-append-lseq-..."><code>(lseq-append lseq ...)</code></h2>
<p>Returns an lseq that lazily contains all the elements of all the lseqs in order.</p>
<h2 id="lseq-zip-lseq1-lseq2-..."><code>(lseq-zip lseq1 lseq2 ...)</code></h2>
<p>If lseq-zip is passed n lseqs, it lazily returns an lseq each element of which is an n-element list comprised of the corresponding elements from the lseqs. If any of the lseqs are finite in length, the result is as long as the shortest lseq.</p>
<div class="sourceCode" id="cb428"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb428-1"><a href="#cb428-1" aria-hidden="true"></a>    (lseq-zip &#39;(one two three)</span>
<span id="cb428-2"><a href="#cb428-2" aria-hidden="true"></a>         (generator-&gt;lseq (make-iota-generator +inf<span class="fl">.0</span> <span class="dv">1</span> <span class="dv">1</span>))</span>
<span id="cb428-3"><a href="#cb428-3" aria-hidden="true"></a>         (generator-&gt;lseq (make-repeating-generator) &#39;(odd even))))</span>
<span id="cb428-4"><a href="#cb428-4" aria-hidden="true"></a>        <span class="op">=&gt;</span> ((one <span class="dv">1</span> odd) (two <span class="dv">2</span> even) (three <span class="dv">3</span> odd))</span>
<span id="cb428-5"><a href="#cb428-5" aria-hidden="true"></a></span>
<span id="cb428-6"><a href="#cb428-6" aria-hidden="true"></a>    (lseq-zip &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)) <span class="op">=&gt;</span> ((<span class="dv">1</span>) (<span class="dv">2</span>) (<span class="dv">3</span>))</span></code></pre></div>
<h2 id="lseq-map-proc-lseq1-lseq2-..."><code>(lseq-map proc lseq1 lseq2 ...)</code></h2>
<p>The lseq-map procedure lazily applies proc element-wise to the corresponding elements of the lseqs, where proc is a procedure taking as many arguments as there are lseqs and returning a single value, and returns an lseq of the results in order. The dynamic order in which proc is applied to the elements of the lseqs is unspecified.</p>
<div class="sourceCode" id="cb429"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb429-1"><a href="#cb429-1" aria-hidden="true"></a>    (lseq-map</span>
<span id="cb429-2"><a href="#cb429-2" aria-hidden="true"></a>      (<span class="kw">lambda</span> (x) (lseq-car (lseq-cdr x)))</span>
<span id="cb429-3"><a href="#cb429-3" aria-hidden="true"></a>      &#39;((a b) (d e) (g h))) <span class="op">=&gt;</span>  (b e h)</span>
<span id="cb429-4"><a href="#cb429-4" aria-hidden="true"></a></span>
<span id="cb429-5"><a href="#cb429-5" aria-hidden="true"></a>    (lseq-map (<span class="kw">lambda</span> (n) (<span class="kw">expt</span> n n))</span>
<span id="cb429-6"><a href="#cb429-6" aria-hidden="true"></a>         (make-iota-generator +inf<span class="fl">.0</span> <span class="dv">1</span> <span class="dv">1</span>)</span>
<span id="cb429-7"><a href="#cb429-7" aria-hidden="true"></a>        <span class="op">=&gt;</span>  (<span class="dv">1</span> <span class="dv">4</span> <span class="dv">27</span> <span class="dv">256</span> <span class="dv">3125</span> ...)</span>
<span id="cb429-8"><a href="#cb429-8" aria-hidden="true"></a></span>
<span id="cb429-9"><a href="#cb429-9" aria-hidden="true"></a>    (lseq-map <span class="op">+</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) &#39;(<span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>)) <span class="op">=&gt;</span>  (<span class="dv">5</span> <span class="dv">7</span> <span class="dv">9</span>)</span>
<span id="cb429-10"><a href="#cb429-10" aria-hidden="true"></a></span>
<span id="cb429-11"><a href="#cb429-11" aria-hidden="true"></a>    (<span class="kw">let</span> ((count <span class="dv">0</span>))</span>
<span id="cb429-12"><a href="#cb429-12" aria-hidden="true"></a>      (lseq-map (<span class="kw">lambda</span> (ignored)</span>
<span id="cb429-13"><a href="#cb429-13" aria-hidden="true"></a>             (set! count (<span class="op">+</span> count <span class="dv">1</span>))</span>
<span id="cb429-14"><a href="#cb429-14" aria-hidden="true"></a>             count)</span>
<span id="cb429-15"><a href="#cb429-15" aria-hidden="true"></a>           &#39;(a b))) <span class="op">=&gt;</span>  (<span class="dv">1</span> <span class="dv">2</span>) <span class="kw">or</span> (<span class="dv">2</span> <span class="dv">1</span>)</span></code></pre></div>
<h2 id="lseq-for-each-proc-lseq1-lseq2">`(lseq-for-each proc lseq1 lseq2 …)</h2>
<p>The arguments to lseq-for-each are like the arguments to lseq-map, but lseq-for-each calls proc for its side effects rather than for its values. Unlike lseq-map, lseq-for-each is guaranteed to call proc on the elements of the lseqs in order from the first element(s) to the last, and the value returned by lseq-for-each is unspecified.</p>
<p>If none of the lseqs are finite, lseq-for-each never returns.</p>
<div class="sourceCode" id="cb430"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb430-1"><a href="#cb430-1" aria-hidden="true"></a>    (<span class="kw">let</span> ((v (<span class="kw">make-vector</span> <span class="dv">5</span>)))</span>
<span id="cb430-2"><a href="#cb430-2" aria-hidden="true"></a>      (lseq-for-each (<span class="kw">let</span> ((count <span class="dv">0</span>))</span>
<span id="cb430-3"><a href="#cb430-3" aria-hidden="true"></a>                       (<span class="kw">lambda</span> (i)</span>
<span id="cb430-4"><a href="#cb430-4" aria-hidden="true"></a>                         (<span class="kw">vector-set!</span> v count (* i i))</span>
<span id="cb430-5"><a href="#cb430-5" aria-hidden="true"></a>                         (set! count (<span class="op">+</span> count <span class="dv">1</span>))))</span>
<span id="cb430-6"><a href="#cb430-6" aria-hidden="true"></a>                     &#39;(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))</span>
<span id="cb430-7"><a href="#cb430-7" aria-hidden="true"></a>      v)</span>
<span id="cb430-8"><a href="#cb430-8" aria-hidden="true"></a>      <span class="op">=&gt;</span>  (#<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)</span></code></pre></div>
<h2 id="lseq-filter-pred-lseq"><code>(lseq-filter pred lseq)</code></h2>
<h2 id="lseq-remove-pred-lseq"><code>(lseq-remove pred lseq)</code></h2>
<p>The procedure lseq-filter lazily returns an lseq that contains only the elements of lseq that satisfy pred.</p>
<p>The procedure lseq-remove is the same as lseq-filter, except that it returns elements that do not satisfy pred. These procedures are guaranteed to call pred on the elements of the lseqs in sequence order.</p>
<div class="sourceCode" id="cb431"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb431-1"><a href="#cb431-1" aria-hidden="true"></a>(lseq-filter <span class="kw">odd?</span> (generator-&gt;lseq (make-range-generator <span class="dv">1</span> <span class="dv">5</span>)))</span>
<span id="cb431-2"><a href="#cb431-2" aria-hidden="true"></a><span class="co">;; =&gt;  (1 3)</span></span>
<span id="cb431-3"><a href="#cb431-3" aria-hidden="true"></a></span>
<span id="cb431-4"><a href="#cb431-4" aria-hidden="true"></a>(lseq-remove <span class="kw">odd?</span> (generator-&gt;lseq (make-range-generator <span class="dv">1</span> <span class="dv">5</span>)))</span>
<span id="cb431-5"><a href="#cb431-5" aria-hidden="true"></a><span class="co">;; =&gt;  (2 4)</span></span></code></pre></div>
<h2 id="lseq-find-tail-pred-lseq"><code>(lseq-find-tail pred lseq)</code></h2>
<p>Returns the longest tail of lseq whose first element satisfies pred, or #f if no element does. The predicate is guaranteed to be evaluated on the elements of lseq in sequence order, and only as often as necessary.</p>
<p>lseq-find-tail can be viewed as a general-predicate variant of the lseq-member function.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb432"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb432-1"><a href="#cb432-1" aria-hidden="true"></a>(lseq-find-tail <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">37</span> <span class="dv">-8</span> <span class="dv">-5</span> <span class="dv">0</span> <span class="dv">0</span>)) <span class="op">=&gt;</span> (-<span class="dv">8</span> <span class="dv">-5</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb432-2"><a href="#cb432-2" aria-hidden="true"></a>(lseq-find-tail <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">37</span> <span class="dv">-5</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb432-3"><a href="#cb432-3" aria-hidden="true"></a></span>
<span id="cb432-4"><a href="#cb432-4" aria-hidden="true"></a><span class="co">;; equivalent to (lseq-member elt lseq)</span></span>
<span id="cb432-5"><a href="#cb432-5" aria-hidden="true"></a>(lseq-find-tail (<span class="kw">lambda</span> (elt) (<span class="kw">equal?</span> x elt)) lseq)</span></code></pre></div>
<h2 id="lseq-take-while-pred-lseq"><code>(lseq-take-while pred lseq)</code></h2>
<p>Lazily returns the longest initial prefix of lseq whose elements all satisfy the predicate pred.</p>
<div class="sourceCode" id="cb433"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb433-1"><a href="#cb433-1" aria-hidden="true"></a>(lseq-take-while <span class="kw">even?</span> &#39;(<span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> (<span class="dv">2</span> <span class="dv">18</span>)</span></code></pre></div>
<h2 id="lseq-drop-while-pred-lseq"><code>(lseq-drop-while pred lseq)</code></h2>
<p>Drops the longest initial prefix of lseq whose elements all satisfy the predicate pred, and returns the rest of the lseq.</p>
<div class="sourceCode" id="cb434"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb434-1"><a href="#cb434-1" aria-hidden="true"></a>(lseq-drop-while <span class="kw">even?</span> &#39;(<span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> (<span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)</span></code></pre></div>
<p>Note that lseq-drop-while is essentially lseq-find-tail where the sense of the predicate is inverted: lseq-find-tail searches until it finds an element satisfying the predicate; lseq-drop-while searches until it finds an element that doesn’t satisfy the predicate.</p>
<h2 id="lseq-any-pred-lseq1-lseq2-..."><code>(lseq-any pred lseq1 lseq2 ...)</code></h2>
<p>Applies pred to successive elements of the lseqs, returning true if pred returns true on any application. If an application returns a true value, lseq-any immediately returns that value. Otherwise, it iterates until a true value is produced or one of the lseqs runs out of values; in the latter case, lseq-any returns #f. It is an error if pred does not accept the same number of arguments as there are lseqs and return a boolean result.</p>
<p>Note the difference between lseq-find and lseq-any — lseq-find returns the element that satisfied the predicate; lseq-any returns the true value that the predicate produced.</p>
<p>Like lseq-every, lseq-any’s name does not end with a question mark — this is to indicate that it does not return a simple boolean (#t or #f), but a general value.</p>
<div class="sourceCode" id="cb435"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb435-1"><a href="#cb435-1" aria-hidden="true"></a>    (lseq-any <span class="kw">integer?</span> &#39;(a <span class="dv">3</span> b <span class="fl">2.7</span>))   <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb435-2"><a href="#cb435-2" aria-hidden="true"></a>    (lseq-any <span class="kw">integer?</span> &#39;(a <span class="fl">3.1</span> b <span class="fl">2.7</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb435-3"><a href="#cb435-3" aria-hidden="true"></a>    (lseq-any <span class="op">&lt;</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span>)</span>
<span id="cb435-4"><a href="#cb435-4" aria-hidden="true"></a>           &#39;(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb435-5"><a href="#cb435-5" aria-hidden="true"></a></span>
<span id="cb435-6"><a href="#cb435-6" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> </span>(factorial n)</span>
<span id="cb435-7"><a href="#cb435-7" aria-hidden="true"></a>      (<span class="kw">cond</span></span>
<span id="cb435-8"><a href="#cb435-8" aria-hidden="true"></a>        ((<span class="op">&lt;</span> n <span class="dv">0</span>) <span class="dv">#f</span>)</span>
<span id="cb435-9"><a href="#cb435-9" aria-hidden="true"></a>        ((<span class="op">=</span> n <span class="dv">0</span>) <span class="dv">1</span>)</span>
<span id="cb435-10"><a href="#cb435-10" aria-hidden="true"></a>        (<span class="kw">else</span> (* n (factorial (<span class="op">-</span> n <span class="dv">1</span>))))))</span>
<span id="cb435-11"><a href="#cb435-11" aria-hidden="true"></a>    (lseq-any factorial &#39;(-<span class="dv">1</span> <span class="dv">-2</span> <span class="dv">3</span> <span class="dv">4</span>))</span>
<span id="cb435-12"><a href="#cb435-12" aria-hidden="true"></a>            <span class="op">=&gt;</span> <span class="dv">6</span></span></code></pre></div>
<h2 id="lseq-every-pred-lseq1-lseq2-..."><code>(lseq-every pred lseq1 lseq2 ...)</code></h2>
<p>Applies pred to successive elements of the lseqs, returning true if the predicate returns true on every application. If an application returns a false value, lseq-every immediately returns that value. Otherwise, it iterates until a false value is produced or one of the lseqs runs out of values; in the latter case, lseq-every returns the last value returned by pred, or #t if pred was never invoked. It is an error if pred does not accept the same number of arguments as there are lseqs and return a boolean result.</p>
<p>Like lseq-any, lseq-every’s name does not end with a question mark — this is to indicate that it does not return a simple boolean (#t or #f), but a general value.</p>
<div class="sourceCode" id="cb436"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb436-1"><a href="#cb436-1" aria-hidden="true"></a>    (lseq-every factorial &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))</span>
<span id="cb436-2"><a href="#cb436-2" aria-hidden="true"></a>            <span class="op">=&gt;</span> <span class="dv">24</span></span></code></pre></div>
<h2 id="lseq-index-pred-lseq1-lseq2-..."><code>(lseq-index pred lseq1 lseq2 ...)</code></h2>
<p>Return the index of the leftmost element that satisfies pred.</p>
<p>Applies pred to successive elements of the lseqs, returning an index usable with lseq-ref if the predicate returns true. Otherwise, it iterates until one of the lseqs runs out of values, in which case #f is returned.</p>
<p>It is an error if pred does not accept the same number of arguments as there are lseqs and return a boolean result.</p>
<p>The iteration stops when one of the lseqs runs out of values; in this case, lseq-index returns #f.</p>
<div class="sourceCode" id="cb437"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb437-1"><a href="#cb437-1" aria-hidden="true"></a>(lseq-index <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> <span class="dv">2</span></span>
<span id="cb437-2"><a href="#cb437-2" aria-hidden="true"></a>(lseq-index <span class="op">&lt;</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) &#39;(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">1</span></span>
<span id="cb437-3"><a href="#cb437-3" aria-hidden="true"></a>(lseq-index <span class="op">=</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) &#39;(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="lseq-member-x-lseq-pred"><code>(lseq-member x lseq [ pred ])</code></h2>
<h2 id="lseq-memq-x-lseq"><code>(lseq-memq x lseq)</code></h2>
<h2 id="lseq-memv-x-lseq"><code>(lseq-memv x lseq)</code></h2>
<p>These procedures return the longest tail of lseq whose first element is x, where the tails of lseq are the non-empty lseqs returned by (lseq-drop lseq i) for i less than the length of lseq. If x does not occur in lseq, then #f is returned. lseq-memq uses eq? to compare x with the elements of lseq, while lseq-memv uses eqv?, and lseq-member uses pred, which defaults to equal?.</p>
<div class="sourceCode" id="cb438"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb438-1"><a href="#cb438-1" aria-hidden="true"></a>(lseq-memq &#39;a &#39;(a b c))           <span class="op">=&gt;</span>  (a b c)</span>
<span id="cb438-2"><a href="#cb438-2" aria-hidden="true"></a>(lseq-memq &#39;b &#39;(a b c))           <span class="op">=&gt;</span>  (b c)</span>
<span id="cb438-3"><a href="#cb438-3" aria-hidden="true"></a>(lseq-memq &#39;a &#39;(b c d))           <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb438-4"><a href="#cb438-4" aria-hidden="true"></a>(lseq-memq (<span class="kw">list</span> &#39;a) &#39;(b (a) c)) <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb438-5"><a href="#cb438-5" aria-hidden="true"></a>(lseq-member (<span class="kw">list</span> &#39;a)</span>
<span id="cb438-6"><a href="#cb438-6" aria-hidden="true"></a>&#39;(b (a) c))           <span class="op">=&gt;</span>  ((a) c)</span>
<span id="cb438-7"><a href="#cb438-7" aria-hidden="true"></a>(lseq-memq <span class="dv">101</span> &#39;(<span class="dv">100</span> <span class="dv">101</span> <span class="dv">102</span>))    <span class="op">=&gt;</span>  *unspecified*</span>
<span id="cb438-8"><a href="#cb438-8" aria-hidden="true"></a>(lseq-memv <span class="dv">101</span> &#39;(<span class="dv">100</span> <span class="dv">101</span> <span class="dv">102</span>))    <span class="op">=&gt;</span>  (<span class="dv">101</span> <span class="dv">102</span>)</span></code></pre></div>
<p>The equality procedure is used to compare the elements ei of lseq to the key x in this way: the first argument is always x, and the second argument is one of the lseq elements. Thus one can reliably find the first element of lseq that is greater than five with (lseq-member 5 lseq &lt;)</p>
<p>Note that fully general lseq searching may be performed with the lseq-find-tail procedure, e.g.</p>
<div class="sourceCode" id="cb439"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb439-1"><a href="#cb439-1" aria-hidden="true"></a>(lseq-find-tail <span class="kw">even?</span> lseq) <span class="co">; Find the first elt with an even key.</span></span></code></pre></div>
<h1 id="scheme-division"><code>(scheme division)</code></h1>
<p>This is based on <a href="https://srfi.schemers.org/srfi-141/">SRFI-141</a>.</p>
<p>This SRFI provides a fairly complete set of integral division and remainder operators.</p>
<h2 id="floor-numerator-denominator"><code>(floor/ numerator denominator)</code></h2>
<h2 id="floor-quotient-numerator-denominator"><code>(floor-quotient numerator denominator)</code></h2>
<h2 id="floor-remainder-numerator-denominator"><code>(floor-remainder numerator denominator)</code></h2>
<blockquote>
<p>q = floor(n/d)</p>
</blockquote>
<p>Thus r is negative iff d is negative.</p>
<h2 id="ceiling-numerator-denominator"><code>(ceiling/ numerator denominator)</code></h2>
<h2 id="ceiling-quotient-numerator-denominator"><code>(ceiling-quotient numerator denominator)</code></h2>
<h2 id="ceiling-remainder-numerator-denominator"><code>(ceiling-remainder numerator denominator)</code></h2>
<blockquote>
<p>q = ceiling(n/d)</p>
</blockquote>
<p>Thus r is negative iff d is non-negative.</p>
<p>If denominator is the number of units in a block, and <numerator> is some number of units, then (ceiling-quotient numerator denominator) gives the number of blocks needed to cover numerator units. For example, denominator might be the number of bytes in a disk sector, and numerator the number of bytes in a file; then the quotient is the number of disk sectors needed to store the contents of the file. For another example, denominator might be the number of octets in the output of a cryptographic hash function, and numerator the number of octets desired in a key for a symmetric cipher, to be derived using the cryptographic hash function; then the quotient is the number of hash values needed to concatenate to make a key.</p>
<h2 id="truncate-numerator-denominator"><code>(truncate/ numerator denominator)</code></h2>
<h2 id="truncate-quotient-numerator-denominator"><code>(truncate-quotient numerator denominator)</code></h2>
<h2 id="truncate-remainder-numerator-denominator"><code>(truncate-remainder numerator denominator)</code></h2>
<blockquote>
<p>q = truncate(n/d)</p>
</blockquote>
<p>Thus r is negative iff n is negative. However, by any non-unit denominator, the quotient of +1, 0, or -1 is 0; that is, three contiguous numerators by a common denominator share a common quotient. Of the other division operator pairs, only the round pair exhibits this property.</p>
<h2 id="round-numerator-denominator"><code>(round/ numerator denominator)</code></h2>
<h2 id="round-quotient-numerator-denominator"><code>(round-quotient numerator denominator)</code></h2>
<h2 id="round-remainder-numerator-denominator"><code>(round-remainder numerator denominator)</code></h2>
<blockquote>
<p>q = round(n/d)</p>
</blockquote>
<p>The round function rounds to the nearest integer, breaking ties by choosing the nearest even integer. Nothing general can be said about the sign of r. Like the truncate operator pair, the quotient of +1, 0, or -1 by any non-unit denominator is 0, so that three contiguous numerators by a common denominator share a common quotient.</p>
<h2 id="euclidean-numerator-denominator"><code>(euclidean/ numerator denominator)</code></h2>
<h2 id="euclidean-quotient-numerator-denominator"><code>(euclidean-quotient numerator denominator)</code></h2>
<h2 id="euclidean-remainder-numerator-denominator"><code>(euclidean-remainder numerator denominator)</code></h2>
<p>If d &gt; 0, q = floor(n/d); if d &lt; 0, q = ceiling(n/d).</p>
<p>This division operator pair satisfies the stronger property</p>
<blockquote>
<p>0 &lt;= r &lt; |d|,</p>
</blockquote>
<p>used often in mathematics. Thus, for example, (euclidean-remainder numerator denominator) is always a valid index into a vector whose length is at least the absolute value of denominator. This division operator pair is so named because it is the subject of the Euclidean division algorithm.</p>
<h2 id="balanced-numerator-denominator"><code>(balanced/ numerator denominator)</code></h2>
<h2 id="balanced-quotient-numerator-denominator"><code>(balanced-quotient numerator denominator)</code></h2>
<h2 id="balanced-remainder-numerator-denominator"><code>(balanced-remainder numerator denominator)</code></h2>
<p>This division operator pair satisfies the property</p>
<blockquote>
<p>-|d/2| &lt;= r &lt; |d/2|.</p>
</blockquote>
<p>When d is a power of 2, say 2k for some k, this reduces to</p>
<blockquote>
<p>-2(k - 1) &lt;= r &lt; 2(k - 1).</p>
</blockquote>
<p>Computer scientists will immediately recognize this as the interval of integers representable in two’s-complement with k bits. # <code>(scheme rlist)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-101/">SRFI-101</a>.</p>
<p>Random-access lists [1] are a purely functional data structure for representing lists of values. A random-access list may act as a drop in replacement for the usual linear-access pair and list data structures (pair?, cons, car, cdr), which additionally supports fast index-based addressing and updating (list-ref, list-set). The impact is a whole class of purely-functional algorithms expressed in terms of index-based list addressing become feasible compared with their linear-access list counterparts.</p>
<p>This document proposes a library API for purely functional random-access lists consistent with the R6RS [2] base library and list utility standard library [3]. # <code>(scheme charset)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-14/">SRFI-14</a>.</p>
<p>The ability to efficiently represent and manipulate sets of characters is an unglamorous but very useful capability for text-processing code – one that tends to pop up in the definitions of other libraries.</p>
<h2 id="char-set-obj"><code>(char-set? obj)</code></h2>
<p>Is the object obj a character set?</p>
<h2 id="char-set-cs1-..."><code>(char-set= cs1 ...)</code></h2>
<p>Are the character sets equal?</p>
<p>Boundary cases:</p>
<div class="sourceCode" id="cb440"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb440-1"><a href="#cb440-1" aria-hidden="true"></a>(char-set=) <span class="op">=&gt;</span> true</span>
<span id="cb440-2"><a href="#cb440-2" aria-hidden="true"></a>(char-set= cs) <span class="op">=&gt;</span> true</span></code></pre></div>
<p>Rationale: transitive binary relations are generally extended to n-ary relations in Scheme, which enables clearer, more concise code to be written. While the zero-argument and one-argument cases will almost certainly not arise in first-order uses of such relations, they may well arise in higher-order cases or macro-generated code. E.g., consider</p>
<div class="sourceCode" id="cb441"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb441-1"><a href="#cb441-1" aria-hidden="true"></a>(apply char-set= cset-list)</span></code></pre></div>
<p>This is well-defined if the list is empty or a singleton list. Hence we extend these relations to any number of arguments. Implementors have reported actual uses of n-ary relations in higher-order cases allowing for fewer than two arguments. The way of Scheme is to handle the general case; we provide the fully general extension.</p>
<p>A counter-argument to this extension is that R5RS’s transitive binary arithmetic relations (=, &lt;, etc.) require at least two arguments, hence this decision is a break with the prior convention – although it is at least one that is backwards-compatible.</p>
<h2 id="char-set-cs1-...-1"><code>(char-set&lt;= cs1 ...)</code></h2>
<p>Returns true if every character set csi is a subset of character set csi+1.</p>
<p>Boundary cases:</p>
<div class="sourceCode" id="cb442"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb442-1"><a href="#cb442-1" aria-hidden="true"></a>(char-set&lt;=) <span class="op">=&gt;</span> true</span>
<span id="cb442-2"><a href="#cb442-2" aria-hidden="true"></a>(char-set&lt;= cs) <span class="op">=&gt;</span> true</span></code></pre></div>
<p>Rationale: See char-set= for discussion of zero- and one-argument applications. Consider testing a list of char-sets for monotonicity with</p>
<div class="sourceCode" id="cb443"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb443-1"><a href="#cb443-1" aria-hidden="true"></a>(apply char-set&lt;= cset-list)</span></code></pre></div>
<h2 id="char-set-hash-cs-bound"><code>(char-set-hash cs [bound])</code></h2>
<p>Compute a hash value for the character set cs. Bound is a non-negative exact integer specifying the range of the hash function. A positive value restricts the return value to the range [0,bound).</p>
<p>If bound is either zero or not given, the implementation may use an implementation-specific default value, chosen to be as large as is efficiently practical. For instance, the default range might be chosen for a given implementation to map all strings into the range of integers that can be represented with a single machine word.</p>
<p>Invariant:</p>
<div class="sourceCode" id="cb444"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb444-1"><a href="#cb444-1" aria-hidden="true"></a>(char-set= cs1 cs2) <span class="op">=&gt;</span> (<span class="op">=</span> (char-set-hash cs1 b) (char-set-hash cs2 b))</span></code></pre></div>
<p>A legal but nonetheless discouraged implementation:</p>
<div class="sourceCode" id="cb445"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb445-1"><a href="#cb445-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(char-set-hash cs . maybe-bound) <span class="dv">1</span>)</span></code></pre></div>
<p>Rationale: allowing the user to specify an explicit bound simplifies user code by removing the mod operation that typically accompanies every hash computation, and also may allow the implementation of the hash function to exploit a reduced range to efficiently compute the hash value. E.g., for small bounds, the hash function may be computed in a fashion such that intermediate values never overflow into bignum integers, allowing the implementor to provide a fixnum-specific “fast path” for computing the common cases very rapidly.</p>
<h2 id="char-set-cursor-cset"><code>(char-set-cursor cset)</code></h2>
<h2 id="char-set-ref-cset-cursor"><code>(char-set-ref cset cursor)</code></h2>
<h2 id="char-set-cursor-next-cset-cursor"><code>(char-set-cursor-next cset cursor)</code></h2>
<h2 id="end-of-char-set-cursor"><code>(end-of-char-set? cursor)</code></h2>
<p>Cursors are a low-level facility for iterating over the characters in a set. A cursor is a value that indexes a character in a char set. char-set-cursor produces a new cursor for a given char set. The set element indexed by the cursor is fetched with char-set-ref. A cursor index is incremented with char-set-cursor-next; in this way, code can step through every character in a char set. Stepping a cursor “past the end” of a char set produces a cursor that answers true to end-of-char-set?. It is an error to pass such a cursor to char-set-ref or to char-set-cursor-next.</p>
<p>A cursor value may not be used in conjunction with a different character set; if it is passed to char-set-ref or char-set-cursor-next with a character set other than the one used to create it, the results and effects are undefined.</p>
<p>Cursor values are not necessarily distinct from other types. They may be integers, linked lists, records, procedures or other values. This license is granted to allow cursors to be very “lightweight” values suitable for tight iteration, even in fairly simple implementations.</p>
<p>Note that these primitives are necessary to export an iteration facility for char sets to loop macros.</p>
<p>Example:</p>
<div class="sourceCode" id="cb446"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb446-1"><a href="#cb446-1" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> cs </span>(char-set <span class="ch">#\G</span> <span class="ch">#\a</span> <span class="ch">#\T</span> <span class="ch">#\e</span> <span class="ch">#\c</span> <span class="ch">#\h</span>))</span>
<span id="cb446-2"><a href="#cb446-2" aria-hidden="true"></a></span>
<span id="cb446-3"><a href="#cb446-3" aria-hidden="true"></a>    <span class="co">;; Collect elts of CS into a list.</span></span>
<span id="cb446-4"><a href="#cb446-4" aria-hidden="true"></a>    (<span class="kw">let</span> lp ((cur (char-set-cursor cs)) (ans &#39;()))</span>
<span id="cb446-5"><a href="#cb446-5" aria-hidden="true"></a>      (<span class="kw">if</span> (end-of-char-set? cur) ans</span>
<span id="cb446-6"><a href="#cb446-6" aria-hidden="true"></a>          (lp (char-set-cursor-next cs cur)</span>
<span id="cb446-7"><a href="#cb446-7" aria-hidden="true"></a>              (<span class="kw">cons</span> (char-set-ref cs cur) ans))))</span>
<span id="cb446-8"><a href="#cb446-8" aria-hidden="true"></a>      <span class="op">=&gt;</span> (<span class="ch">#\G</span> <span class="ch">#\T</span> <span class="ch">#\a</span> <span class="ch">#\c</span> <span class="ch">#\e</span> <span class="ch">#\h</span>)</span>
<span id="cb446-9"><a href="#cb446-9" aria-hidden="true"></a></span>
<span id="cb446-10"><a href="#cb446-10" aria-hidden="true"></a>    <span class="co">;; Equivalently, using a list unfold (from SRFI 1):</span></span>
<span id="cb446-11"><a href="#cb446-11" aria-hidden="true"></a>    (unfold-right end-of-char-set?</span>
<span id="cb446-12"><a href="#cb446-12" aria-hidden="true"></a>                  (curry char-set-ref cs)</span>
<span id="cb446-13"><a href="#cb446-13" aria-hidden="true"></a>              (curry char-set-cursor-next cs)</span>
<span id="cb446-14"><a href="#cb446-14" aria-hidden="true"></a>              (char-set-cursor cs))</span>
<span id="cb446-15"><a href="#cb446-15" aria-hidden="true"></a>      <span class="op">=&gt;</span> (<span class="ch">#\G</span> <span class="ch">#\T</span> <span class="ch">#\a</span> <span class="ch">#\c</span> <span class="ch">#\e</span> <span class="ch">#\h</span>)</span></code></pre></div>
<p>Rationale: Note that the cursor API’s four functions “fit” the functional protocol used by the unfolders provided by the list, string and char-set SRFIs (see the example above). By way of contrast, here is a simpler, two-function API that was rejected for failing this criterion. Besides char-set-cursor, it provided a single function that mapped a cursor and a character set to two values, the indexed character and the next cursor. If the cursor had exhausted the character set, then this function returned false instead of the character value, and another end-of-char-set cursor. In this way, the other three functions of the current API were combined together.</p>
<h2 id="char-set-fold-kons-knil-cs"><code>(char-set-fold kons knil cs)</code></h2>
<p>This is the fundamental iterator for character sets. Applies the function kons across the character set cs using initial state value knil. That is, if cs is the empty set, the procedure returns knil. Otherwise, some element c of cs is chosen; let cs’ be the remaining, unchosen characters. The procedure returns</p>
<div class="sourceCode" id="cb447"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb447-1"><a href="#cb447-1" aria-hidden="true"></a>    (char-set-fold kons (kons c knil) cs&#39;)</span>
<span id="cb447-2"><a href="#cb447-2" aria-hidden="true"></a></span>
<span id="cb447-3"><a href="#cb447-3" aria-hidden="true"></a>    Examples:</span>
<span id="cb447-4"><a href="#cb447-4" aria-hidden="true"></a></span>
<span id="cb447-5"><a href="#cb447-5" aria-hidden="true"></a>    <span class="co">;; CHAR-SET-MEMBERS</span></span>
<span id="cb447-6"><a href="#cb447-6" aria-hidden="true"></a>    (<span class="kw">lambda</span> (cs) (char-set-fold <span class="kw">cons</span> &#39;() cs))</span>
<span id="cb447-7"><a href="#cb447-7" aria-hidden="true"></a></span>
<span id="cb447-8"><a href="#cb447-8" aria-hidden="true"></a>    <span class="co">;; CHAR-SET-SIZE</span></span>
<span id="cb447-9"><a href="#cb447-9" aria-hidden="true"></a>    (<span class="kw">lambda</span> (cs) (char-set-fold (<span class="kw">lambda</span> (c i) (<span class="op">+</span> i <span class="dv">1</span>)) <span class="dv">0</span> cs))</span>
<span id="cb447-10"><a href="#cb447-10" aria-hidden="true"></a></span>
<span id="cb447-11"><a href="#cb447-11" aria-hidden="true"></a>    <span class="co">;; How many vowels in the char set?</span></span>
<span id="cb447-12"><a href="#cb447-12" aria-hidden="true"></a>    (<span class="kw">lambda</span> (cs)</span>
<span id="cb447-13"><a href="#cb447-13" aria-hidden="true"></a>      (char-set-fold (<span class="kw">lambda</span> (c i) (<span class="kw">if</span> (vowel? c) (<span class="op">+</span> i <span class="dv">1</span>) i))</span>
<span id="cb447-14"><a href="#cb447-14" aria-hidden="true"></a>                     <span class="dv">0</span> cs))</span></code></pre></div>
<h2 id="char-set-unfold-f-p-g-seed-base-cs"><code>(char-set-unfold f p g seed [base-cs])</code></h2>
<h2 id="char-set-unfold-f-p-g-seed-base-cs-1"><code>(char-set-unfold! f p g seed base-cs)</code></h2>
<p>This is a fundamental constructor for char-sets.</p>
<ul>
<li><p>G is used to generate a series of “seed” values from the initial seed: seed, (g seed), (g2 seed), (g3 seed), …</p></li>
<li><p>P tells us when to stop – when it returns true when applied to one of these seed values.</p></li>
<li><p>F maps each seed value to a character. These characters are added to the base character set base-cs to form the result; base-cs defaults to the empty set. char-set-unfold! adds the characters to base-cs in a linear-update – it is allowed, but not required, to side-effect and use base-cs’s storage to construct the result.</p></li>
</ul>
<p>More precisely, the following definitions hold, ignoring the optional-argument issues:</p>
<div class="sourceCode" id="cb448"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb448-1"><a href="#cb448-1" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> </span>(char-set-unfold p f g seed base-cs)</span>
<span id="cb448-2"><a href="#cb448-2" aria-hidden="true"></a>      (char-set-unfold! p f g seed (char-set-copy base-cs)))</span>
<span id="cb448-3"><a href="#cb448-3" aria-hidden="true"></a></span>
<span id="cb448-4"><a href="#cb448-4" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> </span>(char-set-unfold! p f g seed base-cs)</span>
<span id="cb448-5"><a href="#cb448-5" aria-hidden="true"></a>      (<span class="kw">let</span> lp ((seed seed) (cs base-cs))</span>
<span id="cb448-6"><a href="#cb448-6" aria-hidden="true"></a>            (<span class="kw">if</span> (p seed) cs                                 <span class="co">; P says we are done.</span></span>
<span id="cb448-7"><a href="#cb448-7" aria-hidden="true"></a>                (lp (g seed)                                <span class="co">; Loop on (G SEED).</span></span>
<span id="cb448-8"><a href="#cb448-8" aria-hidden="true"></a>                    (char-set-adjoin! cs (f seed))))))      <span class="co">; Add (F SEED) to set.</span></span>
<span id="cb448-9"><a href="#cb448-9" aria-hidden="true"></a></span>
<span id="cb448-10"><a href="#cb448-10" aria-hidden="true"></a>    (Note that the actual implementation may be more efficient.)</span></code></pre></div>
<p>Examples:</p>
<div class="sourceCode" id="cb449"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb449-1"><a href="#cb449-1" aria-hidden="true"></a>    (port-&gt;char-set p) <span class="op">=</span> (char-set-unfold <span class="kw">eof-object?</span> <span class="kw">values</span></span>
<span id="cb449-2"><a href="#cb449-2" aria-hidden="true"></a>                                          (<span class="kw">lambda</span> (x) (<span class="kw">read-char</span> p))</span>
<span id="cb449-3"><a href="#cb449-3" aria-hidden="true"></a>                                          (<span class="kw">read-char</span> p))</span>
<span id="cb449-4"><a href="#cb449-4" aria-hidden="true"></a></span>
<span id="cb449-5"><a href="#cb449-5" aria-hidden="true"></a>    (list-&gt;char-set lis) <span class="op">=</span> (char-set-unfold <span class="kw">null?</span> <span class="kw">car</span> <span class="kw">cdr</span> lis)</span></code></pre></div>
<h2 id="char-set-for-each-proc-cs"><code>(char-set-for-each proc cs)</code></h2>
<p>Apply procedure proc to each character in the character set cs. Note that the order in which proc is applied to the characters in the set is not specified, and may even change from one procedure application to another.</p>
<p>Nothing at all is specified about the value returned by this procedure; it is not even required to be consistent from call to call. It is simply required to be a value (or values) that may be passed to a command continuation, e.g. as the value of an expression appearing as a non-terminal subform of a begin expression. Note that in R5RS, this restricts the procedure to returning a single value; non-R5RS systems may not even provide this restriction. char-set-map proc cs -&gt; char-set proc is a char-&gt;char procedure. Apply it to all the characters in the char-set cs, and collect the results into a new character set.</p>
<p>Essentially lifts proc from a char-&gt;char procedure to a char-set -&gt; char-set procedure.</p>
<p>Example:</p>
<div class="sourceCode" id="cb450"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb450-1"><a href="#cb450-1" aria-hidden="true"></a>(char-set-map <span class="kw">char-downcase</span> cset)</span></code></pre></div>
<h2 id="char-set-copy-cs"><code>(char-set-copy cs)</code></h2>
<p>Returns a copy of the character set cs. “Copy” means that if either the input parameter or the result value of this procedure is passed to one of the linear-update procedures described below, the other character set is guaranteed not to be altered.</p>
<p>A system that provides pure-functional implementations of the linear-operator suite could implement this procedure as the identity function – so copies are not guaranteed to be distinct by eq?.</p>
<h2 id="char-set-char1-..."><code>(char-set char1 ...)</code></h2>
<p>Return a character set containing the given characters.</p>
<h2 id="list-char-set-char-list-base-cs"><code>(list-&gt;char-set  char-list [base-cs])</code></h2>
<h2 id="list-char-set-char-list-base-cs-1"><code>(list-&gt;char-set! char-list base-cs)</code></h2>
<p>Return a character set containing the characters in the list of characters char-list.</p>
<p>If character set base-cs is provided, the characters from char-list are added to it. list-&gt;char-set! is allowed, but not required, to side-effect and reuse the storage in base-cs; list-&gt;char-set produces a fresh character set.</p>
<h2 id="string-char-set-s-base-cs"><code>(string-&gt;char-set  s [base-cs])</code></h2>
<h2 id="string-char-set-s-base-cs-1"><code>(string-&gt;char-set! s base-cs)</code></h2>
<p>Return a character set containing the characters in the string s.</p>
<p>If character set base-cs is provided, the characters from s are added to it. string-&gt;char-set! is allowed, but not required, to side-effect and reuse the storage in base-cs; string-&gt;char-set produces a fresh character set.</p>
<h2 id="char-set-filter-pred-cs-base-cs"><code>(char-set-filter  pred cs [base-cs])</code></h2>
<h2 id="char-set-filter-pred-cs-base-cs-1"><code>(char-set-filter! pred cs base-cs)</code></h2>
<p>Returns a character set containing every character c in cs such that (pred c) returns true.</p>
<p>If character set base-cs is provided, the characters specified by pred are added to it. char-set-filter! is allowed, but not required, to side-effect and reuse the storage in base-cs; char-set-filter produces a fresh character set.</p>
<p>An implementation may not save away a reference to pred and invoke it after char-set-filter or char-set-filter! returns – that is, “lazy,” on-demand implementations are not allowed, as pred may have external dependencies on mutable data or have other side-effects.</p>
<p>Rationale: This procedure provides a means of converting a character predicate into its equivalent character set; the cs parameter allows the programmer to bound the predicate’s domain. Programmers should be aware that filtering a character set such as char-set:full could be a very expensive operation in an implementation that provided an extremely large character type, such as 32-bit Unicode. An earlier draft of this library provided a simple predicate-&gt;char-set procedure, which was rejected in favor of char-set-filter for this reason.</p>
<h2 id="ucs-range-char-set-lower-upper-error-base-cs"><code>(ucs-range-&gt;char-set  lower upper [error? base-cs])</code></h2>
<h2 id="ucs-range-char-set-lower-upper-error-base-cs-1"><code>(ucs-range-&gt;char-set! lower upper error? base-cs)</code></h2>
<p>Lower and upper are exact non-negative integers; lower &lt;= upper.</p>
<p>Returns a character set containing every character whose ISO/IEC 10646 UCS-4 code lies in the half-open range [lower,upper).</p>
<p>If the requested range includes unassigned UCS values, these are silently ignored (the current UCS specification has “holes” in the space of assigned codes).</p>
<p>If the requested range includes “private” or “user space” codes, these are handled in an implementation-specific manner; however, a UCS- or Unicode-based Scheme implementation should pass them through transparently.</p>
<p>If any code from the requested range specifies a valid, assigned UCS character that has no corresponding representative in the implementation’s character type, then (1) an error is raised if error? is true, and (2) the code is ignored if error? is false (the default). This might happen, for example, if the implementation uses ASCII characters, and the requested range includes non-ASCII characters.</p>
<p>If character set base-cs is provided, the characters specified by the range are added to it. ucs-range-&gt;char-set! is allowed, but not required, to side-effect and reuse the storage in base-cs; ucs-range-&gt;char-set produces a fresh character set.</p>
<p>Note that ASCII codes are a subset of the Latin-1 codes, which are in turn a subset of the 16-bit Unicode codes, which are themselves a subset of the 32-bit UCS-4 codes. We commit to a specific encoding in this routine, regardless of the underlying representation of characters, so that client code using this library will be portable. I.e., a conformant Scheme implementation may use EBCDIC or SHIFT-JIS to encode characters; it must simply map the UCS characters from the given range into the native representation when possible, and report errors when not possible.</p>
<h2 id="char-set-x"><code>(-&gt;char-set x)</code></h2>
<p>Coerces x into a char-set. X may be a string, character or char-set. A string is converted to the set of its constituent characters; a character is converted to a singleton set; a char-set is returned as-is. This procedure is intended for use by other procedures that want to provide “user-friendly,” wide-spectrum interfaces to their clients.</p>
<h2 id="char-set-size-cs"><code>(char-set-size cs)</code></h2>
<p>Returns the number of elements in character set cs.</p>
<h2 id="char-set-count-pred-cs"><code>(char-set-count pred cs)</code></h2>
<p>Apply pred to the chars of character set cs, and return the number of chars that caused the predicate to return true.</p>
<h2 id="char-set-list-cs"><code>(char-set-&gt;list cs)</code></h2>
<p>This procedure returns a list of the members of character set cs. The order in which cs’s characters appear in the list is not defined, and may be different from one call to another.</p>
<h2 id="char-set-string-cs"><code>(char-set-&gt;string cs)</code></h2>
<p>This procedure returns a string containing the members of character set cs. The order in which cs’s characters appear in the string is not defined, and may be different from one call to another.</p>
<h2 id="char-set-contains-cs-char"><code>(char-set-contains? cs char)</code></h2>
<p>This procedure tests char for membership in character set cs.</p>
<p>The MIT Scheme character-set package called this procedure char-set-member?, but the argument order isn’t consistent with the name.</p>
<h2 id="char-set-every-pred-cs"><code>(char-set-every pred cs)</code></h2>
<h2 id="char-set-any-pred-cs"><code>(char-set-any   pred cs)</code></h2>
<p>The char-set-every procedure returns true if predicate pred returns true of every character in the character set cs. Likewise, char-set-any applies pred to every character in character set cs, and returns the first true value it finds. If no character produces a true value, it returns false. The order in which these procedures sequence through the elements of cs is not specified.</p>
<p>Note that if you need to determine the actual character on which a predicate returns true, use char-set-any and arrange for the predicate to return the character parameter as its true value, e.g.</p>
<div class="sourceCode" id="cb451"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb451-1"><a href="#cb451-1" aria-hidden="true"></a>    (char-set-any (<span class="kw">lambda</span> (c) (<span class="kw">and</span> (<span class="kw">char-upper-case?</span> c) c))</span>
<span id="cb451-2"><a href="#cb451-2" aria-hidden="true"></a>                  cs)</span></code></pre></div>
<h2 id="char-set-adjoin-cs-char1-..."><code>(char-set-adjoin cs char1 ...)</code></h2>
<h2 id="char-set-delete-cs-char1-..."><code>(char-set-delete cs char1 ...)</code></h2>
<p>Add/delete the chari characters to/from character set cs.</p>
<h2 id="char-set-adjoin-cs-char1-...-1"><code>(char-set-adjoin! cs char1 ...)</code></h2>
<h2 id="char-set-delete-cs-char1-...-1"><code>(char-set-delete! cs char1 ...)</code></h2>
<p>Linear-update variants. These procedures are allowed, but not required, to side-effect their first parameter.</p>
<h2 id="char-set-complement-cs"><code>(char-set-complement cs)</code></h2>
<h2 id="char-set-union-cs1-..."><code>(char-set-union cs1 ...)</code></h2>
<h2 id="char-set-intersection-cs1-..."><code>(char-set-intersection cs1 ...)</code></h2>
<h2 id="char-set-difference-cs1-cs2-..."><code>(char-set-difference cs1 cs2 ...)</code></h2>
<h2 id="char-set-xor-cs1-..."><code>(char-set-xor cs1 ...)</code></h2>
<h2 id="char-set-diffintersection-cs1-cs2-..."><code>(char-set-diff+intersection cs1 cs2 ...)</code></h2>
<p>These procedures implement set complement, union, intersection, difference, and exclusive-or for character sets. The union, intersection and xor operations are n-ary. The difference function is also n-ary, associates to the left (that is, it computes the difference between its first argument and the union of all the other arguments), and requires at least one argument.</p>
<p>Boundary cases:</p>
<div class="sourceCode" id="cb452"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb452-1"><a href="#cb452-1" aria-hidden="true"></a>(char-set-union) <span class="op">=&gt;</span> char-set:empty</span>
<span id="cb452-2"><a href="#cb452-2" aria-hidden="true"></a>(char-set-intersection) <span class="op">=&gt;</span> char-set:full</span>
<span id="cb452-3"><a href="#cb452-3" aria-hidden="true"></a>(char-set-xor) <span class="op">=&gt;</span> char-set:empty</span>
<span id="cb452-4"><a href="#cb452-4" aria-hidden="true"></a>(char-set-difference cs) <span class="op">=&gt;</span> cs</span></code></pre></div>
<p>char-set-diff+intersection returns both the difference and the intersection of the arguments – it partitions its first parameter. It is equivalent to</p>
<div class="sourceCode" id="cb453"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb453-1"><a href="#cb453-1" aria-hidden="true"></a>(<span class="kw">values</span> (char-set-difference cs1 cs2 ...)</span>
<span id="cb453-2"><a href="#cb453-2" aria-hidden="true"></a>        (char-set-intersection cs1 (char-set-union cs2 ...)))</span></code></pre></div>
<p>but can be implemented more efficiently.</p>
<p>Programmers should be aware that char-set-complement could potentially be a very expensive operation in Scheme implementations that provide a very large character type, such as 32-bit Unicode. If this is a possibility, sets can be complimented with respect to a smaller universe using char-set-difference.</p>
<h2 id="char-set-complement-cs-1"><code>(char-set-complement! cs)</code></h2>
<h2 id="char-set-union-cs1-cs2-..."><code>(char-set-union! cs1 cs2 ...)</code></h2>
<h2 id="char-set-intersection-cs1-cs2-..."><code>(char-set-intersection! cs1 cs2 ...)</code></h2>
<h2 id="char-set-difference-cs1-cs2-...-1"><code>(char-set-difference! cs1 cs2 ...)</code></h2>
<h2 id="char-set-xor-cs1-cs2-..."><code>(char-set-xor! cs1 cs2 ...)</code></h2>
<h2 id="char-set-diffintersection-cs1-cs2-cs3-..."><code>(char-set-diff+intersection! cs1 cs2 cs3 ...)</code></h2>
<p>These are linear-update variants of the set-algebra functions. They are allowed, but not required, to side-effect their first (required) parameter.</p>
<p>char-set-diff+intersection! is allowed to side-effect both of its two required parameters, cs1 and cs2.</p>
<h2 id="char-setlower-case"><code>char-set:lower-case</code></h2>
<p>Lower-case letters</p>
<h2 id="char-setupper-case"><code>char-set:upper-case</code></h2>
<p>Upper-case letters</p>
<h2 id="char-settitle-case"><code>char-set:title-case</code></h2>
<p>Title-case letters</p>
<h2 id="char-setletter"><code>char-set:letter</code></h2>
<p>Letters</p>
<h2 id="char-setdigit"><code>char-set:digit</code></h2>
<p>Digits</p>
<h2 id="char-setletterdigit"><code>char-set:letter+digit</code></h2>
<p>Letters and digits</p>
<h2 id="char-setgraphic"><code>char-set:graphic</code></h2>
<p>Printing characters except spaces</p>
<h2 id="char-setprinting"><code>char-set:printing</code></h2>
<p>Printing characters including spaces</p>
<h2 id="char-setwhitespace"><code>char-set:whitespace</code></h2>
<p>Whitespace characters</p>
<h2 id="char-setiso-control"><code>char-set:iso-control</code></h2>
<p>The ISO control characters</p>
<h2 id="char-setpunctuation"><code>char-set:punctuation</code></h2>
<p>Punctuation characters</p>
<h2 id="char-setsymbol"><code>char-set:symbol</code></h2>
<p>Symbol characters</p>
<h2 id="char-sethex-digit"><code>char-set:hex-digit</code></h2>
<p>A hexadecimal digit: 0-9, A-F, a-f</p>
<h2 id="char-setblank"><code>char-set:blank</code></h2>
<p>Blank characters – horizontal whitespace</p>
<h2 id="char-setascii"><code>char-set:ascii</code></h2>
<p>All characters in the ASCII set.</p>
<h2 id="char-setempty"><code>char-set:empty</code></h2>
<p>Empty set</p>
<h2 id="char-setfull"><code>char-set:full</code></h2>
<p>All characters # <code>(scheme time)</code></p>
<h2 id="current-jiffy"><code>(current-jiffy)</code></h2>
<p>Returns the number of jiffies as an exact integer that have elapsed since an arbitrary, implementation-defined epoch. A jiffy is an implementation-defined fraction of a second which is defined by the return value of the jiffies-per-second procedure. The starting epoch is guaranteed to be constant during a run of the program, but may vary between runs.</p>
<h2 id="current-second"><code>(current-second)</code></h2>
<p>Returns an inexact number representing the current time on the International Atomic Time (TAI) scale. The value 0.0 represents midnight on January 1, 1970 TAI (equivalent to ten seconds before midnight Universal Time) and the value 1.0 represents one TAI second later. Neither high accuracy nor high precision are required; in particular, returning Coordinated Universal Time plus a suitable constant might be the best an implementation can do.</p>
<h2 id="jiffies-per-second"><code>(jiffies-per-second)</code></h2>
<p>Returns an exact integer representing the number of jiffies per SI second. This value is an implementation-specified constant.</p>
<h1 id="scheme-char"><code>(scheme char)</code></h1>
<h2 id="char-alphabetic-char"><code>(char-alphabetic? char)</code></h2>
<p>TODO</p>
<h2 id="char-alphabetic-char-1"><code>(char-alphabetic? char)</code></h2>
<p>TODO</p>
<h2 id="char-ci-char"><code>(char-ci&lt;=? char)</code></h2>
<p>TODO</p>
<h2 id="char-ci-char-1"><code>(char-ci&lt;? char)</code></h2>
<p>TODO</p>
<h2 id="char-ci-char-2"><code>(char-ci=? char)</code></h2>
<p>TODO</p>
<h2 id="char-ci-char-3"><code>(char-ci&gt;=? char)</code></h2>
<p>TODO</p>
<h2 id="char-ci-char-4"><code>(char-ci&gt;? char)</code></h2>
<p>TODO</p>
<h2 id="char-downcase-char"><code>(char-downcase char)</code></h2>
<p>TODO</p>
<h2 id="char-foldcase-char"><code>(char-foldcase char)</code></h2>
<p>TODO</p>
<h2 id="char-lower-case-char"><code>(char-lower-case? char)</code></h2>
<p>TODO</p>
<h2 id="char-numeric-char"><code>(char-numeric? char)</code></h2>
<p>TODO</p>
<h2 id="char-upcase-char"><code>(char-upcase char)</code></h2>
<p>TODO</p>
<h2 id="char-upper-case-char"><code>(char-upper-case? char)</code></h2>
<p>TODO</p>
<h2 id="char-whitespace-char"><code>(char-whitespace? char)</code></h2>
<p>TODO</p>
<h2 id="string-ci-string1-string2-..."><code>(string-ci&lt;=? string1 string2 ...)</code></h2>
<p>TODO</p>
<h2 id="string-ci-string1-string2-...-1"><code>(string-ci&lt;? string1 string2 ...)</code></h2>
<p>TODO</p>
<h2 id="string-ci-string1-string2-...-2"><code>(string-ci=? string1 string2 ...)</code></h2>
<p>TODO</p>
<h2 id="string-ci-string1-string2-...-3"><code>(string-ci&gt;=? string1 string2 ...)</code></h2>
<p>TODO</p>
<h2 id="string-ci-string1-string2-...-4"><code>(string-ci&gt;? string1 string2 ...)</code></h2>
<p>TODO</p>
<h2 id="string-downcase-string"><code>(string-downcase string)</code></h2>
<p>TODO</p>
<h2 id="string-foldcase-string"><code>(string-foldcase string)</code></h2>
<p>TODO</p>
<h2 id="string-upcase-string"><code>(string-upcase string)</code></h2>
<p>TODO # <code>(scheme complex)</code></p>
<h2 id="angle"><code>angle</code></h2>
<p>TODO</p>
<h2 id="imag-part"><code>imag-part</code></h2>
<p>TODO</p>
<h2 id="magnitude"><code>magnitude</code></h2>
<p>TODO</p>
<h2 id="make-polar"><code>make-polar</code></h2>
<p>TODO</p>
<h2 id="make-rectangular"><code>make-rectangular</code></h2>
<p>TODO</p>
<h2 id="real-part"><code>real-part</code></h2>
<p>TODO # <code>(scheme idque)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-134/">SRFI-134</a>.</p>
<p>This SRFI defines immutable deques. A deque is a double-ended queue, a sequence which allows elements to be added or removed efficiently from either end. A structure is immutable when all its operations leave the structure unchanged. Note that none of the procedures specified here ends with an exclamation point.</p>
<p>This SRFI describes immutable deques, or ideques. Immutable structures are sometimes called persistent and are closely related to pure functional (a.k.a. pure) structures. The availability of immutable data structures facilitates writing efficient programs in the pure-functional style. Immutable deques can also be seen as a bidirectional generalization of immutable lists, and some of the procedures documented below are most useful in that context. Unlike the immutable lists of SRFI 116, it is efficient to produce modified versions of an ideque; unlike the list queues of SRFI 117, it is possible to efficiently return an updated version of an ideque without mutating any earlier versions of it.</p>
<p>The specification was designed jointly by Kevin Wortman and John Cowan. John Cowan is the editor and shepherd. The two-list implementation was written by John Cowan.</p>
<h2 id="ideque-element-..."><code>(ideque element ...)</code></h2>
<p>Returns an ideque containing the elements. The first element (if any) will be at the front of the ideque and the last element (if any) will be at the back. Takes O(n) time, where n is the number of elements.</p>
<h2 id="ideque-tabulate-n-proc"><code>(ideque-tabulate n proc)</code></h2>
<p>Invokes the predicate proc on every exact integer from 0 (inclusive) to n (exclusive). Returns an ideque containing the results in order of generation. Takes O(n) time.</p>
<h2 id="ideque-unfold-stop-mapper-successor-seed"><code>(ideque-unfold stop? mapper successor seed)</code></h2>
<p>Invokes the predicate stop? on seed. If it returns false, generate the next result by applying mapper to seed, generate the next seed by applying successor to seed, and repeat this algorithm with the new seed. If stop? returns true, return an ideque containing the results in order of accumulation. Takes O(n) time.</p>
<h2 id="ideque-unfold-right-stop-mapper-successor-seed"><code>(ideque-unfold-right stop? mapper successor seed)</code></h2>
<p>Invokes the predicate stop? on seed. If it returns false, generate the next result by applying mapper to seed, generate the next seed by applying successor to seed, and repeat the algorithm with the new seed. If stop? returns true, return an ideque containing the results in reverse order of accumulation. Takes O(n) time. Predicates</p>
<h2 id="ideque-x"><code>(ideque? x)</code></h2>
<p>Returns #t if x is an ideque, and #f otherwise. Takes O(1) time.</p>
<h2 id="ideque-empty-idaeque"><code>(ideque-empty? idaeque)</code></h2>
<p>Returns #t if ideque contains zero elements, and #f otherwise. Takes O(1) time.</p>
<h2 id="ideque-elt-ideque-..."><code>(ideque= elt= ideque ...)</code></h2>
<p>Determines ideque equality, given an element-equality procedure. Ideque A equals ideque B if they are of the same length, and their corresponding elements are equal, as determined by elt=. If the element-comparison procedure’s first argument is from idequei, then its second argument is from idequei+1, i.e. it is always called as (elt= a b) for a an element of ideque A, and b an element of ideque B.</p>
<p>In the n-ary case, every idequei is compared to idequei+1 (as opposed, for example, to comparing ideque1 to every idequei, for i &gt; 1). If there are zero or one ideque arguments, ideque= simply returns true. The name does not end in a question mark for compatibility with the SRFI-1 procedure list=.</p>
<p>Note that the dynamic order in which the elt= procedure is applied to pairs of elements is not specified. For example, if ideque= is applied to three ideques, A, B, and C, it may first completely compare A to B, then compare B to C, or it may compare the first elements of A and B, then the first elements of B and C, then the second elements of A and B, and so forth.</p>
<p>The equality procedure must be consistent with eq?. Note that this implies that two ideques which are eq? are always ideque=, as well; implementations may exploit this fact to “short-cut” the element-by-element comparisons.</p>
<h2 id="ideque-any-pred-ideque"><code>(ideque-any pred ideque)</code></h2>
<h2 id="ideque-every-pred-ideque"><code>(ideque-every pred ideque)</code></h2>
<p>Invokes pred on the elements of the ideque in order until one call returns a true/false value, which is then returned. If there are no elements, returns #f/#t. Takes O(n) time. Queue operations</p>
<h2 id="ideque-front-ideque"><code>(ideque-front ideque)</code></h2>
<h2 id="ideque-back-ideque"><code>(ideque-back ideque)</code></h2>
<p>Returns the front/back element of ideque. It is an error for ideque to be empty. Takes O(1) time.</p>
<h2 id="ideque-remove-front-ideque"><code>(ideque-remove-front ideque)</code></h2>
<h2 id="ideque-remove-back-ideque"><code>(ideque-remove-back ideque)</code></h2>
<p>Returns an ideque with the front/back element of ideque removed. It is an error for ideque to be empty. Takes O(1) time.</p>
<h2 id="ideque-add-front-ideque-obj"><code>(ideque-add-front ideque obj)</code></h2>
<h2 id="ideque-add-back-ideque-obj"><code>(ideque-add-back ideque obj)</code></h2>
<p>Returns an ideque with obj pushed to the front/back of ideque. Takes O(1) time. Other accessors</p>
<h2 id="ideque-ref-ideque-n"><code>(ideque-ref ideque n)</code></h2>
<p>Returns the nth element of ideque. It is an error unless n is less than the length of ideque. Takes O(n) time.</p>
<h2 id="ideque-take-ideque-n"><code>(ideque-take ideque n)</code></h2>
<h2 id="ideque-take-right-ideque-n"><code>(ideque-take-right ideque n)</code></h2>
<p>Returns an ideque containing the first/last n elements of ideque. It is an error if n is greater than the length of ideque. Takes O(n) time.</p>
<h2 id="ideque-drop-ideque-n"><code>(ideque-drop ideque n)</code></h2>
<h2 id="ideque-drop-right-ideque-n"><code>(ideque-drop-right ideque n)</code></h2>
<p>Returns an ideque containing all but the first/last n elements of ideque. It is an error if n is greater than the length of ideque. Takes O(n) time.</p>
<h2 id="ideque-split-at-ideque-n"><code>(ideque-split-at ideque n)</code></h2>
<p>Returns two values, the results of (ideque-take ideque n) and (ideque-drop ideque n) respectively, but may be more efficient. Takes O(n) time. The whole ideque</p>
<h2 id="ideque-length-ideque"><code>(ideque-length ideque)</code></h2>
<p>Returns the length of ideque as an exact integer. May take O(n) time, though O(1) is optimal.</p>
<h2 id="ideque-append-ideque-..."><code>(ideque-append ideque ...)</code></h2>
<p>Returns an ideque with the contents of the ideque followed by the others, or an empty ideque if there are none. Takes O(kn) time, where k is the number of ideques and n is the number of elements involved, though O(k log n) is possible.</p>
<h2 id="ideque-reverse-ideque"><code>(ideque-reverse ideque)</code></h2>
<p>Returns an ideque containing the elements of ideque in reverse order. Takes O(1) time.</p>
<h2 id="ideque-count-pred-ideque"><code>(ideque-count pred ideque)</code></h2>
<p>Pred is a procedure taking a single value and returning a single value. It is applied element-wise to the elements of ideque, and a count is tallied of the number of elements that produce a true value. This count is returned. Takes O(n) time. The dynamic order of calls to pred is unspecified.</p>
<h2 id="ideque-zip-ideque1-ideque2-..."><code>(ideque-zip ideque1 ideque2 ...)</code></h2>
<p>Returns an ideque of lists (not ideques) each of which contains the corresponding elements of ideques in the order specified. Terminates when all the elements of any of the ideques have been processed. Takes O(kn) time, where k is the number of ideques and n is the number of elements in the shortest ideque.</p>
<h2 id="ideque-map-proc-ideque"><code>(ideque-map proc ideque)</code></h2>
<p>Applies proc to the elements of ideque and returns an ideque containing the results in order. The dynamic order of calls to proc is unspecified. Takes O(n) time.</p>
<h2 id="ideque-filter-map-proc-ideque"><code>(ideque-filter-map proc ideque)</code></h2>
<p>Applies proc to the elements of ideque and returns an ideque containing the true (i.e. non-#f) results in order. The dynamic order of calls to proc is unspecified. Takes O(n) time.</p>
<h2 id="ideque-for-each-proc-ideque"><code>(ideque-for-each proc ideque)</code></h2>
<h2 id="ideque-for-each-right-proc-ideque"><code>(ideque-for-each-right proc ideque)</code></h2>
<p>Applies proc to the elements of ideque in forward/reverse order and returns an unspecified result. Takes O(n) time.</p>
<h2 id="ideque-fold-proc-nil-ideque"><code>(ideque-fold proc nil ideque)</code></h2>
<h2 id="ideque-fold-right-proc-nil-ideque"><code>(ideque-fold-right proc nil ideque)</code></h2>
<p>Invokes proc on the elements of ideque in forward/reverse order, passing the result of the previous invocation as a second argument. For the first invocation, nil is used as the second argument. Returns the result of the last invocation, or nil if there was no invocation. Takes O(n) time.</p>
<h2 id="ideque-append-map-proc-ideque"><code>(ideque-append-map proc ideque)</code></h2>
<p>Applies proc to the elements of ideque. It is an error if the result is not a list. Returns an ideque containing the elements of the lists in order. Takes O(n) time, where n is the number of elements in all the lists returned.</p>
<h2 id="ideque-filter-pred-ideque"><code>(ideque-filter pred ideque)</code></h2>
<h2 id="ideque-remove-pred-ideque"><code>(ideque-remove pred ideque)</code></h2>
<p>Returns an ideque containing the elements of ideque that do/do not satisfy pred. Takes O(n) time.</p>
<h2 id="ideque-partition-proc-ideque"><code>(ideque-partition proc ideque)</code></h2>
<p>Returns two values, the results of (ideque-filter pred ideque) and (ideque-remove pred ideque) respectively, but may be more efficient. Takes O(n) time.</p>
<h2 id="ideque-find-pred-ideque-failure"><code>(ideque-find pred ideque [ failure ])</code></h2>
<h2 id="ideque-find-right-pred-ideque-failure"><code>(ideque-find-right pred ideque [ failure ])</code></h2>
<p>Returns the first/last element of ideque that satisfies pred. If there is no such element, returns the result of invoking the thunk failure; the default thunk is (lambda () #f). Takes O(n) time.</p>
<h2 id="ideque-take-while-pred-ideque"><code>(ideque-take-while pred ideque)</code></h2>
<h2 id="ideque-take-while-right-pred-ideque"><code>(ideque-take-while-right pred ideque)</code></h2>
<p>Returns an ideque containing the longest initial/final prefix of elements in ideque all of which satisfy pred. Takes O(n) time.</p>
<h2 id="ideque-drop-while-pred-ideque"><code>(ideque-drop-while pred ideque)</code></h2>
<h2 id="ideque-drop-while-right-pred-ideque"><code>(ideque-drop-while-right pred ideque)</code></h2>
<p>Returns an ideque which omits the longest initial/final prefix of elements in ideque all of which satisfy pred, but includes all other elements of ideque. Takes O(n) time.</p>
<h2 id="ideque-span-pred-ideque"><code>(ideque-span pred ideque)</code></h2>
<h2 id="ideque-break-pred-ideque"><code>(ideque-break pred ideque)</code></h2>
<p>Returns two values, the initial prefix of the elements of ideque which do/do not satisfy pred, and the remaining elements. Takes O(n) time.</p>
<h2 id="list-ideque-list"><code>(list-&gt;ideque list)</code></h2>
<h2 id="ideque-list-ideque"><code>(ideque-&gt;list ideque)</code></h2>
<p>Conversion between ideque and list structures. FIFO order is preserved, so the front of a list corresponds to the front of an ideque. Each operation takes O(n) time.</p>
<h2 id="generator-ideque-generator"><code>(generator-&gt;ideque generator)</code></h2>
<h2 id="ideque-generator-ideque"><code>(ideque-&gt;generator ideque)</code></h2>
<p>Conversion between SRFI 121 generators and ideques. Each operation takes O(n) time. A generator is a procedure that is called repeatedly with no arguments to generate consecutive values, and returns an end-of-file object when it has no more values to return. # <code>(scheme bytevector)</code></p>
<p>This is based on <a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-3.html#node_chap_2">R6RS bytevectors library</a></p>
<h2 id="endianness-endianess-symbol-syntax"><code>(endianness &lt;endianess symbol&gt;)</code> syntax</h2>
<h2 id="native-endianness"><code>(native-endianness)</code></h2>
<p>Returns the endianness symbol associated implementation’s preferred endianness (usually that of the underlying machine architecture). This may be any <code>&lt;endianness symbol&gt;</code>, including a symbol other than big and little.</p>
<h2 id="bytevector-obj"><code>(bytevector? obj)</code></h2>
<p>Returns #t if obj is a bytevector, otherwise returns #f.</p>
<h2 id="make-bytevector-k-fill"><code>(make-bytevector k [fill])</code></h2>
<p>Returns a newly allocated bytevector of <code>K</code> bytes.</p>
<p>If the <code>FILL</code> argument is missing, the initial contents of the returned bytevector are unspecified.</p>
<p>If the <code>FILL</code> argument is present, it must be an exact integer object in the interval {-128, … 255} that specifies the initial value for the bytes of the bytevector: If <code>FILL</code> is positive, it is interpreted as an octet; if it is negative, it is interpreted as a byte.</p>
<h2 id="bytevector-length-bytevector"><code>(bytevector-length bytevector)</code></h2>
<p>Returns, as an exact integer object, the number of bytes in bytevector.</p>
<h2 id="bytevector-bytevector1-bytevector2"><code>(bytevector=? bytevector1 bytevector2)</code></h2>
<p>Returns #t if bytevector1 and bytevector2 are equal-that is, if they have the same length and equal bytes at all valid indices. It returns #f otherwise.</p>
<h2 id="bytevector-fill-bytevector-fill"><code>(bytevector-fill! bytevector fill)</code></h2>
<p>The fill argument is as in the description of the make-bytevector procedure. The bytevector-fill! procedure stores fill in every element of bytevector and returns unspecified values. Analogous to vector-fill!.</p>
<h2 id="bytevector-copy-source-source-start-target-target-start-k"><code>(bytevector-copy! source source-start‌‌ target target-start k)</code></h2>
<h2 id="bytevector-copy-bytevector"><code>(bytevector-copy bytevector)‌‌</code></h2>
<p>Returns a newly allocated copy of bytevector.</p>
<h2 id="bytevector-u8-ref-bytevector-k"><code>(bytevector-u8-ref bytevector k)‌‌</code></h2>
<p>The bytevector-u8-ref procedure returns the byte at index k of bytevector, as an octet.</p>
<h2 id="bytevector-s8-ref-bytevector-k"><code>(bytevector-s8-ref bytevector k)‌‌</code></h2>
<p>The bytevector-s8-ref procedure returns the byte at index k of bytevector, as a (signed) byte.</p>
<h2 id="bytevector-u8-set-bytevector-k-octet"><code>(bytevector-u8-set! bytevector k octet)‌‌</code></h2>
<p>The bytevector-u8-set! procedure stores octet in element k of bytevector.</p>
<h2 id="bytevector-s8-set-bytevector-k-byte"><code>(bytevector-s8-set! bytevector k byte)‌‌</code></h2>
<p>The bytevector-s8-set! procedure stores the two’s-complement representation of byte in element k of bytevector.</p>
<h2 id="bytevector-u8-list-bytevector"><code>(bytevector-&gt;u8-list bytevector)‌‌</code></h2>
<p>The bytevector-&gt;u8-list procedure returns a newly allocated list of the octets of bytevector in the same order.</p>
<h2 id="u8-list-bytevector-list"><code>(u8-list-&gt;bytevector list)‌‌</code></h2>
<p>The u8-list-&gt;bytevector procedure returns a newly allocated bytevector whose elements are the elements of list list, in the same order. It is analogous to list-&gt;vector.</p>
<h2 id="bytevector-uint-ref-bytevector-k-endianness-size"><code>(bytevector-uint-ref bytevector k endianness size)‌‌</code></h2>
<h2 id="bytevector-sint-ref-bytevector-k-endianness-size"><code>(bytevector-sint-ref bytevector k endianness size)‌‌</code></h2>
<h2 id="bytevector-uint-set-bytevector-k-n-endianness-size"><code>(bytevector-uint-set! bytevector k n endianness size)‌‌</code></h2>
<h2 id="bytevector-sint-set-bytevector-k-n-endianness-size"><code>(bytevector-sint-set! bytevector k n endianness size)‌‌</code></h2>
<h2 id="bytevector-uint-list-bytevector-endianness-size"><code>(bytevector-&gt;uint-list bytevector endianness size)‌‌</code></h2>
<h2 id="bytevector-sint-list-bytevector-endianness-sizee"><code>(bytevector-&gt;sint-list bytevector endianness sizee‌‌</code></h2>
<h2 id="uint-list-bytevector-list-endianness-size"><code>(uint-list-&gt;bytevector list endianness size)‌‌</code></h2>
<h2 id="sint-list-bytevector-list-endianness-size"><code>(sint-list-&gt;bytevector list endianness size)‌‌</code></h2>
<h2 id="bytevector-u16-ref-bytevector-k-endianness"><code>(bytevector-u16-ref bytevector k endianness)‌‌</code></h2>
<h2 id="bytevector-s16-ref-bytevector-k-endianness"><code>(bytevector-s16-ref bytevector k endianness)‌‌</code></h2>
<h2 id="bytevector-u16-native-ref-bytevector-k"><code>(bytevector-u16-native-ref bytevector k)‌‌</code></h2>
<h2 id="bytevector-s16-native-ref-bytevector-k"><code>(bytevector-s16-native-ref bytevector k)‌‌</code></h2>
<h2 id="bytevector-u16-set-bytevector-k-n-endianness"><code>(bytevector-u16-set! bytevector k n endianness)‌‌</code></h2>
<h2 id="bytevector-s16-set-bytevector-k-n-endianness"><code>(bytevector-s16-set! bytevector k n endianness)‌‌</code></h2>
<h2 id="bytevector-u16-native-set-bytevector-k-n"><code>(bytevector-u16-native-set! bytevector k n)‌‌</code></h2>
<h2 id="bytevector-s16-native-set-bytevector-k-n"><code>(bytevector-s16-native-set! bytevector k n)‌‌</code></h2>
<h2 id="bytevector-u32-ref-bytevector-k-endianness"><code>(bytevector-u32-ref bytevector k endianness)‌‌</code></h2>
<h2 id="bytevector-s32-ref-bytevector-k-endianness"><code>(bytevector-s32-ref bytevector k endianness)‌‌</code></h2>
<h2 id="bytevector-u32-native-ref-bytevector-k"><code>(bytevector-u32-native-ref bytevector k)‌‌</code></h2>
<h2 id="bytevector-s32-native-ref-bytevector-k"><code>(bytevector-s32-native-ref bytevector k)‌‌</code></h2>
<h2 id="bytevector-u32-set-bytevector-k-n-endianness"><code>(bytevector-u32-set! bytevector k n endianness)‌‌</code></h2>
<h2 id="bytevector-s32-set-bytevector-k-n-endianness"><code>(bytevector-s32-set! bytevector k n endianness)‌‌</code></h2>
<h2 id="bytevector-u32-native-set-bytevector-k-n"><code>(bytevector-u32-native-set! bytevector k n)‌‌</code></h2>
<h2 id="bytevector-s32-native-set-bytevector-k-n"><code>(bytevector-s32-native-set! bytevector k n)‌‌</code></h2>
<h2 id="bytevector-u64-ref-bytevector-k-endianness"><code>(bytevector-u64-ref bytevector k endianness)‌‌</code></h2>
<h2 id="bytevector-s64-ref-bytevector-k-endianness"><code>(bytevector-s64-ref bytevector k endianness)‌‌</code></h2>
<h2 id="bytevector-u64-native-ref-bytevector-k"><code>(bytevector-u64-native-ref bytevector k)‌‌</code></h2>
<h2 id="bytevector-s64-native-ref-bytevector-k"><code>(bytevector-s64-native-ref bytevector k)‌‌</code></h2>
<h2 id="bytevector-u64-set-bytevector-k-n-endianness"><code>(bytevector-u64-set! bytevector k n endianness)‌‌</code></h2>
<h2 id="bytevector-s64-set-bytevector-k-n-endianness"><code>(bytevector-s64-set! bytevector k n endianness)‌‌</code></h2>
<h2 id="bytevector-u64-native-set-bytevector-k-n"><code>(bytevector-u64-native-set! bytevector k n)‌‌</code></h2>
<h2 id="bytevector-s64-native-set-bytevector-k-n"><code>(bytevector-s64-native-set! bytevector k n)‌‌</code></h2>
<h2 id="bytevector-ieee-single-native-ref-bytevector-k"><code>(bytevector-ieee-single-native-ref bytevector k)‌‌</code></h2>
<h2 id="bytevector-ieee-single-ref-bytevector-k-endianness"><code>(bytevector-ieee-single-ref bytevector k endianness)‌‌</code></h2>
<h2 id="bytevector-ieee-double-native-ref-bytevector-k"><code>(bytevector-ieee-double-native-ref bytevector k)‌‌</code></h2>
<h2 id="bytevector-ieee-double-ref-bytevector-k-endianness"><code>(bytevector-ieee-double-ref bytevector k endianness)‌‌</code></h2>
<h2 id="bytevector-ieee-single-native-set-bytevector-k-x"><code>(bytevector-ieee-single-native-set! bytevector k x)‌‌</code></h2>
<h2 id="bytevector-ieee-single-set-bytevector-k-x-endianness"><code>(bytevector-ieee-single-set! bytevector ‌k x endianness)</code></h2>
<h2 id="bytevector-ieee-double-native-set-bytevector-k-x"><code>(bytevector-ieee-double-native-set! bytevector k x)‌‌</code></h2>
<h2 id="bytevector-ieee-double-set-bytevector-k-x-endianness"><code>(bytevector-ieee-double-set! bytevector k x endianness)‌</code></h2>
<h2 id="string-utf8-string"><code>(string-&gt;utf8 string)‌‌</code></h2>
<h2 id="string-utf16-string"><code>(string-&gt;utf16 string)‌‌</code></h2>
<h2 id="string-utf16-string-endianness"><code>(string-&gt;utf16 string endianness)‌‌</code></h2>
<h2 id="string-utf32-string"><code>(string-&gt;utf32 string)‌‌</code></h2>
<h2 id="string-utf32-string-endianness"><code>(string-&gt;utf32 string endianness)‌‌</code></h2>
<h2 id="utf8-string-bytevector"><code>(utf8-&gt;string bytevector)‌‌</code></h2>
<h2 id="utf16-string-bytevector-endianness"><code>(utf16-&gt;string bytevector endianness)‌‌</code></h2>
<h2 id="utf16-string-bytevector-endianness-endianness-mandatory"><code>(utf16-&gt;string bytevector‌ endianness endianness-mandatory)</code></h2>
<h2 id="utf32-string-bytevector-endianness"><code>(utf32-&gt;string bytevector endianness)‌‌</code></h2>
<h2 id="utf32-string-bytevector-endianness-endianness-mandatory"><code>(utf32-&gt;string bytevector‌ endianness endianness-mandatory)</code></h2>
<h1 id="scheme-file"><code>(scheme file)</code></h1>
<h2 id="call-with-input-file"><code>(call-with-input-file)</code></h2>
<p>TODO</p>
<h2 id="call-with-output-file"><code>(call-with-output-file)</code></h2>
<p>TODO</p>
<h2 id="delete-file"><code>(delete-file)</code></h2>
<p>TODO</p>
<h2 id="file-exists"><code>(file-exists?)</code></h2>
<p>TODO</p>
<h2 id="open-input-file"><code>(open-input-file)</code></h2>
<p>TODO</p>
<h2 id="open-output-file"><code>(open-output-file)</code></h2>
<p>TODO</p>
<h2 id="with-input-from-file"><code>(with-input-from-file)</code></h2>
<p>TODO</p>
<h2 id="with-output-to-file"><code>(with-output-to-file)</code></h2>
<p>TODO</p>
<h2 id="open-binary-input-file"><code>(open-binary-input-file)</code></h2>
<p>TODO</p>
<h2 id="open-binary-output-file"><code>(open-binary-output-file)</code></h2>
<p>TODO # <code>(scheme eval)</code></p>
<h2 id="environment-list1-..."><code>(environment list1 ...)</code></h2>
<p>This procedure returns a specifier for the environment that results by starting with an empty environment and then importing each list, considered as an import set, into it. The bindings of the environment represented by the specifier are immutable, as is the environment itself.</p>
<h2 id="eval-expr-or-def-environment-specifier"><code>(eval expr-or-def environment-specifier)</code></h2>
<p>If <code>expr-or-def</code> is an expression, it is evaluated in the specified environment and its values are returned. If it is a definition, the specified identifier(s) are defined in the specified environment, provided the environment is not immutable. Implementations may extend <code>eval</code> to allow other objects. # <code>(scheme show)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-159/">SRFI-159</a>.</p>
<p>A library of procedures for formatting Scheme objects to text in various ways, and for easily concatenating, composing and extending these formatters efficiently without resorting to capturing and manipulating intermediate strings.</p>
<h2 id="show-output-dest-fmt-..."><code>(show output-dest fmt ...)</code></h2>
<p>The entry point for all formatting. Applies the fmt formatters in sequence, accumulating the output to output-dest. As with SRFI 28 format, output-dest can be an output port, #t to indicate the current output port, or #f to accumulate the output into a string and return that as the result of show.</p>
<p>Each fmt should be a formatter as discussed below. As a convenience, non-formatter arguments are also allowed and are formatted as if wrapped with displayed, described below, so that</p>
<div class="sourceCode" id="cb454"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb454-1"><a href="#cb454-1" aria-hidden="true"></a>(show <span class="dv">#f</span> <span class="st">&quot;π = &quot;</span> (with ((precision <span class="dv">2</span>)) (<span class="kw">acos</span> <span class="dv">-1</span>)) nl)</span></code></pre></div>
<p>would return the string “π = 3.14”.</p>
<p>As mentioned, formatters are an opaque type and cannot directly be applied outside of show. Custom formatters are built on the existing formatters, and as first class objects may be named or computed dynamically, so that:</p>
<div class="sourceCode" id="cb455"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb455-1"><a href="#cb455-1" aria-hidden="true"></a>      (<span class="kw">let</span> ((~.2f (<span class="kw">lambda</span> (x) (with ((precision <span class="dv">2</span>)) x))))</span>
<span id="cb455-2"><a href="#cb455-2" aria-hidden="true"></a>        (show <span class="dv">#f</span> <span class="st">&quot;π = &quot;</span> (~.2f (<span class="kw">acos</span> <span class="dv">-1</span>)) nl))</span></code></pre></div>
<p>produces the same result. For typical uses you only need to combine the existing high level formatters described in the succeeding sections, but see the section Higher Order Formatters and State for control flow and state manipulation primitives.</p>
<p>The return value of show is the accumulated string if output-dest is #f and unspecified otherwise.</p>
<h2 id="displayed-obj"><code>(displayed obj)</code></h2>
<p>If obj is a formatter, returns obj as is. Otherwise, outputs obj using display semantics. Specifically, strings are output as if by write-string and characters are written as if by write-char. Other objects are output as with written (including nested strings and chars inside obj). This is the default behavior for top-level formats in show, each and most other high-level formatters.</p>
<h2 id="written-obj"><code>(written obj)</code></h2>
<p>Outputs obj using write semantics. Uses the current numeric formatting settings to the extent that the written result can still be passed to read, possibly with loss of precision. Specifically, the current radix is used if set to any of 2, 8, 10 or 16, and the fixed point precision is used if specified and the radix is 10.</p>
<div class="sourceCode" id="cb456"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb456-1"><a href="#cb456-1" aria-hidden="true"></a>(show <span class="dv">#f</span> (written (<span class="kw">cons</span> <span class="dv">0</span> <span class="dv">1</span>)))</span>
<span id="cb456-2"><a href="#cb456-2" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;(0 . 1)&quot;</span></span>
<span id="cb456-3"><a href="#cb456-3" aria-hidden="true"></a></span>
<span id="cb456-4"><a href="#cb456-4" aria-hidden="true"></a>(show <span class="dv">#f</span> <span class="fl">1.5</span> <span class="st">&quot; &quot;</span> (with ((precision <span class="dv">0</span>)) <span class="fl">1.5</span>))</span>
<span id="cb456-5"><a href="#cb456-5" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;1.5 2&quot;</span></span>
<span id="cb456-6"><a href="#cb456-6" aria-hidden="true"></a></span>
<span id="cb456-7"><a href="#cb456-7" aria-hidden="true"></a>(show <span class="dv">#f</span> <span class="dv">1</span>/<span class="dv">7</span> <span class="st">&quot; &quot;</span> (with ((precision <span class="dv">3</span>)) <span class="dv">1</span>/<span class="dv">7</span>)</span>
<span id="cb456-8"><a href="#cb456-8" aria-hidden="true"></a>      <span class="st">&quot; &quot;</span> (with ((precision <span class="dv">20</span>)) <span class="dv">1</span>/<span class="dv">7</span>))</span>
<span id="cb456-9"><a href="#cb456-9" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;1/7 0.143 0.14285714285714285714&quot;</span></span></code></pre></div>
<p>Implementations should allow arbitrary precision for exact rational numbers, for example, using string-segment from SRFI 152, the following code returns the first 100 Fibonacci numbers:</p>
<div class="sourceCode" id="cb457"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb457-1"><a href="#cb457-1" aria-hidden="true"></a>    (map <span class="kw">string-&gt;number</span></span>
<span id="cb457-2"><a href="#cb457-2" aria-hidden="true"></a>         (string-segment</span>
<span id="cb457-3"><a href="#cb457-3" aria-hidden="true"></a>          (show <span class="dv">#f</span> (with ((precision <span class="dv">2500</span>))</span>
<span id="cb457-4"><a href="#cb457-4" aria-hidden="true"></a>                     (<span class="op">/</span> <span class="dv">1000</span> (<span class="op">-</span> <span class="ch">#e</span><span class="dv">1</span>e50 <span class="ch">#e</span><span class="dv">1</span>e25 <span class="dv">1</span>))))</span>
<span id="cb457-5"><a href="#cb457-5" aria-hidden="true"></a>          <span class="dv">25</span>))</span></code></pre></div>
<h2 id="written-simply-obj"><code>(written-simply obj)</code></h2>
<p>As above, but doesn’t handle shared structures. Infinite loops can still be avoided if used inside a formatter that truncates data (see trimmed and fitted below).</p>
<h2 id="pretty-obj"><code>(pretty obj)</code></h2>
<p>Pretty-prints obj. The result should be identical to written except possibly for differences in whitespace to make the output resemble formatted source code. Implementations should print vectors and data lists (lists that don’t begin with a (nested) symbol) in a tabular format when possible to reduce vertical space.</p>
<h2 id="pretty-simply-obj"><code>(pretty-simply obj)</code></h2>
<p>As above but without sharing.</p>
<h2 id="escaped-str-quote-ch-esc-ch-renamer"><code>(escaped str [quote-ch esc-ch renamer])</code></h2>
<p>Outputs the string str, escaping any quote or escape characters. If esc-ch, which defaults to #\, is #f, escapes only the quote-ch, which defaults to #", by doubling it, as in SQL strings and CSV values. If renamer is provided, it should be a procedure of one character which maps that character to its escape value, e.g. #=&gt; #, or #f if there is no escape value.</p>
<div class="sourceCode" id="cb458"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb458-1"><a href="#cb458-1" aria-hidden="true"></a>    (show <span class="dv">#f</span> (escaped <span class="st">&quot;hi, bob!&quot;</span>))</span>
<span id="cb458-2"><a href="#cb458-2" aria-hidden="true"></a>    <span class="op">=&gt;</span> <span class="st">&quot;hi, bob!&quot;</span></span>
<span id="cb458-3"><a href="#cb458-3" aria-hidden="true"></a></span>
<span id="cb458-4"><a href="#cb458-4" aria-hidden="true"></a>    (show <span class="dv">#f</span> (escaped <span class="st">&quot;hi, </span><span class="ch">\&quot;</span><span class="st">bob!</span><span class="ch">\&quot;</span><span class="st">&quot;</span>))</span>
<span id="cb458-5"><a href="#cb458-5" aria-hidden="true"></a>    <span class="op">=&gt;</span> <span class="st">&quot;hi, </span><span class="ch">\&quot;</span><span class="st">bob!</span><span class="ch">\&quot;</span><span class="st">&quot;</span></span></code></pre></div>
<h2 id="maybe-escaped-str-pred-quote-ch-esc-ch-renamer"><code>(maybe-escaped str pred [quote-ch esc-ch renamer])</code></h2>
<p>Like escaped, but first checks if any quoting is required (by the existence of either any quote or escape characters, or any character matching pred), and if so outputs the string in quotes and with escapes. Otherwise outputs the string as is. This is useful for quoting symbols and CSV output, etc.</p>
<div class="sourceCode" id="cb459"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb459-1"><a href="#cb459-1" aria-hidden="true"></a>(show <span class="dv">#f</span> (maybe-escaped <span class="st">&quot;foo&quot;</span> <span class="kw">char-whitespace?</span> <span class="ch">#\&quot;</span>))</span>
<span id="cb459-2"><a href="#cb459-2" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;foo&quot;</span></span>
<span id="cb459-3"><a href="#cb459-3" aria-hidden="true"></a></span>
<span id="cb459-4"><a href="#cb459-4" aria-hidden="true"></a>(show <span class="dv">#f</span> (maybe-escaped <span class="st">&quot;foo bar&quot;</span> <span class="kw">char-whitespace?</span> <span class="ch">#\&quot;</span>))</span>
<span id="cb459-5"><a href="#cb459-5" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">foo bar</span><span class="ch">\&quot;</span><span class="st">&quot;</span></span>
<span id="cb459-6"><a href="#cb459-6" aria-hidden="true"></a></span>
<span id="cb459-7"><a href="#cb459-7" aria-hidden="true"></a>(show <span class="dv">#f</span> (maybe-escaped <span class="st">&quot;foo</span><span class="ch">\&quot;</span><span class="st">bar</span><span class="ch">\&quot;</span><span class="st">baz&quot;</span> <span class="kw">char-whitespace?</span> <span class="ch">#\&quot;</span>))</span>
<span id="cb459-8"><a href="#cb459-8" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">foo</span><span class="ch">\&quot;</span><span class="st">bar</span><span class="ch">\&quot;</span><span class="st">baz</span><span class="ch">\&quot;</span><span class="st">&quot;</span></span></code></pre></div>
<h2 id="numeric-num-radix-precision-sign-comma-comma-sep-decimal-sep"><code>(numeric num [radix precision sign comma comma-sep decimal-sep])</code></h2>
<p>Formats a single number num. You can optionally specify any radix from 2 to 36 (even if num isn’t an integer). precision forces a fixed-point format.</p>
<p>A sign of #t indicates to output a plus sign (+) for positive integers. However, if sign is a pair of two strings, it means to wrap negative numbers with the two strings. For example, (“(” . “)”) prints negative numbers in parentheses, financial style: -1.99 =&gt; (1.99).</p>
<ul>
<li><p>comma is an integer specifying the number of digits between commas.</p></li>
<li><p>comma-sep is the character to use for commas, defaulting to #,.</p></li>
<li><p>decimal-sep is the character to use for decimals, defaulting to #., or to #, (European style) if comma-sep is already #..</p></li>
</ul>
<p>These parameters may seem unwieldy, but they can also take their defaults from state variables, described below.</p>
<h2 id="numericcomma-num-base-precision-sign"><code>(numeric/comma num [base precision sign])</code></h2>
<p>Shortcut for numeric to print with commas.</p>
<div class="sourceCode" id="cb460"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb460-1"><a href="#cb460-1" aria-hidden="true"></a>(show <span class="dv">#f</span> (numeric/comma <span class="dv">1234567</span>))</span>
<span id="cb460-2"><a href="#cb460-2" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;1,234,567&quot;</span></span></code></pre></div>
<h2 id="numericsi-num-base-separator"><code>(numeric/si num [base separator])</code></h2>
<p>Abbreviates num with an SI suffix as in the -h or –si option to many GNU commands. The base defaults to 1024, using suffix names like Ki, Mi, Gi, etc. Other bases (e.g. the standard 1000) have the suffixes k, M, G, etc. If separator is provided, it is inserted after the number, before any suffix.</p>
<div class="sourceCode" id="cb461"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb461-1"><a href="#cb461-1" aria-hidden="true"></a>(show <span class="dv">#f</span> (numeric/si <span class="dv">608</span>))</span>
<span id="cb461-2"><a href="#cb461-2" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;608&quot;</span></span>
<span id="cb461-3"><a href="#cb461-3" aria-hidden="true"></a></span>
<span id="cb461-4"><a href="#cb461-4" aria-hidden="true"></a>(show <span class="dv">#f</span> (numeric/si <span class="dv">608</span>) <span class="st">&quot;B&quot;</span>)</span>
<span id="cb461-5"><a href="#cb461-5" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;608B&quot;</span></span>
<span id="cb461-6"><a href="#cb461-6" aria-hidden="true"></a></span>
<span id="cb461-7"><a href="#cb461-7" aria-hidden="true"></a>(show <span class="dv">#f</span> (numeric/si <span class="dv">608</span> <span class="dv">1000</span> <span class="st">&quot; &quot;</span>) <span class="st">&quot;B&quot;</span>)</span>
<span id="cb461-8"><a href="#cb461-8" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;608 B&quot;</span></span>
<span id="cb461-9"><a href="#cb461-9" aria-hidden="true"></a></span>
<span id="cb461-10"><a href="#cb461-10" aria-hidden="true"></a>(show <span class="dv">#f</span> (numeric/si <span class="dv">3986</span>))</span>
<span id="cb461-11"><a href="#cb461-11" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;3.9Ki&quot;</span></span>
<span id="cb461-12"><a href="#cb461-12" aria-hidden="true"></a></span>
<span id="cb461-13"><a href="#cb461-13" aria-hidden="true"></a>(show <span class="dv">#f</span> (numeric/si <span class="dv">3986</span> <span class="dv">1000</span>) <span class="st">&quot;B&quot;</span>)</span>
<span id="cb461-14"><a href="#cb461-14" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;4kB&quot;</span></span>
<span id="cb461-15"><a href="#cb461-15" aria-hidden="true"></a></span>
<span id="cb461-16"><a href="#cb461-16" aria-hidden="true"></a>(show <span class="dv">#f</span> (numeric/si <span class="fl">1.23e-6</span> <span class="dv">1000</span>) <span class="st">&quot;m&quot;</span>)</span>
<span id="cb461-17"><a href="#cb461-17" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;1.2µm&quot;</span></span>
<span id="cb461-18"><a href="#cb461-18" aria-hidden="true"></a></span>
<span id="cb461-19"><a href="#cb461-19" aria-hidden="true"></a>(show <span class="dv">#f</span> (numeric/si <span class="fl">1.23e-6</span> <span class="dv">1000</span> <span class="st">&quot; &quot;</span>) <span class="st">&quot;m&quot;</span>)</span>
<span id="cb461-20"><a href="#cb461-20" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;1.2 µm&quot;</span></span>
<span id="cb461-21"><a href="#cb461-21" aria-hidden="true"></a></span>
<span id="cb461-22"><a href="#cb461-22" aria-hidden="true"></a>See https://en.wikipedia.org/wiki/Metric_prefix for the complete <span class="kw">list</span> of abbreviations.</span>
<span id="cb461-23"><a href="#cb461-23" aria-hidden="true"></a></span>
<span id="cb461-24"><a href="#cb461-24" aria-hidden="true"></a>    (numeric/fitted width n . args)</span>
<span id="cb461-25"><a href="#cb461-25" aria-hidden="true"></a></span>
<span id="cb461-26"><a href="#cb461-26" aria-hidden="true"></a>Like numeric, but <span class="kw">if</span> the result doesn&#39;t fit in width using the current precision, output instead a <span class="kw">string</span> of hashes rather than showing an incorrectly truncated number. For example</span>
<span id="cb461-27"><a href="#cb461-27" aria-hidden="true"></a></span>
<span id="cb461-28"><a href="#cb461-28" aria-hidden="true"></a>(show <span class="dv">#f</span> (with ((precision <span class="dv">2</span>)) (numeric/fitted <span class="dv">4</span> <span class="fl">1.25</span>)))</span>
<span id="cb461-29"><a href="#cb461-29" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;1.25&quot;</span></span>
<span id="cb461-30"><a href="#cb461-30" aria-hidden="true"></a></span>
<span id="cb461-31"><a href="#cb461-31" aria-hidden="true"></a>(show <span class="dv">#f</span> (with ((precision <span class="dv">2</span>)) (numeric/fitted <span class="dv">4</span> <span class="fl">12.345</span>)))</span>
<span id="cb461-32"><a href="#cb461-32" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;#.##&quot;</span></span></code></pre></div>
<h2 id="nl"><code>nl</code></h2>
<p>Outputs a newline.</p>
<div class="sourceCode" id="cb462"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb462-1"><a href="#cb462-1" aria-hidden="true"></a>(show <span class="dv">#f</span> nl)</span>
<span id="cb462-2"><a href="#cb462-2" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;\n&quot;</span></span></code></pre></div>
<h2 id="fl"><code>fl</code></h2>
<p>Short for “fresh line,” outputs a newline only if we’re not already at the start of a line.</p>
<div class="sourceCode" id="cb463"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb463-1"><a href="#cb463-1" aria-hidden="true"></a>(show <span class="dv">#f</span> fl)</span>
<span id="cb463-2"><a href="#cb463-2" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;&quot;</span></span>
<span id="cb463-3"><a href="#cb463-3" aria-hidden="true"></a></span>
<span id="cb463-4"><a href="#cb463-4" aria-hidden="true"></a>(show <span class="dv">#f</span> <span class="st">&quot;hi&quot;</span> fl)</span>
<span id="cb463-5"><a href="#cb463-5" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;hi\n&quot;</span></span>
<span id="cb463-6"><a href="#cb463-6" aria-hidden="true"></a></span>
<span id="cb463-7"><a href="#cb463-7" aria-hidden="true"></a>(show <span class="dv">#f</span> <span class="st">&quot;hi&quot;</span> nl fl)</span>
<span id="cb463-8"><a href="#cb463-8" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;hi\n&quot;</span></span></code></pre></div>
<h2 id="space-to-column"><code>(space-to column)</code></h2>
<p>Outputs spaces up to the given column. If the current column is already &gt;= column, does nothing. The character used for spacing is the current value of pad-char, described below, which defaults to space. Columns are zero-based.</p>
<div class="sourceCode" id="cb464"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb464-1"><a href="#cb464-1" aria-hidden="true"></a>(show <span class="dv">#f</span> <span class="st">&quot;a&quot;</span> (space-to <span class="dv">5</span>) <span class="st">&quot;b&quot;</span>)</span>
<span id="cb464-2"><a href="#cb464-2" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;a    b&quot;</span></span>
<span id="cb464-3"><a href="#cb464-3" aria-hidden="true"></a></span>
<span id="cb464-4"><a href="#cb464-4" aria-hidden="true"></a>(show <span class="dv">#f</span> <span class="st">&quot;a&quot;</span> (space-to <span class="dv">0</span>) <span class="st">&quot;b&quot;</span>)</span>
<span id="cb464-5"><a href="#cb464-5" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;ab&quot;</span></span></code></pre></div>
<h2 id="tab-to-tab-width"><code>(tab-to [tab-width])</code></h2>
<p>Outputs spaces up to the next tab stop, using tab stops of width tab-width, which defaults to 8. If already on a tab stop, does nothing. If you want to ensure you always tab at least one space, you can use (each " " (tab-to width)). Columns are zero-based.</p>
<pre><code>(show #f (tab-to 5) &quot;b&quot;)
=&gt; &quot;b&quot;

(show #f &quot;a&quot; (tab-to 5) &quot;b&quot;)
=&gt; &quot;a    b&quot;

(show #f &quot;abcdefghi&quot; (tab-to 5) &quot;b&quot;)
=&gt; &quot;abcdefghi b&quot;</code></pre>
<h2 id="nothing"><code>nothing</code></h2>
<p>Outputs nothing (useful in combinators and as a default noop in conditionals).</p>
<pre><code>(show #f &quot;a&quot; nothing &quot;b&quot;)
=&gt; &quot;ab&quot;</code></pre>
<h2 id="each-fmt-..."><code>(each fmt ...)</code></h2>
<p>Applies each fmt in sequence, as in the top-level of show.</p>
<div class="sourceCode" id="cb467"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb467-1"><a href="#cb467-1" aria-hidden="true"></a>(show <span class="dv">#f</span> (each <span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span>))</span>
<span id="cb467-2"><a href="#cb467-2" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;ab&quot;</span></span></code></pre></div>
<h2 id="each-in-list-list-of-fmts"><code>(each-in-list list-of-fmts)</code></h2>
<p>Equivalent to (apply each list-of-fmts) but may be more efficient.</p>
<h2 id="joined-mapper-list-sep"><code>(joined mapper list [sep])</code></h2>
<p>Formats each element elt of list with (mapper elt), inserting sep in between. sep defaults to the empty string, but can be any format or string.</p>
<div class="sourceCode" id="cb468"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb468-1"><a href="#cb468-1" aria-hidden="true"></a>(show <span class="dv">#f</span> (joined displayed &#39;(a b c) <span class="st">&quot;, &quot;</span>))</span>
<span id="cb468-2"><a href="#cb468-2" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;a, b, c&quot;</span></span></code></pre></div>
<h2 id="joinedprefix-mapper-list-sep"><code>(joined/prefix mapper list [sep])</code></h2>
<h2 id="joinedsuffix-mapper-list-sep"><code>(joined/suffix mapper list [sep])</code></h2>
<div class="sourceCode" id="cb469"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb469-1"><a href="#cb469-1" aria-hidden="true"></a>(show <span class="dv">#f</span> (joined/prefix displayed &#39;(usr local bin) <span class="st">&quot;/&quot;</span>))</span>
<span id="cb469-2"><a href="#cb469-2" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;/usr/local/bin&quot;</span></span>
<span id="cb469-3"><a href="#cb469-3" aria-hidden="true"></a></span>
<span id="cb469-4"><a href="#cb469-4" aria-hidden="true"></a>(show <span class="dv">#f</span> (joined/suffix displayed &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) nl))</span>
<span id="cb469-5"><a href="#cb469-5" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;1\n2\n3\n&quot;</span></span></code></pre></div>
<p>As joined, but inserts sep before/after every element.</p>
<h2 id="joinedlast-mapper-last-mapper-list-sep"><code>(joined/last mapper last-mapper list [sep])</code></h2>
<p>As joined, but the last element of the list is formatted with last-mapper instead.</p>
<pre><code>    (show #f (joined/last displayed
                          (lambda (last) (each &quot;and &quot; last))
                          &#39;(lions tigers bears)
                          &quot;, &quot;))
    =&gt; &quot;lions, tigers, and bears&quot;</code></pre>
<h2 id="joineddot-mapper-dot-mapper-list-sep"><code>(joined/dot mapper dot-mapper list [sep])</code></h2>
<p>As joined, but if the list is a dotted list, then formats the dotted value with dot-mapper instead.</p>
<pre><code>    (show #f
          &quot;(&quot;
          (joined/dot displayed
              (lambda (dot) (each &quot;. &quot; dot))
              &#39;(1 2 . 3)
              &quot; &quot;)
          &quot;)&quot;)
    =&gt; &quot;(1 2 . 3)&quot;</code></pre>
<h2 id="joinedrange-mapper-start-end-sep"><code>(joined/range mapper start [end sep])</code></h2>
<p>As joined, but counts from start (inclusive) to end (exclusive), formatting each integer in the range with mapper. If end is #f or unspecified, produces an infinite stream of output.</p>
<div class="sourceCode" id="cb472"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb472-1"><a href="#cb472-1" aria-hidden="true"></a>    (show <span class="dv">#f</span> (joined/range displayed <span class="dv">0</span> <span class="dv">5</span> <span class="st">&quot; &quot;</span>))</span>
<span id="cb472-2"><a href="#cb472-2" aria-hidden="true"></a>    <span class="op">=&gt;</span> <span class="st">&quot;0 1 2 3 4&quot;</span></span></code></pre></div>
<h2 id="padded-width-fmt-..."><code>(padded width fmt ...)</code></h2>
<h2 id="paddedright-width-fmt-..."><code>(padded/right width fmt ...)</code></h2>
<h2 id="paddedboth-width-fmt-..."><code>(padded/both width fmt ...)</code></h2>
<p>Analogs of SRFI 13 string-pad, these add extra space to the left, right or both sides of the output generated by the fmts to pad it to width. If width is exceeded, has no effect. padded/both will include one more extra space on the right side of the output if the difference is odd.</p>
<p>padded/right is guaranteed not to accumulate any intermediate data.</p>
<p>Note these are column-oriented padders, so won’t necessarily work with multi-line output (padding doesn’t seem a likely operation for multi-line output).</p>
<div class="sourceCode" id="cb473"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb473-1"><a href="#cb473-1" aria-hidden="true"></a>(show <span class="dv">#f</span> (padded <span class="dv">5</span> <span class="st">&quot;abc&quot;</span>))</span>
<span id="cb473-2"><a href="#cb473-2" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;  abc&quot;</span></span>
<span id="cb473-3"><a href="#cb473-3" aria-hidden="true"></a></span>
<span id="cb473-4"><a href="#cb473-4" aria-hidden="true"></a>(show <span class="dv">#f</span> (padded/right <span class="dv">5</span> <span class="st">&quot;abc&quot;</span>))</span>
<span id="cb473-5"><a href="#cb473-5" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;abc  &quot;</span></span>
<span id="cb473-6"><a href="#cb473-6" aria-hidden="true"></a></span>
<span id="cb473-7"><a href="#cb473-7" aria-hidden="true"></a>(show <span class="dv">#f</span> (padded/both <span class="dv">5</span> <span class="st">&quot;abc&quot;</span>))</span>
<span id="cb473-8"><a href="#cb473-8" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot; abc &quot;</span></span></code></pre></div>
<h2 id="trimmed-width-fmt-..."><code>(trimmed width fmt ...)</code></h2>
<h2 id="trimmedright-width-fmt-..."><code>(trimmed/right width fmt ...)</code></h2>
<h2 id="trimmedboth-width-fmt-..."><code>(trimmed/both width fmt ...)</code></h2>
<p>Analogs of SRFI 13 string-trim, these truncate the output of the fmts to force it in under width columns. As soon as any of the fmts exceeds width, stop formatting and truncate the result, returning control to whoever called trimmed. If width is not exceeded, is equivalent to each.</p>
<p>If a truncation ellipsis is set, then when any truncation occurs trimmed and trimmed/right will prepend and append the ellipsis, respectively. trimmed/both will both prepend and append. The length of the ellipsis will be considered when truncating the original string, so that the total width will never be longer than width. It is an error if width is less than the length of ellipsis, or double the length for /both.</p>
<div class="sourceCode" id="cb474"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb474-1"><a href="#cb474-1" aria-hidden="true"></a>(show <span class="dv">#f</span> (with ((ellipsis <span class="st">&quot;...&quot;</span>)) (trimmed <span class="dv">5</span> <span class="st">&quot;abcde&quot;</span>)))</span>
<span id="cb474-2"><a href="#cb474-2" aria-hidden="true"></a><span class="op">=&gt;</span>  <span class="st">&quot;abcde&quot;</span></span>
<span id="cb474-3"><a href="#cb474-3" aria-hidden="true"></a></span>
<span id="cb474-4"><a href="#cb474-4" aria-hidden="true"></a>(show <span class="dv">#f</span> (with ((ellipses <span class="st">&quot;...&quot;</span>)) (trimmed <span class="dv">5</span> <span class="st">&quot;abcdef&quot;</span>)))</span>
<span id="cb474-5"><a href="#cb474-5" aria-hidden="true"></a><span class="op">=&gt;</span>  <span class="st">&quot;ab...&quot;</span></span></code></pre></div>
<p>It is an error if width is shorter than the width of the ellipsis.</p>
<h2 id="trimmedlazy-width-fmt-..."><code>(trimmed/lazy width fmt ...)</code></h2>
<p>A variant of trimmed which generates each fmt in left to right order, and truncates and terminates immediately if more than width characters are generated. Thus this is safe to use with an infinite amount of output, e.g. from written-simply on an infinite list.</p>
<h2 id="fitted-width-fmt-..."><code>(fitted width fmt ...)</code></h2>
<h2 id="fittedright-width-fmt-..."><code>(fitted/right width fmt ...)</code></h2>
<h2 id="fittedboth-width-fmt-..."><code>(fitted/both width fmt ...)</code></h2>
<p>A combination of padded and trimmed that ensures that the output width is exactly width, truncating if it goes over and padding if it goes under.</p>
<h2 id="columnar-column-..."><code>(columnar column ...)</code></h2>
<p>Formats each column side-by-side, i.e. as though each were formatted separately and then the individual lines concatenated together. The current line width (from the width state variable) is divided evenly among the columns, and all but the last column are right-padded. For example</p>
<div class="sourceCode" id="cb475"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb475-1"><a href="#cb475-1" aria-hidden="true"></a>    (show <span class="dv">#t</span> (columnar (displayed <span class="st">&quot;abc\ndef\n&quot;</span>)</span>
<span id="cb475-2"><a href="#cb475-2" aria-hidden="true"></a>                       (displayed <span class="st">&quot;123\n456\n&quot;</span>)))</span></code></pre></div>
<p>outputs</p>
<div class="sourceCode" id="cb476"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb476-1"><a href="#cb476-1" aria-hidden="true"></a>    abc     <span class="dv">123</span></span>
<span id="cb476-2"><a href="#cb476-2" aria-hidden="true"></a>    def     <span class="dv">456</span></span></code></pre></div>
<p>assuming a 16-char width (the left side gets half the width, or 8 spaces, and is left aligned). Note that we explicitly use displayed instead of the strings directly. This is because columnar treats raw strings as literals inserted into the given location on every line, to be used as borders, for example:</p>
<div class="sourceCode" id="cb477"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb477-1"><a href="#cb477-1" aria-hidden="true"></a>    (show <span class="dv">#t</span> (columnar <span class="st">&quot;/* &quot;</span> (displayed <span class="st">&quot;abc\ndef\n&quot;</span>)</span>
<span id="cb477-2"><a href="#cb477-2" aria-hidden="true"></a>                       <span class="st">&quot; | &quot;</span> (displayed <span class="st">&quot;123\n456\n&quot;</span>)</span>
<span id="cb477-3"><a href="#cb477-3" aria-hidden="true"></a>                       <span class="st">&quot; */&quot;</span>))</span></code></pre></div>
<p>would output</p>
<pre><code>    /* abc | 123 */
    /* def | 456 */</code></pre>
<p>You may also prefix any column with any of the symbols ’left, ’right or ’center to control the justification. The symbol ’infinite can be used to indicate the column generates an infinite stream of output.</p>
<p>You can further prefix any column with a width modifier. Any positive integer is treated as a fixed width, ignoring the available width. Any real number between 0 and 1 indicates a fraction of the available width (after subtracting out any fixed widths). Columns with unspecified width divide up the remaining width evenly. If the extra space does not divide evenly, it is allocated column-wise left to right, e.g. if the width of 78 is divided among 5 columns, the column widths become 16, 16, 16, 15, 15 in order.</p>
<p>Note that columnar builds its output incrementally, interleaving calls to the generators until each has produced a line, then concatenating that line together and outputting it. This is important because as noted above, some columns may produce an infinite stream of output, and in general you may want to format data larger than can fit into memory. Thus columnar would be suitable for line numbering a file of arbitrary size, or implementing the Unix yes(1) command, etc.</p>
<h2 id="tabular-column-..."><code>(tabular column ...)</code></h2>
<p>Equivalent to columnar except that each column is padded at least to the minimum width required on any of its lines. Thus</p>
<div class="sourceCode" id="cb479"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb479-1"><a href="#cb479-1" aria-hidden="true"></a>    (show <span class="dv">#t</span> (tabular <span class="st">&quot;|&quot;</span> (each <span class="st">&quot;a\nbc\ndef\n&quot;</span>) <span class="st">&quot;|&quot;</span></span>
<span id="cb479-2"><a href="#cb479-2" aria-hidden="true"></a>                          (each <span class="st">&quot;123\n45\n6\n&quot;</span>) <span class="st">&quot;|&quot;</span>))</span></code></pre></div>
<p>outputs</p>
<pre><code>    |a  |123|
    |bc |45 |
    |def|6  |</code></pre>
<p>This makes it easier to generate tables without knowing widths in advance. However, because it requires generating the entire output in advance to determine the correct column widths, tabular cannot format a table larger than would fit in memory. (wrapped fmt …)</p>
<p>Behaves like each, except text is accumulated and lines are wrapped to fit in the current width as in the Unix fmt(1) command. Specifically, words are tokenized by splitting on all characters which satisfy the predicate in the parameter word-separator?, which defaults to char-whitespace?. Words are grouped into lines separating them by space, and line breaks are introduced to minimize the sum of the cube of trailing whitespace on every line.</p>
<h2 id="wrappedlist-list-of-strings"><code>(wrapped/list list-of-strings)</code></h2>
<p>Like wrapped, but taking a pre-tokenized list of strings.</p>
<h2 id="wrappedchar-fmt-..."><code>(wrapped/char fmt ...)</code></h2>
<p>As wrapped, but splits simply on individual characters exactly as the current width is reached on each line. Thus there is nothing to optimize and this formatter doesn’t buffer output.</p>
<h2 id="justified-format-..."><code>(justified &lt;format&gt; ...)</code></h2>
<p>Like wrapped except the lines are full-justified.</p>
<div class="sourceCode" id="cb481"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb481-1"><a href="#cb481-1" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> func</span></span>
<span id="cb481-2"><a href="#cb481-2" aria-hidden="true"></a>      &#39;(<span class="ex">define</span><span class="fu"> </span>(fold kons knil ls)</span>
<span id="cb481-3"><a href="#cb481-3" aria-hidden="true"></a>         (<span class="kw">let</span> lp ((ls ls) (acc knil))</span>
<span id="cb481-4"><a href="#cb481-4" aria-hidden="true"></a>           (<span class="kw">if</span> (<span class="kw">null?</span> ls) acc (lp (<span class="kw">cdr</span> ls) (kons (<span class="kw">car</span> ls) acc))))))</span>
<span id="cb481-5"><a href="#cb481-5" aria-hidden="true"></a></span>
<span id="cb481-6"><a href="#cb481-6" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> doc</span></span>
<span id="cb481-7"><a href="#cb481-7" aria-hidden="true"></a>      (<span class="kw">string-append</span></span>
<span id="cb481-8"><a href="#cb481-8" aria-hidden="true"></a>        <span class="st">&quot;The fundamental list iterator.  Applies KONS to each &quot;</span></span>
<span id="cb481-9"><a href="#cb481-9" aria-hidden="true"></a>        <span class="st">&quot;element of LS and the result of the previous application, &quot;</span></span>
<span id="cb481-10"><a href="#cb481-10" aria-hidden="true"></a>        <span class="st">&quot;beginning with KNIL.  With KONS as CONS and KNIL as &#39;(), &quot;</span></span>
<span id="cb481-11"><a href="#cb481-11" aria-hidden="true"></a>        <span class="st">&quot;equivalent to REVERSE.&quot;</span>))</span>
<span id="cb481-12"><a href="#cb481-12" aria-hidden="true"></a></span>
<span id="cb481-13"><a href="#cb481-13" aria-hidden="true"></a>    (show <span class="dv">#t</span> (columnar (pretty func) <span class="st">&quot; ; &quot;</span> (justified doc)))</span></code></pre></div>
<p>outputs</p>
<div class="sourceCode" id="cb482"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb482-1"><a href="#cb482-1" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> </span>(fold kons knil ls)          <span class="co">; The   fundamental   list   iterator.</span></span>
<span id="cb482-2"><a href="#cb482-2" aria-hidden="true"></a>      (<span class="kw">let</span> lp ((ls ls) (acc knil))       <span class="co">; Applies  KONS  to  each  element  of</span></span>
<span id="cb482-3"><a href="#cb482-3" aria-hidden="true"></a>        (<span class="kw">if</span> (<span class="kw">null?</span> ls)                   <span class="co">; LS  and  the  result of the previous</span></span>
<span id="cb482-4"><a href="#cb482-4" aria-hidden="true"></a>            acc                          <span class="co">; application,  beginning  with  KNIL.</span></span>
<span id="cb482-5"><a href="#cb482-5" aria-hidden="true"></a>            (lp (<span class="kw">cdr</span> ls)                 <span class="co">; With  KONS  as CONS and KNIL as &#39;(),</span></span>
<span id="cb482-6"><a href="#cb482-6" aria-hidden="true"></a>                (kons (<span class="kw">car</span> ls) acc)))))  <span class="co">; equivalent to REVERSE.</span></span></code></pre></div>
<h2 id="from-file-pathname"><code>(from-file pathname)</code></h2>
<p>Displays the contents of the file pathname one line at a time, so that in typical formatters such as columnar only constant memory is consumed, making this suitable for formatting files of arbitrary size.</p>
<h2 id="line-numbers-start"><code>(line-numbers [start])</code></h2>
<p>A convenience utility, just formats an infinite stream of numbers (in the current radix) beginning with start, which defaults to 1.</p>
<p>The Unix nl(1) utility could be implemented as:</p>
<div class="sourceCode" id="cb483"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb483-1"><a href="#cb483-1" aria-hidden="true"></a>    (show <span class="dv">#t</span> (columnar <span class="dv">4</span> &#39;right &#39;infinite (line-numbers)</span>
<span id="cb483-2"><a href="#cb483-2" aria-hidden="true"></a>                       <span class="st">&quot; &quot;</span> (from-file <span class="st">&quot;read-line.scm&quot;</span>)))</span></code></pre></div>
<p>which might output:</p>
<div class="sourceCode" id="cb484"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb484-1"><a href="#cb484-1" aria-hidden="true"></a>       <span class="dv">1</span></span>
<span id="cb484-2"><a href="#cb484-2" aria-hidden="true"></a>       <span class="dv">2</span> (<span class="ex">define</span><span class="fu"> </span>(read-line . o)</span>
<span id="cb484-3"><a href="#cb484-3" aria-hidden="true"></a>       <span class="dv">3</span>   (<span class="kw">let</span> ((port (<span class="kw">if</span> (<span class="kw">pair?</span> o) (<span class="kw">car</span> o) (<span class="kw">current-input-port</span>))))</span>
<span id="cb484-4"><a href="#cb484-4" aria-hidden="true"></a>       <span class="dv">4</span>     (<span class="kw">let</span> lp ((res &#39;()))</span>
<span id="cb484-5"><a href="#cb484-5" aria-hidden="true"></a>       <span class="dv">5</span>       (<span class="kw">let</span> ((c (<span class="kw">read-char</span> port)))</span>
<span id="cb484-6"><a href="#cb484-6" aria-hidden="true"></a>       <span class="dv">6</span>         (<span class="kw">if</span> (<span class="kw">or</span> (<span class="kw">eof-object?</span> c) (<span class="kw">eqv?</span> c <span class="ch">#\newline</span>))</span>
<span id="cb484-7"><a href="#cb484-7" aria-hidden="true"></a>       <span class="dv">7</span>             (<span class="kw">list-&gt;string</span> (<span class="kw">reverse</span> res))</span>
<span id="cb484-8"><a href="#cb484-8" aria-hidden="true"></a>       <span class="dv">8</span>             (lp (<span class="kw">cons</span> c res)))))))</span></code></pre></div>
<h2 id="as-red-fmt-..."><code>(as-red fmt ...)</code></h2>
<h2 id="as-blue-fmt-..."><code>(as-blue fmt ...)</code></h2>
<h2 id="as-green-fmt-..."><code>(as-green fmt ...)</code></h2>
<h2 id="as-cyan-fmt-..."><code>(as-cyan fmt ...)</code></h2>
<h2 id="as-yellow-fmt-..."><code>(as-yellow fmt ...)</code></h2>
<h2 id="as-magenta-fmt-..."><code>(as-magenta fmt ...)</code></h2>
<h2 id="as-white-fmt-..."><code>(as-white fmt ...)</code></h2>
<h2 id="as-black-fmt-..."><code>(as-black fmt ...)</code></h2>
<h2 id="as-bold-fmt-..."><code>(as-bold fmt ...)</code></h2>
<h2 id="as-underline-fmt-..."><code>(as-underline fmt ...)</code></h2>
<p>Outputs the formatters colored or (boldened or underline) with ANSI escapes, for use when formatting to a terminal.</p>
<h2 id="as-unicode-fmt-..."><code>(as-unicode fmt ...)</code></h2>
<p>Equivalent to</p>
<div class="sourceCode" id="cb485"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb485-1"><a href="#cb485-1" aria-hidden="true"></a>(with ((string-width unicode-terminal-width)) fmt ...)</span></code></pre></div>
<p>Padding, trimming and tabbing, etc. will generally not do the right thing in the presence of zero-width and double-width Unicode characters. This formatter overrides the string-width state var used in column tracking to do the right thing in such cases, considering Unicode double or full width characters as 2 characters wide (as they typically are in fixed-width terminals), while treating combining and non-spacing characters as 0 characters wide.</p>
<div class="sourceCode" id="cb486"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb486-1"><a href="#cb486-1" aria-hidden="true"></a><span class="co">;; 3 characters padded to 5</span></span>
<span id="cb486-2"><a href="#cb486-2" aria-hidden="true"></a>(show <span class="dv">#f</span> (with ((pad-char <span class="ch">#\〜</span>)) (padded/both <span class="dv">5</span> <span class="st">&quot;日本語&quot;</span>)))</span>
<span id="cb486-3"><a href="#cb486-3" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;〜日本語〜&quot;</span></span>
<span id="cb486-4"><a href="#cb486-4" aria-hidden="true"></a></span>
<span id="cb486-5"><a href="#cb486-5" aria-hidden="true"></a><span class="co">;; the 3 characters have a terminal width of 6 so are not padded</span></span>
<span id="cb486-6"><a href="#cb486-6" aria-hidden="true"></a>(show <span class="dv">#f</span> (as-unicode (with ((pad-char <span class="ch">#\〜</span>)) (padded/both <span class="dv">5</span> <span class="st">&quot;日本語&quot;</span>))))</span>
<span id="cb486-7"><a href="#cb486-7" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;日本語&quot;</span></span></code></pre></div>
<h2 id="unicode-terminal-width-str"><code>(unicode-terminal-width str)</code></h2>
<p>A utility function which returns the integer number of columns str would require in a terminal, according to the following rules:</p>
<ul>
<li><p>non-spacing characters (format control characters with the property Cf, or non-spacing marks with the property Mn) count as 0 columns</p></li>
<li><p>characters with the East Asian Wide (W) or East Asian Fullwidth (F) properties, according to Unicode TR #11, count as 2 columns</p></li>
<li><p>characters with the Halfwidth (H) or Narrow (Na) should count as 1 column</p></li>
<li><p>characters with the Neutral (N) non-East Asian also count as 1 column</p></li>
<li><p>characters with the Ambiguous (A) property are implementation defined</p></li>
<li><p>ANSI terminal escapes, as output by the color formatters above, count as 0 columns</p></li>
<li><p>the tab character is implementation defined</p></li>
<li><p>Implementations should support the properties from at least the current Unicode specification at time of writing this SRFI, 10.0.0. Higher Order Formatters and State</p></li>
</ul>
<p>Formatters up to this point have been simple accumulators of output, with no control flow or handling of state. Both of these are provided by fn and with for getting and setting state, respectively.</p>
<p>A formatter is essentially an environment monad, although the underlying implementation is unspecified.</p>
<h2 id="fn-id-state-var-...-expr-...-fmt"><code>(fn ((id state-var) ...) expr ... fmt)</code></h2>
<p>Short for “function,” this is the analog to lambda. Returns a formatter which on application evaluates each expr and fmt in left-to-right order, in a lexical environment extended with each identifier id bound to the current value of the state variable named by the symbol state-var. The result of the fmt is then applied as a formatter.</p>
<p>As a convenience, any (id state-var) list may be abbreviated as simply id, indicating id is bound to the state variable of the same (symbol) name.</p>
<div class="sourceCode" id="cb487"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb487-1"><a href="#cb487-1" aria-hidden="true"></a>    (show <span class="dv">#f</span> <span class="st">&quot;column: &quot;</span> (fn (col) col))</span>
<span id="cb487-2"><a href="#cb487-2" aria-hidden="true"></a>    <span class="op">=&gt;</span> <span class="st">&quot;column: 8&quot;</span></span>
<span id="cb487-3"><a href="#cb487-3" aria-hidden="true"></a></span>
<span id="cb487-4"><a href="#cb487-4" aria-hidden="true"></a>    (show <span class="dv">#f</span> <span class="st">&quot;column: &quot;</span> (fn ((col1 col))</span>
<span id="cb487-5"><a href="#cb487-5" aria-hidden="true"></a>                         (each col1 <span class="st">&quot;, &quot;</span> (fn ((col2 col)) col2))))</span>
<span id="cb487-6"><a href="#cb487-6" aria-hidden="true"></a>    <span class="op">=&gt;</span> <span class="st">&quot;column: 8, 11&quot;</span></span></code></pre></div>
<p>The trivial case of no state variables is often useful to allow for lazy applications of formatters, needed for conditional formatting and loops. For example:</p>
<div class="sourceCode" id="cb488"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb488-1"><a href="#cb488-1" aria-hidden="true"></a>    (show <span class="dv">#t</span> (<span class="kw">let</span> lp ((ls ls))</span>
<span id="cb488-2"><a href="#cb488-2" aria-hidden="true"></a>               (<span class="kw">if</span> (<span class="kw">pair?</span> ls)</span>
<span id="cb488-3"><a href="#cb488-3" aria-hidden="true"></a>                   (each (<span class="kw">car</span> ls) (lp (<span class="kw">cdr</span> ls)))</span>
<span id="cb488-4"><a href="#cb488-4" aria-hidden="true"></a>                   nothing)))</span></code></pre></div>
<p>would eagerly create a formatter concatenating every element of ls before starting to accumulate any output, whereas</p>
<div class="sourceCode" id="cb489"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb489-1"><a href="#cb489-1" aria-hidden="true"></a>    (show <span class="dv">#t</span> (<span class="kw">let</span> lp ((ls ls))</span>
<span id="cb489-2"><a href="#cb489-2" aria-hidden="true"></a>               (<span class="kw">if</span> (<span class="kw">pair?</span> ls)</span>
<span id="cb489-3"><a href="#cb489-3" aria-hidden="true"></a>                   (each (<span class="kw">car</span> ls) (fn () (lp (<span class="kw">cdr</span> ls))))</span>
<span id="cb489-4"><a href="#cb489-4" aria-hidden="true"></a>                   nothing)))</span></code></pre></div>
<p>would lazily apply the formatters one at a time.</p>
<h2 id="with-state-var-value-...-fmt-..."><code>(with ((state-var value) ...) fmt ...)</code></h2>
<p>Conceptually the formatting equivalent of parameterize, temporarily altering state variables. Applies each of the formatters fmt with each state-var bound to the corresponding value. The resulting state is then updated to restore each state-var to its original value.</p>
<div class="sourceCode" id="cb490"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb490-1"><a href="#cb490-1" aria-hidden="true"></a>(with! (state-var value) ...)</span></code></pre></div>
<p>Similar to with but does not restore the original values, changing the value of each state-var for any remaining formatters in a sequence.</p>
<h2 id="forked-fmt1-fmt2"><code>(forked fmt1 fmt2)</code></h2>
<p>Calls fmt1 on (a conceptual copy of) the current state, then fmt2 on the same original state as though fmt1 had not been called.</p>
<h2 id="call-with-output-formatter-mapper"><code>(call-with-output formatter mapper)</code></h2>
<p>A utility, calls formatter on a copy of the current state (as with forked), accumulating the results into a string. Then calls the formatter resulting from (mapper result-string) on the original state.</p>
<h2 id="port"><code>port</code></h2>
<p>The textual port output is written to, this can be overridden to capture intermediate output.</p>
<h2 id="row"><code>row</code></h2>
<p>The current row of output.</p>
<h2 id="col"><code>col</code></h2>
<p>The current column of output, used for padding and spacing, etc.</p>
<h2 id="width"><code>width</code></h2>
<p>The current line width, used for wrapping, pretty-printing, and columnar formatting. The default is implementation-defined.</p>
<h2 id="output-1"><code>output</code></h2>
<p>The underlying standard formatter for writing a single string. The default value outputs the string while tracking the current row and col. This can be overridden both to capture intermediate output and perform transformations on strings before outputting, but should generally wrap the existing output to preserve expected behavior.</p>
<h2 id="writer"><code>writer</code></h2>
<p>The mapper for automatic formatting of non-string/char values in top-level show, each and other formatters. Default value is implementation-defined.</p>
<h2 id="string-width"><code>string-width</code></h2>
<p>A function of a single string, it returns the length in columns of that string, used by the default output.</p>
<h2 id="pad-char"><code>pad-char</code></h2>
<p>The character used by space-to, tab-to and other padding formatters.</p>
<div class="sourceCode" id="cb491"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb491-1"><a href="#cb491-1" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> </span>(print-table-of-contents alist)</span>
<span id="cb491-2"><a href="#cb491-2" aria-hidden="true"></a>      (<span class="ex">define</span><span class="fu"> </span>(print-line x)</span>
<span id="cb491-3"><a href="#cb491-3" aria-hidden="true"></a>        (each (<span class="kw">car</span> x) (space-to <span class="dv">72</span>) (padded <span class="dv">3</span> (<span class="kw">cdr</span> x))))</span>
<span id="cb491-4"><a href="#cb491-4" aria-hidden="true"></a>      (show <span class="dv">#t</span> (with ((pad-char <span class="ch">#\.</span>))</span>
<span id="cb491-5"><a href="#cb491-5" aria-hidden="true"></a>                 (joined/suffix print-line alist nl))))</span>
<span id="cb491-6"><a href="#cb491-6" aria-hidden="true"></a></span>
<span id="cb491-7"><a href="#cb491-7" aria-hidden="true"></a>    (print-table-of-contents</span>
<span id="cb491-8"><a href="#cb491-8" aria-hidden="true"></a>     &#39;((<span class="st">&quot;An Unexpected Party&quot;</span> . <span class="dv">29</span>)</span>
<span id="cb491-9"><a href="#cb491-9" aria-hidden="true"></a>       (<span class="st">&quot;Roast Mutton&quot;</span> . <span class="dv">60</span>)</span>
<span id="cb491-10"><a href="#cb491-10" aria-hidden="true"></a>       (<span class="st">&quot;A Short Rest&quot;</span> . <span class="dv">87</span>)</span>
<span id="cb491-11"><a href="#cb491-11" aria-hidden="true"></a>       (<span class="st">&quot;Over Hill and Under Hill&quot;</span> . <span class="dv">100</span>)</span>
<span id="cb491-12"><a href="#cb491-12" aria-hidden="true"></a>       (<span class="st">&quot;Riddles in the Dark&quot;</span> . <span class="dv">115</span>)))</span></code></pre></div>
<p>would output</p>
<pre><code>    An Unexpected Party.....................................................29
    Roast Mutton............................................................60
    A Short Rest............................................................87
    Over Hill and Under Hill...............................................100
    Riddles in the Dark....................................................115</code></pre>
<h2 id="eellipsis"><code>eellipsis</code></h2>
<p>The string used when truncating as described in trimmed.</p>
<h2 id="radix"><code>radix</code></h2>
<p>The radix for numeric output, defaulting to 10, as used in numeric and written.</p>
<h2 id="precision"><code>precision</code></h2>
<p>The precision for numeric output, as described in numeric and written. The precision specifies the number of digits written after the decimal point. If the numeric value to be written out requires more digits to represent it than precision, the written representation is chosen which is closest to the numeric value and representable with the specified precision. If the numeric value falls on the midpoint of two such representations, it is implementation dependent which representation is chosen.</p>
<p>When the numeric value is an inexact floating-point number, there is more than one interpretation of this “rounding”. One is to take the effective value the floating-point number represents (e.g. if we use binary floating-point numbers, we take the value of (* sign mantissa (expt 2 exponent))), and compare it to the two closest numeric representations of the given precision. Another way is to obtain the default notation of the floating-point number and apply rounding to it. The former (we call it effective rounding) is consistent with most floating-point number operations, but may lead to a more non-intuitive result than the latter (we call it notational rounding). For example, 5.015 can’t be represented exactly in binary floating-point numbers. With IEEE754 floating-point numbers, the floating point number closest to 5.015 is smaller than exact 5.015, i.e. (&lt; 5.015 5015/1000) =&gt; #t. With effective rounding with precision 2, it should result in “5.01”. However, users who look at the notation may be confused by “5.015” not being rounded up as they usually expect. With notational rounding the implementation chooses “5.02” (if it also adopts round-half-to-infinity or round-half-up rule). It is up to the implementation to choose which interpretation to adopt.</p>
<h2 id="decimal-sep"><code>decimal-sep</code></h2>
<p>The decimal separator for floating point output, default “.”.</p>
<h2 id="decimal-align"><code>decimal-align</code></h2>
<p>Specifies an alignment for the decimal place when formatting numbers, and is useful for outputting tables of numbers.</p>
<div class="sourceCode" id="cb493"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb493-1"><a href="#cb493-1" aria-hidden="true"></a>    (<span class="ex">define</span><span class="fu"> </span>(print-angles x)</span>
<span id="cb493-2"><a href="#cb493-2" aria-hidden="true"></a>      (joined numeric (<span class="kw">list</span> x (<span class="kw">sin</span> x) (<span class="kw">cos</span> x) (<span class="kw">tan</span> x)) <span class="st">&quot; &quot;</span>))</span>
<span id="cb493-3"><a href="#cb493-3" aria-hidden="true"></a></span>
<span id="cb493-4"><a href="#cb493-4" aria-hidden="true"></a>    (show <span class="dv">#t</span> (with ((decimal-align <span class="dv">5</span>) (precision <span class="dv">3</span>))</span>
<span id="cb493-5"><a href="#cb493-5" aria-hidden="true"></a>               (joined/suffix print-angles (iota <span class="dv">5</span>) nl)))</span></code></pre></div>
<p>would output</p>
<div class="sourceCode" id="cb494"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb494-1"><a href="#cb494-1" aria-hidden="true"></a>     <span class="fl">0.000</span>    <span class="fl">0.000</span>    <span class="fl">1.000</span>    <span class="fl">0.000</span></span>
<span id="cb494-2"><a href="#cb494-2" aria-hidden="true"></a>     <span class="fl">1.000</span>    <span class="fl">0.842</span>    <span class="fl">0.540</span>    <span class="fl">1.557</span></span>
<span id="cb494-3"><a href="#cb494-3" aria-hidden="true"></a>     <span class="fl">2.000</span>    <span class="fl">0.909</span>   <span class="fl">-0.416</span>   <span class="fl">-2.185</span></span>
<span id="cb494-4"><a href="#cb494-4" aria-hidden="true"></a>     <span class="fl">3.000</span>    <span class="fl">0.141</span>   <span class="fl">-0.990</span>   <span class="fl">-0.142</span></span>
<span id="cb494-5"><a href="#cb494-5" aria-hidden="true"></a>     <span class="fl">4.000</span>   <span class="fl">-0.757</span>   <span class="fl">-0.654</span>    <span class="fl">1.158</span></span></code></pre></div>
<h2 id="word-separator"><code>word-separator?</code></h2>
<p>A character predicate used to tokenize words for wrapped and justify. Defaults to char-whitespace?. More flexibility is available with wrapped/list.</p>
<h1 id="scheme-case-lambda"><code>(scheme case-lambda)</code></h1>
<h2 id="case-lambda-clause1-...-syntax"><code>(case-lambda &lt;clause1&gt; ...)</code> syntax</h2>
<p>Each clause is of the form <code>(&lt;formals&gt; &lt;body&gt;)</code>, where <code>&lt;formals&gt;</code> and <code>&lt;body&gt;</code> have the same syntax as in a lambda expression.</p>
<p>A case-lambda expression evaluates to a procedure that accepts a variable number of arguments and is lexically scoped in the same manner as a procedure resulting from a lambda expression. When the procedure is called, the first clause for which the arguments agree with <code>&lt;formals&gt;</code> is selected, where agreement is specified as for the <code>&lt;formals&gt;</code> of a lambda expression. The variables of <code>&lt;formals&gt;</code> are bound to fresh locations, the values of the arguments are stored in those locations, the <code>&lt;body&gt;</code> is evaluated in the extended environment, and the results of <code>&lt;body&gt;</code> are returned as the results of the procedure call.</p>
<p>It is an error for the arguments not to agree with the <code>&lt;formals&gt;</code> of any clause`.</p>
<p>Example:</p>
<div class="sourceCode" id="cb495"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb495-1"><a href="#cb495-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> add1</span></span>
<span id="cb495-2"><a href="#cb495-2" aria-hidden="true"></a>  (case-lambda</span>
<span id="cb495-3"><a href="#cb495-3" aria-hidden="true"></a>    ((a) (add1 a <span class="dv">0</span>))</span>
<span id="cb495-4"><a href="#cb495-4" aria-hidden="true"></a>    ((a b) (<span class="op">+</span> <span class="dv">1</span> a b))))</span>
<span id="cb495-5"><a href="#cb495-5" aria-hidden="true"></a></span>
<span id="cb495-6"><a href="#cb495-6" aria-hidden="true"></a>(add1 <span class="dv">1</span>) <span class="co">;; =&gt; 2</span></span>
<span id="cb495-7"><a href="#cb495-7" aria-hidden="true"></a>(add1 <span class="dv">1</span> <span class="dv">2</span>) <span class="co">;; =&gt; 4</span></span></code></pre></div>
<h1 id="scheme-hash-table"><code>(scheme hash-table)</code></h1>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-125/">srfi-125</a>.</p>
<p>The library doesn’t implement deprecated features. Application must rely on <code>(scheme comparator)</code> to specify equal predicate and hash function.</p>
<p>This SRFI defines an interface to hash tables, which are widely recognized as a fundamental data structure for a wide variety of applications. A hash table is a data structure that:</p>
<ul>
<li><p>Is disjoint from all other types.</p></li>
<li><p>Provides a mapping from objects known as keys to corresponding objects known as values.</p>
<ul>
<li><p>Keys may be any Scheme objects in some kinds of hash tables, but are restricted in other kinds.</p></li>
<li><p>Values may be any Scheme objects.</p></li>
</ul></li>
<li><p>Has no intrinsic order for the key-value associations it contains.</p></li>
<li><p>Provides an equality predicate which defines when a proposed key is the same as an existing key. No table may contain more than one value for a given key.</p></li>
<li><p>Provides a hash function which maps a candidate key into a non-negative exact integer.</p></li>
<li><p>Supports mutation as the primary means of setting the contents of a able.</p></li>
<li><p>Provides key lookup and destructive update in (expected) amortized constant time, provided a satisfactory hash function is available.</p></li>
<li><p>Does not guarantee that whole-table operations work in the presence of concurrent mutation of the whole hash table (values may be safely mutated).</p></li>
</ul>
<h2 id="make-hash-table-comparator-.-args"><code>(make-hash-table comparator . args)</code></h2>
<p>Returns a newly allocated hash table using <code>(scheme comparator)</code> object <code>COMPARATOR</code>. For the time being, <code>ARGS</code> is ignored.</p>
<h2 id="hash-table-comparator-key-value-..."><code>(hash-table comparator [key value] ...)</code></h2>
<p>Returns a newly allocated hash table using <code>(scheme comparator)</code> object <code>COMPARATOR</code>. For each pair of arguments, an association is added to the new hash table with key as its key and value as its value. If the same key (in the sense of the equality predicate) is specified more than once, it is an error.</p>
<h2 id="hash-table-unfold-stop-mapper-successor-seed-comparator-args-..."><code>(hash-table-unfold stop? mapper successor seed comparator args ...)</code></h2>
<p>Create a new hash table as if by <code>make-hash-table</code> using <code>comparator</code> and the <code>args</code>. If the result of applying the predicate <code>stop?</code> to <code>seed</code> is true, return the hash table. Otherwise, apply the procedure <code>mapper</code> to <code>seed</code>. <code>mapper</code> returns two values, which are inserted into the hash table as the key and the value respectively. Then get a new <code>seed</code> by applying the procedure <code>successor</code> to <code>seed</code>, and repeat this algorithm.</p>
<h2 id="alist-hash-table-alist-comparator-arg-..."><code>(alist-&gt;hash-table alist comparator arg ...)</code></h2>
<p>Returns a newly allocated hash-table as if by <code>make-hash-table</code> using <code>comparator</code> and the <code>args</code>. It is then initialized from the associations of <code>alist</code>. Associations earlier in the list take precedence over those that come later.</p>
<h2 id="hash-table-obj"><code>(hash-table? obj)</code></h2>
<p>Returns #t if obj is a hash table, and #f otherwise</p>
<h2 id="hash-table-contains-hash-table-key"><code>(hash-table-contains? hash-table key)</code></h2>
<p>Returns #t if there is any association to key in hash-table, and #f otherwise.</p>
<h2 id="hash-table-empty-hash-table"><code>(hash-table-empty? hash-table)</code></h2>
<p>Returns #t if hash-table contains no associations, and #f otherwise.</p>
<h2 id="hash-table-value-comparator-hash-table1-hash-table2"><code>(hash-table=? value-comparator hash-table1 hash-table2)</code></h2>
<p>Returns #t if hash-table1 and hash-table2 have the same keys (in the sense of their common equality predicate) and each key has the same value (in the sense of value-comparator), and #f otherwise.</p>
<h2 id="hash-table-mutable-hash-table"><code>(hash-table-mutable? hash-table)</code></h2>
<p>Returns #t if the hash table is mutable.</p>
<h2 id="hash-table-ref-hash-table-key-failure-success"><code>(hash-table-ref hash-table key [failure [success]])</code></h2>
<p>Extracts the value associated to key in hash-table, invokes the procedure success on it, and returns its result; if success is not provided, then the value itself is returned. If key is not contained in hash-table and failure is supplied, then failure is invoked on no arguments and its result is returned.</p>
<h2 id="hash-table-refdefault-hash-table-key-default"><code>(hash-table-ref/default hash-table key default)</code></h2>
<p>TODO</p>
<h2 id="hash-table-set-hash-table-key-value-..."><code>(hash-table-set! hash-table key value ...)</code></h2>
<p>Repeatedly mutates hash-table, creating new associations in it by processing the arguments from left to right. The args alternate between keys and values. Whenever there is a previous association for a key, it is deleted. It is an error if the type check procedure of the comparator of hash-table, when invoked on a key, does not return #t. Likewise, it is an error if a key is not a valid argument to the equality predicate of hash-table. Returns an unspecified value.</p>
<h2 id="hash-table-delete-hash-table-key-..."><code>(hash-table-delete! hash-table key ...)</code></h2>
<p>Deletes any association to each key in hash-table and returns the number of keys that had associations.</p>
<h2 id="hash-table-intern-hash-table-key-failure"><code>(hash-table-intern! hash-table key failure)</code></h2>
<p>Effectively invokes hash-table-ref with the given arguments and returns what it returns. If key was not found in hash-table, its value is set to the result of calling failure.</p>
<h2 id="hash-table-update-hash-table-key-updater-failure-success"><code>(hash-table-update! hash-table key updater [failure [success]])</code></h2>
<p>TODO:</p>
<h2 id="hash-table-pop-hash-table"><code>(hash-table-pop! hash-table)</code></h2>
<p>Chooses an arbitrary association from hash-table and removes it, returning the key and value as two values. It is an error if hash-table is empty.</p>
<h2 id="hash-table-clear-hash-table"><code>(hash-table-clear! hash-table)</code></h2>
<p>Delete all the associations from hash-table.</p>
<h2 id="hash-table-size-hash-table"><code>(hash-table-size hash-table)</code></h2>
<p>Returns the number of associations in hash-table as an exact integer.</p>
<h2 id="hash-table-keys-hash-table"><code>(hash-table-keys hash-table)</code></h2>
<p>Returns a newly allocated list of all the keys in hash-table.</p>
<h2 id="hash-table-values-hash-table"><code>(hash-table-values hash-table)</code></h2>
<p>Returns a newly allocated list of all the keys in hash-table.</p>
<h2 id="hash-table-entries-hash-table"><code>(hash-table-entries hash-table)</code></h2>
<p>Returns two values, a newly allocated list of all the keys in hash-table and a newly allocated list of all the values in hash-table in the corresponding order.</p>
<h2 id="hash-table-find-proc-hash-table-failure"><code>(hash-table-find proc hash-table failure)</code></h2>
<p>For each association of hash-table, invoke proc on its key and value. If proc returns true, then hash-table-find returns what proc returns. If all the calls to proc return #f, return the result of invoking the thunk failure.</p>
<h2 id="hash-table-count-pred-hash-table"><code>(hash-table-count pred hash-table)</code></h2>
<p>For each association of hash-table, invoke pred on its key and value. Return the number of calls to pred which returned true.</p>
<h2 id="hash-table-map-proc-comparator-hash-table"><code>(hash-table-map proc comparator hash-table)</code></h2>
<p>Returns a newly allocated hash table as if by <code>(make-hash-table comparator)</code>. Calls <code>PROC</code> for every association in <code>hash-table</code> with the value of the association. The key of the association and the result of invoking <code>proc</code> are entered into the new hash table. Note that this is not the result of lifting mapping over the domain of hash tables, but it is considered more useful.</p>
<p>If comparator recognizes multiple keys in the hash-table as equivalent, any one of such associations is taken.</p>
<h2 id="hash-table-for-each-proc-hash-table"><code>(hash-table-for-each proc hash-table)</code></h2>
<p>Calls proc for every association in hash-table with two arguments: the key of the association and the value of the association. The value returned by proc is discarded. Returns an unspecified value.</p>
<h2 id="hash-table-map-proc-hash-table"><code>(hash-table-map! proc hash-table)</code></h2>
<p>Calls proc for every association in hash-table with two arguments: the key of the association and the value of the association. The value returned by proc is used to update the value of the association. Returns an unspecified value.</p>
<h2 id="hash-table-map-list-proc-hash-table"><code>(hash-table-map-&gt;list proc hash-table)</code></h2>
<p>Calls proc for every association in hash-table with two arguments: the key of the association and the value of the association. The values returned by the invocations of proc are accumulated into a list, which is returned.</p>
<h2 id="hash-table-fold-proc-seed-hash-table"><code>(hash-table-fold proc seed hash-table)</code></h2>
<p>Calls proc for every association in hash-table with three arguments: the key of the association, the value of the association, and an accumulated value val. Val is seed for the first invocation of procedure, and for subsequent invocations of proc, the returned value of the previous invocation. The value returned by hash-table-fold is the return value of the last invocation of proc.</p>
<h2 id="hash-table-prune-proc-hash-table"><code>(hash-table-prune! proc hash-table)</code></h2>
<p>Calls proc for every association in hash-table with two arguments, the key and the value of the association, and removes all associations from hash-table for which proc returns true. Returns an unspecified value.</p>
<h2 id="hash-table-copy-hash-table-mutable"><code>(hash-table-copy hash-table [mutable?])</code></h2>
<p>Returns a newly allocated hash table with the same properties and associations as hash-table. If the second argument is present and is true, the new hash table is mutable. Otherwise it is immutable provided that the implementation supports immutable hash tables.</p>
<h2 id="hash-table-empty-copy-hash-table"><code>(hash-table-empty-copy hash-table)</code></h2>
<p>Returns a newly allocated mutable hash table with the same properties as hash-table, but with no associations.</p>
<h2 id="hash-table-alist-hash-table"><code>(hash-table-&gt;alist hash-table)</code></h2>
<p>Returns an alist with the same associations as hash-table in an unspecified order.</p>
<h2 id="hash-table-union-hash-table1-hash-table2"><code>(hash-table-union! hash-table1 hash-table2)</code></h2>
<p>Adds the associations of hash-table2 to hash-table1 and returns hash-table1. If a key appears in both hash tables, its value is set to the value appearing in hash-table1. Returns hash-table1.</p>
<h2 id="hash-table-intersection-hash-table1-hash-table2"><code>(hash-table-intersection! hash-table1 hash-table2)</code></h2>
<p>Deletes the associations from hash-table1 whose keys don’t also appear in hash-table2 and returns hash-table1.</p>
<h2 id="hash-table-difference-hash-table1-hash-table2"><code>(hash-table-difference! hash-table1 hash-table2)</code></h2>
<p>Deletes the associations of hash-table1 whose keys are also present in hash-table2 and returns hash-table1.</p>
<h2 id="hash-table-xor-hash-table1-hash-table2"><code>(hash-table-xor! hash-table1 hash-table2)</code></h2>
<p>Deletes the associations of hash-table1 whose keys are also present in hash-table2, and then adds the associations of hash-table2 whose keys are not present in hash-table1 to hash-table1. Returns hash-table1. # <code>(scheme fixnum)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-143/">SRFI-143</a>.</p>
<p>This library describes arithmetic procedures applicable to a limited range of exact integers only. These procedures are semantically similar to the corresponding generic-arithmetic procedures, but allow more efficient implementations.</p>
<h2 id="fx-width"><code>fx-width</code></h2>
<p>Bound to the value w that specifies the implementation-defined range. (R6RS fixnum-width is a procedure that always returns this value.)</p>
<h2 id="fx-greatest"><code>fx-greatest</code></h2>
<p>Bound to the value 2w-1-1, the largest representable fixnum. (R6RS greatest-fixnum is a procedure that always returns this value.)</p>
<h2 id="fx-least"><code>fx-least</code></h2>
<p>Bound to the value -2w-1, the smallest representable fixnum. (R6RS least-fixnum is a procedure that always returns this value.)</p>
<h2 id="fixnum-obj"><code>(fixnum? obj)</code></h2>
<p>Returns #t if obj is an exact integer within the fixnum range, and #f otherwise.</p>
<h2 id="fx-i-..."><code>(fx=? i ...)</code></h2>
<p>Semantically equivalent to =.</p>
<h2 id="fx-i-...-1"><code>(fx&lt;? i ...)</code></h2>
<p>Semantically equivalent to &lt;.</p>
<h2 id="fx-i-...-2"><code>(fx&gt;? i ...)</code></h2>
<p>Semantically equivalent to &gt;.</p>
<h2 id="fx-i-...-3"><code>(fx&lt;=? i ...)</code></h2>
<p>Semantically equivalent to &lt;=.</p>
<h2 id="fx-i-...-4"><code>(fx&gt;=? i ...)</code></h2>
<p>Semantically equivalent to &gt;=.</p>
<h2 id="fxzero-i"><code>(fxzero? i)</code></h2>
<p>Semantically equivalent to zero?.</p>
<h2 id="fxpositive-i"><code>(fxpositive? i)</code></h2>
<p>Semantically equivalent to positive?.</p>
<h2 id="fxnegative-i"><code>(fxnegative? i)</code></h2>
<p>Semantically equivalent to negative?.</p>
<h2 id="fxodd-i"><code>(fxodd? i)</code></h2>
<p>Semantically equivalent to odd?.</p>
<h2 id="fxeven-i"><code>(fxeven? i)</code></h2>
<p>Semantically equivalent to even?.</p>
<h2 id="fxmax-i-j-..."><code>(fxmax i j ...)</code></h2>
<p>Semantically equivalent to max.</p>
<h2 id="fxmin-i-j-..."><code>(fxmin i j ...)</code></h2>
<p>Semantically equivalent to min.</p>
<h2 id="fx-i-j"><code>(fx+ i j)</code></h2>
<p>Semantically equivalent to +, but accepts exactly two arguments.</p>
<h2 id="fx--i-j"><code>(fx- i j)</code></h2>
<p>Semantically equivalent to -, but accepts exactly two arguments.</p>
<h2 id="fxneg-i"><code>(fxneg i)</code></h2>
<p>Semantically equivalent to -, but accepts exactly one argument.</p>
<h2 id="fx-i-j-1"><code>(fx* i j)</code></h2>
<p>Semantically equivalent to *, but accepts exactly two arguments.</p>
<h2 id="fxquotient-i-j"><code>(fxquotient i j)</code></h2>
<p>Semantically equivalent to quotient.</p>
<h2 id="fxremainder-i-j"><code>(fxremainder i j)</code></h2>
<p>Semantically equivalent to remainder.</p>
<h2 id="fxabs-i"><code>(fxabs i)</code></h2>
<p>Semantically equivalent to abs. In accordance with the fixnum rule, has undefined results when applied to fx-least.</p>
<h2 id="fxsquare-i"><code>(fxsquare i)</code></h2>
<p>Semantically equivalent to square.</p>
<h2 id="fxsqrt-i"><code>(fxsqrt i)</code></h2>
<p>Semantically equivalent to exact-integer-sqrt (not sqrt).</p>
<h2 id="fxcarry-i-j-k"><code>(fx+/carry i j k)</code></h2>
<p>Returns the two fixnum results of the following computation:</p>
<div class="sourceCode" id="cb496"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb496-1"><a href="#cb496-1" aria-hidden="true"></a>(let*-values (((s) (<span class="op">+</span> i j k))</span>
<span id="cb496-2"><a href="#cb496-2" aria-hidden="true"></a>       ((q r) (balanced/ s (<span class="kw">expt</span> <span class="dv">2</span> fx-width))))</span>
<span id="cb496-3"><a href="#cb496-3" aria-hidden="true"></a>  (<span class="kw">values</span> r q))</span>
<span id="cb496-4"><a href="#cb496-4" aria-hidden="true"></a></span>
<span id="cb496-5"><a href="#cb496-5" aria-hidden="true"></a>(fx-/carry i j k)</span></code></pre></div>
<p>Returns the two fixnum results of the following computation:</p>
<div class="sourceCode" id="cb497"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb497-1"><a href="#cb497-1" aria-hidden="true"></a>(let*-values (((d) (<span class="op">-</span> i j k))</span>
<span id="cb497-2"><a href="#cb497-2" aria-hidden="true"></a>       ((q r) (balanced/ d (<span class="kw">expt</span> <span class="dv">2</span> fx-width))))</span>
<span id="cb497-3"><a href="#cb497-3" aria-hidden="true"></a>  (<span class="kw">values</span> r q))</span>
<span id="cb497-4"><a href="#cb497-4" aria-hidden="true"></a></span>
<span id="cb497-5"><a href="#cb497-5" aria-hidden="true"></a>(fx*/carry i j k)</span></code></pre></div>
<p>Returns the two fixnum results of the following computation:</p>
<div class="sourceCode" id="cb498"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb498-1"><a href="#cb498-1" aria-hidden="true"></a>(let*-values (((s) (<span class="op">+</span> (* i j) k))</span>
<span id="cb498-2"><a href="#cb498-2" aria-hidden="true"></a>       ((q r) (balanced/ s (<span class="kw">expt</span> <span class="dv">2</span> fx-width))))</span>
<span id="cb498-3"><a href="#cb498-3" aria-hidden="true"></a>  (<span class="kw">values</span> r q))</span></code></pre></div>
<p>The balanced/ procedure is available in SRFI 141, and also in the R6RS base library under the name of div0-and-mod0. Bitwise operations</p>
<p>The following procedures are the fixnum counterparts of certain bitwise operations from SRFI 151 and the R6RS (rnrs arithmetic fixnums) library. In case of disagreement, SRFI 151 is preferred. The prefixes bitwise- and integer- are dropped for brevity and compatibility.</p>
<h2 id="fxnot-i"><code>(fxnot i)</code></h2>
<p>Semantically equivalent to bitwise-not.</p>
<h2 id="fxand-i-..."><code>(fxand i ...)</code></h2>
<p>Semantically equivalent to bitwise-and.</p>
<h2 id="fxior-i-..."><code>(fxior i ...)</code></h2>
<p>Semantically equivalent to bitwise-ior.</p>
<h2 id="fxxor-i-..."><code>(fxxor i ...)</code></h2>
<p>Semantically equivalent to bitwise-xor.</p>
<h2 id="fxarithmetic-shift-i-count"><code>(fxarithmetic-shift i count)</code></h2>
<p>Semantically equivalent to arithmetic-shift, except that it is an error for the absolute value of count to exceed w-1.</p>
<h2 id="fxarithmetic-shift-left-i-count"><code>(fxarithmetic-shift-left i count)</code></h2>
<p>The same as fxarithmetic-shift except that a negative value of count is an error. This is provided for additional efficiency.</p>
<h2 id="fxarithmetic-shift-right-i-count"><code>(fxarithmetic-shift-right i count)</code></h2>
<p>The same as fxarithmetic-shift except that a non-negative value of count specifies the number of bits to shift right, and a negative value is an error. This is provided for additional efficiency.</p>
<h2 id="fxbit-count-i"><code>(fxbit-count i)</code></h2>
<p>Semantically equivalent to SRFI 151 bit-count.</p>
<h2 id="fxlength-i"><code>(fxlength i)</code></h2>
<p>Semantically equivalent to integer-length.</p>
<h2 id="fxif-mask-i-j"><code>(fxif mask i j)</code></h2>
<p>Semantically equivalent to bitwise-if. It can be implemented as (fxior (fxand mask i) (fxand (fxnot mask) j))).</p>
<h2 id="fxbit-set-index-i"><code>(fxbit-set? index i)</code></h2>
<p>Semantically equivalent to SRFI 151 bit-set?, except that it is an error for index to be larger than or equal to fx-width.</p>
<h2 id="fxcopy-bit-index-i-boolean"><code>(fxcopy-bit index i boolean)</code></h2>
<p>Semantically equivalent to SRFI 151 copy-bit, except that it is an error for index to be larger than or equal to fx-width.</p>
<h2 id="fxfirst-set-bit-i"><code>(fxfirst-set-bit i)</code></h2>
<p>Semantically equivalent to first-set-bit.</p>
<h2 id="fxbit-field-i-start-end"><code>(fxbit-field i start end)</code></h2>
<p>Semantically equivalent to bit-field.</p>
<h2 id="fxbit-field-rotate-i-count-start-end"><code>(fxbit-field-rotate i count start end)</code></h2>
<p>Semantically equivalent to SRFI 151 bit-field-rotate.</p>
<h2 id="fxbit-field-reverse-i-start-end"><code>(fxbit-field-reverse i start end)</code></h2>
<p>Semantically equivalent to bit-field-reverse. # <code>(scheme write)</code></p>
<h2 id="display-obj-port"><code>(display obj [port])</code></h2>
<p>Writes a representation of obj to the given textual output port. Strings that appear in the written representation are output as if by write-string instead of by write. Symbols are not escaped. Character objects appear in the representation as if written by write-char instead of by write.</p>
<h2 id="write-obj-port"><code>(write obj [port])</code></h2>
<p>Writes a representation of obj to the given textual output port. Strings that appear in the written representation are enclosed in quotation marks, and within those strings backslash and quotation mark characters are escaped by backslashes. Symbols that contain non-ASCII characters are escaped with vertical lines. Character objects are written using the <code>#\</code> notation.</p>
<p>If obj contains cycles which would cause an infinite loop using the normal written representation, then at least the objects that form part of the cycle must be represented using datum labels as described in section 2.4. Datum labels must not be used if there are no cycles.</p>
<h2 id="write-simple-obj-port"><code>(write-simple obj [port])</code></h2>
<p>The write-simple procedure is the same as write, except that shared structure is never represented using datum labels. This can cause write-simple not to terminate if obj contains circular structure.</p>
<h2 id="write-shared-obj-port"><code>(write-shared obj [port])</code></h2>
<p>The write-shared procedure is the same as write, except that shared structure must be represented using datum labels for all pairs and vectors that appear more than once in the output. # <code>(scheme mapping hash)</code></p>
<h2 id="hashmap-comparator-key-value-..."><code>(hashmap comparator [key value] ...)</code></h2>
<p>Returns a newly allocated hashmap. The comparator argument is used to control and distinguish the keys of the hashmap. The args alternate between keys and values and are used to initialize the hashmap. In particular, the number of args has to be even. Earlier associations with equal keys take precedence over later arguments.</p>
<h2 id="hashmap-unfold-stop-mapper-successor-seed-comparator"><code>(hashmap-unfold stop? mapper successor seed comparator)</code></h2>
<p>Create a newly allocated hashmap as if by hashmap using comparator. If the result of applying the predicate stop? to seed is true, return the hashmap. Otherwise, apply the procedure mapper to seed. Mapper returns two values which are added to the hashmap as the key and the value, respectively. Then get a new seed by applying the procedure successor to seed, and repeat this algorithm. Associations earlier in the list take precedence over those that come later.</p>
<h2 id="hashmap-obj"><code>(hashmap? obj)</code></h2>
<p>Returns #t if obj is a hashmap, and #f otherwise.</p>
<h2 id="hashmap-contains-hashmap-key"><code>(hashmap-contains? hashmap key)</code></h2>
<p>Returns #t if key is the key of an association of hashmap and #f otherwise.</p>
<h2 id="hashmap-empty-hashmap"><code>(hashmap-empty? hashmap)</code></h2>
<p>Returns #t if hashmap has no associations and #f otherwise.</p>
<h2 id="hashmap-disjoint-hashmap1-hashmap2"><code>(hashmap-disjoint? hashmap1 hashmap2)</code></h2>
<p>Returns #t if hashmap1 and hashmap2 have no keys in common and #f otherwise.</p>
<h2 id="hashmap-ref-hashmap-key-failure-success"><code>(hashmap-ref hashmap key [failure [success]])</code></h2>
<p>Extracts the value associated to key in the hashmap hashmap, invokes the procedure success in tail context on it, and returns its result; if success is not provided, then the value itself is returned. If key is not contained in hashmap and failure is supplied, then failure is invoked in tail context on no arguments and its values are returned. Otherwise, it is an error.</p>
<h2 id="hashmap-refdefault-hashmap-key-default"><code>(hashmap-ref/default hashmap key default)</code></h2>
<h2 id="hashmap-key-comparator-hashmap"><code>(hashmap-key-comparator hashmap)</code></h2>
<p>Returns the comparator used to compare the keys of the hashmap hashmap.</p>
<h2 id="hashmap-adjoin-hashmap-arg-..."><code>(hashmap-adjoin hashmap arg ...)</code></h2>
<p>The hashmap-adjoin procedure returns a newly allocated hashmap that uses the same comparator as the hashmap hashmap and contains all the associations of hashmap, and in addition new associations by processing the arguments from left to right. The args alternate between keys and values. Whenever there is a previous association for a key, the previous association prevails and the new association is skipped. It is an error to add an association to hashmap whose key that does not return #t when passed to the type test procedure of the comparator.</p>
<h2 id="hashmap-adjoin-hashmap-arg-...-1"><code>(hashmap-adjoin! hashmap arg ...)</code></h2>
<p>The hashmap-adjoin! procedure is the same as hashmap-adjoin, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h2 id="hashmap-set-hashmap-arg-..."><code>(hashmap-set hashmap arg ...)</code></h2>
<p>The hashmap-set procedure returns a newly allocated hashmap that uses the same comparator as the hashmap hashmap and contains all the associations of hashmap, and in addition new associations by processing the arguments from left to right. The args alternate between keys and values. Whenever there is a previous association for a key, it is deleted. It is an error to add an association to hashmap whose key that does not return #t when passed to the type test procedure of the comparator.</p>
<h2 id="hashmap-set-hashmap-arg-...-1"><code>(hashmap-set! hashmap arg ...)</code></h2>
<p>The hashmap-set! procedure is the same as hashmap-set, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h2 id="hashmap-replace-hashmap-key-value"><code>(hashmap-replace hashmap key value)</code></h2>
<p>The hashmap-replace procedure returns a newly allocated hashmap that uses the same comparator as the hashmap hashmap and contains all the associations of hashmap except as follows: If key is equal (in the sense of hashmap’s comparator) to an existing key of hashmap, then the association for that key is omitted and replaced the association defined by the pair key and value. If there is no such key in hashmap, then hashmap is returned unchanged.</p>
<h2 id="hashmap-replace-hashmap-key-value-1"><code>(hashmap-replace! hashmap key value)</code></h2>
<p>The hashmap-replace! procedure is the same as hashmap-replace, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h2 id="hashmap-delete-hashmap-key-..."><code>(hashmap-delete hashmap key ...)</code></h2>
<h2 id="hashmap-delete-hashmap-key-...-1"><code>(hashmap-delete! hashmap key ...)</code></h2>
<h2 id="hashmap-delete-all-hashmap-key-list"><code>(hashmap-delete-all hashmap key-list)</code></h2>
<h2 id="hashmap-delete-all-hashmap-key-list-1"><code>(hashmap-delete-all! hashmap key-list)</code></h2>
<p>The hashmap-delete procedure returns a newly allocated hashmap containing all the associations of the hashmap hashmap except for any whose keys are equal (in the sense of hashmap’s comparator) to one or more of the keys. Any key that is not equal to some key of the hashmap is ignored.</p>
<p>The hashmap-delete! procedure is the same as hashmap-delete, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<p>The hashmap-delete-all and hashmap-delete-all! procedures are the same as hashmap-delete and hashmap-delete!, respectively, except that they accept a single argument which is a list of keys whose associations are to be deleted.</p>
<h2 id="hashmap-intern-hashmap-key-failure"><code>(hashmap-intern hashmap key failure)</code></h2>
<p>Extracts the value associated to key in the hashmap hashmap, and returns hashmap and the value as two values. If key is not contained in hashmap, failure is invoked on no arguments. The procedure then returns two values, a newly allocated hashmap that uses the same comparator as the hashmap and contains all the associations of hashmap, and in addition a new association hashmap key to the result of invoking failure, and the result of invoking failure.</p>
<h2 id="hashmap-intern-hashmap-key-failure-1"><code>(hashmap-intern! hashmap key failure)</code></h2>
<p>The hashmap-intern! procedure is the same as hashmap-intern, except that it is permitted to mutate and return the hashmap argument as its first value rather than allocating a new hashmap.</p>
<h2 id="hashmap-update-hashmap-key-updater-failure-success"><code>(hashmap-update hashmap key updater [failure [success]])</code></h2>
<p>TODO</p>
<h2 id="hashmap-update-hashmap-key-updater-failure-success-1"><code>(hashmap-update! hashmap key updater [failure [success]])</code></h2>
<p>The hashmap-update! procedure is the same as hashmap-update, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h2 id="hashmap-updatedefault-hashmap-key-updater-default"><code>(hashmap-update/default hashmap key updater default)</code></h2>
<p>TODO</p>
<h2 id="hashmap-updatedefault-hashmap-key-updater-default-1"><code>(hashmap-update!/default hashmap key updater default)</code></h2>
<p>The hashmap-update!/default procedure is the same as hashmap-update/default, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h2 id="hashmap-pop-hashmap-failure"><code>(hashmap-pop hashmap [failure])</code></h2>
<p>The hashmap-pop procedure exported from (srfi 146) chooses the association with the least key from hashmap and returns three values, a newly allocated hashmap that uses the same comparator as hashmap and contains all associations of hashmap except the chosen one, and the key and the value of the chosen association. If hashmap contains no association and failure is supplied, then failure is invoked in tail context on no arguments and its values returned. Otherwise, it is an error.</p>
<h2 id="hashmap-pop-hashmap-failure-1"><code>(hashmap-pop! hashmap [failure])</code></h2>
<p>The hashmap-pop! procedure is the same as hashmap-pop, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h2 id="hashmap-search-hashmap-key-failure-success"><code>(hashmap-search hashmap key failure success)</code></h2>
<p>The hashmap hashmap is searched in order (that is in the order of the stored keys) for an association with key key. If it is not found, then the failure procedure is tail-called with two continuation arguments, insert and ignore, and is expected to tail-call one of them. If an association with key key is found, then the success procedure is tail-called with the matching key of hashmap, the associated value, and two continuations, update and remove, and is expected to tail-call one of them.</p>
<p>It is an error if the continuation arguments are invoked, but not in tail position in the failure and success procedures. It is also an error if the failure and success procedures return to their implicit continuation without invoking one of their continuation arguments.</p>
<p>The effects of the continuations are as follows (where obj is any Scheme object):</p>
<ul>
<li><p>Invoking (insert value obj) causes a hashmap to be newly allocated that uses the same comparator as the hashmap hashmap and contains all the associations of hashmap, and in addition a new association hashmap key to value.</p></li>
<li><p>Invoking (ignore obj) has no effects; in particular, no new hashmap is allocated (but see below).</p></li>
<li><p>Invoking (update new-key new-value obj) causes a hashmap to be newly allocated that uses the same comparator as the hashmap and contains all the associations of hashmap, except for the association with key key, which is replaced by a new association hashmap new-key to new-value.</p></li>
<li><p>Invoking (remove obj) causes a hashmap to be newly allocated that uses the same comparator as the hashmap and contains all the associations of hashmap, except for the association with key key.</p></li>
</ul>
<p>In all cases, two values are returned: the possibly newly allocated hashmap and obj.</p>
<h2 id="hashmap-search-hashmap-key-failure-success-1"><code>(hashmap-search! hashmap key failure success)</code></h2>
<p>The hashmap-search! procedure is the same as hashmap-search, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h2 id="hashmap-size-hashmap"><code>(hashmap-size hashmap)</code></h2>
<p>Returns the number of associations in hashmap as an exact integer.</p>
<h2 id="hashmap-find-predicate-hashmap-failure"><code>(hashmap-find predicate hashmap failure)</code></h2>
<p>Returns the association with the least key of the hashmap hashmap consisting of a key and value as two values such that predicate returns a true value when invoked with key and value as arguments, or the result of tail-calling failure with no arguments if there is none. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h2 id="hashmap-count-predicate-hashmap"><code>(hashmap-count predicate hashmap)</code></h2>
<p>Returns the number of associations of the hashmap hashmap that satisfy predicate (in the sense of hashmap-find) as an exact integer. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h2 id="hashmap-any-predicate-hashmap"><code>(hashmap-any? predicate hashmap)</code></h2>
<p>Returns #t if any association of the hashmap hashmap satisfies predicate (in the sense of hashmap-find), or #f otherwise. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h2 id="hashmap-every-predicate-hashmap"><code>(hashmap-every? predicate hashmap)</code></h2>
<p>Returns #t if every association of the hashmap hashmap satisfies predicate (in the sense of hashmap-find), or #f otherwise. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h2 id="hashmap-keys-hashmap"><code>(hashmap-keys hashmap)</code></h2>
<p>Returns a newly allocated list of all the keys in increasing order in the hashmap hashmap.</p>
<h2 id="hashmap-values-hashmap"><code>(hashmap-values hashmap)</code></h2>
<p>Returns a newly allocated list of all the values in increasing order of the keys in the hashmap hashmap.</p>
<h2 id="hashmap-entries-hashmap"><code>(hashmap-entries hashmap)</code></h2>
<p>Returns two values, a newly allocated list of all the keys in the hashmap hashmap, and a newly allocated list of all the values in the hashmap hashmap in increasing order of the keys.</p>
<h2 id="hashmap-map-proc-comparator-hashmap"><code>(hashmap-map proc comparator hashmap)</code></h2>
<p>Applies proc, which returns two values, on two arguments, the key and value of each association of hashmap in increasing order of the keys and returns a newly allocated hashmap that uses the comparator comparator, and which contains the results of the applications inserted as keys and values.</p>
<h2 id="hashmap-map-list-proc-hashmap"><code>(hashmap-map-&gt;list proc hashmap)</code></h2>
<p>Calls proc for every association in increasing order of the keys in the hashmap hashmap with two arguments: the key of the association and the value of the association. The values returned by the invocations of proc are accumulated into a list, which is returned.</p>
<h2 id="hashmap-for-each-proc-hashmap"><code>(hashmap-for-each proc hashmap)</code></h2>
<p>Invokes proc for every association in the hashmap hashmap in increasing order of the keys, discarding the returned values, with two arguments: the key of the association and the value of the association. Returns an unspecified value.</p>
<h2 id="hashmap-fold-proc-nil-hashmap"><code>(hashmap-fold proc nil hashmap)</code></h2>
<p>Invokes proc for each association of the hashmap hashmap in increasing order of the keys with three arguments: the key of the association, the value of the association, and an accumulated result of the previous invocation. For the first invocation, nil is used as the third argument. Returns the result of the last invocation, or nil if there was no invocation.</p>
<h2 id="hashmap-filter-predicate-hashmap"><code>(hashmap-filter predicate hashmap)</code></h2>
<p>Returns a newly allocated hashmap with the same comparator as the hashmap hashmap, containing just the associations of hashmap that satisfy predicate (in the sense of hashmap-find).</p>
<h2 id="hashmap-filter-predicate-hashmap-1"><code>(hashmap-filter! predicate hashmap)</code></h2>
<p>A linear update procedure that returns a hashmap containing just the associations of hashmap that satisfy predicate.</p>
<h2 id="hashmap-remove-predicate-hashmap"><code>(hashmap-remove predicate hashmap)</code></h2>
<p>Returns a newly allocated hashmap with the same comparator as the hashmap hashmap, containing just the associations of hashmap that do not satisfy predicate (in the sense of hashmap-find).</p>
<h2 id="hashmap-remove-predicate-hashmap-1"><code>(hashmap-remove! predicate hashmap)</code></h2>
<p>A linear update procedure that returns a hashmap containing just the associations of hashmap that do not satisfy predicate.</p>
<h2 id="hashmap-partition-predicate-hashmap"><code>(hashmap-partition predicate hashmap)</code></h2>
<p>Returns two values: a newly allocated hashmap with the same comparator as the hashmap hashmap that contains just the associations of hashmap that satisfy predicate (in the sense of hashmap-find), and another newly allocated hashmap, also with the same comparator, that contains just the associations of hashmap that do not satisfy predicate.</p>
<h2 id="hashmap-partition-predicate-hashmap-1"><code>(hashmap-partition! predicate hashmap)</code></h2>
<p>A linear update procedure that returns two hashmaps containing the associations of hashmap that do and do not, respectively, satisfy predicate.</p>
<h2 id="hashmap-copy-hashmap"><code>(hashmap-copy hashmap)</code></h2>
<p>Returns a newly allocated hashmap containing the associations of the hashmap hashmap, and using the same comparator.</p>
<h2 id="hashmap-alist-hashmap"><code>(hashmap-&gt;alist hashmap)</code></h2>
<p>Returns a newly allocated association list containing the associations of the hashmap in increasing order of the keys. Each association in the list is a pair whose car is the key and whose cdr is the associated value.</p>
<h2 id="alist-hashmap-comparator-alist"><code>(alist-&gt;hashmap comparator alist)</code></h2>
<p>Returns a newly allocated hashmap, created as if by hashmap using the comparator comparator, that contains the associations in the list, which consist of a pair whose car is the key and whose cdr is the value. Associations earlier in the list take precedence over those that come later.</p>
<h2 id="alist-hashmap-hashmap-alist"><code>(alist-&gt;hashmap! hashmap alist)</code></h2>
<p>A linear update procedure that returns a hashmap that contains the associations of both hashmap and alist. Associations in the hashmap and those earlier in the list take precedence over those that come later.</p>
<h2 id="hashmap-union-hashmap1-hashmap2-..."><code>(hashmap-union hashmap1 hashmap2 ...)</code></h2>
<h2 id="hashmap-intersection-hashmap1-hashmap2-..."><code>(hashmap-intersection hashmap1 hashmap2 ...)</code></h2>
<h2 id="hashmap-difference-hashmap1-hashmap2-..."><code>(hashmap-difference hashmap1 hashmap2 ...)</code></h2>
<h2 id="hashmap-xor-hashmap1-hashmap2-..."><code>(hashmap-xor hashmap1 hashmap2 ...)</code></h2>
<p>Return a newly allocated hashmap whose set of associations is the union, intersection, asymmetric difference, or symmetric difference of the sets of associations of the hashmaps hashmaps. Asymmetric difference is extended to more than two hashmaps by taking the difference between the first hashmap and the union of the others. Symmetric difference is not extended beyond two hashmaps. When comparing associations, only the keys are compared. In case of duplicate keys (in the sense of the hashmaps comparators), associations in the result hashmap are drawn from the first hashmap in which they appear.</p>
<h2 id="hashmap-union-hashmap1-hashmap2-...-1"><code>(hashmap-union! hashmap1 hashmap2 ...)</code></h2>
<h2 id="hashmap-intersection-hashmap1-hashmap2-...-1"><code>(hashmap-intersection! hashmap1 hashmap2 ...)</code></h2>
<h2 id="hashmap-difference-hashmap1-hashmap2-...-1"><code>(hashmap-difference! hashmap1 hashmap2 ...)</code></h2>
<h2 id="hashmap-xor-hashmap1-hashmap2-...-1"><code>(hashmap-xor! hashmap1 hashmap2 ...)</code></h2>
<p>These procedures are the linear update analogs of the corresponding pure functional procedures above.</p>
<h2 id="comparator-obj"><code>(comparator? obj)</code></h2>
<p>Type predicate for comparators as exported by <code>(scheme comparator)</code>.</p>
<h2 id="hashmap-comparator"><code>hashmap-comparator</code></h2>
<p>hashmap-comparator is constructed by invoking make-hashmap-comparator on (make-default-comparator).</p>
<h2 id="make-hashmap-comparator-comparator"><code>(make-hashmap-comparator comparator)</code></h2>
<p>Returns a comparator for hashmaps that is compatible with the equality predicate (hashmap=? comparator hashmap1 hashmap2). If make-hashmap-comparator is imported from (srfi 146), it provides a (partial) ordering predicate that is applicable to pairs of hashmaps with the same (key) comparator. If (make-hashmap-comparator) is imported from (srfi 146 hash), it provides an implementation-dependent hash function.</p>
<p>If make-hashmap-comparator is imported from (srfi 146), the lexicographic ordering with respect to the keys (and, in case a tiebreak is necessary, with respect to the ordering of the values) is used for hashmaps sharing a comparator.</p>
<p>The existence of comparators returned by make-hashmap-comparator allows hashmaps whose keys are hashmaps themselves, and it allows to compare hashmaps whose values are hashmaps. # <code>(scheme ephemeron)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-124/">SRFI-124</a>, that is itself based on the MIT Scheme Reference Manual.</p>
<p>An ephemeron is an object with two components called its key and its datum. It differs from an ordinary pair as follows: if the garbage collector (GC) can prove that there are no references to the key except from the ephemeron itself and possibly from the datum, then it is free to break the ephemeron, dropping its reference to both key and datum. In other words, an ephemeron can be broken when nobody else cares about its key. Ephemerons can be used to construct weak vectors or lists and (possibly in combination with finalizers) weak hash tables.</p>
<h2 id="ephemeron-obj"><code>(ephemeron? obj)</code></h2>
<p>Returns #t if object is an ephemeron; otherwise returns #f.</p>
<h2 id="make-ephemeron-key-datum"><code>(make-ephemeron key datum)</code></h2>
<p>Returns a newly allocated ephemeron, with components key and datum. Note that if key and datum are the same in the sense of eq?, the ephemeron is effectively a weak reference to the object.</p>
<h2 id="ephemeron-broken-ephemeron"><code>(ephemeron-broken? ephemeron)</code></h2>
<p>Returns #t if ephemeron has been broken; otherwise returns #f.</p>
<p>This procedure must be used with care. If it returns #f, that guarantees only that prior evaluations of ephemeron-key or ephemeron-datum yielded the key or datum that was stored in ephemeron. However, it makes no guarantees about subsequent calls to ephemeron-key or ephemeron-datum, because the GC may run and break the ephemeron immediately after ephemeron-broken? returns. Thus, the correct idiom to fetch an ephemeron’s key and datum and use them if the ephemeron is not broken is:</p>
<div class="sourceCode" id="cb499"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb499-1"><a href="#cb499-1" aria-hidden="true"></a>     (<span class="kw">let</span> ((key (ephemeron-key ephemeron))</span>
<span id="cb499-2"><a href="#cb499-2" aria-hidden="true"></a>           (datum (ephemeron-datum ephemeron)))</span>
<span id="cb499-3"><a href="#cb499-3" aria-hidden="true"></a>       (<span class="kw">if</span> (ephemeron-broken? ephemeron)</span>
<span id="cb499-4"><a href="#cb499-4" aria-hidden="true"></a>           ... broken <span class="kw">case</span> ...</span>
<span id="cb499-5"><a href="#cb499-5" aria-hidden="true"></a>           ... code using key <span class="kw">and</span> datum ...))</span></code></pre></div>
<h2 id="ephemeron-key-ephemeron"><code>(ephemeron-key ephemeron)</code></h2>
<h2 id="ephemeron-value-ephemeron"><code>(ephemeron-value ephemeron)</code></h2>
<p>These return the key or datum component, respectively, of ephemeron. If ephemeron has been broken, these operations return #f, but they can also return #f if that is what was stored as the key or datum.</p>
<h2 id="reference-barrier-key"><code>(reference-barrier key)</code></h2>
<p>This procedure is optional.</p>
<p>This procedure ensures that the garbage collector does not break an ephemeron containing an unreferenced key before a certain point in a program. The program can invoke a reference barrier on the key by calling this procedure, which guarantees that even if the program does not use the key, it will be considered strongly reachable until after reference-barrier returns. # <code>(scheme cxr)</code></p>
<p>Exports the following procedure which are the compositions of from three to four <code>car</code> and <code>cdr</code> operations. For example <code>caddar</code> could be defined:</p>
<div class="sourceCode" id="cb500"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb500-1"><a href="#cb500-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> caddar</span></span>
<span id="cb500-2"><a href="#cb500-2" aria-hidden="true"></a>  (<span class="kw">lambda</span> (x) (<span class="kw">car</span> (<span class="kw">cdr</span> (<span class="kw">cdr</span> (<span class="kw">car</span> x))))))</span></code></pre></div>
<p>Here is the full list:</p>
<ul>
<li><code>caaaar</code></li>
<li><code>caaadr</code></li>
<li><code>caaar</code></li>
<li><code>caadar</code></li>
<li><code>caaddr</code></li>
<li><code>caadr</code></li>
<li><code>cadaar</code></li>
<li><code>cadadr</code></li>
<li><code>cadar</code></li>
<li><code>caddar</code></li>
<li><code>cadddr</code></li>
<li><code>caddr</code></li>
<li><code>cdaaar</code></li>
<li><code>cdaadr</code></li>
<li><code>cdaar</code></li>
<li><code>cdadar</code></li>
<li><code>cdaddr</code></li>
<li><code>cdadr</code></li>
<li><code>cddaar</code></li>
<li><code>cddadr</code></li>
<li><code>cddar</code></li>
<li><code>cdddar</code></li>
<li><code>cddddr</code></li>
<li><code>cdddr</code> # <code>(scheme ilist)</code></li>
</ul>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-116/">SRFI-116</a>.</p>
<p>Scheme currently does not provide immutable pairs corresponding to its existing mutable pairs, although most uses of pairs do not exploit their mutability. The Racket system takes the radical approach of making Scheme’s pairs immutable, and providing a minimal library of mutable pairs with procedures named mpair?, mcons, mcar, mcdr, set-mcar!, set-mcdr!. This SRFI takes the opposite approach of leaving Scheme’s pairs unchanged and providing a full set of routines for creating and dealing with immutable pairs. The sample implementation is portable (to systems with SRFI 9) and efficient.</p>
<h2 id="ipair-a-d"><code>(ipair a d)</code></h2>
<p>The primitive constructor. Returns a newly allocated ipair whose icar is a and whose icdr is d. The ipair is guaranteed to be different (in the sense of eqv?) from every existing object.</p>
<div class="sourceCode" id="cb501"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb501-1"><a href="#cb501-1" aria-hidden="true"></a>(ipair &#39;a &#39;())        <span class="op">=&gt;</span> (a)</span>
<span id="cb501-2"><a href="#cb501-2" aria-hidden="true"></a>(ipair (iq a) (iq b c d)) <span class="op">=&gt;</span> ((a) b c d)</span>
<span id="cb501-3"><a href="#cb501-3" aria-hidden="true"></a>(ipair <span class="st">&quot;a&quot;</span> (iq b c))    <span class="op">=&gt;</span> (<span class="st">&quot;a&quot;</span> b c)</span>
<span id="cb501-4"><a href="#cb501-4" aria-hidden="true"></a>(ipair &#39;a <span class="dv">3</span>)          <span class="op">=&gt;</span> (a . <span class="dv">3</span>)</span>
<span id="cb501-5"><a href="#cb501-5" aria-hidden="true"></a>(ipair (iq a b) &#39;c)     <span class="op">=&gt;</span> ((a b ) . c)</span></code></pre></div>
<h2 id="ilist-object-..."><code>(ilist object ...)</code></h2>
<p>Returns a newly allocated ilist of its arguments.</p>
<div class="sourceCode" id="cb502"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb502-1"><a href="#cb502-1" aria-hidden="true"></a>(ilist &#39;a (<span class="op">+</span> <span class="dv">3</span> <span class="dv">4</span>) &#39;c) <span class="op">=&gt;</span>  (a <span class="dv">7</span> c)</span>
<span id="cb502-2"><a href="#cb502-2" aria-hidden="true"></a>(ilist)               <span class="op">=&gt;</span>  ()</span></code></pre></div>
<h2 id="xipair-d-a"><code>(xipair d a)</code></h2>
<div class="sourceCode" id="cb503"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb503-1"><a href="#cb503-1" aria-hidden="true"></a>(<span class="kw">lambda</span> (d a) (ipair a d))</span></code></pre></div>
<p>Of utility only as a value to be conveniently passed to higher-order procedures.</p>
<div class="sourceCode" id="cb504"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb504-1"><a href="#cb504-1" aria-hidden="true"></a>(xipair (iq b c) &#39;a) <span class="op">=&gt;</span> (a b c)</span></code></pre></div>
<p>The name stands for “eXchanged Immutable PAIR.”</p>
<h2 id="ipair-elt1-elt2">`(ipair* elt1 elt2 …)</h2>
<p>Like ilist, but the last argument provides the tail of the constructed ilist, returning</p>
<div class="sourceCode" id="cb505"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb505-1"><a href="#cb505-1" aria-hidden="true"></a>(ipair elt1 (ipair elt2 (ipair ... eltn)))</span>
<span id="cb505-2"><a href="#cb505-2" aria-hidden="true"></a></span>
<span id="cb505-3"><a href="#cb505-3" aria-hidden="true"></a>(ipair* <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>) <span class="op">=&gt;</span> (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . <span class="dv">4</span>)</span>
<span id="cb505-4"><a href="#cb505-4" aria-hidden="true"></a>(ipair* <span class="dv">1</span>) <span class="op">=&gt;</span> <span class="dv">1</span></span></code></pre></div>
<h2 id="make-ilist-n-fill"><code>(make-ilist n [fill])</code></h2>
<p>Returns an n-element ilist, whose elements are all the value fill. If the fill argument is not given, the elements of the ilist may be arbitrary values.</p>
<div class="sourceCode" id="cb506"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb506-1"><a href="#cb506-1" aria-hidden="true"></a>(make-ilist <span class="dv">4</span> &#39;c) <span class="op">=&gt;</span> (c c c c)</span></code></pre></div>
<h2 id="ilist-tabulate-n-init-proc"><code>(ilist-tabulate n init-proc)</code></h2>
<p>Returns an n-element ilist. Element i of the ilist, where 0 &lt;= i &lt; n, is produced by (init-proc i). No guarantee is made about the dynamic order in which init-proc is applied to these indices.</p>
<div class="sourceCode" id="cb507"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb507-1"><a href="#cb507-1" aria-hidden="true"></a>(ilist-tabulate <span class="dv">4</span> <span class="kw">values</span>) <span class="op">=&gt;</span> (<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</span></code></pre></div>
<h2 id="ilist-copy-dilist"><code>(ilist-copy dilist)</code></h2>
<p>Copies the spine of the argument, including the ilist tail.</p>
<h2 id="iiota-count-start-step"><code>(iiota count [start step])</code></h2>
<p>Returns an ilist containing the elements</p>
<div class="sourceCode" id="cb508"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb508-1"><a href="#cb508-1" aria-hidden="true"></a>(start start+step ... start+(count<span class="dv">-1</span>)*step)</span></code></pre></div>
<p>The start and step parameters default to 0 and 1, respectively. This procedure takes its name from the APL primitive.</p>
<div class="sourceCode" id="cb509"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb509-1"><a href="#cb509-1" aria-hidden="true"></a>(iiota <span class="dv">5</span>) <span class="op">=&gt;</span> (<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)</span>
<span id="cb509-2"><a href="#cb509-2" aria-hidden="true"></a>(iiota <span class="dv">5</span> <span class="dv">0</span> <span class="fl">-0.1</span>) <span class="op">=&gt;</span> (<span class="dv">0</span> <span class="fl">-0.1</span> <span class="fl">-0.2</span> <span class="fl">-0.3</span> <span class="fl">-0.4</span>)</span></code></pre></div>
<h2 id="proper-ilist-x"><code>(proper-ilist? x)</code></h2>
<h2 id="ilist-x"><code>(ilist? x)</code></h2>
<p>These identifiers are bound either to the same procedure, or to procedures of equivalent behavior. In either case, true is returned iff x is a proper ilist — a ()-terminated ilist.</p>
<p>More carefully: The empty list is a proper ilist. An ipair whose icdr is a proper ilist is also a proper ilist. Everything else is a dotted ilist. This includes non-ipair, non-() values (e.g. symbols, numbers, mutable pairs), which are considered to be dotted ilists of length 0.</p>
<h2 id="dotted-ilist-x"><code>(dotted-ilist? x)</code></h2>
<p>True if x is a finite, non-nil-terminated ilist. That is, there exists an n &gt;= 0 such that icdrn(x) is neither an ipair nor (). This includes non-ipair, non-() values (e.g. symbols, numbers), which are considered to be dotted ilists of length 0.</p>
<div class="sourceCode" id="cb510"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb510-1"><a href="#cb510-1" aria-hidden="true"></a>(dotted-ilist? x) <span class="op">=</span> (<span class="kw">not</span> (proper-ilist? x))</span></code></pre></div>
<h2 id="ipair-object"><code>(ipair? object)</code></h2>
<p>Returns #t if object is an ipair; otherwise, #f.</p>
<div class="sourceCode" id="cb511"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb511-1"><a href="#cb511-1" aria-hidden="true"></a>(ipair? (ipair &#39;a &#39;b)) <span class="op">=&gt;</span>  <span class="dv">#t</span></span>
<span id="cb511-2"><a href="#cb511-2" aria-hidden="true"></a>(ipair? (iq a b c)) <span class="op">=&gt;</span>  <span class="dv">#t</span></span>
<span id="cb511-3"><a href="#cb511-3" aria-hidden="true"></a>(ipair? (<span class="kw">cons</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb511-4"><a href="#cb511-4" aria-hidden="true"></a>(ipair? &#39;())        <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb511-5"><a href="#cb511-5" aria-hidden="true"></a>(ipair? &#39;#(a b))    <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb511-6"><a href="#cb511-6" aria-hidden="true"></a>(ipair? <span class="dv">7</span>)          <span class="op">=&gt;</span>  <span class="dv">#f</span></span>
<span id="cb511-7"><a href="#cb511-7" aria-hidden="true"></a>(ipair? &#39;a)         <span class="op">=&gt;</span>  <span class="dv">#f</span></span></code></pre></div>
<h2 id="null-ilist-ilist">`(null-ilist? ilist)</h2>
<p>Ilist is a proper ilist. This procedure returns true if the argument is the empty list (), and false otherwise. It is an error to pass this procedure a value which is not a proper ilist. This procedure is recommended as the termination condition for ilist-processing procedures that are not defined on dotted ilists.</p>
<h2 id="not-ipair-x"><code>(not-ipair? x)</code></h2>
<div class="sourceCode" id="cb512"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb512-1"><a href="#cb512-1" aria-hidden="true"></a>(<span class="kw">lambda</span> (x) (<span class="kw">not</span> (ipair? x)))</span></code></pre></div>
<p>Provided as a procedure as it can be useful as the termination condition for ilist-processing procedures that wish to handle all ilists, both proper and dotted.</p>
<h2 id="ilist-elt-ilist1-..."><code>(ilist= elt= ilist1 ...)</code></h2>
<p>Determines ilist equality, given an element-equality procedure. Proper ilist A equals proper ilist B if they are of the same length, and their corresponding elements are equal, as determined by elt=. If the element-comparison procedure’s first argument is from ilisti, then its second argument is from ilisti+1, i.e. it is always called as (elt= a b) for a an element of ilist A, and b an element of ilist B.</p>
<p>In the n-ary case, every ilisti is compared to ilisti+1 (as opposed, for example, to comparing ilist1 to ilisti, for i&gt;1). If there are no ilist arguments at all, ilist= simply returns true.</p>
<p>It is an error to apply ilist= to anything except proper ilists. It cannot reasonably be extended to dotted ilists, as it provides no way to specify an equality procedure for comparing the ilist terminators.</p>
<p>Note that the dynamic order in which the elt= procedure is applied to pairs of elements is not specified. For example, if ilist= is applied to three ilists, A, B, and C, it may first completely compare A to B, then compare B to C, or it may compare the first elements of A and B, then the first elements of B and C, then the second elements of A and B, and so forth.</p>
<p>The equality procedure must be consistent with eq?. That is, it must be the case that:</p>
<div class="sourceCode" id="cb513"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb513-1"><a href="#cb513-1" aria-hidden="true"></a>(<span class="kw">eq?</span> x y) <span class="op">=&gt;</span> (elt= x y).</span></code></pre></div>
<p>Note that this implies that two ilists which are eq? are always ilist=, as well; implementations may exploit this fact to “short-cut” the element-by-element comparisons.</p>
<div class="sourceCode" id="cb514"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb514-1"><a href="#cb514-1" aria-hidden="true"></a>(ilist= <span class="kw">eq?</span>) <span class="op">=&gt;</span> <span class="dv">#t</span>       <span class="co">; Trivial cases</span></span>
<span id="cb514-2"><a href="#cb514-2" aria-hidden="true"></a>(ilist= <span class="kw">eq?</span> (iq a)) <span class="op">=&gt;</span> <span class="dv">#t</span></span></code></pre></div>
<h2 id="icar-ipair"><code>(icar ipair)</code></h2>
<h2 id="icdr-ipair"><code>(icdr ipair)</code></h2>
<p>These procedures return the contents of the icar and icdr field of their argument, respectively. Note that it is an error to apply them to the empty ilist.</p>
<div class="sourceCode" id="cb515"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb515-1"><a href="#cb515-1" aria-hidden="true"></a>(icar (iq a b c))       <span class="op">=&gt;</span>  a        (icdr (iq a b c))     <span class="op">=&gt;</span>  (b c)</span>
<span id="cb515-2"><a href="#cb515-2" aria-hidden="true"></a>(icar (iq (a) b c d))   <span class="op">=&gt;</span>  (a)      (icdr (iq (a) b c d)) <span class="op">=&gt;</span>  (b c d)</span>
<span id="cb515-3"><a href="#cb515-3" aria-hidden="true"></a>(icar (ipair <span class="dv">1</span> <span class="dv">2</span>))      <span class="op">=&gt;</span>  <span class="dv">1</span>        (icdr (ipair <span class="dv">1</span> <span class="dv">2</span>))    <span class="op">=&gt;</span>  <span class="dv">2</span></span>
<span id="cb515-4"><a href="#cb515-4" aria-hidden="true"></a>(icar &#39;())              <span class="op">=&gt;</span>  *error*  (icdr &#39;())            <span class="op">=&gt;</span>  *error*</span></code></pre></div>
<h2 id="icaar-ipair"><code>(icaar ipair)</code></h2>
<h2 id="icadr-ipair"><code>(icadr ipair)</code></h2>
<p>…</p>
<h2 id="icdddar-ipair"><code>(icdddar ipair)</code></h2>
<h2 id="icddddr-ipair">`(icddddr ipair)</h2>
<p>These procedures are compositions of icar and icdr, where for example icaddr could be defined by</p>
<div class="sourceCode" id="cb516"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb516-1"><a href="#cb516-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> icaddr </span>(<span class="kw">lambda</span> (x) (icar (icdr (icdr x)))))</span></code></pre></div>
<p>Arbitrary compositions, up to four deep, are provided. There are twenty-eight of these procedures in all.</p>
<h2 id="ilist-ref-ilist-i"><code>(ilist-ref ilist i)</code></h2>
<p>Returns the ith element of ilist. (This is the same as the icar of (idrop ilist i).) It is an error if i &gt;= n, where n is the length of ilist.</p>
<div class="sourceCode" id="cb517"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb517-1"><a href="#cb517-1" aria-hidden="true"></a>(ilist-ref (iq a b c d) <span class="dv">2</span>) <span class="op">=&gt;</span> c</span></code></pre></div>
<h2 id="ifirst-ipair"><code>(ifirst ipair)</code></h2>
<h2 id="isecond-ipair"><code>(isecond ipair)</code></h2>
<h2 id="ithird-ipair"><code>(ithird ipair)</code></h2>
<h2 id="ifourth-ipair"><code>(ifourth ipair)</code></h2>
<h2 id="ififth-ipair"><code>(ififth ipair)</code></h2>
<h2 id="isixth-ipair"><code>(isixth ipair)</code></h2>
<h2 id="iseventh-ipair"><code>(iseventh ipair)</code></h2>
<h2 id="ieighth-ipair"><code>(ieighth ipair)</code></h2>
<h2 id="ininth-ipair"><code>(ininth ipair)</code></h2>
<h2 id="itenth-ipair"><code>(itenth ipair)</code></h2>
<p>Synonyms for car, cadr, caddr, …</p>
<div class="sourceCode" id="cb518"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb518-1"><a href="#cb518-1" aria-hidden="true"></a>(ithird &#39;(a b c d e)) <span class="op">=&gt;</span> c</span></code></pre></div>
<h2 id="icaricdr-ipair"><code>(icar+icdr ipair)</code></h2>
<p>The fundamental ipair deconstructor:</p>
<div class="sourceCode" id="cb519"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb519-1"><a href="#cb519-1" aria-hidden="true"></a>(<span class="kw">lambda</span> (p) (<span class="kw">values</span> (icar p) (icdr p)))</span></code></pre></div>
<p>This can, of course, be implemented more efficiently by a compiler.</p>
<h2 id="itake-x-i"><code>(itake x i)</code></h2>
<h2 id="idrop-x-i"><code>(idrop x i)</code></h2>
<h2 id="ilist-tail-x-i"><code>(ilist-tail x i)</code></h2>
<p><code>itake</code> returns the first i elements of ilist x.</p>
<p><code>idrop</code> returns all but the first i elements of ilist x.</p>
<p><code>ilist-tail</code> is either the same procedure as idrop or else a procedure with the same behavior.</p>
<p>``scheme (itake (iq a b c d e) 2) =&gt; (a b) (idrop (iq a b c d e) 2) =&gt; (c d e)</p>
<pre><code>
x may be any value — a proper or dotted ilist:

```scheme
(itake (ipair 1 (ipair 2 (ipair 3 &#39;d)))    =&gt; (1 2)
(idrop (ipair 1 (ipair 2 (ipair 3 &#39;d))) 2) =&gt; (3 . d)
(itake (ipair 1 (ipair 2 (ipair 3 &#39;d))) 3) =&gt; (1 2 3)
(idrop (ipair 1 (ipair 2 (ipair 3 &#39;d))) 3) =&gt; d</code></pre>
<p>For a legal i, itake and idrop partition the ilist in a manner which can be inverted with iappend:</p>
<div class="sourceCode" id="cb521"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb521-1"><a href="#cb521-1" aria-hidden="true"></a>(iappend (itake x i) (idrop x i)) <span class="op">=</span> x</span></code></pre></div>
<p>idrop is exactly equivalent to performing i icdr operations on x; the returned value shares a common tail with x.</p>
<h2 id="itake-right-dilist-i"><code>(itake-right dilist i)</code></h2>
<h2 id="idrop-right-dilist-i"><code>(idrop-right dilist i)</code></h2>
<p>itake-right returns the last i elements of dilist. idrop-right returns all but the last i elements of dilist.</p>
<div class="sourceCode" id="cb522"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb522-1"><a href="#cb522-1" aria-hidden="true"></a>(itake-right (iq a b c d e) <span class="dv">2</span>) <span class="op">=&gt;</span> (d e)</span>
<span id="cb522-2"><a href="#cb522-2" aria-hidden="true"></a>(idrop-right (iq a b c d e) <span class="dv">2</span>) <span class="op">=&gt;</span> (a b c)</span></code></pre></div>
<p>The returned ilist may share a common tail with the argument ilist.</p>
<p>dilist may be any ilist, either proper or dotted:</p>
<div class="sourceCode" id="cb523"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb523-1"><a href="#cb523-1" aria-hidden="true"></a>(itake-right (iq ipair <span class="dv">1</span> (ipair <span class="dv">2</span> (ipair <span class="dv">3</span> &#39;d))) <span class="dv">2</span>) <span class="op">=&gt;</span> (<span class="dv">2</span> <span class="dv">3</span> . d)</span>
<span id="cb523-2"><a href="#cb523-2" aria-hidden="true"></a>(idrop-right (ipair <span class="dv">1</span> (ipair <span class="dv">2</span> (ipair <span class="dv">3</span> &#39;d))) <span class="dv">2</span>)    <span class="op">=&gt;</span> (<span class="dv">1</span>)</span>
<span id="cb523-3"><a href="#cb523-3" aria-hidden="true"></a>(itake-right (ipair <span class="dv">1</span> (ipair <span class="dv">2</span> (ipair <span class="dv">3</span> &#39;d))) <span class="dv">0</span>)    <span class="op">=&gt;</span> d</span>
<span id="cb523-4"><a href="#cb523-4" aria-hidden="true"></a>(idrop-right (ipair <span class="dv">1</span> (ipair <span class="dv">2</span> (ipair <span class="dv">3</span> &#39;d))) <span class="dv">0</span>)    <span class="op">=&gt;</span> (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</span></code></pre></div>
<p>For a legal i, itake-right and idrop-right partition the ilist in a manner which can be inverted with iappend:</p>
<div class="sourceCode" id="cb524"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb524-1"><a href="#cb524-1" aria-hidden="true"></a>(iappend (itake dilist i) (idrop dilist i)) <span class="op">=</span> dilist</span></code></pre></div>
<p>itake-right’s return value is guaranteed to share a common tail with dilist.</p>
<h2 id="isplit-at-x-i"><code>(isplit-at  x i)</code></h2>
<p>isplit-at splits the ilist x at index i, returning an ilist of the first i elements, and the remaining tail. It is equivalent to</p>
<div class="sourceCode" id="cb525"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb525-1"><a href="#cb525-1" aria-hidden="true"></a>(<span class="kw">values</span> (itake x i) (idrop x i))</span></code></pre></div>
<h2 id="ilast-ipair"><code>(ilast ipair)</code></h2>
<h2 id="last-ipair-ipair"><code>(last-ipair ipair)</code></h2>
<p>Returns the last element of the non-empty, possibly dotted, ilist ipair. last-ipair returns the last ipair in the non-empty ilist pair.</p>
<div class="sourceCode" id="cb526"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb526-1"><a href="#cb526-1" aria-hidden="true"></a>(ilast (iq a b c))      <span class="op">=&gt;</span> c</span>
<span id="cb526-2"><a href="#cb526-2" aria-hidden="true"></a>(last-ipair (iq a b c)) <span class="op">=&gt;</span> (c)</span></code></pre></div>
<h2 id="ilength-ilist"><code>(ilength  ilist)</code></h2>
<p>Returns the length of its argument. It is an error to pass a value to ilength which is not a proper ilist (()-terminated).</p>
<p>The length of a proper ilist is a non-negative integer n such that icdr applied n times to the ilist produces the empty list.</p>
<h2 id="iappend-ilist1-..."><code>(iappend  ilist1 ...)</code></h2>
<p>Returns an ilist consisting of the elements of ilist1 followed by the elements of the other ilist parameters.</p>
<div class="sourceCode" id="cb527"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb527-1"><a href="#cb527-1" aria-hidden="true"></a>(iappend (iq x) (iq y))        <span class="op">=&gt;</span>  (x y)</span>
<span id="cb527-2"><a href="#cb527-2" aria-hidden="true"></a>(iappend (iq a) (iq b c d))    <span class="op">=&gt;</span>  (a b c d)</span>
<span id="cb527-3"><a href="#cb527-3" aria-hidden="true"></a>(iappend (iq a (b)) (iq (c)))  <span class="op">=&gt;</span>  (a (b) (c))</span></code></pre></div>
<p>The resulting ilist is always newly allocated, except that it shares structure with the final ilisti argument. This last argument may be any value at all; an improper ilist results if it is not a proper ilist. All other arguments must be proper ilists.</p>
<div class="sourceCode" id="cb528"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb528-1"><a href="#cb528-1" aria-hidden="true"></a>(iappend (iq a b) (ipair &#39;c &#39;d))  <span class="op">=&gt;</span>  (a b c . d)</span>
<span id="cb528-2"><a href="#cb528-2" aria-hidden="true"></a>(iappend &#39;() &#39;a)           <span class="op">=&gt;</span>  a</span>
<span id="cb528-3"><a href="#cb528-3" aria-hidden="true"></a>(iappend (iq x y))         <span class="op">=&gt;</span>  (x y)</span>
<span id="cb528-4"><a href="#cb528-4" aria-hidden="true"></a>(iappend)                  <span class="op">=&gt;</span>  ()</span></code></pre></div>
<h2 id="iconcatenate-ilist-of-ilists"><code>(iconcatenate  ilist-of-ilists)</code></h2>
<p>Appends the elements of its argument together. That is, iconcatenate returns</p>
<div class="sourceCode" id="cb529"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb529-1"><a href="#cb529-1" aria-hidden="true"></a>(iapply iappend ilist-of-ilists)</span></code></pre></div>
<p>or, equivalently,</p>
<div class="sourceCode" id="cb530"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb530-1"><a href="#cb530-1" aria-hidden="true"></a>(ireduce-right iappend &#39;() ilist-of-ilists)</span></code></pre></div>
<p>Note that some Scheme implementations do not support passing more than a certain number (e.g., 64) of arguments to an n-ary procedure. In these implementations, the (iapply iappend …) idiom would fail when applied to long lists, but iconcatenate would continue to function properly.</p>
<p>As with iappend, the last element of the input list may be any value at all.</p>
<h2 id="ireverse-ilist"><code>(ireverse  ilist)</code></h2>
<p>Returns a newly allocated ilist consisting of the elements of ilist in reverse order.</p>
<div class="sourceCode" id="cb531"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb531-1"><a href="#cb531-1" aria-hidden="true"></a>(ireverse (iq a b c)) <span class="op">=&gt;</span>  (c b a)</span>
<span id="cb531-2"><a href="#cb531-2" aria-hidden="true"></a>(ireverse (iq a (b c) d (e (f))))</span>
<span id="cb531-3"><a href="#cb531-3" aria-hidden="true"></a>        <span class="op">=&gt;</span>  ((e (f)) d (b c) a)</span></code></pre></div>
<h2 id="iappend-reverse-rev-head-tail"><code>(iappend-reverse  rev-head tail)</code></h2>
<p>iappend-reverse returns (iappend (ireverse rev-head) tail). It is provided because it is a common operation — a common list-processing style calls for this exact operation to transfer values accumulated in reverse order onto the front of another ilist, and because the implementation is significantly more efficient than the simple composition it replaces. (But note that this pattern of iterative computation followed by a reverse can frequently be rewritten as a recursion, dispensing with the reverse and iappend-reverse steps, and shifting temporary, intermediate storage from the heap to the stack, which is typically a win for reasons of cache locality and eager storage reclamation.)</p>
<h2 id="izip-ilist1-ilist2-..."><code>(izip ilist1 ilist2 ...)</code></h2>
<div class="sourceCode" id="cb532"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb532-1"><a href="#cb532-1" aria-hidden="true"></a>(<span class="kw">lambda</span> ilists (iapply imap ilist ilists))</span></code></pre></div>
<p>If izip is passed n ilists, it returns an ilist as long as the shortest of these ilists, each element of which is an n-element ilist comprised of the corresponding elements from the parameter ilists.</p>
<div class="sourceCode" id="cb533"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb533-1"><a href="#cb533-1" aria-hidden="true"></a>(izip (iq one two three)</span>
<span id="cb533-2"><a href="#cb533-2" aria-hidden="true"></a>  (iq <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</span>
<span id="cb533-3"><a href="#cb533-3" aria-hidden="true"></a>  (iq odd even odd even odd even odd even))</span>
<span id="cb533-4"><a href="#cb533-4" aria-hidden="true"></a>   <span class="co">;; =&gt; ((one 1 odd) (two 2 even) (three 3 odd))</span></span>
<span id="cb533-5"><a href="#cb533-5" aria-hidden="true"></a></span>
<span id="cb533-6"><a href="#cb533-6" aria-hidden="true"></a>(izip (iq <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)) <span class="op">=&gt;</span> ((<span class="dv">1</span>) (<span class="dv">2</span>) (<span class="dv">3</span>))</span></code></pre></div>
<h2 id="iunzip1-ilist"><code>(iunzip1 ilist)</code></h2>
<h2 id="iunzip2-ilist"><code>(iunzip2 ilist)</code></h2>
<h2 id="iunzip3-ilist"><code>(iunzip3 ilist)</code></h2>
<h2 id="iunzip4-ilist"><code>(iunzip4 ilist)</code></h2>
<h2 id="iunzip5-ilist"><code>(iunzip5 ilist)</code></h2>
<p>iunzip1 takes an ilist of ilists, where every ilist must contain at least one element, and returns an ilist containing the initial element of each such ilist. That is, it returns (imap icar ilists). iunzip2 takes an ilist of ilists, where every ilist must contain at least two elements, and returns two values: an ilist of the first elements, and an ilist of the second elements. iunzip3 does the same for the first three elements of the ilists, and so forth.</p>
<div class="sourceCode" id="cb534"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb534-1"><a href="#cb534-1" aria-hidden="true"></a>(iunzip2 (iq (<span class="dv">1</span> one) (<span class="dv">2</span> two) (<span class="dv">3</span> three))) <span class="op">=&gt;</span></span>
<span id="cb534-2"><a href="#cb534-2" aria-hidden="true"></a>  (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</span>
<span id="cb534-3"><a href="#cb534-3" aria-hidden="true"></a>  (one two three)</span></code></pre></div>
<h2 id="icount-pred-ilist1-ilist2-..."><code>(icount pred ilist1 ilist2 ...)</code></h2>
<p>pred is a procedure taking as many arguments as there are ilists and returning a single value. It is applied element-wise to the elements of the ilists, and a count is tallied of the number of elements that produce a true value. This count is returned. count is “iterative” in that it is guaranteed to apply pred to the ilist elements in a left-to-right order. The counting stops when the shortest ilist expires.</p>
<div class="sourceCode" id="cb535"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb535-1"><a href="#cb535-1" aria-hidden="true"></a>(count <span class="kw">even?</span> (iq <span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>)) <span class="op">=&gt;</span> <span class="dv">3</span></span>
<span id="cb535-2"><a href="#cb535-2" aria-hidden="true"></a>(count <span class="op">&lt;</span> (iq <span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span> <span class="dv">8</span>) (iq <span class="dv">2</span> <span class="dv">4</span> <span class="dv">6</span> <span class="dv">8</span> <span class="dv">10</span> <span class="dv">12</span> <span class="dv">14</span> <span class="dv">16</span>)) <span class="op">=&gt;</span> <span class="dv">3</span></span></code></pre></div>
<h2 id="ifold-kons-knil-ilist1-ilist2-..."><code>(ifold kons knil ilist1 ilist2 ...)</code></h2>
<p>The fundamental ilist iterator.</p>
<p>First, consider the single ilist-parameter case. If ilist1 = (e1 e2 … en), then this procedure returns</p>
<div class="sourceCode" id="cb536"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb536-1"><a href="#cb536-1" aria-hidden="true"></a>(kons en ... (kons e2 (kons e1 knil)) ... )</span></code></pre></div>
<p>That is, it obeys the (tail) recursion</p>
<div class="sourceCode" id="cb537"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb537-1"><a href="#cb537-1" aria-hidden="true"></a>(ifold kons knil lis) <span class="op">=</span> (ifold kons (kons (icar lis) knil) (icdr lis))</span>
<span id="cb537-2"><a href="#cb537-2" aria-hidden="true"></a>(ifold kons knil &#39;()) <span class="op">=</span> knil</span></code></pre></div>
<p>Examples:</p>
<div class="sourceCode" id="cb538"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb538-1"><a href="#cb538-1" aria-hidden="true"></a>(ifold <span class="op">+</span> <span class="dv">0</span> lis)         <span class="co">; Add up the elements of LIS.</span></span>
<span id="cb538-2"><a href="#cb538-2" aria-hidden="true"></a></span>
<span id="cb538-3"><a href="#cb538-3" aria-hidden="true"></a>(ifold ipair &#39;() lis)       <span class="co">; Reverse LIS.</span></span>
<span id="cb538-4"><a href="#cb538-4" aria-hidden="true"></a></span>
<span id="cb538-5"><a href="#cb538-5" aria-hidden="true"></a>(ifold ipair tail rev-head) <span class="co">; See APPEND-REVERSE.</span></span>
<span id="cb538-6"><a href="#cb538-6" aria-hidden="true"></a></span>
<span id="cb538-7"><a href="#cb538-7" aria-hidden="true"></a><span class="co">;; How many symbols in LIS?</span></span>
<span id="cb538-8"><a href="#cb538-8" aria-hidden="true"></a>(ifold (<span class="kw">lambda</span> (x count) (<span class="kw">if</span> (<span class="kw">symbol?</span> x) (<span class="op">+</span> count <span class="dv">1</span>) count))</span>
<span id="cb538-9"><a href="#cb538-9" aria-hidden="true"></a>       <span class="dv">0</span></span>
<span id="cb538-10"><a href="#cb538-10" aria-hidden="true"></a>       lis)</span>
<span id="cb538-11"><a href="#cb538-11" aria-hidden="true"></a></span>
<span id="cb538-12"><a href="#cb538-12" aria-hidden="true"></a><span class="co">;; Length of the longest string in LIS:</span></span>
<span id="cb538-13"><a href="#cb538-13" aria-hidden="true"></a>(ifold (<span class="kw">lambda</span> (s max-len) (<span class="kw">max</span> max-len (<span class="kw">string-length</span> s)))</span>
<span id="cb538-14"><a href="#cb538-14" aria-hidden="true"></a>       <span class="dv">0</span></span>
<span id="cb538-15"><a href="#cb538-15" aria-hidden="true"></a>       lis)</span></code></pre></div>
<p>If n ilist arguments are provided, then the kons function must take n+1 parameters: one element from each ilist, and the “seed” or fold state, which is initially knil. The fold operation terminates when the shortest ilist runs out of values:</p>
<div class="sourceCode" id="cb539"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb539-1"><a href="#cb539-1" aria-hidden="true"></a>(ifold ipair* &#39;() (iq a b c) (iq <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)) <span class="op">=&gt;</span> (c <span class="dv">3</span> b <span class="dv">2</span> a <span class="dv">1</span>)</span></code></pre></div>
<h2 id="ifold-right-kons-knil-ilist1-ilist2-..."><code>(ifold-right kons knil ilist1 ilist2 ...)</code></h2>
<p>The fundamental ilist recursion operator.</p>
<p>First, consider the single ilist-parameter case. If ilist1 = (e1 e2 … en), then this procedure returns</p>
<div class="sourceCode" id="cb540"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb540-1"><a href="#cb540-1" aria-hidden="true"></a>(kons e1 (kons e2 ... (kons en knil)))</span></code></pre></div>
<p>That is, it obeys the recursion</p>
<div class="sourceCode" id="cb541"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb541-1"><a href="#cb541-1" aria-hidden="true"></a>(ifold-right kons knil lis) <span class="op">=</span> (kons (icar lis) (ifold-right kons knil (icdr lis)))</span>
<span id="cb541-2"><a href="#cb541-2" aria-hidden="true"></a>(ifold-right kons knil &#39;()) <span class="op">=</span> knil</span></code></pre></div>
<p>Examples:</p>
<div class="sourceCode" id="cb542"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb542-1"><a href="#cb542-1" aria-hidden="true"></a>(ifold-right ipair &#39;() lis)     <span class="co">; Copy LIS.</span></span>
<span id="cb542-2"><a href="#cb542-2" aria-hidden="true"></a></span>
<span id="cb542-3"><a href="#cb542-3" aria-hidden="true"></a><span class="co">;; Filter the even numbers out of LIS.</span></span>
<span id="cb542-4"><a href="#cb542-4" aria-hidden="true"></a>(ifold-right (<span class="kw">lambda</span> (x l) (<span class="kw">if</span> (<span class="kw">even?</span> x) (ipair x l) l)) &#39;() lis))</span></code></pre></div>
<p>If n ilist arguments are provided, then the kons procedure must take n+1 parameters: one element from each ilist, and the “seed” or fold state, which is initially knil. The fold operation terminates when the shortest ilist runs out of values:</p>
<div class="sourceCode" id="cb543"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb543-1"><a href="#cb543-1" aria-hidden="true"></a>(ifold-right ipair* &#39;() (iq a b c) (iq <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)) <span class="op">=&gt;</span> (a <span class="dv">1</span> b <span class="dv">2</span> c <span class="dv">3</span>)</span></code></pre></div>
<h2 id="ipair-fold-kons-knil-ilist1-ilist2-..."><code>(ipair-fold kons knil ilist1 ilist2 ...)</code></h2>
<p>Analogous to fold, but kons is applied to successive sub-ilists of the ilists, rather than successive elements — that is, kons is applied to the ipairs making up the lists, giving this (tail) recursion:</p>
<div class="sourceCode" id="cb544"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb544-1"><a href="#cb544-1" aria-hidden="true"></a>(ipair-fold kons knil lis) <span class="op">=</span> (<span class="kw">let</span> ((tail (icdr lis)))</span>
<span id="cb544-2"><a href="#cb544-2" aria-hidden="true"></a>                               (ipair-fold kons (kons lis knil) tail))</span>
<span id="cb544-3"><a href="#cb544-3" aria-hidden="true"></a>(ipair-fold kons knil &#39;()) <span class="op">=</span> knil</span></code></pre></div>
<p>Example:</p>
<div class="sourceCode" id="cb545"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb545-1"><a href="#cb545-1" aria-hidden="true"></a>(ipair-fold ipair &#39;() (iq a b c)) <span class="op">=&gt;</span> ((c) (b c) (a b c))</span></code></pre></div>
<h2 id="ipair-fold-right-kons-knil-ilist1-ilist2-..."><code>(ipair-fold-right kons knil ilist1 ilist2 ...)</code></h2>
<p>Holds the same relationship with ifold-right that ipair-fold holds with ifold. Obeys the recursion</p>
<div class="sourceCode" id="cb546"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb546-1"><a href="#cb546-1" aria-hidden="true"></a>    (ipair-fold-right kons knil lis) <span class="op">=</span></span>
<span id="cb546-2"><a href="#cb546-2" aria-hidden="true"></a>        (kons lis (ipair-fold-right kons knil (icdr lis)))</span>
<span id="cb546-3"><a href="#cb546-3" aria-hidden="true"></a>    (ipair-fold-right kons knil &#39;()) <span class="op">=</span> knil</span></code></pre></div>
<p>Example:</p>
<div class="sourceCode" id="cb547"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb547-1"><a href="#cb547-1" aria-hidden="true"></a>(ipair-fold-right ipair &#39;() (iq a b c)) <span class="op">=&gt;</span> ((a b c) (b c) (c))</span></code></pre></div>
<h2 id="ireduce-f-ridentity-ilist"><code>(ireduce f ridentity ilist)</code></h2>
<p>ireduce is a variant of ifold.</p>
<p>ridentity should be a “right identity” of the procedure f — that is, for any value x acceptable to f,</p>
<div class="sourceCode" id="cb548"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb548-1"><a href="#cb548-1" aria-hidden="true"></a>(f x ridentity) <span class="op">=</span> x</span></code></pre></div>
<p>ireduce has the following definition:</p>
<p>If ilist = (), return ridentity;</p>
<p>Otherwise, return (ifold f (icar ilist) (icdr ilist)).</p>
<p>…in other words, we compute (ifold f ridentity ilist).</p>
<p>Note that ridentity is used only in the empty-list case. You typically use ireduce when applying f is expensive and you’d like to avoid the extra application incurred when ifold applies f to the head of ilist and the identity value, redundantly producing the same value passed in to f. For example, if f involves searching a file directory or performing a database query, this can be significant. In general, however, ifold is useful in many contexts where ireduce is not (consider the examples given in the ifold definition — only one of the five folds uses a function with a right identity. The other four may not be performed with ireduce).</p>
<div class="sourceCode" id="cb549"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb549-1"><a href="#cb549-1" aria-hidden="true"></a><span class="co">;; take the max of an ilist of non-negative integers.</span></span>
<span id="cb549-2"><a href="#cb549-2" aria-hidden="true"></a>(ireduce <span class="kw">max</span> <span class="dv">0</span> nums) <span class="co">; i.e., (iapply max 0 nums)</span></span></code></pre></div>
<h2 id="ireduce-right-f-ridentity-ilist"><code>(ireduce-right f ridentity ilist)</code></h2>
<p>ireduce-right is the fold-right variant of ireduce. It obeys the following definition:</p>
<div class="sourceCode" id="cb550"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb550-1"><a href="#cb550-1" aria-hidden="true"></a>(ireduce-right f ridentity &#39;()) <span class="op">=</span> ridentity</span>
<span id="cb550-2"><a href="#cb550-2" aria-hidden="true"></a>(ireduce-right f ridentity (iq e1)) <span class="op">=</span> (f e1 ridentity) <span class="op">=</span> e1</span>
<span id="cb550-3"><a href="#cb550-3" aria-hidden="true"></a>(ireduce-right f ridentity (iq e1 e2 ...)) <span class="op">=</span></span>
<span id="cb550-4"><a href="#cb550-4" aria-hidden="true"></a>  (f e1 (ireduce f ridentity (e2 ...)))</span></code></pre></div>
<p>…in other words, we compute (ifold-right f ridentity ilist).</p>
<div class="sourceCode" id="cb551"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb551-1"><a href="#cb551-1" aria-hidden="true"></a><span class="co">;; Append a bunch of ilists together.</span></span>
<span id="cb551-2"><a href="#cb551-2" aria-hidden="true"></a><span class="co">;; I.e., (iapply iappend ilist-of-ilists)</span></span>
<span id="cb551-3"><a href="#cb551-3" aria-hidden="true"></a>(ireduce-right iappend &#39;() ilist-of-ilists)</span></code></pre></div>
<h2 id="iunfold-p-f-g-seed-tail-gen"><code>(iunfold p f g seed [tail-gen])</code></h2>
<p>iunfold is best described by its basic recursion:</p>
<div class="sourceCode" id="cb552"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb552-1"><a href="#cb552-1" aria-hidden="true"></a>    (iunfold p f g seed) <span class="op">=</span></span>
<span id="cb552-2"><a href="#cb552-2" aria-hidden="true"></a>        (<span class="kw">if</span> (p seed) (tail-gen seed)</span>
<span id="cb552-3"><a href="#cb552-3" aria-hidden="true"></a>            (ipair (f seed)</span>
<span id="cb552-4"><a href="#cb552-4" aria-hidden="true"></a>                  (iunfold p f g (g seed))))</span></code></pre></div>
<ul>
<li>p, Determines when to stop unfolding.</li>
<li>f, Maps each seed value to the corresponding ilist element.</li>
<li>g, Maps each seed value to next seed value.</li>
<li>seed, The “state” value for the unfold.</li>
<li>tail-gen, Creates the tail of the ilist; defaults to (lambda (x) ’())</li>
</ul>
<p>In other words, we use g to generate a sequence of seed values</p>
<div class="sourceCode" id="cb553"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb553-1"><a href="#cb553-1" aria-hidden="true"></a>seed, g(seed), g2(seed), g3(seed), ...</span></code></pre></div>
<p>These seed values are mapped to ilist elements by f, producing the elements of the result ilist in a left-to-right order. P says when to stop.</p>
<p>iunfold is the fundamental recursive ilist constructor, just as ifold-right is the fundamental recursive ilist consumer. While iunfold may seem a bit abstract to novice functional programmers, it can be used in a number of ways:</p>
<div class="sourceCode" id="cb554"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb554-1"><a href="#cb554-1" aria-hidden="true"></a>    <span class="co">;; Ilist of squares: 1^2 ... 10^2</span></span>
<span id="cb554-2"><a href="#cb554-2" aria-hidden="true"></a>    (iunfold (<span class="kw">lambda</span> (x) (<span class="op">&gt;</span> x <span class="dv">10</span>))</span>
<span id="cb554-3"><a href="#cb554-3" aria-hidden="true"></a>            (<span class="kw">lambda</span> (x) (* x x))</span>
<span id="cb554-4"><a href="#cb554-4" aria-hidden="true"></a>        (<span class="kw">lambda</span> (x) (<span class="op">+</span> x <span class="dv">1</span>))</span>
<span id="cb554-5"><a href="#cb554-5" aria-hidden="true"></a>        <span class="dv">1</span>)</span>
<span id="cb554-6"><a href="#cb554-6" aria-hidden="true"></a></span>
<span id="cb554-7"><a href="#cb554-7" aria-hidden="true"></a>    (iunfold null-ilist? icar icdr lis) <span class="co">; Copy a proper ilist.</span></span>
<span id="cb554-8"><a href="#cb554-8" aria-hidden="true"></a></span>
<span id="cb554-9"><a href="#cb554-9" aria-hidden="true"></a>    <span class="co">;; Read current input port into an ilist of values.</span></span>
<span id="cb554-10"><a href="#cb554-10" aria-hidden="true"></a>    (iunfold <span class="kw">eof-object?</span> <span class="kw">values</span> (<span class="kw">lambda</span> (x) (<span class="kw">read</span>)) (<span class="kw">read</span>))</span>
<span id="cb554-11"><a href="#cb554-11" aria-hidden="true"></a></span>
<span id="cb554-12"><a href="#cb554-12" aria-hidden="true"></a>    <span class="co">;; Copy a possibly non-proper ilist:</span></span>
<span id="cb554-13"><a href="#cb554-13" aria-hidden="true"></a>    (iunfold not-ipair? icar icdr lis</span>
<span id="cb554-14"><a href="#cb554-14" aria-hidden="true"></a>                  <span class="kw">values</span>)</span>
<span id="cb554-15"><a href="#cb554-15" aria-hidden="true"></a></span>
<span id="cb554-16"><a href="#cb554-16" aria-hidden="true"></a>    <span class="co">;; Append HEAD onto TAIL:</span></span>
<span id="cb554-17"><a href="#cb554-17" aria-hidden="true"></a>    (iunfold null-ilist? icar icdr head</span>
<span id="cb554-18"><a href="#cb554-18" aria-hidden="true"></a>                  (<span class="kw">lambda</span> (x) tail))</span></code></pre></div>
<p>Interested functional programmers may enjoy noting that ifold-right and iunfold are in some sense inverses. That is, given operations knull?, kar, kdr, kons, and knil satisfying</p>
<div class="sourceCode" id="cb555"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb555-1"><a href="#cb555-1" aria-hidden="true"></a>(kons (kar x) (kdr x)) <span class="op">=</span> x <span class="kw">and</span> (knull? knil) <span class="op">=</span> <span class="dv">#t</span></span></code></pre></div>
<p>then</p>
<div class="sourceCode" id="cb556"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb556-1"><a href="#cb556-1" aria-hidden="true"></a>(ifold-right kons knil (iunfold knull? kar kdr x)) <span class="op">=</span> x</span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb557"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb557-1"><a href="#cb557-1" aria-hidden="true"></a>(iunfold knull? kar kdr (ifold-right kons knil x)) <span class="op">=</span> x</span></code></pre></div>
<p>This combinator sometimes is called an “anamorphism;” when an explicit tail-gen procedure is supplied, it is called an “apomorphism.”</p>
<h2 id="iunfold-right-p-f-g-seed-tail"><code>(iunfold-right p f g seed [tail])</code></h2>
<p>iunfold-right constructs an ilist with the following loop:</p>
<div class="sourceCode" id="cb558"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb558-1"><a href="#cb558-1" aria-hidden="true"></a>    (<span class="kw">let</span> lp ((seed seed) (lis tail))</span>
<span id="cb558-2"><a href="#cb558-2" aria-hidden="true"></a>      (<span class="kw">if</span> (p seed) lis</span>
<span id="cb558-3"><a href="#cb558-3" aria-hidden="true"></a>          (lp (g seed)</span>
<span id="cb558-4"><a href="#cb558-4" aria-hidden="true"></a>              (ipair (f seed) lis))))</span>
<span id="cb558-5"><a href="#cb558-5" aria-hidden="true"></a></span>
<span id="cb558-6"><a href="#cb558-6" aria-hidden="true"></a>    p</span>
<span id="cb558-7"><a href="#cb558-7" aria-hidden="true"></a>        Determines when to stop unfolding.</span>
<span id="cb558-8"><a href="#cb558-8" aria-hidden="true"></a>    f</span>
<span id="cb558-9"><a href="#cb558-9" aria-hidden="true"></a>        Maps each seed value to the corresponding ilist element.</span>
<span id="cb558-10"><a href="#cb558-10" aria-hidden="true"></a>    g</span>
<span id="cb558-11"><a href="#cb558-11" aria-hidden="true"></a>        Maps each seed value to next seed value.</span>
<span id="cb558-12"><a href="#cb558-12" aria-hidden="true"></a>    seed</span>
<span id="cb558-13"><a href="#cb558-13" aria-hidden="true"></a>        The <span class="st">&quot;state&quot;</span> value for the unfold.</span>
<span id="cb558-14"><a href="#cb558-14" aria-hidden="true"></a>    tail</span>
<span id="cb558-15"><a href="#cb558-15" aria-hidden="true"></a>        ilist terminator<span class="co">; defaults to &#39;().</span></span></code></pre></div>
<p>In other words, we use g to generate a sequence of seed values</p>
<div class="sourceCode" id="cb559"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb559-1"><a href="#cb559-1" aria-hidden="true"></a>    seed, g(seed), g2(seed), g3(seed), ...</span></code></pre></div>
<p>These seed values are mapped to ilist elements by f, producing the elements of the result ilist in a right-to-left order. P says when to stop.</p>
<p>iunfold-right is the fundamental iterative ilist constructor, just as ifold is the fundamental iterative ilist consumer. While iunfold-right may seem a bit abstract to novice functional programmers, it can be used in a number of ways:</p>
<div class="sourceCode" id="cb560"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb560-1"><a href="#cb560-1" aria-hidden="true"></a>    <span class="co">;; Ilist of squares: 1^2 ... 10^2</span></span>
<span id="cb560-2"><a href="#cb560-2" aria-hidden="true"></a>    (iunfold-right <span class="kw">zero?</span></span>
<span id="cb560-3"><a href="#cb560-3" aria-hidden="true"></a>                  (<span class="kw">lambda</span> (x) (* x x))</span>
<span id="cb560-4"><a href="#cb560-4" aria-hidden="true"></a>                  (<span class="kw">lambda</span> (x) (<span class="op">-</span> x <span class="dv">1</span>))</span>
<span id="cb560-5"><a href="#cb560-5" aria-hidden="true"></a>                  <span class="dv">10</span>)</span>
<span id="cb560-6"><a href="#cb560-6" aria-hidden="true"></a></span>
<span id="cb560-7"><a href="#cb560-7" aria-hidden="true"></a>    <span class="co">;; Reverse a proper ilist.</span></span>
<span id="cb560-8"><a href="#cb560-8" aria-hidden="true"></a>    (iunfold-right null-ilist? icar icdr lis)</span>
<span id="cb560-9"><a href="#cb560-9" aria-hidden="true"></a></span>
<span id="cb560-10"><a href="#cb560-10" aria-hidden="true"></a>    <span class="co">;; Read current input port into an ilist of values.</span></span>
<span id="cb560-11"><a href="#cb560-11" aria-hidden="true"></a>    (iunfold-right <span class="kw">eof-object?</span> <span class="kw">values</span> (<span class="kw">lambda</span> (x) (<span class="kw">read</span>)) (<span class="kw">read</span>))</span>
<span id="cb560-12"><a href="#cb560-12" aria-hidden="true"></a></span>
<span id="cb560-13"><a href="#cb560-13" aria-hidden="true"></a>    <span class="co">;; (iappend-reverse rev-head tail)</span></span>
<span id="cb560-14"><a href="#cb560-14" aria-hidden="true"></a>    (iunfold-right null-ilist? icar icdr rev-head tail)</span></code></pre></div>
<p>Interested functional programmers may enjoy noting that ifold and iunfold-right are in some sense inverses. That is, given operations knull?, kar, kdr, kons, and knil satisfying</p>
<div class="sourceCode" id="cb561"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb561-1"><a href="#cb561-1" aria-hidden="true"></a>(kons (kar x) (kdr x)) <span class="op">=</span> x <span class="kw">and</span> (knull? knil) <span class="op">=</span> <span class="dv">#t</span></span></code></pre></div>
<p>then</p>
<div class="sourceCode" id="cb562"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb562-1"><a href="#cb562-1" aria-hidden="true"></a>(ifold kons knil (iunfold-right knull? kar kdr x)) <span class="op">=</span> x</span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb563"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb563-1"><a href="#cb563-1" aria-hidden="true"></a>(iunfold-right knull? kar kdr (ifold kons knil x)) <span class="op">=</span> x.</span></code></pre></div>
<p>This combinator presumably has some pretentious mathematical name; interested readers are invited to communicate it to the author.</p>
<h2 id="imap-proc-ilist1-ilist2-..."><code>(imap proc ilist1 ilist2 ...)</code></h2>
<p>proc is a procedure taking as many arguments as there are ilist arguments and returning a single value. imap applies proc element-wise to the elements of the ilists and returns an ilist of the results, in order. The dynamic order in which proc is applied to the elements of the ilists is unspecified.</p>
<div class="sourceCode" id="cb564"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb564-1"><a href="#cb564-1" aria-hidden="true"></a>    (imap icadr (iq (a b) (d e) (g h))) <span class="op">=&gt;</span>  (b e h)</span>
<span id="cb564-2"><a href="#cb564-2" aria-hidden="true"></a></span>
<span id="cb564-3"><a href="#cb564-3" aria-hidden="true"></a>    (imap (<span class="kw">lambda</span> (n) (<span class="kw">expt</span> n n))</span>
<span id="cb564-4"><a href="#cb564-4" aria-hidden="true"></a>         (iq <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>))</span>
<span id="cb564-5"><a href="#cb564-5" aria-hidden="true"></a>        <span class="op">=&gt;</span>  (<span class="dv">1</span> <span class="dv">4</span> <span class="dv">27</span> <span class="dv">256</span> <span class="dv">3125</span>)</span>
<span id="cb564-6"><a href="#cb564-6" aria-hidden="true"></a></span>
<span id="cb564-7"><a href="#cb564-7" aria-hidden="true"></a>    (imap <span class="op">+</span> (iq <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) (iq <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>)) <span class="op">=&gt;</span>  (<span class="dv">5</span> <span class="dv">7</span> <span class="dv">9</span>)</span>
<span id="cb564-8"><a href="#cb564-8" aria-hidden="true"></a></span>
<span id="cb564-9"><a href="#cb564-9" aria-hidden="true"></a>    (<span class="kw">let</span> ((count <span class="dv">0</span>))</span>
<span id="cb564-10"><a href="#cb564-10" aria-hidden="true"></a>      (imap (<span class="kw">lambda</span> (ignored)</span>
<span id="cb564-11"><a href="#cb564-11" aria-hidden="true"></a>             (set! count (<span class="op">+</span> count <span class="dv">1</span>))</span>
<span id="cb564-12"><a href="#cb564-12" aria-hidden="true"></a>             count)</span>
<span id="cb564-13"><a href="#cb564-13" aria-hidden="true"></a>           (iq a b))) <span class="op">=&gt;</span>  (<span class="dv">1</span> <span class="dv">2</span>) <span class="kw">or</span> (<span class="dv">2</span> <span class="dv">1</span>)</span></code></pre></div>
<h2 id="ifor-each-proc-ilist1-ilist2-..."><code>(ifor-each proc ilist1 ilist2 ...)</code></h2>
<p>The arguments to ifor-each are like the arguments to imap, but ifor-each calls proc for its side effects rather than for its values. Unlike imap, ifor-each is guaranteed to call proc on the elements of the ilists in order from the first element(s) to the last, and the value returned by ifor-each is unspecified.</p>
<div class="sourceCode" id="cb565"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb565-1"><a href="#cb565-1" aria-hidden="true"></a>    (<span class="kw">let</span> ((v (<span class="kw">make-vector</span> <span class="dv">5</span>)))</span>
<span id="cb565-2"><a href="#cb565-2" aria-hidden="true"></a>      (ifor-each (<span class="kw">lambda</span> (i)</span>
<span id="cb565-3"><a href="#cb565-3" aria-hidden="true"></a>                  (<span class="kw">vector-set!</span> v i (* i i)))</span>
<span id="cb565-4"><a href="#cb565-4" aria-hidden="true"></a>                (iq <span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))</span>
<span id="cb565-5"><a href="#cb565-5" aria-hidden="true"></a>      v)  <span class="op">=&gt;</span>  #(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">9</span> <span class="dv">16</span>)</span></code></pre></div>
<h2 id="iappend-map-f-ilist1-ilist2-..."><code>(iappend-map  f ilist1 ilist2 ...)</code></h2>
<p>Equivalent to</p>
<div class="sourceCode" id="cb566"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb566-1"><a href="#cb566-1" aria-hidden="true"></a>(iapply iappend (imap f ilist1 ilist2 ...))</span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb567"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb567-1"><a href="#cb567-1" aria-hidden="true"></a>(iapply iappend (imap f ilist1 ilist2 ...))</span></code></pre></div>
<p>Map f over the elements of the ilists, just as in the imap function. However, the results of the applications are appended together (using iappend) to make the final result.</p>
<p>The dynamic order in which the various applications of f are made is not specified.</p>
<p>Example:</p>
<div class="sourceCode" id="cb568"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb568-1"><a href="#cb568-1" aria-hidden="true"></a>(iappend-map (<span class="kw">lambda</span> (x) (ilist x (<span class="op">-</span> x))) (iq <span class="dv">1</span> <span class="dv">3</span> <span class="dv">8</span>))</span>
<span id="cb568-2"><a href="#cb568-2" aria-hidden="true"></a>  <span class="co">;; =&gt; (1 -1 3 -3 8 -8)</span></span></code></pre></div>
<h2 id="imap-in-order-f-ilist1-ilist2-..."><code>(imap-in-order f ilist1 ilist2 ...)</code></h2>
<p>A variant of the imap procedure that guarantees to apply f across the elements of the ilisti arguments in a left-to-right order. This is useful for mapping procedures that both have side effects and return useful values.</p>
<h2 id="ipair-for-each-f-ilist1-ilist2-..."><code>(ipair-for-each f ilist1 ilist2 ...)</code></h2>
<p>Like ifor-each, but f is applied to successive sub-ilists of the argument ilists. That is, f is applied to the cells of the ilists, rather than the ilists’ elements. These applications occur in left-to-right order.</p>
<div class="sourceCode" id="cb569"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb569-1"><a href="#cb569-1" aria-hidden="true"></a>    (ipair-for-each (<span class="kw">lambda</span> (ipair) (<span class="kw">display</span> ipair) (<span class="kw">newline</span>)) (iq a b c)) ==&gt;</span>
<span id="cb569-2"><a href="#cb569-2" aria-hidden="true"></a>        (a b c)</span>
<span id="cb569-3"><a href="#cb569-3" aria-hidden="true"></a>        (b c)</span>
<span id="cb569-4"><a href="#cb569-4" aria-hidden="true"></a>        (c)</span></code></pre></div>
<h2 id="ifilter-map-f-ilist1-ilist2-..."><code>(ifilter-map f ilist1 ilist2 ...)</code></h2>
<p>Like imap, but only true values are saved.</p>
<div class="sourceCode" id="cb570"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb570-1"><a href="#cb570-1" aria-hidden="true"></a>    (ifilter-map (<span class="kw">lambda</span> (x) (<span class="kw">and</span> (<span class="kw">number?</span> x) (* x x))) (iq a <span class="dv">1</span> b <span class="dv">3</span> c <span class="dv">7</span>))</span>
<span id="cb570-2"><a href="#cb570-2" aria-hidden="true"></a>        <span class="op">=&gt;</span> (<span class="dv">1</span> <span class="dv">9</span> <span class="dv">49</span>)</span></code></pre></div>
<p>The dynamic order in which the various applications of f are made is not specified.</p>
<h2 id="ifilter-pred-ilist"><code>(ifilter pred ilist)</code></h2>
<p>Return all the elements of ilist that satisfy predicate pred. The ilist is not disordered — elements that appear in the result ilist occur in the same order as they occur in the argument ilist. The returned ilist may share a common tail with the argument ilist. The dynamic order in which the various applications of pred are made is not specified.</p>
<div class="sourceCode" id="cb571"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb571-1"><a href="#cb571-1" aria-hidden="true"></a>(ifilter <span class="kw">even?</span> (iq <span class="dv">0</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">8</span> <span class="dv">43</span> <span class="dv">-4</span>)) <span class="op">=&gt;</span> (<span class="dv">0</span> <span class="dv">8</span> <span class="dv">8</span> <span class="dv">-4</span>)</span></code></pre></div>
<h2 id="ipartition-pred-ilist"><code>(ipartition pred ilist)</code></h2>
<p>Partitions the elements of ilist with predicate pred, and returns two values: the ilist of in-elements and the ilist of out-elements. The ilist is not disordered — elements occur in the result ilists in the same order as they occur in the argument ilist. The dynamic order in which the various applications of pred are made is not specified. One of the returned ilists may share a common tail with the argument ilist.</p>
<div class="sourceCode" id="cb572"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb572-1"><a href="#cb572-1" aria-hidden="true"></a>    (ipartition <span class="kw">symbol?</span> (iq one <span class="dv">2</span> <span class="dv">3</span> four five <span class="dv">6</span>)) <span class="op">=&gt;</span></span>
<span id="cb572-2"><a href="#cb572-2" aria-hidden="true"></a>        (one four five)</span>
<span id="cb572-3"><a href="#cb572-3" aria-hidden="true"></a>        (<span class="dv">2</span> <span class="dv">3</span> <span class="dv">6</span>)</span></code></pre></div>
<h2 id="iremove-pred-ilist"><code>(iremove pred ilist)</code></h2>
<p>Returns ilist without the elements that satisfy predicate pred:</p>
<div class="sourceCode" id="cb573"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb573-1"><a href="#cb573-1" aria-hidden="true"></a>(<span class="kw">lambda</span> (pred ilist) (ifilter (<span class="kw">lambda</span> (x) (<span class="kw">not</span> (pred x))) ilist))</span></code></pre></div>
<p>The ilist is not disordered — elements that appear in the result ilist occur in the same order as they occur in the argument ilist. The returned ilist may share a common tail with the argument ilist. The dynamic order in which the various applications of pred are made is not specified.</p>
<div class="sourceCode" id="cb574"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb574-1"><a href="#cb574-1" aria-hidden="true"></a>(iremove <span class="kw">even?</span> (iq <span class="dv">0</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">8</span> <span class="dv">43</span> <span class="dv">-4</span>)) <span class="op">=&gt;</span> (<span class="dv">7</span> <span class="dv">43</span>)</span></code></pre></div>
<h2 id="ifind-pred-ilist"><code>(ifind pred ilist)</code></h2>
<p>Return the first element of ilist that satisfies predicate pred; false if no element does.</p>
<div class="sourceCode" id="cb575"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb575-1"><a href="#cb575-1" aria-hidden="true"></a>(ifind <span class="kw">even?</span> (iq <span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> <span class="dv">4</span></span></code></pre></div>
<p>Note that ifind has an ambiguity in its lookup semantics — if ifind returns #f, you cannot tell (in general) if it found a #f element that satisfied pred, or if it did not find any element at all. In many situations, this ambiguity cannot arise — either the ilist being searched is known not to contain any #f elements, or the ilist is guaranteed to have an element satisfying pred. However, in cases where this ambiguity can arise, you should use ifind-tail instead of ifind — ifind-tail has no such ambiguity:</p>
<div class="sourceCode" id="cb576"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb576-1"><a href="#cb576-1" aria-hidden="true"></a>    (<span class="kw">cond</span> ((ifind-tail pred lis) <span class="op">=&gt;</span> (<span class="kw">lambda</span> (ipair) ...)) <span class="co">; Handle (icar ipair)</span></span>
<span id="cb576-2"><a href="#cb576-2" aria-hidden="true"></a>          (<span class="kw">else</span> ...)) <span class="co">; Search failed.</span></span></code></pre></div>
<h2 id="ifind-tail-pred-ilist"><code>(ifind-tail pred ilist)</code></h2>
<p>Return the first ipair of ilist whose icar satisfies pred. If no ipair does, return false.</p>
<p>ifind-tail can be viewed as a general-predicate variant of the imember function.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb577"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb577-1"><a href="#cb577-1" aria-hidden="true"></a>    (ifind-tail <span class="kw">even?</span> (iq <span class="dv">3</span> <span class="dv">1</span> <span class="dv">37</span> <span class="dv">-8</span> <span class="dv">-5</span> <span class="dv">0</span> <span class="dv">0</span>)) <span class="op">=&gt;</span> (-<span class="dv">8</span> <span class="dv">-5</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb577-2"><a href="#cb577-2" aria-hidden="true"></a>    (ifind-tail <span class="kw">even?</span> (iq <span class="dv">3</span> <span class="dv">1</span> <span class="dv">37</span> <span class="dv">-5</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb577-3"><a href="#cb577-3" aria-hidden="true"></a></span>
<span id="cb577-4"><a href="#cb577-4" aria-hidden="true"></a>    <span class="co">;; IMEMBER X LIS:</span></span>
<span id="cb577-5"><a href="#cb577-5" aria-hidden="true"></a>    (ifind-tail (<span class="kw">lambda</span> (elt) (<span class="kw">equal?</span> x elt)) lis)</span></code></pre></div>
<p>iqfind-tail is essentially idrop-while, where the sense of the predicate is inverted: Ifind-tail searches until it finds an element satisfying the predicate; idrop-while searches until it finds an element that doesn’t satisfy the predicate.</p>
<h2 id="itake-while-pred-ilist"><code>(itake-while  pred ilist)</code></h2>
<p>Returns the longest initial prefix of ilist whose elements all satisfy the predicate pred.</p>
<div class="sourceCode" id="cb578"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb578-1"><a href="#cb578-1" aria-hidden="true"></a>(itake-while <span class="kw">even?</span> (iq <span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> (<span class="dv">2</span> <span class="dv">18</span>)</span></code></pre></div>
<h2 id="idrop-while-pred-ilist"><code>(idrop-while pred ilist)</code></h2>
<p>idrops the longest initial prefix of ilist whose elements all satisfy the predicate pred, and returns the rest of the ilist.</p>
<div class="sourceCode" id="cb579"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb579-1"><a href="#cb579-1" aria-hidden="true"></a>(idrop-while <span class="kw">even?</span> (iq <span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> (<span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)</span></code></pre></div>
<h2 id="ispan-pred-ilist"><code>(ispan pred ilist)</code></h2>
<h2 id="ibreak-pred-ilist"><code>(ibreak  pred ilist)</code></h2>
<p>ispan splits the ilist into the longest initial prefix whose elements all satisfy pred, and the remaining tail. ibreak inverts the sense of the predicate: the tail commences with the first element of the input ilist that satisfies the predicate.</p>
<p>In other words: ispan finds the initial span of elements satisfying pred, and ibreak breaks the ilist at the first element satisfying pred.</p>
<p>ispan is equivalent to</p>
<div class="sourceCode" id="cb580"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb580-1"><a href="#cb580-1" aria-hidden="true"></a>    (<span class="kw">values</span> (itake-while pred ilist)</span>
<span id="cb580-2"><a href="#cb580-2" aria-hidden="true"></a>            (idrop-while pred ilist))</span>
<span id="cb580-3"><a href="#cb580-3" aria-hidden="true"></a></span>
<span id="cb580-4"><a href="#cb580-4" aria-hidden="true"></a>    (ispan <span class="kw">even?</span> (iq <span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span></span>
<span id="cb580-5"><a href="#cb580-5" aria-hidden="true"></a>      (<span class="dv">2</span> <span class="dv">18</span>)</span>
<span id="cb580-6"><a href="#cb580-6" aria-hidden="true"></a>      (<span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)</span>
<span id="cb580-7"><a href="#cb580-7" aria-hidden="true"></a></span>
<span id="cb580-8"><a href="#cb580-8" aria-hidden="true"></a>    (ibreak <span class="kw">even?</span> (iq <span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="op">=&gt;</span></span>
<span id="cb580-9"><a href="#cb580-9" aria-hidden="true"></a>      (<span class="dv">3</span> <span class="dv">1</span>)</span>
<span id="cb580-10"><a href="#cb580-10" aria-hidden="true"></a>      (<span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)</span></code></pre></div>
<h2 id="iany-pred-ilist1-ilist2-..."><code>(iany pred ilist1 ilist2 ...)</code></h2>
<p>Applies the predicate across the ilists, returning true if the predicate returns true on any application.</p>
<p>If there are n ilist arguments ilist1 … ilistn, then pred must be a procedure taking n arguments and returning a boolean result.</p>
<p>iany applies pred to the first elements of the ilisti parameters. If this application returns a true value, iany immediately returns that value. Otherwise, it iterates, applying pred to the second elements of the ilisti parameters, then the third, and so forth. The iteration stops when a true value is produced or one of the ilists runs out of values; in the latter case, iany returns #f. The application of pred to the last element of the ilists is a tail call.</p>
<p>Note the difference between ifind and iany — ifind returns the element that satisfied the predicate; iany returns the true value that the predicate produced.</p>
<p>Like ievery, iany’s name does not end with a question mark — this is to indicate that it does not return a simple boolean (#t or #f), but a general value.</p>
<div class="sourceCode" id="cb581"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb581-1"><a href="#cb581-1" aria-hidden="true"></a>    (iany <span class="kw">integer?</span> (iq a <span class="dv">3</span> b <span class="fl">2.7</span>))   <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb581-2"><a href="#cb581-2" aria-hidden="true"></a>    (iany <span class="kw">integer?</span> (iq a <span class="fl">3.1</span> b <span class="fl">2.7</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb581-3"><a href="#cb581-3" aria-hidden="true"></a>    (iany <span class="op">&lt;</span> (iq <span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span>)</span>
<span id="cb581-4"><a href="#cb581-4" aria-hidden="true"></a>           (iq <span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">#t</span></span></code></pre></div>
<h2 id="ievery-pred-ilist1-ilist2-..."><code>(ievery pred ilist1 ilist2 ...)</code></h2>
<p>Applies the predicate across the ilists, returning true if the predicate returns true on every application.</p>
<p>If there are n ilist arguments ilist1 … ilistn, then pred must be a procedure taking n arguments and returning a boolean result.</p>
<p>ievery applies pred to the first elements of the ilisti parameters. If this application returns false, ievery immediately returns false. Otherwise, it iterates, applying pred to the second elements of the ilisti parameters, then the third, and so forth. The iteration stops when a false value is produced or one of the ilists runs out of values. In the latter case, ievery returns the true value produced by its final application of pred. The application of pred to the last element of the ilists is a tail call.</p>
<p>If one of the ilisti has no elements, ievery simply returns #t.</p>
<p>Like iany, ievery’s name does not end with a question mark — this is to indicate that it does not return a simple boolean (#t or #f), but a general value.</p>
<h2 id="ilist-index-pred-ilist1-ilist2-..."><code>(ilist-index pred ilist1 ilist2 ...)</code></h2>
<p>Return the index of the leftmost element that satisfies pred.</p>
<p>If there are n ilist arguments ilist1 … ilistn, then pred must be a function taking n arguments and returning a boolean result.</p>
<p>ilist-index applies pred to the first elements of the ilisti parameters. If this application returns true, ilist-index immediately returns zero. Otherwise, it iterates, applying pred to the second elements of the ilisti parameters, then the third, and so forth. When it finds a tuple of ilist elements that cause pred to return true, it stops and returns the zero-based index of that position in the ilists.</p>
<p>The iteration stops when one of the ilists runs out of values; in this case, ilist-index returns #f.</p>
<div class="sourceCode" id="cb582"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb582-1"><a href="#cb582-1" aria-hidden="true"></a>    (ilist-index <span class="kw">even?</span> (iq <span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> <span class="dv">2</span></span>
<span id="cb582-2"><a href="#cb582-2" aria-hidden="true"></a>    (ilist-index <span class="op">&lt;</span> (iq <span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) (iq <span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">1</span></span>
<span id="cb582-3"><a href="#cb582-3" aria-hidden="true"></a>    (ilist-index <span class="op">=</span> (iq <span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) (iq <span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="imember-x-ilist"><code>(imember x ilist [=])</code></h2>
<h2 id="imemq-x-ilist"><code>(imemq x ilist)</code></h2>
<h2 id="imemv-x-ilist">`(imemv x ilist)</h2>
<p>These procedures return the first sub-ilist of ilist whose icar is x, where the sub-ilists of ilist are the non-empty ilists returned by (idrop ilist i) for i less than the length of ilist. If x does not occur in ilist, then #f is returned. imemq uses eq? to compare x with the elements of ilist, while imemv uses eqv?, and imember uses equal?.</p>
<pre><code>        (imemq &#39;a (iq a b c))           =&gt;  (a b c)
        (imemq &#39;b (iq a b c))           =&gt;  (b c)
        (imemq &#39;a (iq b c d))           =&gt;  #f
        (imemq (list &#39;a)
                (ilist &#39;b &#39;(a) &#39;c))     =&gt;  #f
        (imember (list &#39;a)
                (ilist &#39;b &#39;(a) &#39;c)))    =&gt;  ((a) c)
        (imemq 101 (iq 100 101 102))    =&gt;  *unspecified*
        (imemv 101 (iq 100 101 102))    =&gt;  (101 102)</code></pre>
<p>The comparison procedure is used to compare the elements ei of ilist to the key x in this way:</p>
<div class="sourceCode" id="cb584"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb584-1"><a href="#cb584-1" aria-hidden="true"></a>(<span class="op">=</span> x ei) <span class="co">; ilist is (E1 ... En)</span></span></code></pre></div>
<p>That is, the first argument is always x, and the second argument is one of the ilist elements. Thus one can reliably find the first element of ilist that is greater than five with (imember 5 ilist &lt;)</p>
<p>Note that fully general ilist searching may be performed with the ifind-tail and ifind procedures, e.g.</p>
<div class="sourceCode" id="cb585"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb585-1"><a href="#cb585-1" aria-hidden="true"></a>(ifind-tail <span class="kw">even?</span> ilist) <span class="co">; Find the first elt with an even key.</span></span></code></pre></div>
<h2 id="idelete-x-ilist"><code>(idelete  x ilist [=])</code></h2>
<p>idelete uses the comparison procedure =, which defaults to equal?, to find all elements of ilist that are equal to x, and deletes them from ilist. The dynamic order in which the various applications of = are made is not specified.</p>
<p>The ilist is not disordered — elements that appear in the result ilist occur in the same order as they occur in the argument ilist. The result may share a common tail with the argument ilist.</p>
<p>Note that fully general element deletion can be performed with the iremove procedures, e.g.:</p>
<div class="sourceCode" id="cb586"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb586-1"><a href="#cb586-1" aria-hidden="true"></a><span class="co">;; idelete all the even elements from LIS:</span></span>
<span id="cb586-2"><a href="#cb586-2" aria-hidden="true"></a>(iremove <span class="kw">even?</span> lis)</span></code></pre></div>
<p>The comparison procedure is used in this way: (= x ei). That is, x is always the first argument, and an ilist element is always the second argument. The comparison procedure will be used to compare each element of ilist exactly once; the order in which it is applied to the various ei is not specified. Thus, one can reliably remove all the numbers greater than five from an ilist with (idelete 5 ilist &lt;)</p>
<h2 id="idelete-duplicates-ilist"><code>(idelete-duplicates  ilist [=])</code></h2>
<p>idelete-duplicates removes duplicate elements from the ilist argument. If there are multiple equal elements in the argument ilist, the result ilist only contains the first or leftmost of these elements in the result. The order of these surviving elements is the same as in the original ilist — idelete-duplicates does not disorder the ilist (hence it is useful for “cleaning up” immutable association lists).</p>
<p>The = parameter is used to compare the elements of the ilist; it defaults to equal?. If x comes before y in ilist, then the comparison is performed (= x y). The comparison procedure will be used to compare each pair of elements in ilist no more than once; the order in which it is applied to the various pairs is not specified.</p>
<p>Implementations of idelete-duplicates are allowed to share common tails between argument and result ilists — for example, if the ilist argument contains only unique elements, it may simply return exactly this ilist.</p>
<p>Be aware that, in general, idelete-duplicates runs in time O(n2) for n-element ilists. Uniquifying long ilists can be accomplished in O(n lg n) time by sorting the ilist to bring equal elements together, then using a linear-time algorithm to remove equal elements. Alternatively, one can use algorithms based on element-marking, with linear-time results.</p>
<div class="sourceCode" id="cb587"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb587-1"><a href="#cb587-1" aria-hidden="true"></a>(idelete-duplicates (iq a b a c a b c z)) <span class="op">=&gt;</span> (a b c z)</span>
<span id="cb587-2"><a href="#cb587-2" aria-hidden="true"></a></span>
<span id="cb587-3"><a href="#cb587-3" aria-hidden="true"></a><span class="co">;; Clean up an ialist:</span></span>
<span id="cb587-4"><a href="#cb587-4" aria-hidden="true"></a>(idelete-duplicates (iq (a . <span class="dv">3</span>) (b . <span class="dv">7</span>) (a . <span class="dv">9</span>) (c . <span class="dv">1</span>))</span>
<span id="cb587-5"><a href="#cb587-5" aria-hidden="true"></a>  (<span class="kw">lambda</span> (x y) (<span class="kw">eq?</span> (icar x) (icar y))))</span>
<span id="cb587-6"><a href="#cb587-6" aria-hidden="true"></a><span class="co">;; =&gt; ((a . 3) (b . 7) (c . 1))</span></span></code></pre></div>
<h2 id="ialist-cons-key-datum-ialist"><code>(ialist-cons key datum ialist)</code></h2>
<div class="sourceCode" id="cb588"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb588-1"><a href="#cb588-1" aria-hidden="true"></a>(<span class="kw">lambda</span> (key datum ialist) (ipair (ipair key datum) ialist))</span></code></pre></div>
<p>Construct a new ialist entry mapping key -&gt; datum onto ialist.</p>
<h2 id="ialist-delete-key-ialist"><code>(ialist-delete  key ialist [=])</code></h2>
<p>ialist-delete deletes all associations from ialist with the given key, using key-comparison procedure =, which defaults to equal?. The dynamic order in which the various applications of = are made is not specified.</p>
<p>Return values may share common tails with the ialist argument. The ialist is not disordered — elements that appear in the result ialist occur in the same order as they occur in the argument ialist.</p>
<p>The comparison procedure is used to compare the element keys ki of ialist’s entries to the key parameter in this way: (= key ki). Thus, one can reliably remove all entries of ialist whose key is greater than five with (ialist-delete 5 ialist &lt;)</p>
<h2 id="replace-icar-ipair-object"><code>(replace-icar ipair object)</code></h2>
<p>This procedure returns an ipair with object in the icar field and the icdr of ipair in the icdr field.</p>
<h2 id="replace-icdr-ipair-object"><code>(replace-icdr ipair object)</code></h2>
<p>This procedure returns an ipair with object in the icdr field and the icar of ipair in the icar field.</p>
<h2 id="pair-ipair-pair"><code>(pair-&gt;ipair pair)</code></h2>
<h2 id="ipair-pair-ipair"><code>(ipair-&gt;pair ipair)</code></h2>
<p>These procedures, which are inverses, return an ipair and a pair respectively that have the same (i)car and (i)cdr fields as the argument.</p>
<h2 id="list-ilist-flist"><code>(list-&gt;ilist flist)</code></h2>
<h2 id="ilist-list-dilist"><code>(ilist-&gt;list dilist)</code></h2>
<p>These procedures return an ilist and a list respectively that have the same elements as the argument. The tails of dotted (i)lists are preserved in the result, which makes the procedures not inverses when the tail of a dotted ilist is a list or vice versa. The empty list is converted to itself.</p>
<p>It is an error to apply list-&gt;ilist to a circular list.</p>
<h2 id="tree-itree-object"><code>(tree-&gt;itree object)</code></h2>
<h2 id="itree-tree-object"><code>(itree-&gt;tree object)</code></h2>
<p>These procedures walk a tree of pairs or ipairs respectively and make a deep copy of it, returning an isomorphic tree containing ipairs or pairs respectively. The result may share structure with the argument. If the argument is not of the expected type, it is returned.</p>
<p>These procedures are not inverses in the general case. For example, a pair of ipairs would be converted by tree-&gt;itree to an ipair of ipairs, which if converted by itree-&gt;tree would produce a pair of pairs.</p>
<h2 id="gtree-itree-object"><code>(gtree-&gt;itree object)</code></h2>
<h2 id="gtree-tree-object"><code>(gtree-&gt;tree object)</code></h2>
<p>These procedures walk a generalized tree consisting of pairs, ipairs, or a combination of both, and make a deep copy of it, returning an isomorphic tree containing only ipairs or pairs respectively. The result may share structure with the argument. If the argument is neither a pair nor an ipair, it is returned.</p>
<h2 id="iapply-procedure-object-...-ilist"><code>(iapply procedure object ... ilist)</code></h2>
<p>The iapply procedure is an analogue of apply whose last argument is an ilist rather than a list. It is equivalent to (apply procedure object … (ilist-&gt;list ilist)), but may be implemented more efficiently.</p>
<h2 id="ipair-comparator"><code>ipair-comparator</code></h2>
<p>The ipair-comparator object is a SRFI-114 comparator suitable for comparing ipairs. Note that it is not a procedure. It compares pairs using default-comparator on their cars. If the cars are not equal, that value is returned. If they are equal, default-comparator is used on their cdrs and that value is returned.</p>
<h2 id="ilist-comparator"><code>ilist-comparator</code></h2>
<p>The ilist-comparator object is a SRFI-114 comparator suitable for comparing ilists. Note that it is not a procedure. It compares ilists lexicographically, as follows:</p>
<ul>
<li><p>The empty ilist compares equal to itself.</p></li>
<li><p>The empty ilist compares less than any non-empty ilist.</p></li>
<li><p>Two non-empty ilists are compared by comparing their icars. If the icars are not equal when compared using default-comparator, then the result is the result of that comparison. Otherwise, the icdrs are compared using ilist-comparator.</p></li>
</ul>
<h2 id="make-ilist-comparator-comparator"><code>(make-ilist-comparator comparator)</code></h2>
<p>The make-ilist-comparator procedure returns a comparator suitable for comparing ilists using element-comparator to compare the elements.</p>
<h2 id="make-improper-ilist-comparator-comparator"><code>(make-improper-ilist-comparator comparator)</code></h2>
<p>The make-improper-ilist-comparator procedure returns a comparator that compares arbitrary objects as follows: the empty list precedes all ipairs, which precede all other objects. Ipairs are compared as if with (make-ipair-comparator comparator comparator). All other objects are compared using comparator.</p>
<h2 id="make-icar-comparator-comparator"><code>(make-icar-comparator comparator)</code></h2>
<p>The make-icar-comparator procedure returns a comparator that compares ipairs on their icars alone using comparator.</p>
<h2 id="make-icdr-comparator-comparator">`(make-icdr-comparator comparator)</h2>
<p>The make-icdr-comparator procedure returns a comparator that compares ipairs on their icdrs alone using comparator. # <code>(scheme read)</code></p>
<h2 id="read-port"><code>(read [port])</code></h2>
<p>The <code>read</code> procedure converts external epresentations of Scheme objects into the objects themselves. That is, it is a parser for the non-terminal datum. It returns the next object parsable from the given textual input port, updating port to point to the first character past the end of the external representation of the object.</p>
<p>The current implementation is not fully compatible with R7RS. # <code>(scheme bitwise)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-151/">SRFI-151</a>.</p>
<p>This library offers a coherent and comprehensive set of procedures for performing bitwise logical operations on integers.</p>
<h2 id="bitwise-not-i"><code>(bitwise-not i)</code></h2>
<p>Returns the bitwise complement of i; that is, all 1 bits are changed to 0 bits and all 0 bits to 1 bits.</p>
<div class="sourceCode" id="cb589"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb589-1"><a href="#cb589-1" aria-hidden="true"></a>(bitwise-not <span class="dv">10</span>) <span class="co">;; =&gt; -11</span></span>
<span id="cb589-2"><a href="#cb589-2" aria-hidden="true"></a>(bitwise-not <span class="dv">-37</span>) <span class="co">;; =&gt; 36</span></span></code></pre></div>
<p>The following ten procedures correspond to the useful set of non-trivial two-argument boolean functions. For each such function, the corresponding bitwise operator maps that function across a pair of bitstrings in a bit-wise fashion. The core idea of this group of functions is this bitwise “lifting” of the set of dyadic boolean functions to bitstring parameters.</p>
<h2 id="bitwise-and-i-..."><code>(bitwise-and i ...)</code></h2>
<h2 id="bitwise-ior-i-..."><code>(bitwise-ior i ...)</code></h2>
<h2 id="bitwise-xor-i-..."><code>(bitwise-xor i ...)</code></h2>
<h2 id="bitwise-eqv-i-..."><code>(bitwise-eqv i ...)</code></h2>
<p>These operations are associative. When passed no arguments, the procedures return the identity values -1, 0, 0, and -1 respectively.</p>
<p>The bitwise-eqv procedure produces the complement of the bitwise-xor procedure. When applied to three arguments, it does not produce a 1 bit everywhere that a, b and c all agree. That is, it does not produce</p>
<div class="sourceCode" id="cb590"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb590-1"><a href="#cb590-1" aria-hidden="true"></a>     (bitwise-ior (bitwise-and a b c)</span>
<span id="cb590-2"><a href="#cb590-2" aria-hidden="true"></a>                  (bitwise-and (bitwise-not a)</span>
<span id="cb590-3"><a href="#cb590-3" aria-hidden="true"></a>                               (bitwise-not b)</span>
<span id="cb590-4"><a href="#cb590-4" aria-hidden="true"></a>                               (bitwise-not c)))</span></code></pre></div>
<p>Rather, it produces (bitwise-eqv a (bitwise-eqv b c)) or the equivalent (bitwise-eqv (bitwise-eqv a b) c).</p>
<div class="sourceCode" id="cb591"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb591-1"><a href="#cb591-1" aria-hidden="true"></a>(bitwise-ior <span class="dv">3</span>  <span class="dv">10</span>)     <span class="op">=&gt;</span>  <span class="dv">11</span></span>
<span id="cb591-2"><a href="#cb591-2" aria-hidden="true"></a>(bitwise-and <span class="dv">11</span> <span class="dv">26</span>)     <span class="op">=&gt;</span>  <span class="dv">10</span></span>
<span id="cb591-3"><a href="#cb591-3" aria-hidden="true"></a>(bitwise-xor <span class="dv">3</span> <span class="dv">10</span>)      <span class="op">=&gt;</span>   <span class="dv">9</span></span>
<span id="cb591-4"><a href="#cb591-4" aria-hidden="true"></a>(bitwise-eqv <span class="dv">37</span> <span class="dv">12</span>)     <span class="op">=&gt;</span> <span class="dv">-42</span></span>
<span id="cb591-5"><a href="#cb591-5" aria-hidden="true"></a>(bitwise-and <span class="dv">37</span> <span class="dv">12</span>)     <span class="op">=&gt;</span>   <span class="dv">4</span></span></code></pre></div>
<h2 id="bitwise-nand-i-j"><code>(bitwise-nand i j)</code></h2>
<h2 id="bitwise-nor-i-j"><code>(bitwise-nor i j)</code></h2>
<h2 id="bitwise-andc1-i-j"><code>(bitwise-andc1 i j)</code></h2>
<h2 id="bitwise-andc2-i-j"><code>(bitwise-andc2 i j)</code></h2>
<h2 id="bitwise-orc1-i-j"><code>(bitwise-orc1 i j)</code></h2>
<h2 id="bitwise-orc2-i-j"><code>(bitwise-orc2 i j)</code></h2>
<p>These operations are not associative.</p>
<div class="sourceCode" id="cb592"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb592-1"><a href="#cb592-1" aria-hidden="true"></a>(bitwise-nand <span class="dv">11</span> <span class="dv">26</span>) <span class="op">=&gt;</span>  <span class="dv">-11</span></span>
<span id="cb592-2"><a href="#cb592-2" aria-hidden="true"></a>(bitwise-nor  <span class="dv">11</span> <span class="dv">26</span>) <span class="op">=&gt;</span> <span class="dv">-28</span></span>
<span id="cb592-3"><a href="#cb592-3" aria-hidden="true"></a>(bitwise-andc1 <span class="dv">11</span> <span class="dv">26</span>) <span class="op">=&gt;</span> <span class="dv">16</span></span>
<span id="cb592-4"><a href="#cb592-4" aria-hidden="true"></a>(bitwise-andc2 <span class="dv">11</span> <span class="dv">26</span>) <span class="op">=&gt;</span> <span class="dv">1</span></span>
<span id="cb592-5"><a href="#cb592-5" aria-hidden="true"></a>(bitwise-orc1 <span class="dv">11</span> <span class="dv">26</span>) <span class="op">=&gt;</span> <span class="dv">-2</span></span>
<span id="cb592-6"><a href="#cb592-6" aria-hidden="true"></a>(bitwise-orc2 <span class="dv">11</span> <span class="dv">26</span>) <span class="op">=&gt;</span> <span class="dv">-17</span></span></code></pre></div>
<h2 id="arithmetic-shift-i-count"><code>(arithmetic-shift i count)</code></h2>
<p>Returns the arithmetic left shift when count&gt;0; right shift when count &lt; 0.</p>
<div class="sourceCode" id="cb593"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb593-1"><a href="#cb593-1" aria-hidden="true"></a>(arithmetic-shift <span class="dv">8</span> <span class="dv">2</span>) <span class="op">=&gt;</span> <span class="dv">32</span></span>
<span id="cb593-2"><a href="#cb593-2" aria-hidden="true"></a>(arithmetic-shift <span class="dv">4</span> <span class="dv">0</span>) <span class="op">=&gt;</span> <span class="dv">4</span></span>
<span id="cb593-3"><a href="#cb593-3" aria-hidden="true"></a>(arithmetic-shift <span class="dv">8</span> <span class="dv">-1</span>) <span class="op">=&gt;</span> <span class="dv">4</span></span>
<span id="cb593-4"><a href="#cb593-4" aria-hidden="true"></a>(arithmetic-shift <span class="dv">-100000000000000000000000000000000</span> <span class="dv">-100</span>) <span class="op">=&gt;</span> <span class="dv">-79</span></span></code></pre></div>
<h2 id="bit-count-i"><code>(bit-count i)</code></h2>
<p>Returns the population count of 1’s (i &gt;= 0) or 0’s (i &lt; 0). The result is always non-negative.</p>
<p>Compatibility note: The R6RS analogue bitwise-bit-count applies bitwise-not to the population count before returning it if i is negative.</p>
<div class="sourceCode" id="cb594"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb594-1"><a href="#cb594-1" aria-hidden="true"></a>(bit-count <span class="dv">0</span>) <span class="op">=&gt;</span>  <span class="dv">0</span></span>
<span id="cb594-2"><a href="#cb594-2" aria-hidden="true"></a>(bit-count <span class="dv">-1</span>) <span class="op">=&gt;</span>  <span class="dv">0</span></span>
<span id="cb594-3"><a href="#cb594-3" aria-hidden="true"></a>(bit-count <span class="dv">7</span>) <span class="op">=&gt;</span>  <span class="dv">3</span></span>
<span id="cb594-4"><a href="#cb594-4" aria-hidden="true"></a>(bit-count  <span class="dv">13</span>) <span class="op">=&gt;</span>  <span class="dv">3</span> <span class="co">;Two&#39;s-complement binary: ...0001101</span></span>
<span id="cb594-5"><a href="#cb594-5" aria-hidden="true"></a>(bit-count <span class="dv">-13</span>) <span class="op">=&gt;</span>  <span class="dv">2</span> <span class="co">;Two&#39;s-complement binary: ...1110011</span></span>
<span id="cb594-6"><a href="#cb594-6" aria-hidden="true"></a>(bit-count  <span class="dv">30</span>) <span class="op">=&gt;</span>  <span class="dv">4</span> <span class="co">;Two&#39;s-complement binary: ...0011110</span></span>
<span id="cb594-7"><a href="#cb594-7" aria-hidden="true"></a>(bit-count <span class="dv">-30</span>) <span class="op">=&gt;</span>  <span class="dv">4</span> <span class="co">;Two&#39;s-complement binary: ...1100010</span></span>
<span id="cb594-8"><a href="#cb594-8" aria-hidden="true"></a>(bit-count (<span class="kw">expt</span> <span class="dv">2</span> <span class="dv">100</span>)) <span class="op">=&gt;</span>  <span class="dv">1</span></span>
<span id="cb594-9"><a href="#cb594-9" aria-hidden="true"></a>(bit-count (<span class="op">-</span> (<span class="kw">expt</span> <span class="dv">2</span> <span class="dv">100</span>))) <span class="op">=&gt;</span>  <span class="dv">100</span></span>
<span id="cb594-10"><a href="#cb594-10" aria-hidden="true"></a>(bit-count (<span class="op">-</span> (<span class="dv">1</span>+ (<span class="kw">expt</span> <span class="dv">2</span> <span class="dv">100</span>)))) <span class="op">=&gt;</span>  <span class="dv">1</span></span></code></pre></div>
<h2 id="integer-length-i"><code>(integer-length i)</code></h2>
<p>The number of bits needed to represent i, i.e.</p>
<div class="sourceCode" id="cb595"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb595-1"><a href="#cb595-1" aria-hidden="true"></a>(<span class="kw">ceiling</span> (<span class="op">/</span> (<span class="kw">log</span> (<span class="kw">if</span> (<span class="kw">negative?</span> integer)</span>
<span id="cb595-2"><a href="#cb595-2" aria-hidden="true"></a>                     (<span class="op">-</span> integer)</span>
<span id="cb595-3"><a href="#cb595-3" aria-hidden="true"></a>                     (<span class="op">+</span> <span class="dv">1</span> integer)))</span>
<span id="cb595-4"><a href="#cb595-4" aria-hidden="true"></a>            (<span class="kw">log</span> <span class="dv">2</span>)))</span></code></pre></div>
<p>The result is always non-negative. For non-negative i, this is the number of bits needed to represent i in an unsigned binary representation. For all i, (+ 1 (integer-length i)) is the number of bits needed to represent i in a signed twos-complement representation.</p>
<div class="sourceCode" id="cb596"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb596-1"><a href="#cb596-1" aria-hidden="true"></a>(integer-length  <span class="dv">0</span>) <span class="op">=&gt;</span> <span class="dv">0</span></span>
<span id="cb596-2"><a href="#cb596-2" aria-hidden="true"></a>(integer-length  <span class="dv">1</span>) <span class="op">=&gt;</span> <span class="dv">1</span></span>
<span id="cb596-3"><a href="#cb596-3" aria-hidden="true"></a>(integer-length <span class="dv">-1</span>) <span class="op">=&gt;</span> <span class="dv">0</span></span>
<span id="cb596-4"><a href="#cb596-4" aria-hidden="true"></a>(integer-length  <span class="dv">7</span>) <span class="op">=&gt;</span> <span class="dv">3</span></span>
<span id="cb596-5"><a href="#cb596-5" aria-hidden="true"></a>(integer-length <span class="dv">-7</span>) <span class="op">=&gt;</span> <span class="dv">3</span></span>
<span id="cb596-6"><a href="#cb596-6" aria-hidden="true"></a>(integer-length  <span class="dv">8</span>) <span class="op">=&gt;</span> <span class="dv">4</span></span>
<span id="cb596-7"><a href="#cb596-7" aria-hidden="true"></a>(integer-length <span class="dv">-8</span>) <span class="op">=&gt;</span> <span class="dv">3</span></span></code></pre></div>
<h2 id="bitwise-if-mask-i-j"><code>(bitwise-if mask i j)</code></h2>
<p>Merge the bitstrings i and j, with bitstring mask determining from which string to take each bit. That is, if the kth bit of mask is 1, then the kth bit of the result is the kth bit of i, otherwise the kth bit of j.</p>
<div class="sourceCode" id="cb597"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb597-1"><a href="#cb597-1" aria-hidden="true"></a>(bitwise-if <span class="dv">3</span> <span class="dv">1</span> <span class="dv">8</span>) <span class="op">=&gt;</span> <span class="dv">9</span></span>
<span id="cb597-2"><a href="#cb597-2" aria-hidden="true"></a>(bitwise-if <span class="dv">3</span> <span class="dv">8</span> <span class="dv">1</span>) <span class="op">=&gt;</span> <span class="dv">0</span></span>
<span id="cb597-3"><a href="#cb597-3" aria-hidden="true"></a>(bitwise-if <span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="op">=&gt;</span> <span class="dv">3</span></span>
<span id="cb597-4"><a href="#cb597-4" aria-hidden="true"></a>(bitwise-if <span class="ch">#b</span><span class="dv">00111100</span> <span class="ch">#b</span><span class="dv">11110000</span> <span class="ch">#b</span><span class="dv">00001111</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">00110011</span></span></code></pre></div>
<h2 id="bit-set-index-i"><code>(bit-set? index i)</code></h2>
<p>Is bit index set in bitstring i (where index is a non-negative exact integer)?</p>
<p>Compatibility note: The R6RS analogue bitwise-bit-set? accepts its arguments in the opposite order.</p>
<div class="sourceCode" id="cb598"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb598-1"><a href="#cb598-1" aria-hidden="true"></a>(bit-set? <span class="dv">1</span> <span class="dv">1</span>) <span class="op">=&gt;</span>  false</span>
<span id="cb598-2"><a href="#cb598-2" aria-hidden="true"></a>(bit-set? <span class="dv">0</span> <span class="dv">1</span>) <span class="op">=&gt;</span>  true</span>
<span id="cb598-3"><a href="#cb598-3" aria-hidden="true"></a>(bit-set? <span class="dv">3</span> <span class="dv">10</span>) <span class="op">=&gt;</span>  true</span>
<span id="cb598-4"><a href="#cb598-4" aria-hidden="true"></a>(bit-set? <span class="dv">1000000</span> <span class="dv">-1</span>) <span class="op">=&gt;</span>  true</span>
<span id="cb598-5"><a href="#cb598-5" aria-hidden="true"></a>(bit-set? <span class="dv">2</span> <span class="dv">6</span>) <span class="op">=&gt;</span>  true</span>
<span id="cb598-6"><a href="#cb598-6" aria-hidden="true"></a>(bit-set? <span class="dv">0</span> <span class="dv">6</span>) <span class="op">=&gt;</span>  false</span></code></pre></div>
<h2 id="copy-bit-index-i-boolean"><code>(copy-bit index i boolean)</code></h2>
<p>Returns an integer the same as i except in the indexth bit, which is 1 if boolean is #t and 0 if boolean is #f.</p>
<p>Compatibility note: The R6RS analogue bitwise-copy-bit as originally documented has a completely different interface. (bitwise-copy-bit dest index source) replaces the index’th bit of dest with the index’th bit of source. It is equivalent to (bit-field-replace-same dest source index (+ index 1)). However, an erratum made a silent breaking change to interpret the third argument as 0 for a false bit and 1 for a true bit. Some R6RS implementations applied this erratum but others did not.</p>
<div class="sourceCode" id="cb599"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb599-1"><a href="#cb599-1" aria-hidden="true"></a>(copy-bit <span class="dv">0</span> <span class="dv">0</span> <span class="dv">#t</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">1</span></span>
<span id="cb599-2"><a href="#cb599-2" aria-hidden="true"></a>(copy-bit <span class="dv">2</span> <span class="dv">0</span> <span class="dv">#t</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">100</span></span>
<span id="cb599-3"><a href="#cb599-3" aria-hidden="true"></a>(copy-bit <span class="dv">2</span> <span class="ch">#b</span><span class="dv">1111</span> <span class="dv">#f</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">1011</span></span></code></pre></div>
<h2 id="bit-swap-index1-index2-i"><code>(bit-swap index1 index2 i)</code></h2>
<p>Returns an integer the same as i except that the index1th bit and the index2th bit have been exchanged.</p>
<div class="sourceCode" id="cb600"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb600-1"><a href="#cb600-1" aria-hidden="true"></a>(bit-swap <span class="dv">0</span> <span class="dv">2</span> <span class="dv">4</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">1</span></span></code></pre></div>
<h2 id="any-bit-set-test-bits-i"><code>(any-bit-set? test-bits i)</code></h2>
<h2 id="every-bit-set-test-bits-i"><code>(every-bit-set? test-bits i)</code></h2>
<p>Determines if any/all of the bits set in bitstring test-bits are set in bitstring i. I.e., returns (not (zero? (bitwise-and test-bits i))) and (= test-bits (bitwise-and test-bits i))) respectively.</p>
<div class="sourceCode" id="cb601"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb601-1"><a href="#cb601-1" aria-hidden="true"></a>(any-bit-set? <span class="dv">3</span> <span class="dv">6</span>) <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb601-2"><a href="#cb601-2" aria-hidden="true"></a>(any-bit-set? <span class="dv">3</span> <span class="dv">12</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb601-3"><a href="#cb601-3" aria-hidden="true"></a>(every-bit-set? <span class="dv">4</span> <span class="dv">6</span>) <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb601-4"><a href="#cb601-4" aria-hidden="true"></a>(every-bit-set? <span class="dv">7</span> <span class="dv">6</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="first-set-bit-i"><code>(first-set-bit i)</code></h2>
<p>Return the index of the first (smallest index) 1 bit in bitstring i. Return -1 if i contains no 1 bits (i.e., if i is zero).</p>
<div class="sourceCode" id="cb602"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb602-1"><a href="#cb602-1" aria-hidden="true"></a>(first-set-bit <span class="dv">1</span>) <span class="op">=&gt;</span> <span class="dv">0</span></span>
<span id="cb602-2"><a href="#cb602-2" aria-hidden="true"></a>(first-set-bit <span class="dv">2</span>) <span class="op">=&gt;</span> <span class="dv">1</span></span>
<span id="cb602-3"><a href="#cb602-3" aria-hidden="true"></a>(first-set-bit <span class="dv">0</span>) <span class="op">=&gt;</span> <span class="dv">-1</span></span>
<span id="cb602-4"><a href="#cb602-4" aria-hidden="true"></a>(first-set-bit <span class="dv">40</span>) <span class="op">=&gt;</span> <span class="dv">3</span></span>
<span id="cb602-5"><a href="#cb602-5" aria-hidden="true"></a>(first-set-bit <span class="dv">-28</span>) <span class="op">=&gt;</span> <span class="dv">2</span></span>
<span id="cb602-6"><a href="#cb602-6" aria-hidden="true"></a>(first-set-bit (<span class="kw">expt</span>  <span class="dv">2</span> <span class="dv">99</span>)) <span class="op">=&gt;</span> <span class="dv">99</span></span>
<span id="cb602-7"><a href="#cb602-7" aria-hidden="true"></a>(first-set-bit (<span class="kw">expt</span> <span class="dv">-2</span> <span class="dv">99</span>)) <span class="op">=&gt;</span> <span class="dv">99</span></span></code></pre></div>
<h2 id="bit-field-i-start-end"><code>(bit-field i start end)</code></h2>
<p>Returns the field from i, shifted down to the least-significant position in the result.</p>
<div class="sourceCode" id="cb603"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb603-1"><a href="#cb603-1" aria-hidden="true"></a>(bit-field <span class="ch">#b</span><span class="dv">1101101010</span> <span class="dv">0</span> <span class="dv">4</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">1010</span></span>
<span id="cb603-2"><a href="#cb603-2" aria-hidden="true"></a>(bit-field <span class="ch">#b</span><span class="dv">1101101010</span> <span class="dv">3</span> <span class="dv">9</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">101101</span></span>
<span id="cb603-3"><a href="#cb603-3" aria-hidden="true"></a>(bit-field <span class="ch">#b</span><span class="dv">1101101010</span> <span class="dv">4</span> <span class="dv">9</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">10110</span></span>
<span id="cb603-4"><a href="#cb603-4" aria-hidden="true"></a>(bit-field <span class="ch">#b</span><span class="dv">1101101010</span> <span class="dv">4</span> <span class="dv">10</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">110110</span></span>
<span id="cb603-5"><a href="#cb603-5" aria-hidden="true"></a>(bit-field <span class="dv">6</span> <span class="dv">0</span> <span class="dv">1</span>) <span class="op">=&gt;</span> <span class="dv">0</span></span>
<span id="cb603-6"><a href="#cb603-6" aria-hidden="true"></a>(bit-field <span class="dv">6</span> <span class="dv">1</span> <span class="dv">3</span>) <span class="op">=&gt;</span> <span class="dv">3</span></span>
<span id="cb603-7"><a href="#cb603-7" aria-hidden="true"></a>(bit-field <span class="dv">6</span> <span class="dv">2</span> <span class="dv">999</span>) <span class="op">=&gt;</span> <span class="dv">1</span></span>
<span id="cb603-8"><a href="#cb603-8" aria-hidden="true"></a>(bit-field <span class="ch">#x</span><span class="dv">100000000000000000000000000000000</span> <span class="dv">128</span> <span class="dv">129</span>) <span class="op">=&gt;</span> <span class="dv">1</span></span></code></pre></div>
<h2 id="bit-field-any-i-start-end"><code>(bit-field-any? i start end)</code></h2>
<p>Returns true if any of the field’s bits are set in bitstring i, and false otherwise.</p>
<div class="sourceCode" id="cb604"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb604-1"><a href="#cb604-1" aria-hidden="true"></a>(bit-field-any? <span class="ch">#b</span><span class="dv">1001001</span> <span class="dv">1</span> <span class="dv">6</span>) <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb604-2"><a href="#cb604-2" aria-hidden="true"></a>(bit-field-any? <span class="ch">#b</span><span class="dv">1000001</span> <span class="dv">1</span> <span class="dv">6</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="bit-field-every-i-start-end"><code>(bit-field-every? i start end)</code></h2>
<p>Returns false if any of the field’s bits are not set in bitstring i, and true otherwise.</p>
<div class="sourceCode" id="cb605"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb605-1"><a href="#cb605-1" aria-hidden="true"></a>(bit-field-every? <span class="ch">#b</span><span class="dv">1011110</span> <span class="dv">1</span> <span class="dv">5</span>) <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb605-2"><a href="#cb605-2" aria-hidden="true"></a>(bit-field-every? <span class="ch">#b</span><span class="dv">1011010</span> <span class="dv">1</span> <span class="dv">5</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="bit-field-clear-i-start-end"><code>(bit-field-clear i start end)</code></h2>
<h2 id="bit-field-set-i-start-end"><code>(bit-field-set i start end)</code></h2>
<p>Returns i with the field’s bits set to all 0s/1s.</p>
<div class="sourceCode" id="cb606"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb606-1"><a href="#cb606-1" aria-hidden="true"></a>(bit-field-clear <span class="ch">#b</span><span class="dv">101010</span> <span class="dv">1</span> <span class="dv">4</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">100000</span></span>
<span id="cb606-2"><a href="#cb606-2" aria-hidden="true"></a>(bit-field-set <span class="ch">#b</span><span class="dv">101010</span> <span class="dv">1</span> <span class="dv">4</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">101110</span></span></code></pre></div>
<h2 id="bit-field-replace-dest-source-start-end"><code>(bit-field-replace dest source start end)</code></h2>
<p>Returns dest with the field replaced by the least-significant end-start bits in source.</p>
<div class="sourceCode" id="cb607"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb607-1"><a href="#cb607-1" aria-hidden="true"></a>(bit-field-replace <span class="ch">#b</span><span class="dv">101010</span> <span class="ch">#b</span><span class="dv">010</span> <span class="dv">1</span> <span class="dv">4</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">100100</span></span>
<span id="cb607-2"><a href="#cb607-2" aria-hidden="true"></a>(bit-field-replace <span class="ch">#b</span><span class="dv">110</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">1</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">111</span></span>
<span id="cb607-3"><a href="#cb607-3" aria-hidden="true"></a>(bit-field-replace <span class="ch">#b</span><span class="dv">110</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">110</span></span></code></pre></div>
<h2 id="bit-field-replace-same-dest-source-start-end"><code>(bit-field-replace-same dest source start end)</code></h2>
<p>Returns dest with its field replaced by the corresponding field in source.</p>
<div class="sourceCode" id="cb608"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb608-1"><a href="#cb608-1" aria-hidden="true"></a>(bit-field-replace-same <span class="ch">#b</span><span class="dv">1111</span> <span class="ch">#b</span><span class="dv">0000</span> <span class="dv">1</span> <span class="dv">3</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">1001</span></span></code></pre></div>
<h2 id="bit-field-rotate-i-count-start-end"><code>(bit-field-rotate i count start end)</code></h2>
<p>Returns i with the field cyclically permuted by count bits towards high-order.</p>
<p>Compatibility note: The R6RS analogue bitwise-rotate-bit-field uses the argument ordering i start end count.</p>
<div class="sourceCode" id="cb609"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb609-1"><a href="#cb609-1" aria-hidden="true"></a>(bit-field-rotate <span class="ch">#b</span><span class="dv">110</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">10</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">110</span></span>
<span id="cb609-2"><a href="#cb609-2" aria-hidden="true"></a>(bit-field-rotate <span class="ch">#b</span><span class="dv">110</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">256</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">110</span></span>
<span id="cb609-3"><a href="#cb609-3" aria-hidden="true"></a>(bit-field-rotate <span class="ch">#x</span><span class="dv">100000000000000000000000000000000</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">129</span>) <span class="op">=&gt;</span> <span class="dv">1</span></span>
<span id="cb609-4"><a href="#cb609-4" aria-hidden="true"></a>(bit-field-rotate <span class="ch">#b</span><span class="dv">110</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">110</span></span>
<span id="cb609-5"><a href="#cb609-5" aria-hidden="true"></a>(bit-field-rotate <span class="ch">#b</span><span class="dv">110</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">1010</span></span>
<span id="cb609-6"><a href="#cb609-6" aria-hidden="true"></a>(bit-field-rotate <span class="ch">#b</span><span class="dv">0111</span> <span class="dv">-1</span> <span class="dv">1</span> <span class="dv">4</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">1011</span></span></code></pre></div>
<h2 id="bit-field-reverse-i-start-end"><code>(bit-field-reverse i start end)</code></h2>
<p>Returns i with the order of the bits in the field reversed.</p>
<div class="sourceCode" id="cb610"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb610-1"><a href="#cb610-1" aria-hidden="true"></a>(bit-field-reverse <span class="dv">6</span> <span class="dv">1</span> <span class="dv">3</span>) <span class="op">=&gt;</span> <span class="dv">6</span></span>
<span id="cb610-2"><a href="#cb610-2" aria-hidden="true"></a>(bit-field-reverse <span class="dv">6</span> <span class="dv">1</span> <span class="dv">4</span>) <span class="op">=&gt;</span> <span class="dv">12</span></span>
<span id="cb610-3"><a href="#cb610-3" aria-hidden="true"></a>(bit-field-reverse <span class="dv">1</span> <span class="dv">0</span> <span class="dv">32</span>) <span class="op">=&gt;</span> <span class="ch">#x</span><span class="dv">80000000</span></span>
<span id="cb610-4"><a href="#cb610-4" aria-hidden="true"></a>(bit-field-reverse <span class="dv">1</span> <span class="dv">0</span> <span class="dv">31</span>) <span class="op">=&gt;</span> <span class="ch">#x</span><span class="dv">40000000</span></span>
<span id="cb610-5"><a href="#cb610-5" aria-hidden="true"></a>(bit-field-reverse <span class="dv">1</span> <span class="dv">0</span> <span class="dv">30</span>) <span class="op">=&gt;</span> <span class="ch">#x</span><span class="dv">20000000</span></span>
<span id="cb610-6"><a href="#cb610-6" aria-hidden="true"></a>(bit-field-reverse <span class="ch">#x</span><span class="dv">140000000000000000000000000000000</span> <span class="dv">0</span> <span class="dv">129</span>) <span class="op">=&gt;</span> <span class="dv">5</span></span></code></pre></div>
<h2 id="bits-list-i-len"><code>(bits-&gt;list i [ len ])</code></h2>
<h2 id="bits-vector-i-len"><code>(bits-&gt;vector i [ len ])</code></h2>
<p>Returns a list/vector of len booleans corresponding to each bit of the non-negative integer i, returning bit #0 as the first element, bit #1 as the second, and so on. #t is returned for each 1; #f for 0.</p>
<div class="sourceCode" id="cb611"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb611-1"><a href="#cb611-1" aria-hidden="true"></a>(bits-&gt;list <span class="ch">#b</span><span class="dv">1110101</span>)) <span class="op">=&gt;</span> (<span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)</span>
<span id="cb611-2"><a href="#cb611-2" aria-hidden="true"></a>(bits-&gt;list <span class="dv">3</span> <span class="dv">5</span>)) <span class="op">=&gt;</span> (<span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#f</span>)</span>
<span id="cb611-3"><a href="#cb611-3" aria-hidden="true"></a>(bits-&gt;list <span class="dv">6</span> <span class="dv">4</span>)) <span class="op">=&gt;</span> (<span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#f</span>)</span>
<span id="cb611-4"><a href="#cb611-4" aria-hidden="true"></a></span>
<span id="cb611-5"><a href="#cb611-5" aria-hidden="true"></a>(bits-&gt;vector <span class="ch">#b</span><span class="dv">1110101</span>)) <span class="op">=&gt;</span> #(<span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)</span></code></pre></div>
<h2 id="list-bits-list"><code>(list-&gt;bits list)</code></h2>
<h2 id="vector-bits-vector"><code>(vector-&gt;bits vector)</code></h2>
<p>Returns an integer formed from the booleans in list/vector, using the first element as bit #0, the second element as bit #1, and so on. It is an error if list/vector contains non-booleans. A 1 bit is coded for each #t; a 0 bit for #f. Note that the result is never a negative integer.</p>
<div class="sourceCode" id="cb612"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb612-1"><a href="#cb612-1" aria-hidden="true"></a>(list-&gt;bits &#39;(<span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">1110101</span></span>
<span id="cb612-2"><a href="#cb612-2" aria-hidden="true"></a>(list-&gt;bits &#39;(<span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">111010100</span></span>
<span id="cb612-3"><a href="#cb612-3" aria-hidden="true"></a>(list-&gt;bits &#39;(<span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="op">=&gt;</span> <span class="dv">6</span></span>
<span id="cb612-4"><a href="#cb612-4" aria-hidden="true"></a>(list-&gt;bits &#39;(<span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#f</span>)) <span class="op">=&gt;</span> <span class="dv">6</span></span>
<span id="cb612-5"><a href="#cb612-5" aria-hidden="true"></a>(list-&gt;bits &#39;(<span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="op">=&gt;</span> <span class="dv">12</span></span>
<span id="cb612-6"><a href="#cb612-6" aria-hidden="true"></a></span>
<span id="cb612-7"><a href="#cb612-7" aria-hidden="true"></a>(vector-&gt;bits &#39;#(<span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">1110101</span></span>
<span id="cb612-8"><a href="#cb612-8" aria-hidden="true"></a>(vector-&gt;bits &#39;#(<span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">111010100</span></span>
<span id="cb612-9"><a href="#cb612-9" aria-hidden="true"></a>(vector-&gt;bits &#39;#(<span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="op">=&gt;</span> <span class="dv">6</span></span>
<span id="cb612-10"><a href="#cb612-10" aria-hidden="true"></a>(vector-&gt;bits &#39;#(<span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#f</span>)) <span class="op">=&gt;</span> <span class="dv">6</span></span>
<span id="cb612-11"><a href="#cb612-11" aria-hidden="true"></a>(vector-&gt;bits &#39;#(<span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="op">=&gt;</span> <span class="dv">12</span></span></code></pre></div>
<p>For positive integers, bits-&gt;list and list-&gt;bits are inverses in the sense of equal?, and so are bits-&gt;vector and vector-&gt;bits.</p>
<h2 id="bits-bool-..."><code>(bits bool ...)</code></h2>
<p>Returns the integer coded by the bool arguments. The first argument is bit #0, the second argument is bit #1, and so on. Note that the result is never a negative integer.</p>
<div class="sourceCode" id="cb613"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb613-1"><a href="#cb613-1" aria-hidden="true"></a>(bits <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">1110101</span></span>
<span id="cb613-2"><a href="#cb613-2" aria-hidden="true"></a>(bits <span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">111010100</span></span></code></pre></div>
<h2 id="bitwise-fold-proc-seed-i"><code>(bitwise-fold proc seed i)</code></h2>
<p>For each bit b of i from bit #0 (inclusive) to bit (integer-length i) (exclusive), proc is called as (proc b r), where r is the current accumulated result. The initial value of r is seed, and the value returned by proc becomes the next accumulated result. When the last bit has been processed, the final accumulated result becomes the result of bitwise-fold.</p>
<div class="sourceCode" id="cb614"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb614-1"><a href="#cb614-1" aria-hidden="true"></a>(bitwise-fold <span class="kw">cons</span> &#39;() <span class="ch">#b</span><span class="dv">1010111</span>) <span class="op">=&gt;</span> (<span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)</span></code></pre></div>
<h2 id="bitwise-for-each-proc-i"><code>(bitwise-for-each proc i)</code></h2>
<p>Repeatedly applies proc to the bits of i starting with bit #0 (inclusive) and ending with bit (integer-length i) (exclusive). The values returned by proc are discarded. Returns an unspecified value.</p>
<div class="sourceCode" id="cb615"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb615-1"><a href="#cb615-1" aria-hidden="true"></a>      (<span class="kw">let</span> ((count <span class="dv">0</span>))</span>
<span id="cb615-2"><a href="#cb615-2" aria-hidden="true"></a>        (bitwise-for-each (<span class="kw">lambda</span> (b) (<span class="kw">if</span> b (set! count (<span class="op">+</span> count <span class="dv">1</span>))))</span>
<span id="cb615-3"><a href="#cb615-3" aria-hidden="true"></a>                          <span class="ch">#b</span><span class="dv">1010111</span>)</span>
<span id="cb615-4"><a href="#cb615-4" aria-hidden="true"></a>       count)</span></code></pre></div>
<h2 id="bitwise-unfold-stop-mapper-successor-seed"><code>(bitwise-unfold stop? mapper successor seed)</code></h2>
<p>Generates a non-negative integer bit by bit, starting with bit 0. If the result of applying stop? to the current state (whose initial value is seed) is true, return the currently accumulated bits as an integer. Otherwise, apply mapper to the current state to obtain the next bit of the result by interpreting a true value as a 1 bit and a false value as a 0 bit. Then get a new state by applying successor to the current state, and repeat this algorithm.</p>
<div class="sourceCode" id="cb616"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb616-1"><a href="#cb616-1" aria-hidden="true"></a>  (bitwise-unfold (<span class="kw">lambda</span> (i) (<span class="op">=</span> i <span class="dv">10</span>))</span>
<span id="cb616-2"><a href="#cb616-2" aria-hidden="true"></a>                  <span class="kw">even?</span></span>
<span id="cb616-3"><a href="#cb616-3" aria-hidden="true"></a>                  (<span class="kw">lambda</span> (i) (<span class="op">+</span> i <span class="dv">1</span>))</span>
<span id="cb616-4"><a href="#cb616-4" aria-hidden="true"></a>                  <span class="dv">0</span>)) <span class="op">=&gt;</span> <span class="ch">#b</span><span class="dv">101010101</span></span></code></pre></div>
<h2 id="make-bitwise-generator-i"><code>(make-bitwise-generator i)</code></h2>
<p>Returns a SRFI 121 generator that generates all the bits of i starting with bit #0. Note that the generator is infinite.</p>
<div class="sourceCode" id="cb617"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb617-1"><a href="#cb617-1" aria-hidden="true"></a>(<span class="kw">let</span> ((g (make-bitwise-generator <span class="ch">#b</span><span class="dv">110</span>)))</span>
<span id="cb617-2"><a href="#cb617-2" aria-hidden="true"></a>  (test <span class="dv">#f</span> (g))</span>
<span id="cb617-3"><a href="#cb617-3" aria-hidden="true"></a>  (test <span class="dv">#t</span> (g))</span>
<span id="cb617-4"><a href="#cb617-4" aria-hidden="true"></a>  (test <span class="dv">#t</span> (g))</span>
<span id="cb617-5"><a href="#cb617-5" aria-hidden="true"></a>  (test <span class="dv">#f</span> (g)))</span></code></pre></div>
<h1 id="scheme-sort"><code>(scheme sort)</code></h1>
<p>This is based on <a href="https://srfi.schemers.org/srfi-132/">SRFI-132</a>.</p>
<p>This library describes the API for a full-featured sort toolkit.</p>
<h2 id="list-sorted-lis"><code>(list-sorted? &lt; lis)</code></h2>
<h2 id="vector-sorted-v-start-end"><code>(vector-sorted? &lt; v [start [ end ] ]</code></h2>
<p>These procedures return true iff their input list or vector is in sorted order, as determined by &lt;. Specifically, they return #f iff there is an adjacent pair … X Y … in the input list or vector such that Y &lt; X in the sense of &lt;. The optional start and end range arguments restrict vector-sorted? to examining the indicated subvector.</p>
<p>These procedures are equivalent to the SRFI 95 sorted? procedure when applied to lists or vectors respectively, except that they do not accept a key procedure.</p>
<h2 id="list-sort-lis"><code>(list-sort &lt; lis)</code></h2>
<h2 id="list-stable-sort-lis"><code>(list-stable-sort &lt; lis)</code></h2>
<p>These procedures do not alter their inputs, but are allowed to return a value that shares a common tail with a list argument.</p>
<p>The list-stable-sort procedure is equivalent to the R6RS list-sort procedure. It is also equivalent to the SRFI 95 sort procedure when applied to lists, except that it does not accept a key procedure.</p>
<h2 id="list-sort-lis-1"><code>(list-sort! &lt; lis)</code></h2>
<h2 id="list-stable-sort-lis-1"><code>(list-stable-sort! &lt; lis)</code></h2>
<p>These procedures are linear update operators — they are allowed, but not required, to alter the cons cells of their arguments to produce their results. They return a sorted list containing the same elements as lis.</p>
<p>The list-stable-sort! procedure is equivalent to the SRFI 95 sort! procedure when applied to lists, except that it does not accept a key procedure.</p>
<h2 id="vector-sort-v-start-end"><code>(vector-sort &lt; v [ start [ end ] ])</code></h2>
<h2 id="vector-stable-sort-v-start-end"><code>(vector-stable-sort &lt; v [ start [ end ] ])</code></h2>
<p>These procedures do not alter their inputs, but allocate a fresh vector as their result, of length end - start. The vector-stable-sort procedure with no optional arguments is equivalent to the R6RS vector-sort procedure. It is also equivalent to the SRFI 95 sort procedure when applied to vectors, except that it does not accept a key procedure.</p>
<h2 id="vector-sort-v-start-end-1"><code>(vector-sort! &lt; v [ start [ end ] ])</code></h2>
<h2 id="vector-stable-sort-v-start-end-1"><code>(vector-stable-sort! &lt; v [ start [ end ] ])</code></h2>
<p>These procedures sort their data in-place. (But note that vector-stable-sort! may allocate temporary storage proportional to the size of the input — there are no known O(n lg n) stable vector sorting algorithms that run in constant space.) They return an unspecified value.</p>
<p>The vector-sort! procedure with no optional arguments is equivalent to the R6RS vector-sort! procedure.</p>
<h2 id="list-merge-lis1-lis2"><code>(list-merge &lt; lis1 lis2)</code></h2>
<p>This procedure does not alter its inputs, and is allowed to return a value that shares a common tail with a list argument.</p>
<p>This procedure is equivalent to the SRFI 95 merge procedure when applied to lists, except that it does not accept a key procedure.</p>
<h2 id="list-merge-lis1-lis2-1"><code>(list-merge! &lt; lis1 lis2)</code></h2>
<p>This procedure makes only a single, iterative, linear-time pass over its argument lists, using set-cdr!s to rearrange the cells of the lists into the list that is returned — it works “in place.” Hence, any cons cell appearing in the result must have originally appeared in an input. It returns the sorted input.</p>
<p>Additionally, list-merge! is iterative, not recursive — it can operate on arguments of arbitrary size without requiring an unbounded amount of stack space. The intent of this iterative-algorithm commitment is to allow the programmer to be sure that if, for example, list-merge! is asked to merge two ten-million-element lists, the operation will complete without performing some extremely (possibly twenty-million) deep recursion.</p>
<p>This procedure is equivalent to the SRFI 95 merge! procedure when applied to lists, except that it does not accept a key procedure.</p>
<h2 id="vector-merge-v1-v2-start1-end1-start2-end2"><code>(vector-merge &lt; v1 v2 [ start1 [ end1 [ start2 [ end2 ] ] ] ])</code></h2>
<p>This procedure does not alter its inputs, and returns a newly allocated vector of length (end1 - start1) + (end2 - start2).</p>
<p>This procedure is equivalent to the SRFI 95 merge procedure when applied to vectors, except that it does not accept a key procedure.</p>
<h2 id="vector-merge-to-from1-from2-start-start1-end1-start2-end2"><code>(vector-merge! &lt; to from1 from2 [ start [ start1 [ end1 [ start2 [ end2 ] ] ] ] ])</code></h2>
<p>This procedure writes its result into vector to, beginning at index start, for indices less than end, which is defined as start + (end1 - start1) + (end2 - start2). The target subvector to[start, end) may not overlap either of the source subvectors from1[start1, end1] and from2[start2, end2]. It returns an unspecified value.</p>
<p>This procedure is equivalent to the SRFI 95 merge! procedure when applied to lists, except that it does not accept a key procedure.</p>
<h2 id="list-delete-neighbor-dups-lis"><code>(list-delete-neighbor-dups = lis)</code></h2>
<p>This procedure does not alter its input list, but its result may share storage with the input list.</p>
<h2 id="list-delete-neighbor-dups-lis-1"><code>(list-delete-neighbor-dups! = lis)</code></h2>
<p>This procedure mutates its input list in order to construct its result. It makes only a single, iterative, linear-time pass over its argument, using set-cdr!s to rearrange the cells of the list into the final result — it works “in place.” Hence, any cons cell appearing in the result must have originally appeared in the input.</p>
<h2 id="vector-delete-neighbor-dups-v-start-end"><code>(vector-delete-neighbor-dups = v [ start [ end ] ])</code></h2>
<p>This procedure does not alter its input vector, but rather newly allocates and returns a vector to hold the result.</p>
<h2 id="vector-delete-neighbor-dups-v-start-end-1"><code>(vector-delete-neighbor-dups! = v [ start [ end ] ])</code></h2>
<p>This procedure reuses its input vector to hold the answer, packing it into the index range [start, newend), where newend is the non-negative exact integer that is returned as its value. The vector is not altered outside the range [start, newend).</p>
<p>Examples:</p>
<div class="sourceCode" id="cb618"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb618-1"><a href="#cb618-1" aria-hidden="true"></a>    (list-delete-neighbor-dups <span class="op">=</span> &#39;(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">7</span> <span class="dv">7</span> <span class="dv">7</span> <span class="dv">0</span> <span class="dv">-2</span> <span class="dv">-2</span>))</span>
<span id="cb618-2"><a href="#cb618-2" aria-hidden="true"></a>               <span class="op">=&gt;</span> (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">7</span> <span class="dv">0</span> <span class="dv">-2</span>)</span>
<span id="cb618-3"><a href="#cb618-3" aria-hidden="true"></a></span>
<span id="cb618-4"><a href="#cb618-4" aria-hidden="true"></a>    (vector-delete-neighbor-dups <span class="op">=</span> &#39;#(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">7</span> <span class="dv">7</span> <span class="dv">7</span> <span class="dv">0</span> <span class="dv">-2</span> <span class="dv">-2</span>))</span>
<span id="cb618-5"><a href="#cb618-5" aria-hidden="true"></a>               <span class="op">=&gt;</span> #(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">7</span> <span class="dv">0</span> <span class="dv">-2</span>)</span>
<span id="cb618-6"><a href="#cb618-6" aria-hidden="true"></a></span>
<span id="cb618-7"><a href="#cb618-7" aria-hidden="true"></a>    (vector-delete-neighbor-dups <span class="op">&lt;</span> &#39;#(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">7</span> <span class="dv">7</span> <span class="dv">7</span> <span class="dv">0</span> <span class="dv">-2</span> <span class="dv">-2</span>) <span class="dv">3</span> <span class="dv">7</span>))</span>
<span id="cb618-8"><a href="#cb618-8" aria-hidden="true"></a>               <span class="op">=&gt;</span> #(<span class="dv">7</span> <span class="dv">0</span> <span class="dv">-2</span>)</span>
<span id="cb618-9"><a href="#cb618-9" aria-hidden="true"></a></span>
<span id="cb618-10"><a href="#cb618-10" aria-hidden="true"></a><span class="co">;; Result left in v[3,9):</span></span>
<span id="cb618-11"><a href="#cb618-11" aria-hidden="true"></a>(<span class="kw">let</span> ((v (<span class="kw">vector</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">6</span>)))</span>
<span id="cb618-12"><a href="#cb618-12" aria-hidden="true"></a>  (<span class="kw">cons</span> (vector-delete-neighbor-dups! <span class="op">&lt;</span> v <span class="dv">3</span>)</span>
<span id="cb618-13"><a href="#cb618-13" aria-hidden="true"></a>        v))</span>
<span id="cb618-14"><a href="#cb618-14" aria-hidden="true"></a>              <span class="op">=&gt;</span> (<span class="dv">9</span> . #(<span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">4</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">6</span>))</span></code></pre></div>
<h2 id="vector-find-median-v-knil-mean"><code>(vector-find-median &lt; v knil [ mean ])</code></h2>
<p>This procedure does not alter its input vector, but rather newly allocates a vector to hold the intermediate result. Runs in O(n) time.</p>
<h2 id="vector-find-median-v-knil-mean-1"><code>(vector-find-median! &lt; v knil [ mean ])</code></h2>
<p>This procedure reuses its input vector to hold the intermediate result, leaving it sorted, but is otherwise the same as vector-find-median. Runs in O(n ln n) time.</p>
<h2 id="vector-select-v-k-start-end"><code>(vector-select! &lt; v k [ start [ end ] ] )</code></h2>
<p>This procedure returns the kth smallest element (in the sense of the &lt; argument) of the region of a vector between start and end. Elements within the range may be reordered, whereas those outside the range are left alone. Runs in O(n) time.</p>
<h2 id="vector-separate-v-k-start-end"><code>(vector-separate! &lt; v k [ start [ end ] ] )</code></h2>
<p>This procedure places the smallest k elements (in the sense of the &lt; argument) of the region of a vector between start and end into the first k positions of that range, and the remaining elements into the remaining positions. Otherwise, the elements are not in any particular order. Elements outside the range are left alone. Runs in O(n) time. Returns an unspecified value.</p>
<h1 id="scheme-box"><code>(scheme box)</code></h1>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-111/">SRFI-111</a>.</p>
<p>Boxes are objects with a single mutable state. Several Schemes have them, sometimes called cells. A constructor, predicate, accessor, and mutator are provided.</p>
<h2 id="box-value"><code>(box value)</code></h2>
<p>Constructor. Returns a newly allocated box initialized to value.</p>
<h2 id="box-object"><code>(box? object)</code></h2>
<p>Predicate. Returns <code>#t</code> if object is a box, and <code>#f</code> otherwise.</p>
<h2 id="unbox-box"><code>(unbox box)</code></h2>
<p>Accessor. Returns the current value of box.</p>
<h2 id="set-box-box-value"><code>(set-box! box value)</code></h2>
<p>Mutator. Changes box to hold value. # <code>(scheme mapping)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-146/">SRFI-146</a>.</p>
<p>Mappings are finite sets of associations, where each association is a pair consisting of a key and an arbitrary Scheme value. The keys are elements of a suitable domain. Each mapping holds no more than one association with the same key. The fundamental mapping operation is retrieving the value of an association stored in the mapping when the key is given.</p>
<h2 id="mapping-comparator-key-value-..."><code>(mapping comparator [key value] ...)</code></h2>
<p>Returns a newly allocated mapping. The comparator argument is used to control and distinguish the keys of the mapping. The args alternate between keys and values and are used to initialize the mapping. In particular, the number of args has to be even. Earlier associations with equal keys take precedence over later arguments.</p>
<h2 id="mapping-unfold-stop-mapper-successor-seed-comparator"><code>(mapping-unfold stop? mapper successor seed comparator)</code></h2>
<p>Create a newly allocated mapping as if by mapping using comparator. If the result of applying the predicate stop? to seed is true, return the mapping. Otherwise, apply the procedure mapper to seed. Mapper returns two values which are added to the mapping as the key and the value, respectively. Then get a new seed by applying the procedure successor to seed, and repeat this algorithm. Associations earlier in the list take precedence over those that come later.</p>
<h2 id="mappingordered"><code>(mapping/ordered)</code></h2>
<h2 id="mapping-unfoldordered"><code>(mapping-unfold/ordered</code></h2>
<p>These are the same as mapping and mapping-unfold, except that it is an error if the keys are not in order, and they may be more efficient.</p>
<h2 id="mapping-obj"><code>(mapping? obj)</code></h2>
<p>Returns #t if obj is a mapping, and #f otherwise.</p>
<h2 id="mapping-contains-mapping-key"><code>(mapping-contains? mapping key)</code></h2>
<p>Returns #t if key is the key of an association of mapping and #f otherwise.</p>
<h2 id="mapping-empty-mapping"><code>(mapping-empty? mapping)</code></h2>
<p>Returns #t if mapping has no associations and #f otherwise.</p>
<h2 id="mapping-disjoint-mapping1-mapping2"><code>(mapping-disjoint? mapping1 mapping2)</code></h2>
<p>Returns #t if mapping1 and mapping2 have no keys in common and #f otherwise.</p>
<h2 id="mapping-ref-mapping-key-failure-success"><code>(mapping-ref mapping key [failure [success]])</code></h2>
<p>Extracts the value associated to key in the mapping mapping, invokes the procedure success in tail context on it, and returns its result; if success is not provided, then the value itself is returned. If key is not contained in mapping and failure is supplied, then failure is invoked in tail context on no arguments and its values are returned. Otherwise, it is an error.</p>
<h2 id="mapping-refdefault-mapping-key-default"><code>(mapping-ref/default mapping key default)</code></h2>
<h2 id="mapping-key-comparator-mapping"><code>(mapping-key-comparator mapping)</code></h2>
<p>Returns the comparator used to compare the keys of the mapping mapping.</p>
<h2 id="mapping-adjoin-mapping-arg-..."><code>(mapping-adjoin mapping arg ...)</code></h2>
<p>The mapping-adjoin procedure returns a newly allocated mapping that uses the same comparator as the mapping mapping and contains all the associations of mapping, and in addition new associations by processing the arguments from left to right. The args alternate between keys and values. Whenever there is a previous association for a key, the previous association prevails and the new association is skipped. It is an error to add an association to mapping whose key that does not return #t when passed to the type test procedure of the comparator.</p>
<h2 id="mapping-adjoin-mapping-arg-...-1"><code>(mapping-adjoin! mapping arg ...)</code></h2>
<p>The mapping-adjoin! procedure is the same as mapping-adjoin, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h2 id="mapping-set-mapping-arg-..."><code>(mapping-set mapping arg ...)</code></h2>
<p>The mapping-set procedure returns a newly allocated mapping that uses the same comparator as the mapping mapping and contains all the associations of mapping, and in addition new associations by processing the arguments from left to right. The args alternate between keys and values. Whenever there is a previous association for a key, it is deleted. It is an error to add an association to mapping whose key that does not return #t when passed to the type test procedure of the comparator.</p>
<h2 id="mapping-set-mapping-arg-...-1"><code>(mapping-set! mapping arg ...)</code></h2>
<p>The mapping-set! procedure is the same as mapping-set, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h2 id="mapping-replace-mapping-key-value"><code>(mapping-replace mapping key value)</code></h2>
<p>The mapping-replace procedure returns a newly allocated mapping that uses the same comparator as the mapping mapping and contains all the associations of mapping except as follows: If key is equal (in the sense of mapping’s comparator) to an existing key of mapping, then the association for that key is omitted and replaced the association defined by the pair key and value. If there is no such key in mapping, then mapping is returned unchanged.</p>
<h2 id="mapping-replace-mapping-key-value-1"><code>(mapping-replace! mapping key value)</code></h2>
<p>The mapping-replace! procedure is the same as mapping-replace, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h2 id="mapping-delete-mapping-key-..."><code>(mapping-delete mapping key ...)</code></h2>
<h2 id="mapping-delete-mapping-key-...-1"><code>(mapping-delete! mapping key ...)</code></h2>
<h2 id="mapping-delete-all-mapping-key-list"><code>(mapping-delete-all mapping key-list)</code></h2>
<h2 id="mapping-delete-all-mapping-key-list-1"><code>(mapping-delete-all! mapping key-list)</code></h2>
<p>The mapping-delete procedure returns a newly allocated mapping containing all the associations of the mapping mapping except for any whose keys are equal (in the sense of mapping’s comparator) to one or more of the keys. Any key that is not equal to some key of the mapping is ignored.</p>
<p>The mapping-delete! procedure is the same as mapping-delete, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<p>The mapping-delete-all and mapping-delete-all! procedures are the same as mapping-delete and mapping-delete!, respectively, except that they accept a single argument which is a list of keys whose associations are to be deleted.</p>
<h2 id="mapping-intern-mapping-key-failure"><code>(mapping-intern mapping key failure)</code></h2>
<p>Extracts the value associated to key in the mapping mapping, and returns mapping and the value as two values. If key is not contained in mapping, failure is invoked on no arguments. The procedure then returns two values, a newly allocated mapping that uses the same comparator as the mapping and contains all the associations of mapping, and in addition a new association mapping key to the result of invoking failure, and the result of invoking failure.</p>
<h2 id="mapping-intern-mapping-key-failure-1"><code>(mapping-intern! mapping key failure)</code></h2>
<p>The mapping-intern! procedure is the same as mapping-intern, except that it is permitted to mutate and return the mapping argument as its first value rather than allocating a new mapping.</p>
<h2 id="mapping-update-mapping-key-updater-failure-success"><code>(mapping-update mapping key updater [failure [success]])</code></h2>
<h2 id="mapping-update-mapping-key-updater-failure-success-1"><code>(mapping-update! mapping key updater [failure [success]])</code></h2>
<p>The mapping-update! procedure is the same as mapping-update, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h2 id="mapping-updatedefault-mapping-key-updater-default"><code>(mapping-update/default mapping key updater default)</code></h2>
<h2 id="mapping-updatedefault-mapping-key-updater-default-1"><code>(mapping-update!/default mapping key updater default)</code></h2>
<p>The mapping-update!/default procedure is the same as mapping-update/default, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h2 id="mapping-pop-mapping-failure"><code>(mapping-pop mapping [failure])</code></h2>
<p>The mapping-pop procedure exported from (srfi 146) chooses the association with the least key from mapping and returns three values, a newly allocated mapping that uses the same comparator as mapping and contains all associations of mapping except the chosen one, and the key and the value of the chosen association. If mapping contains no association and failure is supplied, then failure is invoked in tail context on no arguments and its values returned. Otherwise, it is an error.</p>
<h2 id="mapping-pop-mapping-failure-1"><code>(mapping-pop! mapping [failure])</code></h2>
<p>The mapping-pop! procedure is the same as mapping-pop, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h2 id="mapping-search-mapping-key-failure-success"><code>(mapping-search mapping key failure success)</code></h2>
<p>The mapping mapping is searched in order (that is in the order of the stored keys) for an association with key key. If it is not found, then the failure procedure is tail-called with two continuation arguments, insert and ignore, and is expected to tail-call one of them. If an association with key key is found, then the success procedure is tail-called with the matching key of mapping, the associated value, and two continuations, update and remove, and is expected to tail-call one of them.</p>
<p>It is an error if the continuation arguments are invoked, but not in tail position in the failure and success procedures. It is also an error if the failure and success procedures return to their implicit continuation without invoking one of their continuation arguments.</p>
<p>The effects of the continuations are as follows (where obj is any Scheme object):</p>
<ul>
<li><p>Invoking (insert value obj) causes a mapping to be newly allocated that uses the same comparator as the mapping mapping and contains all the associations of mapping, and in addition a new association mapping key to value.</p></li>
<li><p>Invoking (ignore obj) has no effects; in particular, no new mapping is allocated (but see below).</p></li>
<li><p>Invoking (update new-key new-value obj) causes a mapping to be newly allocated that uses the same comparator as the mapping and contains all the associations of mapping, except for the association with key key, which is replaced by a new association mapping new-key to new-value.</p></li>
<li><p>Invoking (remove obj) causes a mapping to be newly allocated that uses the same comparator as the mapping and contains all the associations of mapping, except for the association with key key.</p></li>
</ul>
<p>In all cases, two values are returned: the possibly newly allocated mapping and obj.</p>
<h2 id="mapping-search-mapping-key-failure-success-1"><code>(mapping-search! mapping key failure success)</code></h2>
<p>The mapping-search! procedure is the same as mapping-search, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h2 id="mapping-size-mapping"><code>(mapping-size mapping)</code></h2>
<p>Returns the number of associations in mapping as an exact integer.</p>
<h2 id="mapping-find-predicate-mapping-failure"><code>(mapping-find predicate mapping failure)</code></h2>
<p>Returns the association with the least key of the mapping mapping consisting of a key and value as two values such that predicate returns a true value when invoked with key and value as arguments, or the result of tail-calling failure with no arguments if there is none. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h2 id="mapping-count-predicate-mapping"><code>(mapping-count predicate mapping)</code></h2>
<p>Returns the number of associations of the mapping mapping that satisfy predicate (in the sense of mapping-find) as an exact integer. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h2 id="mapping-any-predicate-mapping"><code>(mapping-any? predicate mapping)</code></h2>
<p>Returns #t if any association of the mapping mapping satisfies predicate (in the sense of mapping-find), or #f otherwise. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h2 id="mapping-every-predicate-mapping"><code>(mapping-every? predicate mapping)</code></h2>
<p>Returns #t if every association of the mapping mapping satisfies predicate (in the sense of mapping-find), or #f otherwise. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h2 id="mapping-keys-mapping"><code>(mapping-keys mapping)</code></h2>
<p>Returns a newly allocated list of all the keys in increasing order in the mapping mapping.</p>
<h2 id="mapping-values-mapping"><code>(mapping-values mapping)</code></h2>
<p>Returns a newly allocated list of all the values in increasing order of the keys in the mapping mapping.</p>
<h2 id="mapping-entries-mapping"><code>(mapping-entries mapping)</code></h2>
<p>Returns two values, a newly allocated list of all the keys in the mapping mapping, and a newly allocated list of all the values in the mapping mapping in increasing order of the keys.</p>
<h2 id="mapping-map-proc-comparator-mapping"><code>(mapping-map proc comparator mapping)</code></h2>
<p>Applies proc, which returns two values, on two arguments, the key and value of each association of mapping in increasing order of the keys and returns a newly allocated mapping that uses the comparator comparator, and which contains the results of the applications inserted as keys and values.</p>
<h2 id="mapping-map-list-proc-mapping"><code>(mapping-map-&gt;list proc mapping)</code></h2>
<p>Calls proc for every association in increasing order of the keys in the mapping mapping with two arguments: the key of the association and the value of the association. The values returned by the invocations of proc are accumulated into a list, which is returned.</p>
<h2 id="mapping-for-each-proc-mapping"><code>(mapping-for-each proc mapping)</code></h2>
<p>Invokes proc for every association in the mapping mapping in increasing order of the keys, discarding the returned values, with two arguments: the key of the association and the value of the association. Returns an unspecified value.</p>
<h2 id="mapping-fold-proc-nil-mapping"><code>(mapping-fold proc nil mapping)</code></h2>
<p>Invokes proc for each association of the mapping mapping in increasing order of the keys with three arguments: the key of the association, the value of the association, and an accumulated result of the previous invocation. For the first invocation, nil is used as the third argument. Returns the result of the last invocation, or nil if there was no invocation.</p>
<h2 id="mapping-filter-predicate-mapping"><code>(mapping-filter predicate mapping)</code></h2>
<p>Returns a newly allocated mapping with the same comparator as the mapping mapping, containing just the associations of mapping that satisfy predicate (in the sense of mapping-find).</p>
<h2 id="mapping-filter-predicate-mapping-1"><code>(mapping-filter! predicate mapping)</code></h2>
<p>A linear update procedure that returns a mapping containing just the associations of mapping that satisfy predicate.</p>
<h2 id="mapping-remove-predicate-mapping"><code>(mapping-remove predicate mapping)</code></h2>
<p>Returns a newly allocated mapping with the same comparator as the mapping mapping, containing just the associations of mapping that do not satisfy predicate (in the sense of mapping-find).</p>
<h2 id="mapping-remove-predicate-mapping-1"><code>(mapping-remove! predicate mapping)</code></h2>
<p>A linear update procedure that returns a mapping containing just the associations of mapping that do not satisfy predicate.</p>
<h2 id="mapping-partition-predicate-mapping"><code>(mapping-partition predicate mapping)</code></h2>
<p>Returns two values: a newly allocated mapping with the same comparator as the mapping mapping that contains just the associations of mapping that satisfy predicate (in the sense of mapping-find), and another newly allocated mapping, also with the same comparator, that contains just the associations of mapping that do not satisfy predicate.</p>
<h2 id="mapping-partition-predicate-mapping-1"><code>(mapping-partition! predicate mapping)</code></h2>
<p>A linear update procedure that returns two mappings containing the associations of mapping that do and do not, respectively, satisfy predicate.</p>
<h2 id="mapping-copy-mapping"><code>(mapping-copy mapping)</code></h2>
<p>Returns a newly allocated mapping containing the associations of the mapping mapping, and using the same comparator.</p>
<h2 id="mapping-alist-mapping"><code>(mapping-&gt;alist mapping)</code></h2>
<p>Returns a newly allocated association list containing the associations of the mapping in increasing order of the keys. Each association in the list is a pair whose car is the key and whose cdr is the associated value.</p>
<h2 id="alist-mapping-comparator-alist"><code>(alist-&gt;mapping comparator alist)</code></h2>
<p>Returns a newly allocated mapping, created as if by mapping using the comparator comparator, that contains the associations in the list, which consist of a pair whose car is the key and whose cdr is the value. Associations earlier in the list take precedence over those that come later.</p>
<h2 id="alist-mapping-mapping-alist"><code>(alist-&gt;mapping! mapping alist)</code></h2>
<p>A linear update procedure that returns a mapping that contains the associations of both mapping and alist. Associations in the mapping and those earlier in the list take precedence over those that come later.</p>
<h2 id="mapping-comparator-mapping1-mapping2-..."><code>(mapping=? comparator mapping1 mapping2 ...)</code></h2>
<p>Returns #t if each mapping mapping contains the same associations, and #f otherwise.</p>
<p>Furthermore, it is explicitly not an error if mapping=? is invoked on mappings that do not share the same (key) comparator. In that case, #f is returned.</p>
<h2 id="mapping-comparator-mapping1-mapping2-...-1"><code>(mapping&lt;? comparator mapping1 mapping2 ...)</code></h2>
<p>Returns #t if the set of associations of each mapping mapping other than the last is a proper subset of the following mapping, and #f otherwise.</p>
<h2 id="mapping-comparator-mapping1-mapping2-...-2"><code>(mapping&gt;? comparator mapping1 mapping2 ...)</code></h2>
<p>Returns #t if each mapping mapping contains the same associations, and #f otherwise.</p>
<p>Furthermore, it is explicitly not an error if mapping=? is invoked on mappings that do not share the same (key) comparator. In that case, #f is returned.</p>
<h2 id="mapping-comparator-mapping1-mapping2-...-3"><code>(mapping&lt;=? comparator mapping1 mapping2 ...)</code></h2>
<p>Returns #t if the set of associations of each mapping mapping other than the last is a subset of the following mapping, and #f otherwise.</p>
<h2 id="mapping-comparator-mapping1-mapping2-...-4"><code>(mapping&gt;=? comparator mapping1 mapping2 ...)</code></h2>
<p>Returns #t if the set of associations of each mapping mapping other than the last is a superset of the following mapping, and #f otherwise.</p>
<h2 id="mapping-union-mapping1-mapping2-..."><code>(mapping-union mapping1 mapping2 ...)</code></h2>
<h2 id="mapping-intersection-mapping1-mapping2-..."><code>(mapping-intersection mapping1 mapping2 ...)</code></h2>
<h2 id="mapping-difference-mapping1-mapping2-..."><code>(mapping-difference mapping1 mapping2 ...)</code></h2>
<h2 id="mapping-xor-mapping1-mapping2-..."><code>(mapping-xor mapping1 mapping2 ...)</code></h2>
<p>Return a newly allocated mapping whose set of associations is the union, intersection, asymmetric difference, or symmetric difference of the sets of associations of the mappings mappings. Asymmetric difference is extended to more than two mappings by taking the difference between the first mapping and the union of the others. Symmetric difference is not extended beyond two mappings. When comparing associations, only the keys are compared. In case of duplicate keys (in the sense of the mappings comparators), associations in the result mapping are drawn from the first mapping in which they appear.</p>
<h2 id="mapping-union-mapping1-mapping2-...-1"><code>(mapping-union! mapping1 mapping2 ...)</code></h2>
<h2 id="mapping-intersection-mapping1-mapping2-...-1"><code>(mapping-intersection! mapping1 mapping2 ...)</code></h2>
<h2 id="mapping-difference-mapping1-mapping2-...-1"><code>(mapping-difference! mapping1 mapping2 ...)</code></h2>
<h2 id="mapping-xor-mapping1-mapping2-...-1"><code>(mapping-xor! mapping1 mapping2 ...)</code></h2>
<p>These procedures are the linear update analogs of the corresponding pure functional procedures above.</p>
<h2 id="mapping-min-key-mapping"><code>(mapping-min-key mapping)</code></h2>
<h2 id="mapping-max-key-mapping"><code>(mapping-max-key mapping)</code></h2>
<p>Returns the least/greatest key contained in the mapping mapping. It is an error for mapping to be empty.</p>
<h2 id="mapping-min-value-mapping"><code>(mapping-min-value mapping)</code></h2>
<h2 id="mapping-max-value-mapping"><code>(mapping-max-value mapping)</code></h2>
<p>Returns the value associated with the least/greatest key contained in the mapping mapping. It is an error for mapping to be empty.</p>
<h2 id="mapping-min-entry-mapping"><code>(mapping-min-entry mapping)</code></h2>
<h2 id="mapping-max-entry-mapping"><code>(mapping-max-entry mapping)</code></h2>
<p>Returns the entry associated with the least/greatest key contained in the mapping mapping as two values, the key and its associated value. It is an error for mapping to be empty.</p>
<h2 id="mapping-key-predecessor-mapping-obj-failure"><code>(mapping-key-predecessor mapping obj failure)</code></h2>
<h2 id="mapping-key-successor-mapping-obj-failure"><code>(mapping-key-successor mapping obj failure)</code></h2>
<p>Returns the key contained in the mapping mapping that immediately precedes/succeeds obj in the mapping’s order of keys. If no such key is contained in mapping (because obj is the minimum/maximum key, or because mapping is empty), returns the result of tail-calling the thunk failure.</p>
<h2 id="mapping-range-mapping-obj"><code>(mapping-range= mapping obj)</code></h2>
<h2 id="mapping-range-mapping-obj-1"><code>(mapping-range&lt; mapping obj)</code></h2>
<h2 id="mapping-range-mapping-obj-2"><code>(mapping-range&gt; mapping obj)</code></h2>
<h2 id="mapping-range-mapping-obj-3"><code>(mapping-range&lt;= mapping obj)</code></h2>
<h2 id="mapping-range-mapping-obj-4"><code>(mapping-range&gt;= mapping obj)</code></h2>
<p>Returns a mapping containing only the associations of the mapping whose keys are equal to, less than, greater than, less than or equal to, or greater than or equal to obj.</p>
<h2 id="mapping-range-mapping-obj-5"><code>(mapping-range=! mapping obj)</code></h2>
<h2 id="mapping-range-mapping-obj-6"><code>(mapping-range&lt;! mapping obj)</code></h2>
<h2 id="mapping-range-mapping-obj-7"><code>(mapping-range&gt;! mapping obj)</code></h2>
<h2 id="mapping-range-mapping-obj-8"><code>(mapping-range&lt;=! mapping obj)</code></h2>
<h2 id="mapping-range-mapping-obj-9"><code>(mapping-range&gt;=! mapping obj)</code></h2>
<p>Linear update procedures returning a mapping containing only the associations of the mapping whose keys are equal to, less than, greater than, less than or equal to, or greater than or equal to obj.</p>
<h2 id="mapping-split-mapping-obj"><code>(mapping-split mapping obj)</code></h2>
<p>Returns five values, equivalent to the results of invoking (mapping-range&lt; mapping obj), (mapping-range&lt;= mapping obj), (mapping-range= mapping obj), (mapping-range&gt;= mapping obj), and (mapping-range&gt; mapping obj), but may be more efficient.</p>
<h2 id="mapping-split-mapping-obj-1"><code>(mapping-split! mapping obj)</code></h2>
<p>The mapping-split! procedure is the same as mapping-split, except that it is permitted to mutate and return the mapping rather than allocating a new mapping.</p>
<h2 id="mapping-catenate-comparator-mapping1-key-value-mapping2"><code>(mapping-catenate comparator mapping1 key value mapping2)</code></h2>
<p>Returns a newly allocated mapping using the comparator comparator whose set of associations is the union of the sets of associations of the mapping mapping1, the association mapping key to value, and the associations of mapping2. It is an error if the keys contained in mapping1 in their natural order, the key key, and the keys contained in mapping2 in their natural order (in that order) do not form a strictly monotone sequence with respect to the ordering of comparator.</p>
<h2 id="mapping-catenate-comparator-mapping1-key-value-mapping2-1"><code>(mapping-catenate! comparator mapping1 key value mapping2)</code></h2>
<p>Returns a newly allocated mapping using the comparator comparator whose set of associations is the union of the sets of associations of the mapping mapping1, the association mapping key to value, and the associations of mapping2. It is an error if the keys contained in mapping1 in their natural order, the key key, and the keys contained in mapping2 in their natural order (in that order) do not form a strictly monotone sequence with respect to the ordering of comparator.</p>
<h2 id="mapping-mapmonotone-proc-comparator-mapping"><code>(mapping-map/monotone proc comparator mapping)</code></h2>
<p>Equivalent to (mapping-map proc comparator mapping), but it is an error if proc does not induce a strictly monotone mapping between the keys with respect to the ordering of the comparator of mapping and the ordering of comparator. Maybe be implemented more efficiently than mapping-map.</p>
<h2 id="mapping-mapmonotone-proc-comparator-mapping-1"><code>(mapping-map/monotone! proc comparator mapping)</code></h2>
<p>The mapping-map/monotone! procedure is the same as mapping-map/monotone, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h2 id="mapping-foldreverse-proc-nil-mapping"><code>(mapping-fold/reverse proc nil mapping)</code></h2>
<p>Equivalent to (mapping-fold proc nil mapping) except that the associations are processed in reverse order with respect to the natural ordering of the keys.</p>
<h2 id="comparator-obj-1"><code>(comparator? obj)</code></h2>
<p>Type predicate for comparators as exported by <code>(scheme comparator)</code>.</p>
<h2 id="mapping-comparator"><code>mapping-comparator</code></h2>
<p>mapping-comparator is constructed by invoking make-mapping-comparator on (make-default-comparator).</p>
<h2 id="make-mapping-comparator-comparator"><code>(make-mapping-comparator comparator)</code></h2>
<p>Returns a comparator for mappings that is compatible with the equality predicate (mapping=? comparator mapping1 mapping2). If make-mapping-comparator is imported from (srfi 146), it provides a (partial) ordering predicate that is applicable to pairs of mappings with the same (key) comparator. If (make-hashmap-comparator) is imported from (srfi 146 hash), it provides an implementation-dependent hash function.</p>
<p>If make-mapping-comparator is imported from (srfi 146), the lexicographic ordering with respect to the keys (and, in case a tiebreak is necessary, with respect to the ordering of the values) is used for mappings sharing a comparator.</p>
<p>The existence of comparators returned by make-mapping-comparator allows mappings whose keys are mappings themselves, and it allows to compare mappings whose values are mappings.</p>
<h1 id="scheme-generator"><code>(scheme generator)</code></h1>
<p>This is based on <a href="https://srfi.schemers.org/srfi-158/srfi-158.html">SRFI-158</a></p>
<p>This SRFI defines utility procedures that create, transform, and consume generators. A generator is simply a procedure with no arguments that works as a source of values. Every time it is called, it yields a value. Generators may be finite or infinite; a finite generator returns an end-of-file object to indicate that it is exhausted. For example, read-char, read-line, and read are generators that generate characters, lines, and objects from the current input port. Generators provide lightweight laziness.</p>
<p>This SRFI also defines procedures that return accumulators. An accumulator is the inverse of a generator: it is a procedure of one argument that works as a sink of values.</p>
<h2 id="generator-arg-..."><code>(generator arg ...)</code></h2>
<p>The simplest finite generator. Generates each of its arguments in turn. When no arguments are provided, it returns an empty generator that generates no values.</p>
<h2 id="circular-generator-arg-..."><code>(circular-generator arg ...)</code></h2>
<p>The simplest infinite generator. Generates each of its arguments in turn, then generates them again in turn, and so on forever.</p>
<h2 id="make-iota-generator-count-start-step"><code>(make-iota-generator count [start [step]])</code></h2>
<p>Creates a finite generator of a sequence of count numbers. The sequence begins with start (which defaults to 0) and increases by step (which defaults to 1). If both start and step are exact, it generates exact numbers; otherwise it generates inexact numbers. The exactness of count doesn’t affect the exactness of the results.</p>
<h2 id="make-range-generator-start-end-step"><code>(make-range-generator start [end [step]])</code></h2>
<p>Creates a generator of a sequence of numbers. The sequence begins with start, increases by step (default 1), and continues while the number is less than end, or forever if end is omitted. If both start and step are exact, it generates exact numbers; otherwise it generates inexact numbers. The exactness of end doesn’t affect the exactness of the results.</p>
<h2 id="make-coroutine-generator-proc"><code>(make-coroutine-generator proc)</code></h2>
<p>Creates a generator from a coroutine.</p>
<p>The proc argument is a procedure that takes one argument, yield. When called, make-coroutine-generator immediately returns a generator g. When g is called, proc runs until it calls yield. Calling yield causes the execution of proc to be suspended, and g returns the value passed to yield.</p>
<p>Whether this generator is finite or infinite depends on the behavior of proc. If proc returns, it is the end of the sequence — g returns an end-of-file object from then on. The return value of proc is ignored.</p>
<p>The following code creates a generator that produces a series 0, 1, and 2 (effectively the same as (make-range-generator 0 3)) and binds it to g.</p>
<div class="sourceCode" id="cb619"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb619-1"><a href="#cb619-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> g</span></span>
<span id="cb619-2"><a href="#cb619-2" aria-hidden="true"></a>  (make-coroutine-generator</span>
<span id="cb619-3"><a href="#cb619-3" aria-hidden="true"></a>   (<span class="kw">lambda</span> (yield) (<span class="kw">let</span> loop ((i <span class="dv">0</span>))</span>
<span id="cb619-4"><a href="#cb619-4" aria-hidden="true"></a>               (when (<span class="op">&lt;</span> i <span class="dv">3</span>) (yield i) (loop (<span class="op">+</span> i <span class="dv">1</span>)))))))</span>
<span id="cb619-5"><a href="#cb619-5" aria-hidden="true"></a></span>
<span id="cb619-6"><a href="#cb619-6" aria-hidden="true"></a>(generator-&gt;list g) <span class="co">;; =&gt; (0 1 2)</span></span></code></pre></div>
<h2 id="list-generator-list"><code>(list-&gt;generator list)</code></h2>
<p>Convert <code>LIST</code> into a generator.</p>
<h2 id="vector-generator-vector-start-end"><code>(vector-&gt;generator vector [start [end]])</code></h2>
<h2 id="reverse-vector-generator-vector-start-end"><code>(reverse-vector-&gt;generator vector [start [end]])</code></h2>
<h2 id="string-generator-string-start-end"><code>(string-&gt;generator string [start [end]])</code></h2>
<h2 id="bytevector-generator-bytevector-start-end"><code>(bytevector-&gt;generator bytevector [start [end]])</code></h2>
<p>These procedures return generators that yield each element of the given argument. Mutating the underlying object will affect the results of the generator.</p>
<div class="sourceCode" id="cb620"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb620-1"><a href="#cb620-1" aria-hidden="true"></a>(generator-&gt;list (list-&gt;generator &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)))</span>
<span id="cb620-2"><a href="#cb620-2" aria-hidden="true"></a>  <span class="co">;; =&gt; (1 2 3 4 5)</span></span>
<span id="cb620-3"><a href="#cb620-3" aria-hidden="true"></a>(generator-&gt;list (vector-&gt;generator &#39;#(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)))</span>
<span id="cb620-4"><a href="#cb620-4" aria-hidden="true"></a>  <span class="co">;; =&gt; (1 2 3 4 5)</span></span>
<span id="cb620-5"><a href="#cb620-5" aria-hidden="true"></a>(generator-&gt;list (reverse-vector-&gt;generator &#39;#(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)))</span>
<span id="cb620-6"><a href="#cb620-6" aria-hidden="true"></a>  <span class="co">;; =&gt; (5 4 3 2 1)</span></span>
<span id="cb620-7"><a href="#cb620-7" aria-hidden="true"></a>(generator-&gt;list (string-&gt;generator <span class="st">&quot;abcde&quot;</span>))</span>
<span id="cb620-8"><a href="#cb620-8" aria-hidden="true"></a>  <span class="co">;; =&gt; (#\a #\b #\c #\d #\e)</span></span></code></pre></div>
<p>The generators returned by the constructors are exhausted once all elements are retrieved; the optional start-th and end-th arguments can limit the range the generator walks across.</p>
<p>For reverse-vector-&gt;generator, the first value is the element right before the end-th element, and the last value is the start-th element. For all the other constructors, the first value the generator yields is the start-th element, and it ends right before the end-th element.</p>
<div class="sourceCode" id="cb621"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb621-1"><a href="#cb621-1" aria-hidden="true"></a>(generator-&gt;list (vector-&gt;generator &#39;#(a b c d e) <span class="dv">2</span>))</span>
<span id="cb621-2"><a href="#cb621-2" aria-hidden="true"></a>  <span class="co">;; =&gt; (c d e)</span></span>
<span id="cb621-3"><a href="#cb621-3" aria-hidden="true"></a>(generator-&gt;list (vector-&gt;generator &#39;#(a b c d e) <span class="dv">2</span> <span class="dv">4</span>))</span>
<span id="cb621-4"><a href="#cb621-4" aria-hidden="true"></a>  <span class="co">;; =&gt; (c d)</span></span>
<span id="cb621-5"><a href="#cb621-5" aria-hidden="true"></a>(generator-&gt;list (reverse-vector-&gt;generator &#39;#(a b c d e) <span class="dv">2</span>))</span>
<span id="cb621-6"><a href="#cb621-6" aria-hidden="true"></a>  <span class="co">;; =&gt; (e d c)</span></span>
<span id="cb621-7"><a href="#cb621-7" aria-hidden="true"></a>(generator-&gt;list (reverse-vector-&gt;generator &#39;#(a b c d e) <span class="dv">2</span> <span class="dv">4</span>))</span>
<span id="cb621-8"><a href="#cb621-8" aria-hidden="true"></a>  <span class="co">;; =&gt; (d c)</span></span>
<span id="cb621-9"><a href="#cb621-9" aria-hidden="true"></a>(generator-&gt;list (reverse-vector-&gt;generator &#39;#(a b c d e) <span class="dv">0</span> <span class="dv">2</span>))</span>
<span id="cb621-10"><a href="#cb621-10" aria-hidden="true"></a>  <span class="co">;; =&gt; (b a)</span></span></code></pre></div>
<h2 id="make-for-each-generator-for-each-obj"><code>(make-for-each-generator for-each obj)</code></h2>
<p>A generator constructor that converts any collection obj to a generator that returns its elements using a for-each procedure appropriate for obj. This must be a procedure that when called as (for-each proc obj) calls proc on each element of obj. Examples of such procedures are for-each, string-for-each, and vector-for-each from R7RS. The value returned by for-each is ignored. The generator is finite if the collection is finite, which would typically be the case.</p>
<p>The collections need not be conventional ones (lists, strings, etc.) as long as for-each can invoke a procedure on everything that counts as a member. For example, the following procedure allows for-each-generator to generate the digits of an integer from least to most significant:</p>
<div class="sourceCode" id="cb622"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb622-1"><a href="#cb622-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(for-each-digit proc n)</span>
<span id="cb622-2"><a href="#cb622-2" aria-hidden="true"></a>  (when (<span class="op">&gt;</span> n <span class="dv">0</span>)</span>
<span id="cb622-3"><a href="#cb622-3" aria-hidden="true"></a>    (let-values (((div rem) (truncate/ n <span class="dv">10</span>)))</span>
<span id="cb622-4"><a href="#cb622-4" aria-hidden="true"></a>      (proc rem)</span>
<span id="cb622-5"><a href="#cb622-5" aria-hidden="true"></a>      (for-each-digit proc div))))</span></code></pre></div>
<h2 id="make-unfold-generator-stop-mapper-successor-seed"><code>(make-unfold-generator stop? mapper successor seed)</code></h2>
<p>A generator constructor similar to <code>(scheme list)</code> unfold.</p>
<p>The stop? predicate takes a seed value and determines whether to stop. The mapper procedure calculates a value to be returned by the generator from a seed value. The successor procedure calculates the next seed value from the current seed value.</p>
<p>For each call of the resulting generator, stop? is called with the current seed value. If it returns true, then the generator returns an end-of-file object. Otherwise, it applies mapper to the current seed value to get the value to return, and uses successor to update the seed value.</p>
<p>This generator is finite unless stop? never returns true.</p>
<div class="sourceCode" id="cb623"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb623-1"><a href="#cb623-1" aria-hidden="true"></a>(generator-&gt;list (make-unfold-generator</span>
<span id="cb623-2"><a href="#cb623-2" aria-hidden="true"></a>                      (<span class="kw">lambda</span> (s) (<span class="op">&gt;</span> s <span class="dv">5</span>))</span>
<span id="cb623-3"><a href="#cb623-3" aria-hidden="true"></a>                      (<span class="kw">lambda</span> (s) (* s <span class="dv">2</span>))</span>
<span id="cb623-4"><a href="#cb623-4" aria-hidden="true"></a>                      (<span class="kw">lambda</span> (s) (<span class="op">+</span> s <span class="dv">1</span>))</span>
<span id="cb623-5"><a href="#cb623-5" aria-hidden="true"></a>                      <span class="dv">0</span>))</span>
<span id="cb623-6"><a href="#cb623-6" aria-hidden="true"></a>  <span class="co">;; =&gt; (0 2 4 6 8 10)</span></span></code></pre></div>
<h2 id="gcons-item-...-generator"><code>(gcons* item ... generator)</code></h2>
<p>Returns a generator that adds items in front of gen. Once the items have been consumed, the generator is guaranteed to tail-call gen.</p>
<div class="sourceCode" id="cb624"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb624-1"><a href="#cb624-1" aria-hidden="true"></a>(generator-&gt;list (gcons* &#39;a &#39;b (make-range-generator <span class="dv">0</span> <span class="dv">2</span>)))</span>
<span id="cb624-2"><a href="#cb624-2" aria-hidden="true"></a> <span class="co">;; =&gt; (a b 0 1)</span></span></code></pre></div>
<h2 id="gappend-generator-..."><code>(gappend generator ...)</code></h2>
<p>Returns a generator that yields the items from the first given generator, and once it is exhausted, from the second generator, and so on.</p>
<div class="sourceCode" id="cb625"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb625-1"><a href="#cb625-1" aria-hidden="true"></a>(generator-&gt;list (gappend (make-range-generator <span class="dv">0</span> <span class="dv">3</span>) (make-range-generator <span class="dv">0</span> <span class="dv">2</span>)))</span>
<span id="cb625-2"><a href="#cb625-2" aria-hidden="true"></a> <span class="co">;; =&gt; (0 1 2 0 1)</span></span>
<span id="cb625-3"><a href="#cb625-3" aria-hidden="true"></a></span>
<span id="cb625-4"><a href="#cb625-4" aria-hidden="true"></a>(generator-&gt;list (gappend))</span>
<span id="cb625-5"><a href="#cb625-5" aria-hidden="true"></a> <span class="co">;; =&gt; ()</span></span></code></pre></div>
<h2 id="gflatten-generator"><code>(gflatten generator)</code></h2>
<p>Returns a generator that yields the elements of the lists produced by the given generator.</p>
<h2 id="ggroup-generator-k-padding"><code>(ggroup generator k [padding])</code></h2>
<p>Returns a generator that yields lists of k items from the given generator. If fewer than k elements are available for the last list, and padding is absent, the short list is returned; otherwise, it is padded by padding to length k.</p>
<h2 id="gmerge-less-than-generator1-..."><code>(gmerge less-than generator1 ...)</code></h2>
<p>Returns a generator that yields the items from the given generators in the order dictated by less-than. If the items are equal, the leftmost item is used first. When all of given generators are exhausted, the returned generator is exhausted also.</p>
<p>As a special case, if only one generator is given, it is returned.</p>
<h2 id="gmap-proc-generator-..."><code>(gmap proc generator ...)</code></h2>
<p>When only one generator is given, returns a generator that yields the items from the given generator after invoking proc on them.</p>
<p>When more than one generator is given, each item of the resulting generator is a result of applying proc to the items from each generator. If any of input generator is exhausted, the resulting generator is also exhausted.</p>
<p>Note: This differs from generator-map-&gt;list, which consumes all values at once and returns the results as a list, while gmap returns a generator immediately without consuming input.</p>
<div class="sourceCode" id="cb626"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb626-1"><a href="#cb626-1" aria-hidden="true"></a>(generator-&gt;list (gmap <span class="op">-</span> (make-range-generator <span class="dv">0</span> <span class="dv">3</span>)))</span>
<span id="cb626-2"><a href="#cb626-2" aria-hidden="true"></a> <span class="co">;; =&gt; (0 -1 -2)</span></span>
<span id="cb626-3"><a href="#cb626-3" aria-hidden="true"></a></span>
<span id="cb626-4"><a href="#cb626-4" aria-hidden="true"></a>(generator-&gt;list (gmap <span class="kw">cons</span> (generator <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) (generator <span class="dv">4</span> <span class="dv">5</span>)))</span>
<span id="cb626-5"><a href="#cb626-5" aria-hidden="true"></a> <span class="co">;; =&gt; ((1 . 4) (2 . 5))</span></span></code></pre></div>
<h2 id="gcombine-proc-seed-generator-generator2"><code>(gcombine proc seed generator generator2)</code></h2>
<p>A generator for mapping with state. It yields a sequence of sub-folds over proc.</p>
<p>The proc argument is a procedure that takes as many arguments as the input generators plus one. It is called as (proc v1 v2 … seed), where v1, v2, … are the values yielded from the input generators, and seed is the current seed value. It must return two values, the yielding value and the next seed. The result generator is exhausted when any of the genn generators is exhausted, at which time all the others are in an undefined state.</p>
<h2 id="gfilter-predicate-generator"><code>(gfilter predicate generator)</code></h2>
<h2 id="gremove-predicate-generator"><code>(gremove predicate generator)</code></h2>
<p>Returns generators that yield the items from the source generator, except those on which pred answers false or true respectively.</p>
<h2 id="gstate-filter-proc-seed-generator"><code>(gstate-filter proc seed generator)</code></h2>
<p>Returns a generator that obtains items from the source generator and passes an item and a state (whose initial value is seed) as arguments to proc. Proc in turn returns two values, a boolean and a new value of the state. If the boolean is true, the item is returned; otherwise, this algorithm is repeated until gen is exhausted, at which point the returned generator is also exhausted. The final value of the state is discarded.</p>
<h2 id="gtake-gen-k-padding"><code>(gtake gen k [padding])</code></h2>
<h2 id="gdrop-gen-k"><code>(gdrop gen k)</code></h2>
<p>These are generator analogues of SRFI 1 take and drop. Gtake returns a generator that yields (at most) the first k items of the source generator, while gdrop returns a generator that skips the first k items of the source generator.</p>
<p>These won’t complain if the source generator is exhausted before generating k items. By default, the generator returned by gtake terminates when the source generator does, but if you provide the padding argument, then the returned generator will yield exactly k items, using the padding value as needed to provide sufficient additional values.</p>
<h2 id="gtake-while-pred-gen"><code>gtake-while pred gen</code></h2>
<h2 id="gdrop-while-pred-gen"><code>gdrop-while pred gen</code></h2>
<p>The generator analogues of SRFI-1 take-while and drop-while. The generator returned from gtake-while yields items from the source generator as long as pred returns true for each. The generator returned from gdrop-while first reads and discards values from the source generator while pred returns true for them, then starts yielding items returned by the source.</p>
<h2 id="gdelete-item-gen"><code>(gdelete item gen [=])</code></h2>
<p>Creates a generator that returns whatever gen returns, except for any items that are the same as item in the sense of =, which defaults to equal?. The = predicate is passed exactly two arguments, of which the first was generated by gen before the second.</p>
<div class="sourceCode" id="cb627"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb627-1"><a href="#cb627-1" aria-hidden="true"></a>(generator-&gt;list (gdelete <span class="dv">3</span> (generator <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">3</span> <span class="dv">6</span> <span class="dv">7</span>)))</span>
<span id="cb627-2"><a href="#cb627-2" aria-hidden="true"></a>  <span class="co">;; =&gt; (1 2 4 5 6 7)</span></span></code></pre></div>
<h2 id="gdelete-neighbor-dups-gen"><code>(gdelete-neighbor-dups gen [=])</code></h2>
<p>Creates a generator that returns whatever gen returns, except for any items that are equal to the preceding item in the sense of =, which defaults to equal?. The = predicate is passed exactly two arguments, of which the first was generated by gen before the second.</p>
<div class="sourceCode" id="cb628"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb628-1"><a href="#cb628-1" aria-hidden="true"></a>(generator-&gt;list (gdelete-neighbor-dups (list-&gt;generator &#39;(a a b c a a a d c))))</span>
<span id="cb628-2"><a href="#cb628-2" aria-hidden="true"></a>  <span class="co">;; =&gt; (a b c a d c)</span></span></code></pre></div>
<h2 id="gindex-value-gen-index-gen"><code>(gindex value-gen index-gen)</code></h2>
<p>Creates a generator that returns elements of value-gen specified by the indices (non-negative exact integers) generated by index-gen. It is an error if the indices are not strictly increasing, or if any index exceeds the number of elements generated by value-gen. The result generator is exhausted when either generator is exhausted, at which time the other is in an undefined state.</p>
<div class="sourceCode" id="cb629"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb629-1"><a href="#cb629-1" aria-hidden="true"></a>(generator-&gt;list (gindex (list-&gt;generator &#39;(a b c d e f))</span>
<span id="cb629-2"><a href="#cb629-2" aria-hidden="true"></a>                         (list-&gt;generator &#39;(<span class="dv">0</span> <span class="dv">2</span> <span class="dv">4</span>))))</span>
<span id="cb629-3"><a href="#cb629-3" aria-hidden="true"></a>  <span class="co">;; =&gt; (a c e)</span></span></code></pre></div>
<h2 id="gselect-value-gen-truth-gen"><code>(gselect value-gen truth-gen)</code></h2>
<p>Creates a generator that returns elements of value-gen that correspond to the values generated by truth-gen. If the current value of truth-gen is true, the current value of value-gen is generated, but otherwise not. The result generator is exhausted when either generator is exhausted, at which time the other is in an undefined state.</p>
<div class="sourceCode" id="cb630"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb630-1"><a href="#cb630-1" aria-hidden="true"></a>(generator-&gt;list (gselect (list-&gt;generator &#39;(a b c d e f))</span>
<span id="cb630-2"><a href="#cb630-2" aria-hidden="true"></a>                          (list-&gt;generator &#39;(<span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#f</span>))))</span>
<span id="cb630-3"><a href="#cb630-3" aria-hidden="true"></a>  <span class="co">;; =&gt; (a d e)</span></span></code></pre></div>
<h2 id="generator-list-generator-k"><code>(generator-&gt;list generator [k])</code></h2>
<p>Reads items from generator and returns a newly allocated list of them. By default, it reads until the generator is exhausted.</p>
<p>If an optional argument k is given, it must be a non-negative integer, and the list ends when either k items are consumed, or generator is exhausted; therefore generator can be infinite in this case.</p>
<h2 id="generator-reverse-list-generator-k"><code>(generator-&gt;reverse-list generator [k])</code></h2>
<p>Reads items from generator and returns a newly allocated list of them in reverse order. By default, this reads until the generator is exhausted.</p>
<p>If an optional argument k is given, it must be a non-negative integer, and the list ends when either k items are read, or generator is exhausted; therefore generator can be infinite in this case.</p>
<h2 id="generator-vector-generator-k"><code>(generator-&gt;vector generator [k])</code></h2>
<p>Reads items from generator and returns a newly allocated vector of them. By default, it reads until the generator is exhausted.</p>
<p>If an optional argument k is given, it must be a non-negative integer, and the list ends when either k items are consumed, or generator is exhausted; therefore generator can be infinite in this case.</p>
<h2 id="generator-vector-vector-at-generator"><code>(generator-&gt;vector! vector at generator)</code></h2>
<p>Reads items from generator and puts them into vector starting at index at, until vector is full or generator is exhausted. Generator can be infinite. The number of elements generated is returned.</p>
<h2 id="generator-string-generator-k"><code>(generator-&gt;string generator [k])</code></h2>
<p>Reads items from generator and returns a newly allocated string of them. It is an error if the items are not characters. By default, it reads until the generator is exhausted.</p>
<p>If an optional argument k is given, it must be a non-negative integer, and the string ends when either k items are consumed, or generator is exhausted; therefore generator can be infinite in this case.</p>
<h2 id="generator-fold-proc-seed-generator-..."><code>(generator-fold proc seed generator ...)</code></h2>
<p>Works like <code>(scheme list)</code> fold on the values generated by the generator arguments.</p>
<p>When one generator is given, for each value v generated by gen, proc is called as (proc v r), where r is the current accumulated result; the initial value of the accumulated result is seed, and the return value from proc becomes the next accumulated result. When gen is exhausted, the accumulated result at that time is returned from generator-fold.</p>
<p>When more than one generator is given, proc is invoked on the values returned by all the generator arguments followed by the current accumulated result. The procedure terminates when any of the genn generators is exhausted, at which time all the others are in an undefined state.</p>
<div class="sourceCode" id="cb631"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb631-1"><a href="#cb631-1" aria-hidden="true"></a>(with-input-from-string <span class="st">&quot;a b c d e&quot;</span></span>
<span id="cb631-2"><a href="#cb631-2" aria-hidden="true"></a>  (<span class="kw">lambda</span> () (generator-fold <span class="kw">cons</span> &#39;z <span class="kw">read</span>)))</span>
<span id="cb631-3"><a href="#cb631-3" aria-hidden="true"></a>  <span class="co">;; =&gt; (e d c b a . z)</span></span></code></pre></div>
<h2 id="generator-for-each-proc-generator-..."><code>(generator-for-each proc generator ...)</code></h2>
<p>A generator analogue of for-each that consumes generated values using side effects. Repeatedly applies proc on the values yielded by gen, gen2 … until any one of the generators is exhausted, at which time all the others are in an undefined state. The values returned from proc are discarded. Returns an unspecified value.</p>
<h2 id="generator-map-list-proc-generator-..."><code>(generator-map-&gt;list proc generator ...)</code></h2>
<p>A generator analogue of map that consumes generated values, processes them through a mapping function, and returns a list of the mapped values. Repeatedly applies proc on the values yielded by gen, gen2 … until any one of the generators is exhausted, at which time all the others are in an undefined state. The values returned from proc are accumulated into a list, which is returned.</p>
<h2 id="generator-find-predicate-generator"><code>(generator-find predicate generator)</code></h2>
<p>Returns the first item from the generator gen that satisfies the predicate pred, or #f if no such item is found before gen is exhausted. If gen is infinite, generator-find will not return if it cannot find an appropriate item.</p>
<h2 id="generator-count-predicate-generator"><code>(generator-count predicate generator)</code></h2>
<p>Returns the number of items available from the generator gen that satisfy the predicate pred.</p>
<h2 id="generator-any-predicate-generator"><code>(generator-any predicate generator)</code></h2>
<p>Applies predicate to each item from gen. As soon as it yields a true value, the value is returned without consuming the rest of gen. If gen is exhausted, returns #f.</p>
<h2 id="generator-every-predicate-generator"><code>(generator-every predicate generator)</code></h2>
<p>Applies pred to each item from gen. As soon as it yields a false value, the value is returned without consuming the rest of gen. If gen is exhausted, returns the last value returned by pred, or #t if pred was never called.</p>
<h2 id="generator-unfold-gen-unfold-arg-..."><code>(generator-unfold gen unfold arg ...)</code></h2>
<p>Equivalent to <code>(unfold eof-object? (lambda (x) x) (lambda (x) (gen)) (gen) arg ...)</code>. The values of gen are unfolded into the collection that unfold creates.</p>
<p>The signature of the unfold procedure is (unfold stop? mapper successor seed args …). Note that the vector-unfold and vector-unfold-right of SRFI 43 and SRFI 133 do not have this signature and cannot be used with this procedure. To unfold into a vector, use SRFI 1’s unfold and then apply list-&gt;vector to the result.</p>
<div class="sourceCode" id="cb632"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb632-1"><a href="#cb632-1" aria-hidden="true"></a><span class="co">;; Iterates over string and unfolds into a list using SRFI 1 unfold</span></span>
<span id="cb632-2"><a href="#cb632-2" aria-hidden="true"></a>(generator-unfold (make-for-each-generator string-for-each <span class="st">&quot;abc&quot;</span>) unfold)</span>
<span id="cb632-3"><a href="#cb632-3" aria-hidden="true"></a><span class="co">;; =&gt; (#\a #\b #\c)</span></span></code></pre></div>
<h2 id="make-accumulator-kons-knil-finalizer"><code>(make-accumulator kons knil finalizer)</code></h2>
<p>Returns an accumulator that, when invoked on an object other than an end-of-file object, invokes kons on its argument and the accumulator’s current state, using the same order as a function passed to fold. It then sets the accumulator’s state to the value returned by kons and returns an unspecified value. The initial state of the accumulator is set to knil. However, if an end-of-file object is passed to the accumulator, it returns the result of tail-calling the procedure finalizer on the state. Repeated calls with an end-of-file object will reinvoke finalizer.</p>
<h2 id="count-accumulator"><code>(count-accumulator)</code></h2>
<p>qReturns an accumulator that, when invoked on an object, adds 1 to a count inside the accumulator and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the count.</p>
<h2 id="list-accumulator"><code>(list-accumulator)</code></h2>
<p>Returns an accumulator that, when invoked on an object, adds that object to a list inside the accumulator in order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the list.</p>
<h2 id="reverse-list-accumulator"><code>(reverse-list-accumulator)</code></h2>
<p>Returns an accumulator that, when invoked on an object, adds that object to a list inside the accumulator in reverse order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the list.</p>
<h2 id="vector-accumulator"><code>(vector-accumulator)</code></h2>
<p>Returns an accumulator that, when invoked on an object, adds that object to a vector inside the accumulator in order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the vector.</p>
<h2 id="reverse-vector-accumulator"><code>(reverse-vector-accumulator)</code></h2>
<p>Returns an accumulator that, when invoked on an object, adds that object to a vector inside the accumulator in reverse order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the vector.</p>
<h2 id="vector-accumulator-vector-at"><code>(vector-accumulator! vector at)</code></h2>
<p>Returns an accumulator that, when invoked on an object, adds that object to consecutive positions of vector starting at at in order of accumulation. It is an error to try to accumulate more objects than vector will hold. An unspecified value is returned. However, if an end-of-file object is passed, the accumulator returns vector.</p>
<h2 id="string-accumulator"><code>(string-accumulator)</code></h2>
<p>Returns an accumulator that, when invoked on a character, adds that character to a string inside the accumulator in order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the string.</p>
<h2 id="bytevector-accumulator"><code>(bytevector-accumulator)</code></h2>
<p>Returns an accumulator that, when invoked on a byte, adds that integer to a bytevector inside the accumulator in order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the bytevector.</p>
<h2 id="bytevector-accumulator-bytevector-at"><code>(bytevector-accumulator! bytevector at)</code></h2>
<p>Returns an accumulator that, when invoked on a byte, adds that byte to consecutive positions of bytevector starting at at in order of accumulation. It is an error to try to accumulate more bytes than vector will hold. An unspecified value is returned. However, if an end-of-file object is passed, the accumulator returns bytevector.</p>
<h2 id="sum-accumulator"><code>(sum-accumulator)</code></h2>
<p>Returns an accumulator that, when invoked on a number, adds that number to a sum inside the accumulator in order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the sum.</p>
<h2 id="product-accumulator"><code>(product-accumulator)</code></h2>
<p>Returns an accumulator that, when invoked on a number, multiplies that number to a product inside the accumulator in order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the product. # <code>(scheme list-queue)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-117/">SRFI-117</a>.</p>
<p>List queues are mutable ordered collections that can contain any Scheme object. Each list queue is based on an ordinary Scheme list containing the elements of the list queue by maintaining pointers to the first and last pairs of the list. It’s cheap to add or remove elements from the front of the list or to add elements to the back, but not to remove elements from the back. List queues are disjoint from other types of Scheme objects.</p>
<h2 id="make-list-queue-list-last"><code>(make-list-queue list [ last ])</code></h2>
<p>Returns a newly allocated list queue containing the elements of list in order. The result shares storage with list. If the last argument is not provided, this operation is O(n) where n is the length of list.</p>
<p>However, if last is provided, make-list-queue returns a newly allocated list queue containing the elements of the list whose first pair is first and whose last pair is last. It is an error if the pairs do not belong to the same list. Alternatively, both first and last can be the empty list. In either case, the operation is O(1).</p>
<p>Note: To apply a non-destructive list procedure to a list queue and return a new list queue, use (make-list-queue (proc (list-queue-list list-queue))).</p>
<h2 id="list-queue-element-..."><code>(list-queue element ...)</code></h2>
<p>Returns a newly allocated list queue containing the elements. This operation is O(n) where n is the number of elements.</p>
<h2 id="list-queue-copy-list-queue"><code>(list-queue-copy list-queue)</code></h2>
<p>Returns a newly allocated list queue containing the elements of list-queue. This operation is O(n) where n is the length of list-queue</p>
<h2 id="list-queue-unfold-stop-mapper-successor-seed-queue"><code>(list-queue-unfold stop? mapper successor seed [ queue ])</code></h2>
<p>Performs the following algorithm:</p>
<p>If the result of applying the predicate stop? to seed is true, return queue. Otherwise, apply the procedure mapper to seed, returning a value which is added to the front of queue. Then get a new seed by applying the procedure successor to seed, and repeat this algorithm.</p>
<p>If queue is omitted, a newly allocated list queue is used.</p>
<h2 id="list-queue-unfold-right-stop-mapper-successor-seed-queue"><code>(list-queue-unfold-right stop? mapper successor seed [ queue ])</code></h2>
<p>Performs the following algorithm:</p>
<p>If the result of applying the predicate stop? to seed is true, return the list queue. Otherwise, apply the procedure mapper to seed, returning a value which is added to the back of the list queue. Then get a new seed by applying the procedure successor to seed, and repeat this algorithm.</p>
<p>If queue is omitted, a newly allocated list queue is used.</p>
<h2 id="list-queue-obj"><code>(list-queue? obj)</code></h2>
<p>Returns #t if obj is a list queue, and #f otherwise. This operation is O(1).</p>
<h2 id="list-queue-empty-list-queue"><code>(list-queue-empty? list-queue)</code></h2>
<p>Returns #t if list-queue has no elements, and #f otherwise. This operation is O(1).</p>
<h2 id="list-queue-front-list-queue"><code>(list-queue-front list-queue)</code></h2>
<p>Returns the first element of list-queue. If the list queue is empty, it is an error. This operation is O(1).</p>
<h2 id="list-queue-back-list-queue"><code>(list-queue-back list-queue)</code></h2>
<p>Returns the last element of list-queue. If the list queue is empty, it is an error. This operation is O(1).</p>
<h2 id="list-queue-list-list-queue"><code>(list-queue-list list-queue)</code></h2>
<p>Returns the list that contains the members of list-queue in order. The result shares storage with list-queue. This operation is O(1).</p>
<h2 id="list-queue-first-last-list-queue"><code>(list-queue-first-last list-queue)</code></h2>
<p>Returns two values, the first and last pairs of the list that contains the members of list-queue in order. If list-queue is empty, returns two empty lists. The results share storage with list-queue. This operation is O(1).</p>
<h2 id="list-queue-add-front-list-queue-element"><code>(list-queue-add-front! list-queue element)</code></h2>
<p>Adds element to the beginning of list-queue. Returns an unspecified value. This operation is O(1).</p>
<h2 id="list-queue-add-back-list-queue-element"><code>(list-queue-add-back! list-queue element)</code></h2>
<p>Adds element to the end of list-queue. Returns an unspecified value. This operation is O(1).</p>
<h2 id="list-queue-remove-front-list-queue"><code>(list-queue-remove-front! list-queue)</code></h2>
<p>Removes the first element of list-queue and returns it. If the list queue is empty, it is an error. This operation is O(1).</p>
<h2 id="list-queue-remove-back-list-queue"><code>(list-queue-remove-back! list-queue)</code></h2>
<p>Removes the last element of list-queue and returns it. If the list queue is empty, it is an error. This operation is O(n) where n is the length of list-queue, because queues do not not have backward links.</p>
<h2 id="list-queue-remove-all-list-queue"><code>(list-queue-remove-all! list-queue)</code></h2>
<p>Removes all the elements of list-queue and returns them in order as a list. This operation is O(1).</p>
<h2 id="list-queue-set-list-list-queue-list-last"><code>(list-queue-set-list! list-queue list [ last ])</code></h2>
<p>Replaces the list associated with list-queue with list, effectively discarding all the elements of list-queue in favor of those in list. Returns an unspecified value. This operation is O(n) where n is the length of list. If last is provided, it is treated in the same way as in make-list-queue, and the operation is O(1).</p>
<p>Note: To apply a destructive list procedure to a list queue, use (list-queue-set-list! (proc (list-queue-list list-queue))).</p>
<h2 id="list-queue-append-list-queue-..."><code>(list-queue-append list-queue ...)</code></h2>
<p>Returns a list queue which contains all the elements in front-to-back order from all the list-queues in front-to-back order. The result does not share storage with any of the arguments. This operation is O(n) in the total number of elements in all queues.</p>
<h2 id="list-queue-append-list-queue-...-1"><code>(list-queue-append! list-queue ...)</code></h2>
<p>Returns a list queue which contains all the elements in front-to-back order from all the list-queues in front-to-back order. It is an error to assume anything about the contents of the list-queues after the procedure returns. This operation is O(n) in the total number of queues, not elements. It is not part of the R7RS-small list API, but is included here for efficiency when pure functional append is not required.</p>
<h2 id="list-queue-concatenate-list-of-list-queues"><code>(list-queue-concatenate list-of-list-queues)</code></h2>
<p>Returns a list queue which contains all the elements in front-to-back order from all the list queues which are members of list-of-list-queues in front-to-back order. The result does not share storage with any of the arguments. This operation is O(n) in the total number of elements in all queues. It is not part of the R7RS-small list API, but is included here to make appending a large number of queues possible in Schemes that limit the number of arguments to apply.</p>
<h2 id="list-queue-map-proc-list-queue"><code>(list-queue-map proc list-queue)</code></h2>
<p>Applies proc to each element of list-queue in unspecified order and returns a newly allocated list queue containing the results. This operation is O(n) where n is the length of list-queue.</p>
<h2 id="list-queue-map-proc-list-queue-1"><code>(list-queue-map! proc list-queue)</code></h2>
<p>Applies proc to each element of list-queue in front-to-back order and modifies list-queue to contain the results. This operation is O(n) in the length of list-queue. It is not part of the R7RS-small list API, but is included here to make transformation of a list queue by mutation more efficient.</p>
<h2 id="list-queue-for-each-proc-list-queue"><code>(list-queue-for-each proc list-queue)</code></h2>
<p>Applies proc to each element of list-queue in front-to-back order, discarding the returned values. Returns an unspecified value. This operation is O(n) where n is the length of list-queue.</p>
<h1 id="scheme-flonum"><code>(scheme flonum)</code></h1>
<p>This is based on <a href="https://srfi.schemers.org/srfi-144/">SRFI-144</a>.</p>
<p>This library describes numeric procedures applicable to flonums, a subset of the inexact real numbers provided by a Scheme implementation. In most Schemes, the flonums and the inexact reals are the same. These procedures are semantically equivalent to the corresponding generic procedures, but allow more efficient implementations.</p>
<h2 id="fl-e"><code>fl-e</code></h2>
<p>Bound to the mathematical constant e. (C99 M_E)</p>
<h2 id="fl-1e"><code>fl-1/e</code></h2>
<p>Bound to 1/e. (C99 M_E)</p>
<h2 id="fl-e-2"><code>fl-e-2</code></h2>
<p>Bound to e2.</p>
<h2 id="fl-e-pi4"><code>fl-e-pi/4</code></h2>
<p>Bound to eπ/4.</p>
<h2 id="fl-log2-e"><code>fl-log2-e</code></h2>
<p>Bound to log2 e. (C99 M_LOG2E)</p>
<h2 id="fl-log10-e"><code>fl-log10-e</code></h2>
<p>Bound to log10 e. (C99 M_LOG10E)</p>
<h2 id="fl-log-2"><code>fl-log-2</code></h2>
<p>Bound to loge 2. (C99 M_LN2)</p>
<h2 id="fl-1log-2"><code>fl-1/log-2</code></h2>
<p>Bound to 1/loge 2. (C99 M_LN2)</p>
<h2 id="fl-log-3"><code>fl-log-3</code></h2>
<p>Bound to loge 3.</p>
<h2 id="fl-log-pi"><code>fl-log-pi</code></h2>
<p>Bound to loge π.</p>
<h2 id="fl-log-10"><code>fl-log-10</code></h2>
<p>Bound to loge 10. (C99 M_LN10)</p>
<h2 id="fl-1log-10"><code>fl-1/log-10</code></h2>
<p>Bound to 1/loge 10. (C99 M_LN10)</p>
<h2 id="fl-pi"><code>fl-pi</code></h2>
<p>Bound to the mathematical constant π. (C99 M_PI)</p>
<h2 id="fl-1pi"><code>fl-1/pi</code></h2>
<p>Bound to 1/π. (C99 M_1_PI)</p>
<h2 id="fl-2pi"><code>fl-2pi</code></h2>
<p>Bound to 2π.</p>
<h2 id="fl-pi2"><code>fl-pi/2</code></h2>
<p>Bound to π/2. (C99 M_PI_2)</p>
<h2 id="fl-pi4"><code>fl-pi/4</code></h2>
<p>Bound to π/4. (C99 M_PI_4)</p>
<h2 id="fl-pi-squared"><code>fl-pi-squared</code></h2>
<p>Bound to π2.</p>
<h2 id="fl-degree"><code>fl-degree</code></h2>
<p>Bound to π/180, the number of radians in a degree.</p>
<h2 id="fl-2pi-1"><code>fl-2/pi</code></h2>
<p>Bound to 2/π. (C99 M_2_PI)</p>
<h2 id="fl-2sqrt-pi"><code>fl-2/sqrt-pi</code></h2>
<p>Bound to 2/√π. (C99 M_2_SQRTPI)</p>
<h2 id="fl-sqrt-2"><code>fl-sqrt-2</code></h2>
<p>Bound to √2. (C99 M_SQRT2)</p>
<h2 id="fl-sqrt-3"><code>fl-sqrt-3</code></h2>
<p>Bound to √3.</p>
<h2 id="fl-sqrt-5"><code>fl-sqrt-5</code></h2>
<p>Bound to √5.</p>
<h2 id="fl-sqrt-10"><code>fl-sqrt-10</code></h2>
<p>Bound to √10.</p>
<h2 id="fl-1sqrt-2"><code>fl-1/sqrt-2</code></h2>
<p>Bound to 1/√2. (C99 M_SQRT1_2)</p>
<h2 id="fl-cbrt-2"><code>fl-cbrt-2</code></h2>
<p>Bound to ∛2.</p>
<h2 id="fl-cbrt-3"><code>fl-cbrt-3</code></h2>
<p>Bound to ∛3.</p>
<h2 id="fl-4thrt-2"><code>fl-4thrt-2</code></h2>
<p>Bound to ∜2.</p>
<h2 id="fl-phi">fl-phi`</h2>
<p>Bound to the mathematical constant φ.</p>
<h2 id="fl-log-phi"><code>fl-log-phi</code></h2>
<p>Bound to log(φ).</p>
<h2 id="fl-1log-phi"><code>fl-1/log-phi</code></h2>
<p>Bound to 1/log(φ).</p>
<h2 id="fl-euler"><code>fl-euler</code></h2>
<p>Bound to the mathematical constant γ (Euler’s constant).</p>
<h2 id="fl-e-euler"><code>fl-e-euler</code></h2>
<p>Bound to eγ.</p>
<h2 id="fl-sin-1"><code>fl-sin-1</code></h2>
<p>Bound to sin 1.</p>
<h2 id="fl-cos-1"><code>fl-cos-1</code></h2>
<p>Bound to cos 1.</p>
<h2 id="fl-gamma-12"><code>fl-gamma-1/2</code></h2>
<p>Bound to Γ(1/2).</p>
<h2 id="fl-gamma-13"><code>fl-gamma-1/3</code></h2>
<p>Bound to Γ(1/3).</p>
<h2 id="fl-gamma-23"><code>fl-gamma-2/3</code></h2>
<p>Bound to Γ(2/3).</p>
<h2 id="fl-greatest"><code>fl-greatest</code></h2>
<h2 id="fl-least"><code>fl-least</code></h2>
<p>Bound to the largest/smallest positive finite flonum. (e.g. C99 DBL_MAX and C11 DBL_TRUE_MIN)</p>
<h2 id="fl-epsilon"><code>fl-epsilon</code></h2>
<p>Bound to the appropriate machine epsilon for the hardware representation of flonums. (C99 DBL_EPSILON in &lt;float.h&gt;)</p>
<h2 id="fl-fast-fl"><code>fl-fast-fl+*</code></h2>
<p>Bound to #t if (fl+* x y z) executes about as fast as, or faster than, (fl+ (fl* x y) z); bound to #f otherwise. (C99 FP_FAST_FMA)</p>
<p>So that the value of this variable can be determined at compile time, R7RS implementations and other implementations that provide a features function should provide the feature fl-fast-fl+* if this variable is true, and not if it is false or the value is unknown at compile time.</p>
<h2 id="fl-integer-exponent-zero"><code>fl-integer-exponent-zero</code></h2>
<p>Bound to whatever exact integer is returned by (flinteger-exponent 0.0). (C99 FP_ILOGB0)</p>
<h2 id="fl-integer-exponent-nan"><code>fl-integer-exponent-nan</code></h2>
<p>Bound to whatever exact integer is returned by (flinteger-exponent +nan.0). (C99 FP_ILOGBNAN)</p>
<h2 id="flonum-number"><code>(flonum number)</code></h2>
<p>If number is an inexact real number and there exists a flonum that is the same (in the sense of =) to number, returns that flonum. If number is a negative zero, an infinity, or a NaN, return its flonum equivalent. If such a flonum does not exist, returns the nearest flonum, where “nearest” is implementation-dependent. If number is not a real number, it is an error. If number is exact, applies inexact or exact-&gt;inexact to number first.</p>
<h2 id="fladjacent-x-y"><code>(fladjacent x y)</code></h2>
<p>Returns a flonum adjacent to x in the direction of y. Specifically: if x &lt; y, returns the smallest flonum larger than x; if x &gt; y, returns the largest flonum smaller than x; if x = y, returns x. (C99 nextafter)</p>
<h2 id="flcopysign-x-y"><code>(flcopysign x y)</code></h2>
<p>Returns a flonum whose magnitude is the magnitude of x and whose sign is the sign of y. (C99 copysign)</p>
<h2 id="make-flonum-x-n"><code>(make-flonum x n)</code></h2>
<p>Returns x × 2n, where n is an integer with an implementation-dependent range. (C99 ldexp)</p>
<h2 id="flinteger-fraction-x"><code>(flinteger-fraction x)</code></h2>
<p>Returns two values, the integral part of x as a flonum and the fractional part of x as a flonum. (C99 modf)</p>
<h2 id="flexponent-x"><code>(flexponent x)</code></h2>
<p>Returns the exponent of x. (C99 logb)</p>
<h2 id="flinteger-exponent-x"><code>(flinteger-exponent x)</code></h2>
<p>Returns the same as flexponent truncated to an exact integer. If x is zero, returns fl-integer-exponent-zero; if x is a NaN, returns fl-integer-exponent-nan; if x is infinite, returns a large implementation-dependent exact integer. (C99 ilogb)</p>
<h2 id="flnormalized-fraction-exponent-x"><code>(flnormalized-fraction-exponent x)</code></h2>
<p>Returns two values, a correctly signed fraction y whose absolute value is between 0.5 (inclusive) and 1.0 (exclusive), and an exact integer exponent n such that x = y(2n). (C99 frexp)</p>
<h2 id="flsign-bit-x"><code>(flsign-bit x)</code></h2>
<p>Returns 0 for positive flonums and 1 for negative flonums and -0.0. The value of (flsign-bit +nan.0) is implementation-dependent, reflecting the sign bit of the underlying representation of NaNs. (C99 signbit)</p>
<h2 id="flonum-obj"><code>(flonum? obj)</code></h2>
<p>Returns #t if obj is a flonum and #f otherwise.</p>
<h2 id="fl-x-y-z-..."><code>(fl=? x y z ...)</code></h2>
<h2 id="fl-x-y-z-...-1"><code>(fl&lt;? x y z ...)</code></h2>
<h2 id="fl-x-y-z-...-2"><code>(fl&gt;? x y z ...)</code></h2>
<h2 id="fl-x-y-z-...-3"><code>(fl&lt;=? x y z ...)</code></h2>
<h2 id="fl-x-y-z-...-4"><code>(fl&gt;=? x y z ...)</code></h2>
<p>These procedures return #t if their arguments are (respectively): equal, monotonically increasing, monotonically decreasing, monotonically nondecreasing, or monotonically nonincreasing; they return #f otherwise. These predicates must be transitive. (C99 =, &lt;, &gt; &lt;=, &gt;= operators respectively)</p>
<h2 id="flunordered-x-y"><code>(flunordered? x y)</code></h2>
<p>Returns #t if x and y are unordered according to IEEE rules. This means that one of them is a NaN.</p>
<p>These numerical predicates test a flonum for a particular property, returning #t or #f.</p>
<h2 id="flinteger-x"><code>(flinteger? x)</code></h2>
<p>Tests whether x is an integral flonum.</p>
<h2 id="flzero-x"><code>(flzero? x)</code></h2>
<p>Tests whether x is zero. Beware of roundoff errors.</p>
<h2 id="flpositive-x"><code>(flpositive? x)</code></h2>
<p>Tests whether x is positive.</p>
<h2 id="flnegative-x"><code>(flnegative? x)</code></h2>
<p>Tests whether x is negative. Note that (flnegative? -0.0) must return #f; otherwise it would lose the correspondence with (fl&lt;? -0.0 0.0), which is #f according to IEEE 754.</p>
<h2 id="flodd-x"><code>(flodd? x)</code></h2>
<p>Tests whether the flonum x is odd. It is an error if x is not an integer.</p>
<h2 id="fleven-x"><code>(fleven? x)</code></h2>
<p>Tests whether the flonum x is even. It is an error if x is not an integer.</p>
<h2 id="flfinite-x"><code>(flfinite? x)</code></h2>
<p>Tests whether the flonum x is finite. (C99 isfinite)</p>
<h2 id="flinfinite-x"><code>(flinfinite? x)</code></h2>
<p>Tests whether the flonum x is infinite. (C99 isinf)</p>
<h2 id="flnan-x"><code>(flnan? x)</code></h2>
<p>Tests whether the flonum x is NaN. (C99 isnan)</p>
<h2 id="flnormalized-x"><code>(flnormalized? x)</code></h2>
<p>Tests whether the flonum x is normalized. (C11 isnormal; in C99, use fpclassify(x) == FP_NORMAL)</p>
<h2 id="fldenormalized-x"><code>(fldenormalized? x)</code></h2>
<p>Tests whether the flonum x is denormalized. (C11 issubnormal; in C99, use fpclassify(x) == FP_SUBNORMAL)</p>
<h2 id="flmax-x-..."><code>(flmax x ...)</code></h2>
<h2 id="flmin-x-..."><code>(flmin x ...)</code></h2>
<p>Return the maximum/minimum argument. If there are no arguments, these procedures return -inf.0 or +inf.0 if the implementation provides these numbers, and (fl- fl-greatest) or fl-greatest otherwise. (C99 fmax fmin)</p>
<h2 id="fl-x-..."><code>(fl+ x ...)</code></h2>
<h2 id="fl-x-...-1"><code>(fl* x ...)</code></h2>
<p>Return the flonum sum or product of their flonum arguments. (C99 + * operators respectively)</p>
<h2 id="fl-x-y-z"><code>(fl+* x y z)</code></h2>
<p>Returns xy + z as if to infinite precision and rounded only once. The boolean constant fl-fast-fl+* indicates whether this procedure executes about as fast as, or faster than, a multiply and an add of flonums. (C99 fma)</p>
<h2 id="fl--x-y-..."><code>(fl- x y ...)</code></h2>
<h2 id="fl-x-y-..."><code>(fl/ x y ...)</code></h2>
<p>With two or more arguments, these procedures return the difference or quotient of their arguments, associating to the left. With one argument, however, they return the additive or multiplicative inverse of their argument. (C99 - / operators respectively)</p>
<h2 id="flabs-x"><code>(flabs x)</code></h2>
<p>Returns the absolute value of x. (C99 fabs)</p>
<h2 id="flabsdiff-x-y"><code>(flabsdiff x y)</code></h2>
<p>Returns |x - y|.</p>
<h2 id="flposdiff-x-y"><code>(flposdiff x y)</code></h2>
<p>Returns the difference of x and y if it is non-negative, or zero if the difference is negative. (C99 fdim)</p>
<h2 id="flsgn-x"><code>(flsgn x)</code></h2>
<p>Returns (flcopysign 1.0 x).</p>
<h2 id="flnumerator-x"><code>(flnumerator x)</code></h2>
<h2 id="fldenominator-x"><code>(fldenominator x)</code></h2>
<p>Returns the numerator/denominator of x as a flonum; the result is computed as if x was represented as a fraction in lowest terms. The denominator is always positive. The numerator of an infinite flonum is itself. The denominator of an infinite or zero flonum is 1.0. The numerator and denominator of a NaN is a NaN.</p>
<h2 id="flfloor-x"><code>(flfloor x)</code></h2>
<p>Returns the largest integral flonum not larger than x. (C99 floor)</p>
<h2 id="flceiling-x"><code>(flceiling x)</code></h2>
<p>Returns the smallest integral flonum not smaller than x. (C99 ceil)</p>
<h2 id="flround-x"><code>(flround x)</code></h2>
<p>Returns the closest integral flonum to x, rounding to even when x represents a number halfway between two integers. (Not the same as C99 round, which rounds away from zero)</p>
<h2 id="fltruncate-x"><code>(fltruncate x)</code></h2>
<p>Returns the closest integral flonum to x whose absolute value is not larger than the absolute value of x (C99 trunc) Exponents and logarithms</p>
<h2 id="flexp-x"><code>(flexp x)</code></h2>
<p>Returns ex. (C99 exp)</p>
<h2 id="flexp2-x"><code>(flexp2 x)</code></h2>
<p>Returns 2x. (C99 exp2)</p>
<h2 id="flexp-1-x"><code>(flexp-1 x)</code></h2>
<p>Returns ex - 1, but is much more accurate than flexp for very small values of x. It is recommended for use in algorithms where accuracy is important. (C99 expm1)</p>
<h2 id="flsquare-x"><code>(flsquare x)</code></h2>
<p>Returns x2.</p>
<h2 id="flsqrt-x"><code>(flsqrt x)</code></h2>
<p>Returns √x. For -0.0, flsqrt should return -0.0. (C99 sqrt)</p>
<h2 id="flcbrt-x"><code>(flcbrt x)</code></h2>
<p>Returns ∛x. (C99 cbrt)</p>
<h2 id="flhypot-x-y"><code>(flhypot x y)</code></h2>
<p>Returns the length of the hypotenuse of a right triangle whose sides are of length |x| and |y|. (C99 hypot)</p>
<h2 id="flexpt-x-y"><code>(flexpt x y)</code></h2>
<p>Returns xy. If x is zero, then the result is zero. (C99 pow)</p>
<h2 id="fllog-x"><code>(fllog x)</code></h2>
<p>Returns loge x. (C99 log)</p>
<h2 id="fllog1-x"><code>(fllog1+ x)</code></h2>
<p>Returns loge (x+ 1), but is much more accurate than fllog for values of x near 0. It is recommended for use in algorithms where accuracy is important. (C99 log1p)</p>
<h2 id="fllog2-x"><code>(fllog2 x)</code></h2>
<p>Returns log2 x. (C99 log2)</p>
<h2 id="fllog10-x"><code>(fllog10 x)</code></h2>
<p>Returns log10 x. (C99 log10)</p>
<h2 id="make-fllog-base-x"><code>(make-fllog-base x)</code></h2>
<p>Returns a procedure that calculates the base-x logarithm of its argument. If x is 1.0 or less than 1.0, it is an error.</p>
<h2 id="flsin-x"><code>(flsin x)</code></h2>
<p>Returns sin x. (C99 sin)</p>
<h2 id="flcos-x"><code>(flcos x)</code></h2>
<p>Returns cos x. (C99 cos)</p>
<h2 id="fltan-x"><code>(fltan x)</code></h2>
<p>Returns tan x. (C99 tan)</p>
<h2 id="flasin-x"><code>(flasin x)</code></h2>
<p>Returns arcsin x. (C99 asin)</p>
<h2 id="flacos-x"><code>(flacos x)</code></h2>
<p>Returns arccos x. (C99 acos)</p>
<h2 id="flatan-y-x"><code>(flatan [y] x)</code></h2>
<p>Returns arctan x. (C99 atan)</p>
<p>With two arguments, returns arctan(y/x). in the range [-π,π], using the signs of x and y to choose the correct quadrant for the result. (C99 atan2)</p>
<h2 id="flsinh-x"><code>(flsinh x)</code></h2>
<p>Returns sinh x. (C99 sinh)</p>
<h2 id="flcosh-x"><code>(flcosh x)</code></h2>
<p>Returns cosh x. (C99 cosh)</p>
<h2 id="fltanh-x"><code>(fltanh x)</code></h2>
<p>Returns tanh x. (C99 tanh)</p>
<h2 id="flasinh-x"><code>(flasinh x)</code></h2>
<p>Returns arcsinh x. (C99 asinh)</p>
<h2 id="flacosh-x"><code>(flacosh x)</code></h2>
<p>Returns arccosh x. (C99 acosh)</p>
<h2 id="flatanh-x"><code>(flatanh x)</code></h2>
<p>Returns arctanh x. (C99 atanh)</p>
<h2 id="flquotient-x-y"><code>(flquotient x y)</code></h2>
<p>Returns the quotient of x/y as an integral flonum, truncated towards zero.</p>
<h2 id="flremainder-x-y"><code>(flremainder x y)</code></h2>
<p>Returns the truncating remainder of x/y as an integral flonum.</p>
<h2 id="flremquo-x-y"><code>(flremquo x y)</code></h2>
<p>` Returns two values, the rounded remainder of x/y and the low-order n bits (as a correctly signed exact integer) of the rounded quotient. The value of n is implementation-dependent but at least 3. This procedure can be used to reduce the argument of the inverse trigonometric functions, while preserving the correct quadrant or octant. (C99 remquo)</p>
<h2 id="flgamma-x"><code>(flgamma x)</code></h2>
<p>Returns Γ(x), the gamma function applied to x. This is equal to (x-1)! for integers. (C99 tgamma)</p>
<h2 id="flloggamma-x"><code>(flloggamma x)</code></h2>
<p>Returns two values, log |Γ(x)| without internal overflow, and the sign of Γ(x) as 1.0 if it is positive and -1.0 if it is negative. (C99 lgamma)</p>
<h2 id="flfirst-bessel-n-x"><code>(flfirst-bessel n x)</code></h2>
<p>Returns the nth order Bessel function of the first kind applied to x, Jn(x). (jn, which is an XSI Extension of C99)</p>
<h2 id="flsecond-bessel-n-x"><code>(flsecond-bessel n x)</code></h2>
<p>Returns the nth order Bessel function of the second kind applied to x, Yn(x). (yn, which is an XSI Extension of C99)</p>
<h2 id="flerf-x"><code>(flerf x)</code></h2>
<p>Returns the error function erf(x). (C99 erf)</p>
<h2 id="flerfc-x"><code>(flerfc x)</code></h2>
<p>Returns the complementary error function, 1 - erf(x). (C99 erfc)</p>
<h1 id="scheme-lazy"><code>(scheme lazy)</code></h1>
<h2 id="delay-exp"><code>(delay exp)</code></h2>
<p>TODO</p>
<h2 id="force-promise"><code>(force promise)</code></h2>
<p>TODO</p>
<h2 id="delay-force-exp"><code>(delay-force exp)</code></h2>
<p>TODO</p>
<h2 id="promise-obj"><code>(promise? obj)</code></h2>
<p>TODO</p>
<h2 id="make-promise-exp"><code>(make-promise exp)</code></h2>
<p>TODO # <code>(scheme comparator)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-128/">SRFI-128</a>.</p>
<p>A comparator is an object of a disjoint type. It is a bundle of procedures that are useful for comparing two objects either for equality or for ordering. There are four procedures in the bundle:</p>
<ul>
<li><p>The type test predicate returns #t if its argument has the correct type to be passed as an argument to the other three procedures, and #f otherwise.</p></li>
<li><p>The equality predicate returns #t if the two objects are the same in the sense of the comparator, and #f otherwise. It is the programmer’s responsibility to ensure that it is reflexive, symmetric, transitive, and can handle any arguments that satisfy the type test predicate.</p></li>
<li><p>The comparison procedure returns -1, 0, or 1 if the first object precedes the second, is equal to the second, or follows the second, respectively, in a total order defined by the comparator. It is the programmer’s responsibility to ensure that it is reflexive, weakly antisymmetric, transitive, can handle any arguments that satisfy the type test predicate, and returns 0 iff the equality predicate returns #t.</p></li>
<li><p>The hash function takes one argument, and returns an exact non-negative integer. It is the programmer’s responsibility to ensure that it can handle any argument that satisfies the type test predicate, and that it returns the same value on two objects if the equality predicate says they are the same (but not necessarily the converse).</p></li>
</ul>
<p>It is also the programmer’s responsibility to ensure that all four procedures provide the same result whenever they are applied to the same object(s) (in the sense of eqv?), unless the object(s) have been mutated since the last invocation. In particular, they must not depend in any way on memory addresses in implementations where the garbage collector can move objects in memory.</p>
<p>B&gt; Limitations: The comparator objects defined in this library are not B&gt; applicable to circular structure or to NaNs or objects containing B&gt; them. Attempts to pass any such objects to any procedure defined B&gt; here, or to any procedure that is part of a comparator defined B&gt; here, is an error except as otherwise noted.</p>
<h2 id="comparator-obj-2"><code>(comparator? obj)</code></h2>
<p>Returns #t if obj is a comparator, and #f otherwise.</p>
<h2 id="comparator-comparison-procedure-comparator"><code>(comparator-comparison-procedure? comparator)</code></h2>
<p>Returns #t if comparator has a supplied comparison procedure, and #f otherwise.</p>
<h2 id="comparator-hash-function-comparator"><code>(comparator-hash-function? comparator)</code></h2>
<p>Returns #t if comparator has a supplied hash function, and #f otherwise.</p>
<h2 id="boolean-comparator"><code>boolean-comparator</code></h2>
<p>Compares booleans using the total order #f &lt; #t.</p>
<h2 id="char-comparator"><code>char-comparator</code></h2>
<p>Compares characters using the total order implied by char&lt;?. On R6RS and R7RS systems, this is Unicode codepoint order.</p>
<h2 id="char-ci-comparator"><code>char-ci-comparator</code></h2>
<p>Compares characters using the total order implied by char-ci&lt;? On R6RS and R7RS systems, this is Unicode codepoint order after the characters have been folded to lower case.</p>
<h2 id="string-comparator"><code>string-comparator</code></h2>
<p>Compares strings using the total order implied by string&lt;?. Note that this order is implementation-dependent.</p>
<h2 id="string-ci-comparator"><code>string-ci-comparator</code></h2>
<p>Compares strings using the total order implied by string-ci&lt;?. Note that this order is implementation-dependent.</p>
<h2 id="symbol-comparator"><code>symbol-comparator</code></h2>
<p>Compares symbols using the total order implied by applying symbol-&gt;string to the symbols and comparing them using the total order implied by string&lt;?. It is not a requirement that the hash function of symbol-comparator be consistent with the hash function of string-comparator, however.</p>
<h2 id="exact-integer-comparator"><code>exact-integer-comparator</code></h2>
<h2 id="integer-comparator"><code>integer-comparator</code></h2>
<h2 id="rational-comparator"><code>rational-comparator</code></h2>
<h2 id="real-comparator"><code>real-comparator</code></h2>
<h2 id="complex-comparator"><code>complex-comparator</code></h2>
<h2 id="number-comparator"><code>number-comparator</code></h2>
<p>These comparators compare exact integers, integers, rational numbers, real numbers, complex numbers, and any numbers using the total order implied by &lt;. They must be compatible with the R5RS numerical tower in the following sense: If S is a subtype of the numerical type T and the two objects are members of S , then the equality predicate and comparison procedures (but not necessarily the hash function) of S-comparator and T-comparator compute the same results on those objects.</p>
<p>Since non-real numbers cannot be compared with &lt;, the following least-surprising ordering is defined: If the real parts are &lt; or &gt;, so are the numbers; otherwise, the numbers are ordered by their imaginary parts. This can still produce surprising results if one real part is exact and the other is inexact.</p>
<h2 id="pair-comparator"><code>pair-comparator</code></h2>
<p>This comparator compares pairs using default-comparator (see below) on their cars. If the cars are not equal, that value is returned. If they are equal, default-comparator is used on their cdrs and that value is returned.</p>
<h2 id="list-comparator"><code>list-comparator</code></h2>
<p>This comparator compares lists lexicographically, as follows:</p>
<ul>
<li><p>The empty list compares equal to itself.</p></li>
<li><p>The empty list compares less than any non-empty list.</p></li>
<li><p>Two non-empty lists are compared by comparing their cars. If the cars are not equal when compared using default-comparator (see below), then the result is the result of that comparison. Otherwise, the cdrs are compared using list-comparator.</p></li>
</ul>
<h2 id="vector-comparator"><code>vector-comparator</code></h2>
<h2 id="bytevector-comparator"><code>bytevector-comparator</code></h2>
<p>These comparators compare vectors and bytevectors by comparing their lengths. A shorter argument is always less than a longer one. If the lengths are equal, then each element is compared in turn using default-comparator (see below) until a pair of unequal elements is found, in which case the result is the result of that comparison. If all elements are equal, the arguments are equal.</p>
<p>If the implementation does not support bytevectors, bytevector-comparator has a type testing procedure that always returns #f.</p>
<h2 id="default-comparator"><code>default-comparator</code></h2>
<p>This is a comparator that accepts any two Scheme values (with the exceptions listed in the Limitations section) and orders them in some implementation-defined way, subject to the following conditions:</p>
<ul>
<li><p>The following ordering between types must hold: the empty list precedes pairs, which precede booleans, which precede characters, which precede strings, which precede symbols, which precede numbers, which precede vectors, which precede bytevectors, which precede all other objects.</p></li>
<li><p>When applied to pairs, booleans, characters, strings, symbols, numbers, vectors, or bytevectors, its behavior must be the same as pair-comparator, boolean-comparator, character-comparator, string-comparator, symbol-comparator, number-comparator, vector-comparator, and bytevector-comparator respectively. The same should be true when applied to an object or objects of a type for which a standard comparator is defined elsewhere.</p></li>
<li><p>Given disjoint types a and b, one of three conditions must hold:</p>
<ul>
<li><p>All objects of type a compare less than all objects of type b.</p></li>
<li><p>All objects of type a compare greater than all objects of type b.</p></li>
<li><p>All objects of either type a or type b compare equal to each other. This is not permitted for any of the standard types mentioned above.</p></li>
</ul></li>
</ul>
<h2 id="make-comparator-type-test-equality-compare-hash"><code>(make-comparator type-test equality compare hash)</code></h2>
<p>Returns a comparator which bundles the type-test, equality, compare, and hash procedures provided. As a convenience, the following additional values are accepted:</p>
<ul>
<li><p>If type-test is #t, a type-test procedure that accepts any arguments is provided.</p></li>
<li><p>If equality is #t, an equality predicate is provided that returns #t iff compare returns 0.</p></li>
<li><p>If compare or hash is #f, a procedure is provided that signals an error on application. The predicates comparator-comparison-procedure? and/or comparator-hash-function?, respectively, will return #f in these cases.</p></li>
</ul>
<h2 id="make-inexact-real-comparator-epsilon-rounding-nan-handling"><code>(make-inexact-real-comparator epsilon rounding nan-handling)</code></h2>
<p>Returns a comparator that compares inexact real numbers including NaNs as follows: if after rounding to the nearest epsilon they are the same, they compare equal; otherwise they compare as specified by &lt;. The direction of rounding is specified by the rounding argument, which is either a procedure accepting two arguments (the number and epsilon, or else one of the symbols floor, ceiling, truncate, or round.</p>
<p>The argument nan-handling specifies how to compare NaN arguments to non-NaN arguments. If it is a procedure, the procedure is invoked on the other argument if either argument is a NaN. If it is the symbol min, NaN values precede all other values; if it is the symbol max, they follow all other values, and if it is the symbol error, an error is signaled if a NaN value is compared. If both arguments are NaNs, however, they always compare as equal.</p>
<h2 id="make-list-comparator-element-comparator"><code>(make-list-comparator element-comparator)</code></h2>
<h2 id="make-vector-comparator-element-comparator"><code>(make-vector-comparator element-comparator)</code></h2>
<h2 id="make-bytevector-comparator-element-comparator"><code>(make-bytevector-comparator element-comparator)</code></h2>
<p>These procedures return comparators which compare two lists, vectors, or bytevectors in the same way as list-comparator, vector-comparator, and bytevector-comparator respectively, but using element-comparator rather than default-comparator.</p>
<p>If the implementation does not support bytevectors, the result of invoking make-bytevector-comparator is a comparator whose type testing procedure always returns #f.</p>
<h2 id="make-listwise-comparator-type-test-element-comparator-empty-head-tail"><code>(make-listwise-comparator type-test element-comparator empty? head tail)</code></h2>
<p>Returns a comparator which compares two objects that satisfy type-test as if they were lists, using the empty? procedure to determine if an object is empty, and the head and tail procedures to access particular elements.</p>
<h2 id="make-vectorwise-comparator-type-test-element-comparator-length-ref"><code>(make-vectorwise-comparator type-test element-comparator length ref)</code></h2>
<p>Returns a comparator which compares two objects that satisfy type-test as if they were vectors, using the length procedure to determine the length of the object, and the ref procedure to access a particular element.</p>
<h2 id="make-car-comparator-comparator"><code>(make-car-comparator comparator)</code></h2>
<p>Returns a comparator that compares pairs on their cars alone using comparator.</p>
<h2 id="make-cdr-comparator-comparator"><code>(make-cdr-comparator comparator)</code></h2>
<p>Returns a comparator that compares pairs on their cdrs alone using comparator.</p>
<h2 id="make-pair-comparator-car-comparator-cdr-comparator"><code>(make-pair-comparator car-comparator cdr-comparator)</code></h2>
<p>Returns a comparator that compares pairs first on their cars using car-comparator. If the cars are equal, it compares the cdrs using cdr-comparator.</p>
<h2 id="make-improper-list-comparator-element-comparator"><code>(make-improper-list-comparator element-comparator)</code></h2>
<p>Returns a comparator that compares arbitrary objects as follows: the empty list precedes all pairs, which precede all other objects. Pairs are compared as if with (make-pair-comparator element-comparator element-comparator). All other objects are compared using element-comparator.</p>
<h2 id="make-selecting-comparator-comparator1-comparator2-..."><code>(make-selecting-comparator comparator1 comparator2 ...)</code></h2>
<p>Returns a comparator whose procedures make use of the comparators as follows:</p>
<p>The type test predicate passes its argument to the type test predicates of comparators in the sequence given. If any of them returns #t, so does the type test predicate; otherwise, it returns #f.</p>
<p>The arguments of the equality, compare, and hash functions are passed to the type test predicate of each comparator in sequence. The first comparator whose type test predicate is satisfied on all the arguments is used when comparing those arguments. All other comparators are ignored. If no type test predicate is satisfied, an error is signaled.</p>
<h2 id="make-refining-comparator-comparator1-comparator2-..."><code>(make-refining-comparator comparator1 comparator2 ...)</code></h2>
<p>Returns a comparator that makes use of the comparators in the same way as make-selecting-comparator, except that its procedures can look past the first comparator whose type test predicate is satisfied. If the comparison procedure of that comparator returns zero, then the next comparator whose type test predicate is satisfied is tried in place of it until one returns a non-zero value. If there are no more such comparators, then the comparison procedure returns zero. The equality predicate is defined in the same way. If no type test predicate is satisfied, an error is signaled.</p>
<p>The hash function of the result returns a value which depends, in an implementation-defined way, on the results of invoking the hash functions of the comparators whose type test predicates are satisfied on its argument. In particular, it may depend solely on the first or last such hash function. If no type test predicate is satisfied, an error is signaled.</p>
<p>This procedure is analogous to the expression type refine-compare from SRFI 67.</p>
<h2 id="make-reverse-comparator-comparator"><code>(make-reverse-comparator comparator)</code></h2>
<p>Returns a comparator that behaves like comparator, except that the compare procedure returns 1, 0, and -1 instead of -1, 0, and 1 respectively. This allows ordering in reverse.</p>
<h2 id="make-debug-comparator-comparator"><code>(make-debug-comparator comparator)</code></h2>
<p>Returns a comparator that behaves exactly like comparator, except that whenever any of its procedures are invoked, it verifies all the programmer responsibilities (except stability), and an error is signaled if any of them are violated. Because it requires three arguments, transitivity is not tested on the first call to a debug comparator; it is tested on all future calls using an arbitrarily chosen argument from the previous invocation. Note that this may cause unexpected storage leaks.</p>
<h2 id="eq-comparator"><code>eq-comparator</code></h2>
<h2 id="eqv-comparator"><code>eqv-comparator</code></h2>
<h2 id="equal-comparator"><code>equal-comparator</code></h2>
<p>The equality predicates of these comparators are eq?, eqv?, and equal? respectively. When their comparison procedures are applied to non-equal objects, their behavior is implementation-defined. The type test predicates always return #t.</p>
<p>These comparators accept circular structure (in the case of equal-comparator, provided the implementation’s equal does so) and NaNs.</p>
<h2 id="comparator-type-test-procedure-comparator"><code>(comparator-type-test-procedure comparator)</code></h2>
<p>Returns the type test predicate of comparator.</p>
<h2 id="comparator-equality-predicate-comparator"><code>(comparator-equality-predicate comparator)</code></h2>
<p>Returns the equality predicate of comparator.</p>
<h2 id="comparator-comparison-procedure-comparator-1"><code>(comparator-comparison-procedure comparator)</code></h2>
<p>Returns the comparison procedure of comparator.</p>
<h2 id="comparator-hash-function-comparator-1"><code>(comparator-hash-function comparator)</code></h2>
<p>Returns the hash function of comparator.</p>
<h2 id="comparator-test-type-comparator-obj"><code>(comparator-test-type comparator obj)</code></h2>
<p>Invokes the type test predicate of comparator on obj and returns what it returns.</p>
<h2 id="comparator-check-type-comparator-obj"><code>(comparator-check-type comparator obj)</code></h2>
<p>Invokes the type test predicate of comparator on obj and returns true if it returns true and signals an error otherwise.</p>
<h2 id="comparator-equal-comparator-obj1-obj2"><code>(comparator-equal? comparator obj1 obj2)</code></h2>
<p>Invokes the equality predicate of comparator on obj1 and obj2 and returns what it returns.</p>
<h2 id="comparator-compare-comparator-obj1-obj2"><code>(comparator-compare comparator obj1 obj2)</code></h2>
<p>Invokes the comparison procedure of comparator on obj1 and obj2 and returns what it returns.</p>
<h2 id="comparator-hash-comparator-obj"><code>(comparator-hash comparator obj)</code></h2>
<p>Invokes the hash function of comparator on obj and returns what it returns.</p>
<h2 id="make-comparison-lt-pred"><code>(make-comparison&lt; lt-pred)</code></h2>
<h2 id="make-comparison-gt-pred"><code>(make-comparison&gt; gt-pred)</code></h2>
<h2 id="make-comparison-le-pred"><code>(make-comparison&lt;= le-pred)</code></h2>
<h2 id="make-comparison-ge-pred"><code>(make-comparison&gt;= ge-pred)</code></h2>
<h2 id="make-comparison-eq-pred-lt-pred"><code>(make-comparison=/&lt; eq-pred lt-pred)</code></h2>
<h2 id="make-comparison-eq-pred-gt-pred"><code>(make-comparison=/&gt; eq-pred gt-pred)</code></h2>
<p>These procedures return a comparison procedure, given a less-than predicate, a greater-than predicate, a less-than-or-equal-to predicate, a greater-than-or-equal-to predicate, or the combination of an equality predicate and either a less-than or a greater-than predicate.</p>
<h2 id="if3-expr-less-equal-greater"><code>(if3 &lt;expr&gt; &lt;less&gt; &lt;equal&gt; &lt;greater&gt;)</code></h2>
<p>The expression <code>&lt;expr&gt;</code> is evaluated; it will typically, but not necessarily, be a call on a comparison procedure. If the result is -1, <code>&lt;less&gt;</code> is evaluated and its value(s) are returned; if the result is 0, <code>&lt;equal&gt;</code> is evaluated and its value(s) are returned; if the result is 1, <code>&lt;greater&gt;</code> is evaluated and its value(s) are returned. Otherwise an error is signaled.</p>
<h2 id="if-expr-consequent-alternate"><code>(if=? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h2>
<h2 id="if-expr-consequent-alternate-1"><code>(if&lt;? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h2>
<h2 id="if-expr-consequent-alternate-2"><code>(if&gt;? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h2>
<h2 id="if-expr-consequent-alternate-3"><code>(if&lt;=? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h2>
<h2 id="if-expr-consequent-alternate-4"><code>(if&gt;=? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h2>
<h2 id="if-not-expr-consequent-alternate"><code>(if-not=? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h2>
<p>The expression <code>&lt;expr&gt;</code> is evaluated; it will typically, but not necessarily, be a call on a comparison procedure. It is an error if its value is not -1, 0, or 1. If the value is consistent with the specified relation, <code>&lt;consequent&gt;</code> is evaluated and its value(s) are returned. Otherwise, if <code>&lt;alternate&gt;</code> is present, it is evaluated and its value(s) are returned; if it is absent, an unspecified value is returned.</p>
<h2 id="comparator-object1-object2-object3-..."><code>(=? comparator object1 object2 object3 ...)</code></h2>
<h2 id="comparator-object1-object2-object3-...-1"><code>(&lt;? comparator object1 object2 object3 ...)</code></h2>
<h2 id="comparator-object1-object2-object3-...-2"><code>(&gt;? comparator object1 object2 object3 ...)</code></h2>
<h2 id="comparator-object1-object2-object3-...-3"><code>(&lt;=? comparator object1 object2 object3 ...)</code></h2>
<h2 id="comparator-object1-object2-object3-...-4"><code>(&gt;=? comparator object1 object2 object3 ...)</code></h2>
<p>These procedures are analogous to the number, character, and string comparison predicates of Scheme. They allow the convenient use of comparators in situations where the expression types are not usable. They are also analogous to the similarly named procedures SRFI 67, but handle arbitrary numbers of arguments, which in SRFI 67 requires the use of the variants whose names begin with chain.</p>
<p>These procedures apply the comparison procedure of comparator to the objects as follows. If the specified relation returns #t for all objecti and objectj where n is the number of objects and 1 &lt;= i &lt; j &lt;= n, then the procedures return #t, but otherwise #f.</p>
<p>The order in which the values are compared is unspecified. Because the relations are transitive, it suffices to compare each object with its successor.</p>
<h2 id="make-comparator"><code>(make=? comparator)</code></h2>
<h2 id="make-comparator-1"><code>(make&lt;? comparator)</code></h2>
<h2 id="make-comparator-2"><code>(make&gt;? comparator)</code></h2>
<h2 id="make-comparator-3"><code>(make&lt;=? comparator)</code></h2>
<h2 id="make-comparator-4"><code>(make&gt;=? comparator)</code></h2>
<p>These procedures return predicates which, when applied to two or more arguments, return #t if comparing obj1 and obj2 using the equality or comparison procedures of comparator shows that the objects bear the specified relation to one another. Such predicates can be used in contexts that do not understand or expect comparators.</p>
<h2 id="in-open-interval-comparator-obj1-obj2-obj3"><code>(in-open-interval? [comparator] obj1 obj2 obj3)</code></h2>
<p>Return #t if obj1 is less than obj2, which is less thanobj3, and #f otherwise.</p>
<h2 id="in-closed-interval-comparator-obj1-obj2-obj3"><code>(in-closed-interval? [comparator] obj1 obj2 obj3)</code></h2>
<p>Returns #t if obj1 is less than or equal to obj2, which is less than or equal to obj3, and #f otherwise.</p>
<h2 id="in-open-closed-interval-comparator-obj1-obj2-obj3"><code>(in-open-closed-interval? [comparator] obj1 obj2 obj3)</code></h2>
<p>Returns #t if obj1 is less than obj2, which is less than or equal to obj3, and #f otherwise.</p>
<h2 id="in-closed-open-interval-comparator-obj1-obj2-obj3"><code>(in-closed-open-interval? [comparator] obj1 obj2 obj3)</code></h2>
<p>Returns #t if obj1 is less than or equal to obj2, which is less than obj3, and #f otherwise.</p>
<h2 id="comparator-min-comparator-object1-object2-..."><code>(comparator-min comparator object1 object2 ...)</code></h2>
<h2 id="comparator-max-comparator-object1-object2-..."><code>(comparator-max comparator object1 object2 ...)</code></h2>
<p>These procedures are analogous to min and max respectively. They apply the comparison procedure of comparator to the objects to find and return a minimal (or maximal) object. The order in which the values are compared is unspecified. # <code>(scheme regex)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-115/">SRFI-115</a>.</p>
<p>This library provides a library for matching strings with regular expressions described using the SRE “Scheme Regular Expression” notation first introduced by SCSH, and extended heavily by IrRegex.</p>
<h2 id="regexp-re"><code>(regexp re)</code></h2>
<p>Compiles a regexp if given an object whose structure matches the SRE syntax. This may be written as a literal or partial literal with quote or quasiquote, or may be generated entirely programmatically. Returns re unmodified if it is already a regexp. Raises an error if re is neither a regexp nor a valid representation of an SRE.</p>
<p>Mutating re may invalidate the resulting regexp, causing unspecified results if subsequently used for matching.</p>
<h2 id="rx-sre-..."><code>(rx sre ...)</code></h2>
<p>Macro shorthand for (regexp `(: sre …)). May be able to perform some or all computation at compile time if sre is not unquoted. Note because of this equivalence with the procedural constructor regexp, the semantics of unquote differs from the original SCSH implementation in that unquoted expressions can expand into any object matching the SRE syntax, but not a compiled regexp object. Further, unquote and unquote-splicing both expand all matches.</p>
<p>Rationale: Providing a procedural interface provides for greater flexibility, and without loss of potential compile-time optimizations by preserving the syntactic shorthand. The alternative is to rely on eval to dynamically generate regular expressions. However regexps in many cases come from untrusted sources, such as search parameters to a server, or from serialized sources such as config files or command-line arguments. Moreover many applications may want to keep many thousands of regexps in memory at once. Given the relatively heavy cost and insecurity of eval, and the frequency with which SREs are read and written as text, we prefer the procedural interface.</p>
<h2 id="regexp-sre-re"><code>(regexp-&gt;sre re)</code></h2>
<p>Returns an SRE corresponding to the given regexp re. The SRE will be equivalent to (will match the same strings) but not necessarily equal? to the SRE originally used to compile re. Mutating the result may invalidate re, causing unspecified results if subsequently used for matching.</p>
<h2 id="char-set-sre-char-set"><code>(char-set-&gt;sre char-set)</code></h2>
<p>Returns an SRE corresponding to the given SRFI 14 character set. The resulting SRE expands the character set into notation which does not make use of embedded SRFI 14 character sets, and so is suitable for writing portably.</p>
<h2 id="valid-sre-obj"><code>(valid-sre? obj)</code></h2>
<p>Returns true iff obj can be safely passed to regexp.</p>
<h2 id="regexp-obj"><code>(regexp? obj)</code></h2>
<p>Returns true iff obj is a regexp.</p>
<h2 id="regexp-matches-re-str-start-end"><code>(regexp-matches re str [start [end]])</code></h2>
<p>Returns an regexp-match object if re successfully matches the entire string str from start (inclusive) to end (exclusive), or #f is the match fails. The regexp-match object will contain information needed to extract any submatches.</p>
<h2 id="regexp-matches-re-str-start-end-1"><code>(regexp-matches? re str [start [end]])</code></h2>
<p>Returns #t if re matches str as in regexp-matches, or #f otherwise. May be faster than regexp-matches since it doesn’t need to return submatch data.</p>
<h2 id="regexp-search-re-str-start-end"><code>(regexp-search re str [start [end]])</code></h2>
<p>Returns a regexp-match object if re successfully matches a substring of str between start (inclusive) and end (exclusive), or #f if the match fails. The regexp-match object will contain information needed to extract any submatches.</p>
<h2 id="regexp-fold-re-kons-knil-str-finish-start-end"><code>(regexp-fold re kons knil str [finish [start [end]]])</code></h2>
<p>The fundamental regexp matching iterator. Repeatedly searches str for the regexp re so long as a match can be found. On each successful match, applies (kons i regexp-match str acc) where i is the index since the last match (beginning with start), regexp-match is the resulting match, and acc is the result of the previous kons application, beginning with knil. When no more matches can be found, calls finish with the same arguments, except that regexp-match is #f.</p>
<p>By default finish just returns acc.</p>
<div class="sourceCode" id="cb633"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb633-1"><a href="#cb633-1" aria-hidden="true"></a>   (regexp-fold &#39;word</span>
<span id="cb633-2"><a href="#cb633-2" aria-hidden="true"></a>                (<span class="kw">lambda</span> (i m str acc)</span>
<span id="cb633-3"><a href="#cb633-3" aria-hidden="true"></a>                  (<span class="kw">let</span> ((s (regexp-match-submatch m <span class="dv">0</span>)))</span>
<span id="cb633-4"><a href="#cb633-4" aria-hidden="true"></a>                   (<span class="kw">cond</span> ((<span class="kw">assoc</span> s acc)</span>
<span id="cb633-5"><a href="#cb633-5" aria-hidden="true"></a>                          <span class="op">=&gt;</span> (<span class="kw">lambda</span> (x) (<span class="kw">set-cdr!</span> x (<span class="op">+</span> <span class="dv">1</span> (<span class="kw">cdr</span> x))) acc))</span>
<span id="cb633-6"><a href="#cb633-6" aria-hidden="true"></a>                         (<span class="kw">else</span> `((,s . <span class="dv">1</span>) ,@acc)))))</span>
<span id="cb633-7"><a href="#cb633-7" aria-hidden="true"></a>                &#39;()</span>
<span id="cb633-8"><a href="#cb633-8" aria-hidden="true"></a>                <span class="st">&quot;to be or not to be&quot;</span>)</span>
<span id="cb633-9"><a href="#cb633-9" aria-hidden="true"></a>   <span class="op">=&gt;</span> &#39;((<span class="st">&quot;not&quot;</span> . <span class="dv">1</span>) (<span class="st">&quot;or&quot;</span> . <span class="dv">1</span>) (<span class="st">&quot;be&quot;</span> . <span class="dv">2</span>) (<span class="st">&quot;to&quot;</span> . <span class="dv">2</span>))</span></code></pre></div>
<h2 id="regexp-extract-re-str-start-end"><code>(regexp-extract re str [start [end]])</code></h2>
<p>Extracts all non-empty substrings of str which match re between start and end as a list of strings.</p>
<div class="sourceCode" id="cb634"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb634-1"><a href="#cb634-1" aria-hidden="true"></a>   (regexp-extract &#39;(<span class="op">+</span> numeric) <span class="st">&quot;192.168.0.1&quot;</span>)</span>
<span id="cb634-2"><a href="#cb634-2" aria-hidden="true"></a>   <span class="op">=&gt;</span> (<span class="st">&quot;192&quot;</span> <span class="st">&quot;168&quot;</span> <span class="st">&quot;0&quot;</span> <span class="st">&quot;1&quot;</span>)</span></code></pre></div>
<h2 id="regexp-split-re-str-start-end"><code>(regexp-split re str [start [end]])</code></h2>
<p>Splits str into a list of (possibly empty) strings separated by non-empty matches of re.</p>
<div class="sourceCode" id="cb635"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb635-1"><a href="#cb635-1" aria-hidden="true"></a>(regexp-split &#39;(<span class="op">+</span> space) <span class="st">&quot; fee fi  fo\tfum\n&quot;</span>)</span>
<span id="cb635-2"><a href="#cb635-2" aria-hidden="true"></a><span class="op">=&gt;</span> (<span class="st">&quot;&quot;</span> <span class="st">&quot;fee&quot;</span> <span class="st">&quot;fi&quot;</span> <span class="st">&quot;fo&quot;</span> <span class="st">&quot;fum&quot;</span> <span class="st">&quot;&quot;</span>)</span>
<span id="cb635-3"><a href="#cb635-3" aria-hidden="true"></a>(regexp-split &#39;(<span class="st">&quot;,;&quot;</span>) <span class="st">&quot;a,,b,&quot;</span>)</span>
<span id="cb635-4"><a href="#cb635-4" aria-hidden="true"></a><span class="op">=&gt;</span> (<span class="st">&quot;a&quot;</span> <span class="st">&quot;&quot;</span> <span class="st">&quot;b&quot;</span> <span class="st">&quot;&quot;</span>)</span>
<span id="cb635-5"><a href="#cb635-5" aria-hidden="true"></a>(regexp-split &#39;(* digit) <span class="st">&quot;abc123def456ghi789&quot;</span>)</span>
<span id="cb635-6"><a href="#cb635-6" aria-hidden="true"></a><span class="op">=&gt;</span> (<span class="st">&quot;abc&quot;</span> <span class="st">&quot;def&quot;</span> <span class="st">&quot;ghi&quot;</span> <span class="st">&quot;&quot;</span>)</span></code></pre></div>
<h2 id="regexp-partition-re-str-start-end"><code>(regexp-partition re str [start [end]])</code></h2>
<p>Partitions str into a list of non-empty strings matching re, interspersed with the unmatched portions of the string. The first and every odd element is an unmatched substring, which will be the empty string if re matches at the beginning of the string or end of the previous match. The second and every even element will be a substring matching re. If the final match ends at the end of the string, no trailing empty string will be included. Thus, in the degenerate case where str is the empty string, the result is ("").</p>
<p>Note that regexp-partition is equivalent to interleaving the results of regexp-split and regexp-extract, starting with the former.</p>
<div class="sourceCode" id="cb636"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb636-1"><a href="#cb636-1" aria-hidden="true"></a>(regexp-partition &#39;(<span class="op">+</span> (<span class="kw">or</span> space punct)) <span class="st">&quot;&quot;</span>)</span>
<span id="cb636-2"><a href="#cb636-2" aria-hidden="true"></a><span class="op">=&gt;</span> (<span class="st">&quot;&quot;</span>)</span>
<span id="cb636-3"><a href="#cb636-3" aria-hidden="true"></a>(regexp-partition &#39;(<span class="op">+</span> (<span class="kw">or</span> space punct)) <span class="st">&quot;Hello, world!\n&quot;</span>)</span>
<span id="cb636-4"><a href="#cb636-4" aria-hidden="true"></a><span class="op">=&gt;</span> (<span class="st">&quot;Hello&quot;</span> <span class="st">&quot;, &quot;</span> <span class="st">&quot;world&quot;</span> <span class="st">&quot;!\n&quot;</span>)</span>
<span id="cb636-5"><a href="#cb636-5" aria-hidden="true"></a>(regexp-partition &#39;(<span class="op">+</span> (<span class="kw">or</span> space punct)) <span class="st">&quot;¿Dónde Estás?&quot;</span>)</span>
<span id="cb636-6"><a href="#cb636-6" aria-hidden="true"></a><span class="op">=&gt;</span> (<span class="st">&quot;&quot;</span> <span class="st">&quot;¿&quot;</span> <span class="st">&quot;Dónde&quot;</span> <span class="st">&quot; &quot;</span> <span class="st">&quot;Estás&quot;</span> <span class="st">&quot;?&quot;</span>)</span>
<span id="cb636-7"><a href="#cb636-7" aria-hidden="true"></a>(regexp-partition &#39;(* digit) <span class="st">&quot;abc123def456ghi789&quot;</span>)</span>
<span id="cb636-8"><a href="#cb636-8" aria-hidden="true"></a><span class="op">=&gt;</span> (<span class="st">&quot;abc&quot;</span> <span class="st">&quot;123&quot;</span> <span class="st">&quot;def&quot;</span> <span class="st">&quot;456&quot;</span> <span class="st">&quot;ghi&quot;</span> <span class="st">&quot;789&quot;</span>)</span></code></pre></div>
<h2 id="regexp-replace-re-str-subst-start-end-count"><code>(regexp-replace re str subst [start [end [count]])</code></h2>
<p>Returns a new string replacing the countth match of re in str the subst, where the zero-indexed count defaults to zero (i.e. the first match). If there are not count matches, returns the selected substring unmodified.</p>
<p>subst can be a string, an integer or symbol indicating the contents of a numbered or named submatch of re, ’pre for the substring to the left of the match, or ’post for the substring to the right of the match.</p>
<p>The optional parameters start and end restrict both the matching and the substitution, to the given indices, such that the result is equivalent to omitting these parameters and replacing on (substring str start end). As a convenience, a value of #f for end is equivalent to (string-length str).</p>
<div class="sourceCode" id="cb637"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb637-1"><a href="#cb637-1" aria-hidden="true"></a>(regexp-replace &#39;(<span class="op">+</span> space) <span class="st">&quot;one two three&quot;</span> <span class="st">&quot;_&quot;</span>)</span>
<span id="cb637-2"><a href="#cb637-2" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;one_two three&quot;</span></span>
<span id="cb637-3"><a href="#cb637-3" aria-hidden="true"></a>(regexp-replace &#39;(<span class="op">+</span> space) <span class="st">&quot;one two three&quot;</span> <span class="st">&quot;_&quot;</span> <span class="dv">0</span> <span class="dv">#f</span> <span class="dv">0</span>)</span>
<span id="cb637-4"><a href="#cb637-4" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;one_two three&quot;</span></span>
<span id="cb637-5"><a href="#cb637-5" aria-hidden="true"></a>(regexp-replace &#39;(<span class="op">+</span> space) <span class="st">&quot;one two three&quot;</span> <span class="st">&quot;_&quot;</span> <span class="dv">0</span> <span class="dv">#f</span> <span class="dv">1</span>)</span>
<span id="cb637-6"><a href="#cb637-6" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;one two_three&quot;</span></span>
<span id="cb637-7"><a href="#cb637-7" aria-hidden="true"></a>(regexp-replace &#39;(<span class="op">+</span> space) <span class="st">&quot;one two three&quot;</span> <span class="st">&quot;_&quot;</span> <span class="dv">0</span> <span class="dv">#f</span> <span class="dv">2</span>)</span>
<span id="cb637-8"><a href="#cb637-8" aria-hidden="true"></a><span class="op">=&gt;</span> <span class="st">&quot;one two three&quot;</span></span></code></pre></div>
<h2 id="regexp-replace-all-re-str-subst-start-end"><code>(regexp-replace-all re str subst [start [end]])</code></h2>
<p>Equivalent to regexp-replace, but replaces all occurrences of re in str.</p>
<pre><code>(regexp-replace-all &#39;(+ space) &quot;one two three&quot; &quot;_&quot;)
=&gt; &quot;one_two_three&quot;</code></pre>
<h2 id="regexp-match-obj"><code>(regexp-match? obj)</code></h2>
<p>Returns true iff obj is a successful match from regexp-matches or regexp-search.</p>
<div class="sourceCode" id="cb639"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb639-1"><a href="#cb639-1" aria-hidden="true"></a>(regexp-match? (regexp-matches <span class="st">&quot;x&quot;</span> <span class="st">&quot;x&quot;</span>))  <span class="op">=&gt;</span> <span class="dv">#t</span></span>
<span id="cb639-2"><a href="#cb639-2" aria-hidden="true"></a>(regexp-match? (regexp-matches <span class="st">&quot;x&quot;</span> <span class="st">&quot;y&quot;</span>))  <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="regexp-match-count-regexp-match"><code>(regexp-match-count regexp-match)</code></h2>
<p>Returns the number of submatches of regexp-match, regardless of whether they matched or not. Does not include the implicit zero full match in the count.</p>
<div class="sourceCode" id="cb640"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb640-1"><a href="#cb640-1" aria-hidden="true"></a>(regexp-match-count (regexp-matches <span class="st">&quot;x&quot;</span> <span class="st">&quot;x&quot;</span>))  <span class="op">=&gt;</span> <span class="dv">0</span></span>
<span id="cb640-2"><a href="#cb640-2" aria-hidden="true"></a>(regexp-match-count (regexp-matches &#39;($ <span class="st">&quot;x&quot;</span>) <span class="st">&quot;x&quot;</span>))  <span class="op">=&gt;</span> <span class="dv">1</span></span></code></pre></div>
<h2 id="regexp-match-submatch-regexp-match-field"><code>(regexp-match-submatch regexp-match field)</code></h2>
<p>Returns the substring matched in regexp-match corresponding to field, either an integer or a symbol for a named submatch. Index 0 refers to the entire match, index 1 to the first lexicographic submatch, and so on. If there are multiple submatches with the same name, the first which matched is returned. If passed an integer outside the range of matches, or a symbol which does not correspond to a named submatch of the pattern, it is an error. If the corresponding submatch did not match, returns false.</p>
<p>The result of extracting a submatch after the original matched string has been mutated is unspecified.</p>
<div class="sourceCode" id="cb641"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb641-1"><a href="#cb641-1" aria-hidden="true"></a>(regexp-match-submatch (regexp-search &#39;word <span class="st">&quot;**foo**&quot;</span>) <span class="dv">0</span>)  <span class="op">=&gt;</span> <span class="st">&quot;foo&quot;</span></span>
<span id="cb641-2"><a href="#cb641-2" aria-hidden="true"></a>(regexp-match-submatch</span>
<span id="cb641-3"><a href="#cb641-3" aria-hidden="true"></a>  (regexp-search &#39;(: <span class="st">&quot;*&quot;</span> ($ word) <span class="st">&quot;*&quot;</span>) <span class="st">&quot;**foo**&quot;</span>) <span class="dv">0</span>)  <span class="op">=&gt;</span> <span class="st">&quot;*foo*&quot;</span></span>
<span id="cb641-4"><a href="#cb641-4" aria-hidden="true"></a>(regexp-match-submatch</span>
<span id="cb641-5"><a href="#cb641-5" aria-hidden="true"></a>  (regexp-search &#39;(: <span class="st">&quot;*&quot;</span> ($ word) <span class="st">&quot;*&quot;</span>) <span class="st">&quot;**foo**&quot;</span>) <span class="dv">1</span>)  <span class="op">=&gt;</span> <span class="st">&quot;foo&quot;</span></span></code></pre></div>
<h2 id="regexp-match-submatch-start-regexp-match-field"><code>(regexp-match-submatch-start regexp-match field)</code></h2>
<p>Returns the start index regexp-match corresponding to field, as in regexp-match-submatch.</p>
<div class="sourceCode" id="cb642"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb642-1"><a href="#cb642-1" aria-hidden="true"></a>   (regexp-match-submatch-start</span>
<span id="cb642-2"><a href="#cb642-2" aria-hidden="true"></a>    (regexp-search &#39;word <span class="st">&quot;**foo**&quot;</span>) <span class="dv">0</span>)  <span class="op">=&gt;</span> <span class="dv">2</span></span>
<span id="cb642-3"><a href="#cb642-3" aria-hidden="true"></a>   (regexp-match-submatch-start</span>
<span id="cb642-4"><a href="#cb642-4" aria-hidden="true"></a>    (regexp-search &#39;(: <span class="st">&quot;*&quot;</span> ($ word) <span class="st">&quot;*&quot;</span>) <span class="st">&quot;**foo**&quot;</span>) <span class="dv">0</span>)  <span class="op">=&gt;</span> <span class="dv">1</span></span>
<span id="cb642-5"><a href="#cb642-5" aria-hidden="true"></a>   (regexp-match-submatch-start</span>
<span id="cb642-6"><a href="#cb642-6" aria-hidden="true"></a>    (regexp-search &#39;(: <span class="st">&quot;*&quot;</span> ($ word) <span class="st">&quot;*&quot;</span>) <span class="st">&quot;**foo**&quot;</span>) <span class="dv">1</span>)  <span class="op">=&gt;</span> <span class="dv">2</span></span></code></pre></div>
<h2 id="regexp-match-submatch-end-regexp-match-field"><code>(regexp-match-submatch-end regexp-match field)</code></h2>
<p>Returns the end index in regexp-match corresponding to field, as in regexp-match-submatch.</p>
<div class="sourceCode" id="cb643"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb643-1"><a href="#cb643-1" aria-hidden="true"></a>   (regexp-match-submatch-end</span>
<span id="cb643-2"><a href="#cb643-2" aria-hidden="true"></a>    (regexp-search &#39;word <span class="st">&quot;**foo**&quot;</span>) <span class="dv">0</span>)  <span class="op">=&gt;</span> <span class="dv">5</span></span>
<span id="cb643-3"><a href="#cb643-3" aria-hidden="true"></a>   (regexp-match-submatch-end</span>
<span id="cb643-4"><a href="#cb643-4" aria-hidden="true"></a>    (regexp-search &#39;(: <span class="st">&quot;*&quot;</span> ($ word) <span class="st">&quot;*&quot;</span>) <span class="st">&quot;**foo**&quot;</span>) <span class="dv">0</span>)  <span class="op">=&gt;</span> <span class="dv">6</span></span>
<span id="cb643-5"><a href="#cb643-5" aria-hidden="true"></a>   (regexp-match-submatch-end</span>
<span id="cb643-6"><a href="#cb643-6" aria-hidden="true"></a>    (regexp-search &#39;(: <span class="st">&quot;*&quot;</span> ($ word) <span class="st">&quot;*&quot;</span>) <span class="st">&quot;**foo**&quot;</span>) <span class="dv">1</span>)  <span class="op">=&gt;</span> <span class="dv">5</span></span></code></pre></div>
<h2 id="regexp-match-list-regexp-match"><code>(regexp-match-&gt;list regexp-match)</code></h2>
<p>Returns a list of all submatches in regexp-match as string or false, beginning with the entire match 0.</p>
<div class="sourceCode" id="cb644"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb644-1"><a href="#cb644-1" aria-hidden="true"></a>   (regexp-match-&gt;list</span>
<span id="cb644-2"><a href="#cb644-2" aria-hidden="true"></a>    (regexp-search &#39;(: ($ word) (<span class="op">+</span> (<span class="kw">or</span> space punct)) ($ word)) <span class="st">&quot;cats &amp; dogs&quot;</span>))</span>
<span id="cb644-3"><a href="#cb644-3" aria-hidden="true"></a>    <span class="op">=&gt;</span> &#39;(<span class="st">&quot;cats &amp; dogs&quot;</span> <span class="st">&quot;cats&quot;</span> <span class="st">&quot;dogs&quot;</span>)</span></code></pre></div>
<h2 id="sre-syntax">SRE Syntax</h2>
<p>The grammar for SREs is summarized below. Note that an SRE is a first-class object consisting of nested lists of strings, chars, char-sets, symbols and numbers. Where the syntax is described as (foo bar), this can be constructed equivalently as ’(foo bar) or (list ’foo ’bar), etc. The following sections explain the semantics in greater detail.</p>
<p>```scheme <sre> ::= | <string> ; A literal string match. | <cset-sre> ; A character set match. | (* <sre> …) ; 0 or more matches. | (zero-or-more <sre> …) | (+ <sre> …) ; 1 or more matches. | (one-or-more <sre> …) | (? <sre> …) ; 0 or 1 matches. | (optional <sre> …) | (= <n> <sre> …) ; <n> matches. | (exactly <n> <sre> …) | (&gt;= <n> <sre> …) ; <n> or more matches. | (at-least <n> <sre> …) | (** <n> <m> <sre> …) ; <n> to <m> matches. | (repeated <n> <m> <sre> …)</p>
<pre><code> | (|  &lt;sre&gt; ...)              ; Alternation.
 | (or &lt;sre&gt; ...)

 | (:   &lt;sre&gt; ...)             ; Sequence.
 | (seq &lt;sre&gt; ...)
 | ($ &lt;sre&gt; ...)               ; Numbered submatch.
 | (submatch &lt;sre&gt; ...)
 | (-&gt; &lt;name&gt; &lt;sre&gt; ...)               ;  Named submatch.  &lt;name&gt; is
 | (submatch-named &lt;name&gt; &lt;sre&gt; ...)   ;  a symbol.

 | (w/case   &lt;sre&gt; ...)        ; Introduce a case-sensitive context.
 | (w/nocase &lt;sre&gt; ...)        ; Introduce a case-insensitive context.

 | (w/unicode   &lt;sre&gt; ...)     ; Introduce a unicode context.
 | (w/ascii &lt;sre&gt; ...)         ; Introduce an ascii context.

 | (w/nocapture &lt;sre&gt; ...)     ; Ignore all enclosed submatches.

 | bos                         ; Beginning of string.
 | eos                         ; End of string.

 | bol                         ; Beginning of line.
 | eol                         ; End of line.

 | bog                         ; Beginning of grapheme cluster.
 | eog                         ; End of grapheme cluster.
 | grapheme                    ; A single grapheme cluster.

 | bow                         ; Beginning of word.
 | eow                         ; End of word.
 | nwb                         ; A non-word boundary.
 | (word &lt;sre&gt; ...)            ; An SRE wrapped in word boundaries.
 | (word+ &lt;cset-sre&gt; ...)      ; A single word restricted to a cset.
 | word                        ; A single word.

 | (?? &lt;sre&gt; ...)              ; A non-greedy pattern, 0 or 1 match.
 | (non-greedy-optional &lt;sre&gt; ...)
 | (*? &lt;sre&gt; ...)              ; Non-greedy 0 or more matches.
 | (non-greedy-zero-or-more &lt;sre&gt; ...)
 | (**? &lt;m&gt; &lt;n&gt; &lt;sre&gt; ...)     ; Non-greedy &lt;m&gt; to &lt;n&gt; matches.
 | (non-greedy-repeated &lt;sre&gt; ...)
 | (look-ahead &lt;sre&gt; ...)      ; Zero-width look-ahead assertion.
 | (look-behind &lt;sre&gt; ...)     ; Zero-width look-behind assertion.
 | (neg-look-ahead &lt;sre&gt; ...)  ; Zero-width negative look-ahead assertion.
 | (neg-look-behind &lt;sre&gt; ...) ; Zero-width negative look-behind assertion.

 | (backref &lt;n-or-name&gt;)       ; Match a previous submatch.</code></pre>
<pre><code>
The grammar for cset-sre is as follows.

```scheme
    &lt;cset-sre&gt; ::=
     | &lt;char&gt;                      ; literal char
     | &quot;&lt;char&gt;&quot;                    ; string of one char
     | &lt;char-set&gt;                  ; embedded SRFI 14 char set
     | (&lt;string&gt;)                  ; literal char set
     | (char-set &lt;string&gt;)
     | (/ &lt;range-spec&gt; ...)        ; ranges
     | (char-range &lt;range-spec&gt; ...)
     | (or &lt;cset-sre&gt; ...)         ; union
     | (|\|| &lt;cset-sre&gt; ...)
     | (and &lt;cset-sre&gt; ...)        ; intersection
     | (&amp; &lt;cset-sre&gt; ...)
     | (- &lt;cset-sre&gt; ...)          ; difference
     | (- &lt;difference&gt; ...)
     | (~ &lt;cset-sre&gt; ...)          ; complement of union
     | (complement &lt;cset-sre&gt; ...)
     | (w/case &lt;cset-sre&gt; ...)     ; case and unicode toggling
     | (w/nocase &lt;cset-sre&gt; ...)
     | (w/ascii &lt;cset-sre&gt; ...)
     | (w/unicode &lt;cset-sre&gt; ...)
     | any | nonl | ascii | lower-case | lower
     | upper-case | upper | title-case | title
     | alphabetic | alpha | alphanumeric | alphanum | alnum
     | numeric | num | punctuation | punct | symbol
     | graphic | graph | whitespace | white | space
     | printing | print | control | cntrl | hex-digit | xdigit

    &lt;range-spec&gt; ::= &lt;string&gt; | &lt;char&gt;</code></pre>
<h2 id="string-1"><code>&lt;string&gt;</code></h2>
<p>A literal string.</p>
<div class="sourceCode" id="cb647"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb647-1"><a href="#cb647-1" aria-hidden="true"></a>   (regexp-search <span class="st">&quot;needle&quot;</span> <span class="st">&quot;hayneedlehay&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb647-2"><a href="#cb647-2" aria-hidden="true"></a>   (regexp-search <span class="st">&quot;needle&quot;</span> <span class="st">&quot;haynEEdlehay&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="seq-sre-..."><code>(seq sre ...)</code></h2>
<h2 id="sre-..."><code>(: sre ...)</code></h2>
<p>Sequencing. Matches if each of sre matches adjacently in order.</p>
<div class="sourceCode" id="cb648"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb648-1"><a href="#cb648-1" aria-hidden="true"></a>(regexp-search &#39;(: <span class="st">&quot;one&quot;</span> space <span class="st">&quot;two&quot;</span> space <span class="st">&quot;three&quot;</span>) <span class="st">&quot;one two three&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span></code></pre></div>
<h2 id="or-sre-..."><code>(or sre ...)</code></h2>
<h2 id="sre-...-1"><code>(|\|| sre ...)</code></h2>
<p>Alternation. Matches if any of sre match.</p>
<div class="sourceCode" id="cb649"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb649-1"><a href="#cb649-1" aria-hidden="true"></a>(regexp-search &#39;(<span class="kw">or</span> <span class="st">&quot;eeney&quot;</span> <span class="st">&quot;meeney&quot;</span> <span class="st">&quot;miney&quot;</span>) <span class="st">&quot;meeney&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb649-2"><a href="#cb649-2" aria-hidden="true"></a>(regexp-search &#39;(<span class="kw">or</span> <span class="st">&quot;eeney&quot;</span> <span class="st">&quot;meeney&quot;</span> <span class="st">&quot;miney&quot;</span>) <span class="st">&quot;moe&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="wnocase-sre-..."><code>(w/nocase sre ...)</code></h2>
<p>Enclosed sres are case-insensitive. In a Unicode context character and string literals match with the default simple Unicode case-insensitive matching. Implementations may, but are not required to, handle variable length case conversions, such as #00DF “ß” matching the two characters “SS”.</p>
<p>Character sets match if any character in the set matches case-insensitively to the input. Conceptually each cset-sre is expanded to contain all case variants for all of its characters. In a compound cset-sre the expansion is applied at the terminals consisting of characters, strings, embedded SRFI 14 char-sets, and named character sets. For simple unions this would be equivalent to computing the full union first and then expanding case variants, but the semantics can differ when differences and intersections are applied. For example, (w/nocase (~ (“Aab”))) is equivalent to (~ (“AaBb”)), for which “B” is clearly not a member. However if you were to compute (~ (“Aab”)) first then you would have a char-set containing “B”, and after expanding case variants both “B” and “b” would be members.</p>
<p>In an ASCII context only the 52 ASCII letters (/ “a-zA-Z”) match case-insensitively to each other.</p>
<p>In a Unicode context the only named cset-sre which are affected by w/nocase are upper and lower. Note that the case insensitive versions of these are not equivalent to alpha as there are characters with the letter property but no case.</p>
<div class="sourceCode" id="cb650"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb650-1"><a href="#cb650-1" aria-hidden="true"></a>(regexp-search <span class="st">&quot;needle&quot;</span> <span class="st">&quot;haynEEdlehay&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb650-2"><a href="#cb650-2" aria-hidden="true"></a>(regexp-search &#39;(w/nocase <span class="st">&quot;needle&quot;</span>) <span class="st">&quot;haynEEdlehay&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb650-3"><a href="#cb650-3" aria-hidden="true"></a></span>
<span id="cb650-4"><a href="#cb650-4" aria-hidden="true"></a>(regexp-search &#39;(~ (<span class="st">&quot;Aab&quot;</span>)) <span class="st">&quot;B&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb650-5"><a href="#cb650-5" aria-hidden="true"></a>(regexp-search &#39;(~ (<span class="st">&quot;Aab&quot;</span>)) <span class="st">&quot;b&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb650-6"><a href="#cb650-6" aria-hidden="true"></a>(regexp-search &#39;(w/nocase (~ (<span class="st">&quot;Aab&quot;</span>))) <span class="st">&quot;B&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb650-7"><a href="#cb650-7" aria-hidden="true"></a>(regexp-search &#39;(w/nocase (~ (<span class="st">&quot;Aab&quot;</span>))) <span class="st">&quot;b&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb650-8"><a href="#cb650-8" aria-hidden="true"></a>(regexp-search &#39;(~ (w/nocase (<span class="st">&quot;Aab&quot;</span>))) <span class="st">&quot;B&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb650-9"><a href="#cb650-9" aria-hidden="true"></a>(regexp-search &#39;(~ (w/nocase (<span class="st">&quot;Aab&quot;</span>))) <span class="st">&quot;b&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="wcase-sre-..."><code>(w/case sre ...)</code></h2>
<p>Enclosed sres are case-sensitive. This is the default, and overrides any enclosing w/nocase setting.</p>
<div class="sourceCode" id="cb651"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb651-1"><a href="#cb651-1" aria-hidden="true"></a>(regexp-search &#39;(w/nocase <span class="st">&quot;SMALL&quot;</span> (w/case <span class="st">&quot;BIG&quot;</span>)) <span class="st">&quot;smallBIGsmall&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb651-2"><a href="#cb651-2" aria-hidden="true"></a>(regexp-search &#39;(w/nocase (~ (w/case (<span class="st">&quot;Aab&quot;</span>)))) <span class="st">&quot;b&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="wascii-sre-..."><code>(w/ascii sre ...)</code></h2>
<p>Enclosed sres are interpreted in an ASCII context. In practice many regular expressions are used for simple parsing and only ASCII characters are relevant. Switching to ASCII mode can improve performance in some implementations.</p>
<div class="sourceCode" id="cb652"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb652-1"><a href="#cb652-1" aria-hidden="true"></a>(regexp-search &#39;(w/ascii bos (* alpha) eos) <span class="st">&quot;English&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb652-2"><a href="#cb652-2" aria-hidden="true"></a>(regexp-search &#39;(w/ascii bos (* alpha) eos) <span class="st">&quot;Ελληνική&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="wunicode-sre-..."><code>(w/unicode sre ...)</code></h2>
<p>Enclosed sres are interpreted in a Unicode context - character sets with both an ASCII and Unicode definition take the latter. Has no effect if the regexp-unicode feature is not provided. This is the default.</p>
<pre><code>(regexp-search &#39;(w/unicode bos (* alpha) eos) &quot;English&quot;) =&gt; #&lt;regexp-match&gt;
(regexp-search &#39;(w/unicode bos (* alpha) eos) &quot;Ελληνική&quot;) =&gt; #&lt;regexp-match&gt;</code></pre>
<h2 id="wnocapture-sre-..."><code>(w/nocapture sre ...)</code></h2>
<p>Disables capturing for all submatches ($, submatch, -&gt; and submatch-named) in the enclosed sres. The resulting SRE matches exactly the same strings, but without any associated submatch info. Useful for utility SREs which you want to incorporate without affecting your submatch positions.</p>
<div class="sourceCode" id="cb654"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb654-1"><a href="#cb654-1" aria-hidden="true"></a>   (<span class="kw">let</span> ((number &#39;($ (<span class="op">+</span> digit))))</span>
<span id="cb654-2"><a href="#cb654-2" aria-hidden="true"></a>     (<span class="kw">cdr</span></span>
<span id="cb654-3"><a href="#cb654-3" aria-hidden="true"></a>      (regexp-match-&gt;list</span>
<span id="cb654-4"><a href="#cb654-4" aria-hidden="true"></a>       (regexp-search `(: ,number <span class="st">&quot;-&quot;</span> ,number <span class="st">&quot;-&quot;</span> ,number)</span>
<span id="cb654-5"><a href="#cb654-5" aria-hidden="true"></a>                      <span class="st">&quot;555-867-5309&quot;</span>)))  <span class="co">; =&gt; &#39;(&quot;555&quot; &quot;867&quot; &quot;5309&quot;)</span></span>
<span id="cb654-6"><a href="#cb654-6" aria-hidden="true"></a>     (<span class="kw">cdr</span></span>
<span id="cb654-7"><a href="#cb654-7" aria-hidden="true"></a>      (regexp-match-&gt;list</span>
<span id="cb654-8"><a href="#cb654-8" aria-hidden="true"></a>       (regexp-search `(: ,number <span class="st">&quot;-&quot;</span> (w/nocapture ,number) <span class="st">&quot;-&quot;</span> ,number)</span>
<span id="cb654-9"><a href="#cb654-9" aria-hidden="true"></a>                      <span class="st">&quot;555-867-5309&quot;</span>))))   <span class="op">=&gt;</span> &#39;(<span class="st">&quot;555&quot;</span> <span class="st">&quot;5309&quot;</span>)</span></code></pre></div>
<h2 id="optional-sre-..."><code>(optional sre ...)</code></h2>
<h2 id="sre-...-2"><code>(? sre ...)</code></h2>
<p>An optional pattern - matches 1 or 0 times.</p>
<div class="sourceCode" id="cb655"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb655-1"><a href="#cb655-1" aria-hidden="true"></a>(regexp-search &#39;(: <span class="st">&quot;match&quot;</span> (? <span class="st">&quot;es&quot;</span>) <span class="st">&quot;!&quot;</span>) <span class="st">&quot;matches!&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb655-2"><a href="#cb655-2" aria-hidden="true"></a>(regexp-search &#39;(: <span class="st">&quot;match&quot;</span> (? <span class="st">&quot;es&quot;</span>) <span class="st">&quot;!&quot;</span>) <span class="st">&quot;match!&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb655-3"><a href="#cb655-3" aria-hidden="true"></a>(regexp-search &#39;(: <span class="st">&quot;match&quot;</span> (? <span class="st">&quot;es&quot;</span>) <span class="st">&quot;!&quot;</span>) <span class="st">&quot;matche!&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="zero-or-more-sre-..."><code>(zero-or-more sre ...)</code></h2>
<h2 id="sre-...-3"><code>(* sre ...)</code></h2>
<p>Kleene star, matches 0 or more times.</p>
<div class="sourceCode" id="cb656"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb656-1"><a href="#cb656-1" aria-hidden="true"></a>(regexp-search &#39;(: <span class="st">&quot;&lt;&quot;</span> (* (~ <span class="ch">#\&gt;</span>)) <span class="st">&quot;&gt;&quot;</span>) <span class="st">&quot;&lt;html&gt;&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb656-2"><a href="#cb656-2" aria-hidden="true"></a>(regexp-search &#39;(: <span class="st">&quot;&lt;&quot;</span> (* (~ <span class="ch">#\&gt;</span>)) <span class="st">&quot;&gt;&quot;</span>) <span class="st">&quot;&lt;&gt;&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb656-3"><a href="#cb656-3" aria-hidden="true"></a>(regexp-search &#39;(: <span class="st">&quot;&lt;&quot;</span> (* (~ <span class="ch">#\&gt;</span>)) <span class="st">&quot;&gt;&quot;</span>) <span class="st">&quot;&lt;html&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="one-or-more-sre-..."><code>(one-or-more sre ...)</code></h2>
<h2 id="sre-...-4"><code>(+ sre ...)</code></h2>
<p>1 or more matches. Like * but requires at least a single match.</p>
<div class="sourceCode" id="cb657"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb657-1"><a href="#cb657-1" aria-hidden="true"></a>(regexp-search &#39;(: <span class="st">&quot;&lt;&quot;</span> (<span class="op">+</span> (~ <span class="ch">#\&gt;</span>)) <span class="st">&quot;&gt;&quot;</span>) <span class="st">&quot;&lt;html&gt;&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb657-2"><a href="#cb657-2" aria-hidden="true"></a>(regexp-search &#39;(: <span class="st">&quot;&lt;&quot;</span> (<span class="op">+</span> (~ <span class="ch">#\&gt;</span>)) <span class="st">&quot;&gt;&quot;</span>) <span class="st">&quot;&lt;a&gt;&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb657-3"><a href="#cb657-3" aria-hidden="true"></a>(regexp-search &#39;(: <span class="st">&quot;&lt;&quot;</span> (<span class="op">+</span> (~ <span class="ch">#\&gt;</span>)) <span class="st">&quot;&gt;&quot;</span>) <span class="st">&quot;&lt;&gt;&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="at-least-n-sre-..."><code>(at-least n sre ...)</code></h2>
<h2 id="n-sre-..."><code>(&gt;= n sre ...)</code></h2>
<p>More generally, n or more matches.</p>
<div class="sourceCode" id="cb658"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb658-1"><a href="#cb658-1" aria-hidden="true"></a>(regexp-search &#39;(: <span class="st">&quot;&lt;&quot;</span> (<span class="op">&gt;=</span> <span class="dv">3</span> (~ <span class="ch">#\&gt;</span>)) <span class="st">&quot;&gt;&quot;</span>) <span class="st">&quot;&lt;table&gt;&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb658-2"><a href="#cb658-2" aria-hidden="true"></a>(regexp-search &#39;(: <span class="st">&quot;&lt;&quot;</span> (<span class="op">&gt;=</span> <span class="dv">3</span> (~ <span class="ch">#\&gt;</span>)) <span class="st">&quot;&gt;&quot;</span>) <span class="st">&quot;&lt;pre&gt;&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb658-3"><a href="#cb658-3" aria-hidden="true"></a>(regexp-search &#39;(: <span class="st">&quot;&lt;&quot;</span> (<span class="op">&gt;=</span> <span class="dv">3</span> (~ <span class="ch">#\&gt;</span>)) <span class="st">&quot;&gt;&quot;</span>) <span class="st">&quot;&lt;tr&gt;&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="exactly-n-sre-..."><code>(exactly n sre ...)</code></h2>
<h2 id="n-sre-...-1"><code>(= n sre ...)</code></h2>
<p>Exactly n matches.</p>
<div class="sourceCode" id="cb659"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb659-1"><a href="#cb659-1" aria-hidden="true"></a>(regexp-search &#39;(: <span class="st">&quot;&lt;&quot;</span> (<span class="op">=</span> <span class="dv">4</span> (~ <span class="ch">#\&gt;</span>)) <span class="st">&quot;&gt;&quot;</span>) <span class="st">&quot;&lt;html&gt;&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb659-2"><a href="#cb659-2" aria-hidden="true"></a>(regexp-search &#39;(: <span class="st">&quot;&lt;&quot;</span> (<span class="op">=</span> <span class="dv">4</span> (~ <span class="ch">#\&gt;</span>)) <span class="st">&quot;&gt;&quot;</span>) <span class="st">&quot;&lt;table&gt;&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="repeated-from-to-sre-..."><code>(repeated from to sre ...)</code></h2>
<h2 id="from-to-sre-..."><code>(** from to sre ...)</code></h2>
<p>The most general form, from n to m matches, inclusive.</p>
<div class="sourceCode" id="cb660"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb660-1"><a href="#cb660-1" aria-hidden="true"></a>(regexp-search &#39;(: (<span class="op">=</span> <span class="dv">3</span> (** <span class="dv">1</span> <span class="dv">3</span> numeric) <span class="st">&quot;.&quot;</span>) (** <span class="dv">1</span> <span class="dv">3</span> numeric)) <span class="st">&quot;192.168.1.10&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb660-2"><a href="#cb660-2" aria-hidden="true"></a>(regexp-search &#39;(: (<span class="op">=</span> <span class="dv">3</span> (** <span class="dv">1</span> <span class="dv">3</span> numeric) <span class="st">&quot;.&quot;</span>) (** <span class="dv">1</span> <span class="dv">3</span> numeric)) <span class="st">&quot;192.0168.1.10&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="submatch-sre-..."><code>(submatch sre ...)</code></h2>
<h2 id="sre-...-5"><code>($ sre ...)</code></h2>
<p>A numbered submatch. The contents matching the pattern will be available in the resulting regexp-match.</p>
<h2 id="submatch-named-name-sre-..."><code>(submatch-named name sre ...)</code></h2>
<h2 id="name-sre-..."><code>(-&gt; name sre ...)</code></h2>
<p>A named submatch. Behaves just like submatch, but the field may also be referred to by name.</p>
<h2 id="backref-n-or-name"><code>(backref n-or-name)</code></h2>
<p>Optional: Match a previously matched submatch. The feature regexp-backrefs will be provided if this pattern is supported. Backreferences are expensive, and can trivially be shown to be NP-hard, so one should avoid their use even in implementations which support them.</p>
<h2 id="char"><code>&lt;char&gt;</code></h2>
<p>A singleton char set.</p>
<div class="sourceCode" id="cb661"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb661-1"><a href="#cb661-1" aria-hidden="true"></a>   (regexp-matches &#39;(* <span class="ch">#\-</span>) <span class="st">&quot;---&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb661-2"><a href="#cb661-2" aria-hidden="true"></a>   (regexp-matches &#39;(* <span class="ch">#\-</span>) <span class="st">&quot;-_-&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="char-1"><code>"&lt;char&gt;"</code></h2>
<p>A singleton char set written as a string of length one rather than a character. Equivalent to its interpretation as a literal string match, but included to clarify it can be composed in cset-sres.</p>
<h2 id="char-set"><code>&lt;char-set&gt;</code></h2>
<p>A SRFI 14 character set, which matches any character in the set. Note that currently there is no portable written representation of SRFI 14 character sets, which means that this pattern is typically generated programmatically, such as with a quasiquoted expression.</p>
<pre><code>(regexp-partition `(+ ,char-set:vowels) &quot;vowels&quot;)
   =&gt; (&quot;v&quot; &quot;o&quot; &quot;w&quot; &quot;e&quot; &quot;ls&quot;)</code></pre>
<p>Rationale: Many useful character sets are likely to be available as SRFI 14 char-sets, so it is desirable to reuse them in regular expressions. Since many Unicode character sets are extremely large, converting back and forth between an internal and external representation can be expensive, so the option of direct embedding is necessary. When a readable external representation is needed, char-set-&gt;sre can be used.</p>
<h2 id="char-set-string"><code>(char-set &lt;string&gt;)</code></h2>
<h2 id="string-2"><code>(&lt;string&gt;)</code></h2>
<p>The set of chars as formed by SRFI 14 (string-&gt;char-set <string>).</p>
<p>Note that char-sets contain code points, not grapheme clusters, so any combining characters in <string> will be inserted separately from any preceding base characters by string-&gt;char-set.</p>
<div class="sourceCode" id="cb663"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb663-1"><a href="#cb663-1" aria-hidden="true"></a>   (regexp-matches &#39;(* (<span class="st">&quot;aeiou&quot;</span>)) <span class="st">&quot;oui&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb663-2"><a href="#cb663-2" aria-hidden="true"></a>   (regexp-matches &#39;(* (<span class="st">&quot;aeiou&quot;</span>)) <span class="st">&quot;ouais&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb663-3"><a href="#cb663-3" aria-hidden="true"></a>   (regexp-matches &#39;(* (<span class="st">&quot;e\x0301&quot;</span>)) <span class="st">&quot;e\x0301&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb663-4"><a href="#cb663-4" aria-hidden="true"></a>   (regexp-matches &#39;(<span class="st">&quot;e\x0301&quot;</span>) <span class="st">&quot;e\x0301&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb663-5"><a href="#cb663-5" aria-hidden="true"></a>   (regexp-matches &#39;(<span class="st">&quot;e\x0301&quot;</span>) <span class="st">&quot;e&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb663-6"><a href="#cb663-6" aria-hidden="true"></a>   (regexp-matches &#39;(<span class="st">&quot;e\x0301&quot;</span>) <span class="st">&quot;\x0301&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb663-7"><a href="#cb663-7" aria-hidden="true"></a>   (regexp-matches &#39;(<span class="st">&quot;e\x0301&quot;</span>) <span class="st">&quot;\x00E9&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="char-range-range-spec-..."><code>(char-range &lt;range-spec&gt; ...)</code></h2>
<h2 id="range-spec-..."><code>(/ &lt;range-spec&gt; ...)</code></h2>
<p>Ranged char set. The <range-spec> is a list of strings and characters. These are flattened and grouped into pairs of characters, and all ranges formed by the pairs are included in the char set.</p>
<div class="sourceCode" id="cb664"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb664-1"><a href="#cb664-1" aria-hidden="true"></a>(regexp-matches &#39;(* (<span class="op">/</span> <span class="st">&quot;AZ09&quot;</span>)) <span class="st">&quot;R2D2&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb664-2"><a href="#cb664-2" aria-hidden="true"></a>(regexp-matches &#39;(* (<span class="op">/</span> <span class="st">&quot;AZ09&quot;</span>)) <span class="st">&quot;C-3PO&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="or-cset-sre-..."><code>(or &lt;cset-sre&gt; ...)</code></h2>
<h2 id="cset-sre-..."><code>(|\|| &lt;cset-sre&gt; ...)</code></h2>
<p>Char set union. The single vertical bar form is provided for consistency and compatibility with SCSH, although it needs to be escaped in R7RS.</p>
<h2 id="complement-cset-sre-..."><code>(complement &lt;cset-sre&gt; ...)</code></h2>
<h2 id="cset-sre-...-1"><code>(~ &lt;cset-sre&gt; ...)</code></h2>
<p>Char set complement (i.e. [^...] in PCRE notation). (~ x) is equivalent to (- any x), thus in an ASCII context the complement is always ASCII.</p>
<h2 id="difference-cset-sre-..."><code>(difference &lt;cset-sre&gt; ...)</code></h2>
<h2 id="cset-sre-...-2"><code>(- &lt;cset-sre&gt; ...)</code></h2>
<p>Char set difference.</p>
<div class="sourceCode" id="cb665"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb665-1"><a href="#cb665-1" aria-hidden="true"></a>(regexp-matches &#39;(* (<span class="op">-</span> (<span class="op">/</span> <span class="st">&quot;az&quot;</span>) (<span class="st">&quot;aeiou&quot;</span>))) <span class="st">&quot;xyzzy&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb665-2"><a href="#cb665-2" aria-hidden="true"></a>(regexp-matches &#39;(* (<span class="op">-</span> (<span class="op">/</span> <span class="st">&quot;az&quot;</span>) (<span class="st">&quot;aeiou&quot;</span>))) <span class="st">&quot;vowels&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="and-cset-sre-..."><code>(and &lt;cset-sre&gt; ...)</code></h2>
<h2 id="cset-sre-...-3"><code>(&amp; &lt;cset-sre&gt; ...)</code></h2>
<p>Char set intersection.</p>
<pre><code>(regexp-matches &#39;(* (&amp; (/ &quot;az&quot;) (~ (&quot;aeiou&quot;)))) &quot;xyzzy&quot;) =&gt; #&lt;regexp-match&gt;
(regexp-matches &#39;(* (&amp; (/ &quot;az&quot;) (~ (&quot;aeiou&quot;)))) &quot;vowels&quot;) =&gt; #f</code></pre>
<h2 id="any"><code>any</code></h2>
<p>Match any character. Equivalent to ascii in an ASCII context.</p>
<h2 id="nonl"><code>nonl</code></h2>
<p>Match any character other than #or #.</p>
<h2 id="ascii"><code>ascii</code></h2>
<p>Match any ASCII character [0..127].</p>
<h2 id="lower-case"><code>lower-case</code></h2>
<h2 id="lower"><code>lower</code></h2>
<p>Matches any character for which char-lower-case? returns true. In a Unicode context this corresponds to the Lowercase (Ll + Other_Lowercase) property. In an ASCII context corresponds to (/ “az”).</p>
<h2 id="upper-case"><code>upper-case</code></h2>
<h2 id="upper"><code>upper</code></h2>
<p>Matches any character for which char-upper-case? returns true. In a Unicode context this corresponds to the Uppercase (Lu + Other_Uppercase) property. In an ASCII context corresponds to (/ “AZ”).</p>
<h2 id="title-case"><code>title-case</code></h2>
<h2 id="title"><code>title</code></h2>
<p>Matches any character with the Unicode Titlecase (Lt) property. This property only exists for the sake of ligature characters, of which only 31 exist at time of writing. In an ASCII context this is empty.</p>
<h2 id="alphabetic"><code>alphabetic</code></h2>
<h2 id="alpha"><code>alpha</code></h2>
<p>Matches any character for which char-alphabetic? returns true. In a Unicode context this corresponds to the Alphabetic (L + Nl + Other_Alphabetic) property. In an ASCII context corresponds to (w/nocase (/ “az”)).</p>
<h2 id="numeric"><code>numeric</code></h2>
<h2 id="num"><code>num</code></h2>
<p>Matches any character for which char-numeric? returns true. For In a Unicode context this corresponds to the Numeric_Digit (Nd) property. In an ASCII context corresponds to (/ “09”).</p>
<h2 id="alphanumeric"><code>alphanumeric</code></h2>
<h2 id="alphanum"><code>alphanum</code></h2>
<h2 id="alnum"><code>alnum</code></h2>
<p>Matches any character which is either a letter or number. Equivalent to:</p>
<div class="sourceCode" id="cb667"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb667-1"><a href="#cb667-1" aria-hidden="true"></a>   (<span class="kw">or</span> alphabetic numeric)</span></code></pre></div>
<h2 id="punctuation"><code>punctuation</code></h2>
<h2 id="punct"><code>punct</code></h2>
<p>Matches any punctuation character. In a Unicode context this corresponds to the Punctuation property (P). In an ASCII context this corresponds to "!"#%&amp;’()*,-./:;?@[]_{}".</p>
<h2 id="symbol-1"><code>symbol</code></h2>
<p>Matches any symbol character. In a Unicode context this corresponds to the Symbol property (Sm, Sc, Sk, or So). In an ASCII this corresponds to “$+&lt;=&gt;^`|~”.</p>
<h2 id="graphic"><code>graphic</code></h2>
<h2 id="graph"><code>graph</code></h2>
<p>Matches any graphic character. Equivalent to:</p>
<div class="sourceCode" id="cb668"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb668-1"><a href="#cb668-1" aria-hidden="true"></a>   (<span class="kw">or</span> alphanumeric punctuation symbol)</span></code></pre></div>
<h2 id="whitespace"><code>whitespace</code></h2>
<h2 id="white"><code>white</code></h2>
<h2 id="space"><code>space</code></h2>
<p>Matches any whitespace character. In a Unicode context this corresponds to the Separator property (Zs, Zl or Zp). In an ASCII context this corresponds to space, tab, line feed, form feed, and carriage return.</p>
<h2 id="printing"><code>printing</code></h2>
<h2 id="print"><code>print</code></h2>
<p>Matches any printing character. Equivalent to:</p>
<div class="sourceCode" id="cb669"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb669-1"><a href="#cb669-1" aria-hidden="true"></a>   (<span class="kw">or</span> graphic whitespace)</span></code></pre></div>
<h2 id="control"><code>control</code></h2>
<h2 id="cntrl"><code>cntrl</code></h2>
<p>Matches any control or other character. In a Unicode context this corresponds to the Other property (Cc, Cf, Co, Cs or Cn). In an ASCII context this corresponds to:</p>
<div class="sourceCode" id="cb670"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb670-1"><a href="#cb670-1" aria-hidden="true"></a>   `(<span class="op">/</span> ,(<span class="kw">integer-&gt;char</span> <span class="dv">0</span>) ,(integer-char <span class="dv">31</span>))</span></code></pre></div>
<h2 id="hex-digit"><code>hex-digit</code></h2>
<h2 id="xdigit"><code>xdigit</code></h2>
<p>Matches any valid digit in hexadecimal notation. Always ASCII-only. Equivalent to:</p>
<div class="sourceCode" id="cb671"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb671-1"><a href="#cb671-1" aria-hidden="true"></a>(w/ascii (w/nocase (<span class="kw">or</span> numeric <span class="st">&quot;abcdef&quot;</span>)))</span></code></pre></div>
<h2 id="bos"><code>bos</code></h2>
<h2 id="eos"><code>eos</code></h2>
<p>Matches at the beginning/end of string without consuming any characters (a zero-width assertion). If the search was initiated with start/end parameters, these are considered the end points, rather than the full string.</p>
<h2 id="bol"><code>bol</code></h2>
<h2 id="eol"><code>eol</code></h2>
<p>Matches at the beginning/end of a line without consuming any characters (a zero-width assertion). A line is a possibly empty sequence of characters followed by an end of line sequence as understood by the R7RS read-line procedure, specifically any of a linefeed character, carriage return character, or a carriage return followed by a linefeed character. The string is assumed to contain end of line sequences before the start and after the end of the string, even if the search was made on a substring and the actual surrounding characters differ.</p>
<h2 id="bow"><code>bow</code></h2>
<h2 id="eow"><code>eow</code></h2>
<p>Matches at the beginning/end of a word without consuming any characters (a zero-width assertion). A word is a contiguous sequence of characters that are either alphanumeric or the underscore character, i.e. (or alphanumeric "_"), with the definition of alphanumeric depending on the Unicode or ASCII context. The string is assumed to contain non-word characters immediately before the start and after the end, even if the search was made on a substring and word constituent characters appear immediately before the beginning or after the end.</p>
<div class="sourceCode" id="cb672"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb672-1"><a href="#cb672-1" aria-hidden="true"></a>  (regexp-search &#39;(: bow <span class="st">&quot;foo&quot;</span>) <span class="st">&quot;foo&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb672-2"><a href="#cb672-2" aria-hidden="true"></a>  (regexp-search &#39;(: bow <span class="st">&quot;foo&quot;</span>) <span class="st">&quot;&lt;foo&gt;&gt;&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb672-3"><a href="#cb672-3" aria-hidden="true"></a>  (regexp-search &#39;(: bow <span class="st">&quot;foo&quot;</span>) <span class="st">&quot;snafoo&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span>
<span id="cb672-4"><a href="#cb672-4" aria-hidden="true"></a>  (regexp-search &#39;(: <span class="st">&quot;foo&quot;</span> eow) <span class="st">&quot;foo&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb672-5"><a href="#cb672-5" aria-hidden="true"></a>  (regexp-search &#39;(: <span class="st">&quot;foo&quot;</span> eow) <span class="st">&quot;foo!&quot;</span>) <span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb672-6"><a href="#cb672-6" aria-hidden="true"></a>  (regexp-search &#39;(: <span class="st">&quot;foo&quot;</span> eow) <span class="st">&quot;foobar&quot;</span>) <span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="nwb"><code>nwb</code></h2>
<p>Matches a non-word-boundary (i.e. in PCRE). Equivalent to (neg-look-ahead (or bow eow)).</p>
<h2 id="word-sre-..."><code>(word sre ...)</code></h2>
<p>Anchors a sequence to word boundaries. Equivalent to:</p>
<div class="sourceCode" id="cb673"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb673-1"><a href="#cb673-1" aria-hidden="true"></a>   (: bow sre ... eow)</span></code></pre></div>
<h2 id="word-cset-sre-..."><code>(word+ cset-sre ...)</code></h2>
<p>Matches a single word composed of characters in the intersection of the given cset-sre and the word constituent characters. Equivalent to:</p>
<div class="sourceCode" id="cb674"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb674-1"><a href="#cb674-1" aria-hidden="true"></a>   (word (<span class="op">+</span> (<span class="kw">and</span> (<span class="kw">or</span> alphanumeric <span class="st">&quot;_&quot;</span>) (<span class="kw">or</span> cset-sre ...))))</span></code></pre></div>
<h2 id="word"><code>word</code></h2>
<p>A shorthand for (word+ any).</p>
<h2 id="bog"><code>bog</code></h2>
<h2 id="eog"><code>eog</code></h2>
<p>Matches at the beginning/end of a single extended grapheme cluster without consuming any characters (a zero-width assertion). Grapheme cluster boundaries are defined in Unicode TR29. The string is assumed to contain non-combining codepoints immediately before the start and after the end. These always succeed in an ASCII context.</p>
<h2 id="grapheme"><code>grapheme</code></h2>
<p>Matches a single grapheme cluster (i.e. in PCRE). This is what the end-user typically thinks of as a single character, comprised of a base non-combining codepoint followed by zero or more combining marks. In an ASCII context this is equivalent to any.</p>
<p>Assuming char-set:mark contains all characters with the Extend or SpacingMark properties defined in TR29, and char-set:control, char-set:regional-indicator and char-set:hangul-* are defined similarly, then the following SRE can be used with regexp-extract to define grapheme:</p>
<div class="sourceCode" id="cb675"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb675-1"><a href="#cb675-1" aria-hidden="true"></a>   `(<span class="kw">or</span> (: (* ,char-set:hangul-l) (<span class="op">+</span> ,char-set:hangul-v)</span>
<span id="cb675-2"><a href="#cb675-2" aria-hidden="true"></a>           (* ,char-set:hangul-t))</span>
<span id="cb675-3"><a href="#cb675-3" aria-hidden="true"></a>        (: (* ,char-set:hangul-l) ,char-set:hangul-v</span>
<span id="cb675-4"><a href="#cb675-4" aria-hidden="true"></a>           (* ,char-set:hangul-v) (* ,char-set:hangul-t))</span>
<span id="cb675-5"><a href="#cb675-5" aria-hidden="true"></a>        (: (* ,char-set:hangul-l) ,char-set:hangul-lvt</span>
<span id="cb675-6"><a href="#cb675-6" aria-hidden="true"></a>           (* ,char-set:hangul-t))</span>
<span id="cb675-7"><a href="#cb675-7" aria-hidden="true"></a>        (<span class="op">+</span> ,char-set:hangul-l)</span>
<span id="cb675-8"><a href="#cb675-8" aria-hidden="true"></a>        (<span class="op">+</span> ,char-set:hangul-t)</span>
<span id="cb675-9"><a href="#cb675-9" aria-hidden="true"></a>        (<span class="op">+</span> ,char-set:regional-indicator)</span>
<span id="cb675-10"><a href="#cb675-10" aria-hidden="true"></a>        (: <span class="st">&quot;\r\n&quot;</span>)</span>
<span id="cb675-11"><a href="#cb675-11" aria-hidden="true"></a>        (: (~ control (<span class="st">&quot;\r\n&quot;</span>))</span>
<span id="cb675-12"><a href="#cb675-12" aria-hidden="true"></a>           (* ,char-set:mark))</span>
<span id="cb675-13"><a href="#cb675-13" aria-hidden="true"></a>        control)</span></code></pre></div>
<h2 id="non-greedy-optional-sre-..."><code>(non-greedy-optional sre ...)</code></h2>
<h2 id="sre-...-6"><code>(?? sre ...)</code></h2>
<p>Non-greedy pattern, matches 0 or 1 times, preferring the shorter match.</p>
<h2 id="non-greedy-zero-or-more-sre-..."><code>(non-greedy-zero-or-more&lt; sre ...)</code></h2>
<h2 id="sre-...-7"><code>(*? sre ...)</code></h2>
<p>Non-greedy Kleene star, matches 0 or more times, preferring the shorter match.</p>
<h2 id="non-greedy-repeated-m-n-sre-..."><code>(non-greedy-repeated m n sre ...)</code></h2>
<h2 id="m-n-sre-..."><code>(**? m n sre ...)</code></h2>
<p>Non-greedy Kleene star, matches m to n times, preferring the shorter match.</p>
<h2 id="look-ahead-sre-..."><code>(look-ahead sre ...)</code></h2>
<p>Zero-width look-ahead assertion. Asserts the sequence matches from the current position, without advancing the position.</p>
<div class="sourceCode" id="cb676"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb676-1"><a href="#cb676-1" aria-hidden="true"></a>(regexp-matches &#39;(: <span class="st">&quot;regular&quot;</span> (look-ahead <span class="st">&quot; expression&quot;</span>) <span class="st">&quot; expression&quot;</span>) <span class="st">&quot;regular expression&quot;</span>)<span class="op">=&gt;</span> #&lt;regexp-match&gt;</span>
<span id="cb676-2"><a href="#cb676-2" aria-hidden="true"></a>(regexp-matches &#39;(: <span class="st">&quot;regular&quot;</span> (look-ahead <span class="st">&quot; &quot;</span>) <span class="st">&quot;expression&quot;</span>) <span class="st">&quot;regular expression&quot;</span>)<span class="op">=&gt;</span> <span class="dv">#f</span></span></code></pre></div>
<h2 id="look-behind-sre-..."><code>(look-behind sre ...)</code></h2>
<p>Zero-width look-behind assertion. Asserts the sequence matches behind the current position, without advancing the position. It is an error if the sequence does not have a fixed length.</p>
<h2 id="neg-look-ahead-sre-..."><code>(neg-look-ahead sre ...)</code></h2>
<p>Zero-width negative look-ahead assertion.</p>
<h2 id="neg-look-behind-sre-..."><code>(neg-look-behind sre ...)</code></h2>
<p>Zero-width negative look-behind assertion. # <code>(scheme vector)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-133/">SRFI-133</a>.</p>
<h2 id="make-vector-size-fill"><code>(make-vector size [fill])</code></h2>
<p>[R7RS-small] Creates and returns a vector of size size. If fill is specified, all the elements of the vector are initialized to fill. Otherwise, their contents are indeterminate.</p>
<p>Example:</p>
<div class="sourceCode" id="cb677"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb677-1"><a href="#cb677-1" aria-hidden="true"></a>(<span class="kw">make-vector</span> <span class="dv">5</span> <span class="dv">3</span>)</span>
<span id="cb677-2"><a href="#cb677-2" aria-hidden="true"></a>#(<span class="dv">3</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">3</span>)</span></code></pre></div>
<h2 id="vector-x-..."><code>(vector x ...)</code></h2>
<p>[R7RS-small] Creates and returns a vector whose elements are x ….</p>
<p>Example:</p>
<div class="sourceCode" id="cb678"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb678-1"><a href="#cb678-1" aria-hidden="true"></a>(<span class="kw">vector</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)</span>
<span id="cb678-2"><a href="#cb678-2" aria-hidden="true"></a>#(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)</span></code></pre></div>
<h2 id="vector-unfold-f-length-initial-seed-..."><code>(vector-unfold f length initial-seed ...)</code></h2>
<p>The fundamental vector constructor. Creates a vector whose length is length and iterates across each index k between 0 and length, applying f at each iteration to the current index and current seeds, in that order, to receive n + 1 values: first, the element to put in the kth slot of the new vector and n new seeds for the next iteration. It is an error for the number of seeds to vary between iterations. Note that the termination condition is different from the unfold procedure of SRFI 1.</p>
<p>Examples:</p>
<p>``scheme (vector-unfold (λ (i x) (values x (- x 1))) 10 0) #(0 -1 -2 -3 -4 -5 -6 -7 -8 -9)</p>
<pre><code>
Construct a vector of the sequence of integers in the range [0,n).

```scheme
(vector-unfold values n)
#(0 1 2 ... n-2 n-1)</code></pre>
<p>Copy vector.</p>
<div class="sourceCode" id="cb680"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb680-1"><a href="#cb680-1" aria-hidden="true"></a>    (vector-unfold (λ (i) (<span class="kw">vector-ref</span> <span class="kw">vector</span> i))</span>
<span id="cb680-2"><a href="#cb680-2" aria-hidden="true"></a>                     (<span class="kw">vector-length</span> <span class="kw">vector</span>))</span></code></pre></div>
<h2 id="vector-unfold-right-f-length-initial-seed-..."><code>(vector-unfold-right f length initial-seed ...)</code></h2>
<p>Like vector-unfold, but it uses f to generate elements from right-to-left, rather than left-to-right. The first index used is length - 1. Note that the termination condition is different from the unfold-right procedure of SRFI 1.</p>
<p>Examples:</p>
<p>Construct a vector of pairs of non-negative integers whose values sum to 4.</p>
<div class="sourceCode" id="cb681"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb681-1"><a href="#cb681-1" aria-hidden="true"></a>(vector-unfold-right (λ (i x) (<span class="kw">values</span> (<span class="kw">cons</span> i x) (<span class="op">+</span> x <span class="dv">1</span>))) <span class="dv">5</span> <span class="dv">0</span>)</span>
<span id="cb681-2"><a href="#cb681-2" aria-hidden="true"></a>#((<span class="dv">0</span> . <span class="dv">4</span>) (<span class="dv">1</span> . <span class="dv">3</span>) (<span class="dv">2</span> . <span class="dv">2</span>) (<span class="dv">3</span> . <span class="dv">1</span>) (<span class="dv">4</span> . <span class="dv">0</span>))</span></code></pre></div>
<p>Reverse vector.</p>
<div class="sourceCode" id="cb682"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb682-1"><a href="#cb682-1" aria-hidden="true"></a>    (vector-unfold-right (λ (i x) (<span class="kw">values</span> (<span class="kw">vector-ref</span> <span class="kw">vector</span> x) (<span class="op">+</span> x <span class="dv">1</span>)))</span>
<span id="cb682-2"><a href="#cb682-2" aria-hidden="true"></a>                           (<span class="kw">vector-length</span> <span class="kw">vector</span>)</span>
<span id="cb682-3"><a href="#cb682-3" aria-hidden="true"></a>                           <span class="dv">0</span>)</span></code></pre></div>
<h2 id="vector-copy-vec-start-end"><code>(vector-copy vec [start [end]])</code></h2>
<p>[R7RS-small] Allocates a new vector whose length is end - start and fills it with elements from vec, taking elements from vec starting at index start and stopping at index end. Start defaults to 0 and end defaults to the value of (vector-length vec). SRFI 43 provides an optional fill argument to supply values if end is greater than the length of vec. Neither R7RS-small nor this SRFI requires support for this argument.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb683"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb683-1"><a href="#cb683-1" aria-hidden="true"></a>    (vector-copy &#39;#(a b c d e f g h i))</span>
<span id="cb683-2"><a href="#cb683-2" aria-hidden="true"></a>    #(a b c d e f g h i)</span>
<span id="cb683-3"><a href="#cb683-3" aria-hidden="true"></a></span>
<span id="cb683-4"><a href="#cb683-4" aria-hidden="true"></a>    (vector-copy &#39;#(a b c d e f g h i) <span class="dv">6</span>)</span>
<span id="cb683-5"><a href="#cb683-5" aria-hidden="true"></a>    #(g h i)</span>
<span id="cb683-6"><a href="#cb683-6" aria-hidden="true"></a></span>
<span id="cb683-7"><a href="#cb683-7" aria-hidden="true"></a>    (vector-copy &#39;#(a b c d e f g h i) <span class="dv">3</span> <span class="dv">6</span>)</span>
<span id="cb683-8"><a href="#cb683-8" aria-hidden="true"></a>    #(d e f)</span></code></pre></div>
<h2 id="vector-reverse-copy-vec-start-end"><code>(vector-reverse-copy vec [start [end]])</code></h2>
<p>Like vector-copy, but it copies the elements in the reverse order from vec.</p>
<p>Example:</p>
<div class="sourceCode" id="cb684"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb684-1"><a href="#cb684-1" aria-hidden="true"></a>(vector-reverse-copy &#39;#(<span class="dv">5</span> <span class="dv">4</span> <span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span> <span class="dv">0</span>) <span class="dv">1</span> <span class="dv">5</span>)</span>
<span id="cb684-2"><a href="#cb684-2" aria-hidden="true"></a>#(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)</span></code></pre></div>
<h2 id="vector-append-vec-..."><code>(vector-append vec ...)</code></h2>
<p>[R7RS-small] Returns a newly allocated vector that contains all elements in order from the subsequent locations in vec ….</p>
<p>Examples:</p>
<div class="sourceCode" id="cb685"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb685-1"><a href="#cb685-1" aria-hidden="true"></a>(vector-append &#39;#(x) &#39;#(y))</span>
<span id="cb685-2"><a href="#cb685-2" aria-hidden="true"></a>#(x y)</span>
<span id="cb685-3"><a href="#cb685-3" aria-hidden="true"></a></span>
<span id="cb685-4"><a href="#cb685-4" aria-hidden="true"></a>(vector-append &#39;#(a) &#39;#(b c d))</span>
<span id="cb685-5"><a href="#cb685-5" aria-hidden="true"></a>#(a b c d)</span>
<span id="cb685-6"><a href="#cb685-6" aria-hidden="true"></a></span>
<span id="cb685-7"><a href="#cb685-7" aria-hidden="true"></a>(vector-append &#39;#(a #(b)) &#39;#(#(c)))</span>
<span id="cb685-8"><a href="#cb685-8" aria-hidden="true"></a>#(a #(b) #(c))</span></code></pre></div>
<h2 id="vector-concatenate-list-of-vectors"><code>(vector-concatenate list-of-vectors)</code></h2>
<p>Appends each vector in list-of-vectors. This is equivalent to:</p>
<div class="sourceCode" id="cb686"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb686-1"><a href="#cb686-1" aria-hidden="true"></a>(apply vector-append list-of-vectors)</span></code></pre></div>
<p>However, it may be implemented better.</p>
<p>Example:</p>
<div class="sourceCode" id="cb687"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb687-1"><a href="#cb687-1" aria-hidden="true"></a>(vector-concatenate &#39;(#(a b) #(c d)))</span>
<span id="cb687-2"><a href="#cb687-2" aria-hidden="true"></a>#(a b c d)</span></code></pre></div>
<h2 id="vector-append-subvectors-vec-start-end-..."><code>(vector-append-subvectors [vec start end] ...)</code></h2>
<p>Returns a vector that contains every element of each vec from start to end in the specified order. This procedure is a generalization of vector-append.</p>
<p>Example:</p>
<div class="sourceCode" id="cb688"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb688-1"><a href="#cb688-1" aria-hidden="true"></a>(vector-append-subvectors &#39;#(a b c d e) <span class="dv">0</span> <span class="dv">2</span> &#39;#(f g h i j) <span class="dv">2</span> <span class="dv">4</span>)</span>
<span id="cb688-2"><a href="#cb688-2" aria-hidden="true"></a>#(a b h i)</span></code></pre></div>
<h2 id="vector-x"><code>(vector? x)</code></h2>
<p>[R7RS-small] Disjoint type predicate for vectors: this returns #t if x is a vector, and #f if otherwise.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb689"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb689-1"><a href="#cb689-1" aria-hidden="true"></a>(<span class="kw">vector?</span> &#39;#(a b c))</span>
<span id="cb689-2"><a href="#cb689-2" aria-hidden="true"></a><span class="dv">#t</span></span>
<span id="cb689-3"><a href="#cb689-3" aria-hidden="true"></a></span>
<span id="cb689-4"><a href="#cb689-4" aria-hidden="true"></a>(<span class="kw">vector?</span> &#39;(a b c))</span>
<span id="cb689-5"><a href="#cb689-5" aria-hidden="true"></a><span class="dv">#f</span></span>
<span id="cb689-6"><a href="#cb689-6" aria-hidden="true"></a></span>
<span id="cb689-7"><a href="#cb689-7" aria-hidden="true"></a>(<span class="kw">vector?</span> <span class="dv">#t</span>)</span>
<span id="cb689-8"><a href="#cb689-8" aria-hidden="true"></a><span class="dv">#f</span></span>
<span id="cb689-9"><a href="#cb689-9" aria-hidden="true"></a></span>
<span id="cb689-10"><a href="#cb689-10" aria-hidden="true"></a>(<span class="kw">vector?</span> &#39;#())</span>
<span id="cb689-11"><a href="#cb689-11" aria-hidden="true"></a><span class="dv">#t</span></span>
<span id="cb689-12"><a href="#cb689-12" aria-hidden="true"></a></span>
<span id="cb689-13"><a href="#cb689-13" aria-hidden="true"></a>(<span class="kw">vector?</span> &#39;())</span>
<span id="cb689-14"><a href="#cb689-14" aria-hidden="true"></a><span class="dv">#f</span></span></code></pre></div>
<h2 id="vector-empty-vec"><code>(vector-empty? vec)</code></h2>
<p>Returns #t if vec is empty, i.e. its length is 0, and #f if not.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb690"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb690-1"><a href="#cb690-1" aria-hidden="true"></a>(vector-empty? &#39;#(a))</span>
<span id="cb690-2"><a href="#cb690-2" aria-hidden="true"></a><span class="dv">#f</span></span>
<span id="cb690-3"><a href="#cb690-3" aria-hidden="true"></a></span>
<span id="cb690-4"><a href="#cb690-4" aria-hidden="true"></a>(vector-empty? &#39;#(()))</span>
<span id="cb690-5"><a href="#cb690-5" aria-hidden="true"></a><span class="dv">#f</span></span>
<span id="cb690-6"><a href="#cb690-6" aria-hidden="true"></a></span>
<span id="cb690-7"><a href="#cb690-7" aria-hidden="true"></a>(vector-empty? &#39;#(#()))</span>
<span id="cb690-8"><a href="#cb690-8" aria-hidden="true"></a><span class="dv">#f</span></span>
<span id="cb690-9"><a href="#cb690-9" aria-hidden="true"></a></span>
<span id="cb690-10"><a href="#cb690-10" aria-hidden="true"></a>(vector-empty? &#39;#())</span>
<span id="cb690-11"><a href="#cb690-11" aria-hidden="true"></a><span class="dv">#t</span></span></code></pre></div>
<h2 id="vector-elt-vec-..."><code>(vector= elt=? vec ...)</code></h2>
<p>Vector structure comparator, generalized across user-specified element comparators. Vectors a and b are considered equal by vector= iff their lengths are the same, and for each respective element Ea and Eb, (elt=? Ea Eb) returns a true value. Elt=? is always applied to two arguments.</p>
<p>If there are only zero or one vector arguments, #t is automatically returned. The dynamic order in which comparisons of elements and of vectors are performed is left completely unspecified; do not rely on a particular order.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb691"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb691-1"><a href="#cb691-1" aria-hidden="true"></a>(vector= <span class="kw">eq?</span> &#39;#(a b c d) &#39;#(a b c d))</span>
<span id="cb691-2"><a href="#cb691-2" aria-hidden="true"></a><span class="dv">#t</span></span>
<span id="cb691-3"><a href="#cb691-3" aria-hidden="true"></a></span>
<span id="cb691-4"><a href="#cb691-4" aria-hidden="true"></a>(vector= <span class="kw">eq?</span> &#39;#(a b c d) &#39;#(a b d c))</span>
<span id="cb691-5"><a href="#cb691-5" aria-hidden="true"></a><span class="dv">#f</span></span>
<span id="cb691-6"><a href="#cb691-6" aria-hidden="true"></a></span>
<span id="cb691-7"><a href="#cb691-7" aria-hidden="true"></a>(vector= <span class="op">=</span> &#39;#(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>) &#39;#(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))</span>
<span id="cb691-8"><a href="#cb691-8" aria-hidden="true"></a><span class="dv">#f</span></span>
<span id="cb691-9"><a href="#cb691-9" aria-hidden="true"></a></span>
<span id="cb691-10"><a href="#cb691-10" aria-hidden="true"></a>(vector= <span class="op">=</span> &#39;#(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>) &#39;#(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))</span>
<span id="cb691-11"><a href="#cb691-11" aria-hidden="true"></a><span class="dv">#t</span></span>
<span id="cb691-12"><a href="#cb691-12" aria-hidden="true"></a></span>
<span id="cb691-13"><a href="#cb691-13" aria-hidden="true"></a>The two trivial cases.</span>
<span id="cb691-14"><a href="#cb691-14" aria-hidden="true"></a></span>
<span id="cb691-15"><a href="#cb691-15" aria-hidden="true"></a>(vector= <span class="kw">eq?</span>)</span>
<span id="cb691-16"><a href="#cb691-16" aria-hidden="true"></a><span class="dv">#t</span></span>
<span id="cb691-17"><a href="#cb691-17" aria-hidden="true"></a></span>
<span id="cb691-18"><a href="#cb691-18" aria-hidden="true"></a>(vector= <span class="kw">eq?</span> &#39;#(a))</span>
<span id="cb691-19"><a href="#cb691-19" aria-hidden="true"></a><span class="dv">#t</span></span>
<span id="cb691-20"><a href="#cb691-20" aria-hidden="true"></a></span>
<span id="cb691-21"><a href="#cb691-21" aria-hidden="true"></a>Note the fact that we don&#39;t use <span class="kw">vector</span> literals in the next two — it is unspecified whether <span class="kw">or</span> <span class="kw">not</span> literal vectors with the same external representation are <span class="kw">eq?</span>.</span>
<span id="cb691-22"><a href="#cb691-22" aria-hidden="true"></a></span>
<span id="cb691-23"><a href="#cb691-23" aria-hidden="true"></a>(vector= <span class="kw">eq?</span> (<span class="kw">vector</span> (<span class="kw">vector</span> &#39;a)) (<span class="kw">vector</span> (<span class="kw">vector</span> &#39;a)))</span>
<span id="cb691-24"><a href="#cb691-24" aria-hidden="true"></a><span class="dv">#f</span></span>
<span id="cb691-25"><a href="#cb691-25" aria-hidden="true"></a></span>
<span id="cb691-26"><a href="#cb691-26" aria-hidden="true"></a>(vector= <span class="kw">equal?</span> (<span class="kw">vector</span> (<span class="kw">vector</span> &#39;a)) (<span class="kw">vector</span> (<span class="kw">vector</span> &#39;a)))</span>
<span id="cb691-27"><a href="#cb691-27" aria-hidden="true"></a><span class="dv">#t</span></span></code></pre></div>
<h2 id="vector-ref-vec-i"><code>(vector-ref vec i)</code></h2>
<p>[R7RS-small] Vector element dereferencing: returns the value that the location in vec at i is mapped to in the store. Indexing is based on zero. I must be within the range [0, (vector-length vec)).</p>
<p>Example:</p>
<div class="sourceCode" id="cb692"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb692-1"><a href="#cb692-1" aria-hidden="true"></a>(<span class="kw">vector-ref</span> &#39;#(a b c d) <span class="dv">2</span>)</span>
<span id="cb692-2"><a href="#cb692-2" aria-hidden="true"></a>c</span></code></pre></div>
<h2 id="vector-length-vec"><code>(vector-length vec)</code></h2>
<p>[R7RS-small] Returns the length of vec, the number of locations reachable from vec. (The careful word ‘reachable’ is used to allow for ‘vector slices,’ whereby vec refers to a larger vector that contains more locations that are unreachable from vec. This SRFI does not define vector slices, but later SRFIs may.)</p>
<p>Example:</p>
<div class="sourceCode" id="cb693"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb693-1"><a href="#cb693-1" aria-hidden="true"></a>(<span class="kw">vector-length</span> &#39;#(a b c))</span>
<span id="cb693-2"><a href="#cb693-2" aria-hidden="true"></a><span class="dv">3</span></span></code></pre></div>
<h2 id="vector-fold-kons-knil-vec1-vec2-..."><code>(vector-fold kons knil vec1 vec2 ...)</code></h2>
<p>The fundamental vector iterator. Kons is iterated over each value in all of the vectors, stopping at the end of the shortest; kons is applied as (kons state (vector-ref vec1 i) (vector-ref vec2 i) …) where state is the current state value — the current state value begins with knil, and becomes whatever kons returned on the previous iteration —, and i is the current index.</p>
<p>The iteration is strictly left-to-right.</p>
<p>Examples:</p>
<p>Find the longest string’s length in vector-of-strings.</p>
<div class="sourceCode" id="cb694"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb694-1"><a href="#cb694-1" aria-hidden="true"></a>    (vector-fold (λ (len str) (<span class="kw">max</span> (<span class="kw">string-length</span> str) len))</span>
<span id="cb694-2"><a href="#cb694-2" aria-hidden="true"></a>                   <span class="dv">0</span> vector-of-strings)</span></code></pre></div>
<p>Produce a list of the reversed elements of vec.</p>
<pre><code>    (vector-fold (λ (tail elt) (cons elt tail))
                   &#39;() vec)</code></pre>
<p>Count the number of even numbers in vec.</p>
<div class="sourceCode" id="cb696"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb696-1"><a href="#cb696-1" aria-hidden="true"></a>    (vector-fold (λ (counter n)</span>
<span id="cb696-2"><a href="#cb696-2" aria-hidden="true"></a>                     (<span class="kw">if</span> (<span class="kw">even?</span> n) (<span class="op">+</span> counter <span class="dv">1</span>) counter))</span>
<span id="cb696-3"><a href="#cb696-3" aria-hidden="true"></a>                   <span class="dv">0</span> vec)</span></code></pre></div>
<h2 id="vector-fold-right-kons-knil-vec1-vec2-..."><code>(vector-fold-right kons knil vec1 vec2 ...)</code></h2>
<p>Similar to vector-fold, but it iterates right to left instead of left to right.</p>
<p>Example:</p>
<p>Convert a vector to a list.</p>
<div class="sourceCode" id="cb697"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb697-1"><a href="#cb697-1" aria-hidden="true"></a>    (vector-fold-right (λ (tail elt) (<span class="kw">cons</span> elt tail))</span>
<span id="cb697-2"><a href="#cb697-2" aria-hidden="true"></a>                         &#39;() &#39;#(a b c d))</span>
<span id="cb697-3"><a href="#cb697-3" aria-hidden="true"></a>    (a b c d)</span></code></pre></div>
<h2 id="vector-map-f-vec1-vec2-..."><code>(vector-map f vec1 vec2 ...)</code></h2>
<p>[R7RS-small] Constructs a new vector of the shortest size of the vector arguments. Each element at index i of the new vector is mapped from the old vectors by (f (vector-ref vec1 i) (vector-ref vec2 i) …). The dynamic order of application of f is unspecified.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb698"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb698-1"><a href="#cb698-1" aria-hidden="true"></a>    (vector-map (λ (x) (* x x))</span>
<span id="cb698-2"><a href="#cb698-2" aria-hidden="true"></a>                  (vector-unfold (λ (i x) (<span class="kw">values</span> x (<span class="op">+</span> x <span class="dv">1</span>))) <span class="dv">4</span> <span class="dv">1</span>))</span>
<span id="cb698-3"><a href="#cb698-3" aria-hidden="true"></a>    #(<span class="dv">1</span> <span class="dv">4</span> <span class="dv">9</span> <span class="dv">16</span>)</span>
<span id="cb698-4"><a href="#cb698-4" aria-hidden="true"></a></span>
<span id="cb698-5"><a href="#cb698-5" aria-hidden="true"></a>    (vector-map (λ (x y) (* x y))</span>
<span id="cb698-6"><a href="#cb698-6" aria-hidden="true"></a>                  (vector-unfold (λ (x) (<span class="kw">values</span> x (<span class="op">+</span> x <span class="dv">1</span>))) <span class="dv">5</span> <span class="dv">1</span>)</span>
<span id="cb698-7"><a href="#cb698-7" aria-hidden="true"></a>                  (vector-unfold (λ (x) (<span class="kw">values</span> x (<span class="op">-</span> x <span class="dv">1</span>))) <span class="dv">5</span> <span class="dv">5</span>))</span>
<span id="cb698-8"><a href="#cb698-8" aria-hidden="true"></a>    #(<span class="dv">5</span> <span class="dv">8</span> <span class="dv">9</span> <span class="dv">8</span> <span class="dv">5</span>)</span>
<span id="cb698-9"><a href="#cb698-9" aria-hidden="true"></a></span>
<span id="cb698-10"><a href="#cb698-10" aria-hidden="true"></a>    (<span class="kw">let</span> ((count <span class="dv">0</span>))</span>
<span id="cb698-11"><a href="#cb698-11" aria-hidden="true"></a>       (vector-map (λ (ignored-elt)</span>
<span id="cb698-12"><a href="#cb698-12" aria-hidden="true"></a>                     (set! count (<span class="op">+</span> count <span class="dv">1</span>))</span>
<span id="cb698-13"><a href="#cb698-13" aria-hidden="true"></a>                     count)</span>
<span id="cb698-14"><a href="#cb698-14" aria-hidden="true"></a>                   &#39;#(a b)))</span>
<span id="cb698-15"><a href="#cb698-15" aria-hidden="true"></a>    #(<span class="dv">1</span> <span class="dv">2</span>) OR #(<span class="dv">2</span> <span class="dv">1</span>)</span></code></pre></div>
<h2 id="vector-map-f-vec1-vec2-...-1"><code>(vector-map! f vec1 vec2 ...)</code></h2>
<p>Similar to vector-map, but rather than mapping the new elements into a new vector, the new mapped elements are destructively inserted into vec1. Again, the dynamic order of application of f unspecified, so it is dangerous for f to apply either vector-ref or vector-set! to vec1 in f.</p>
<h2 id="vector-for-each-f-vec1-vec2-..."><code>(vector-for-each f vec1 vec2 ...)</code></h2>
<p>[R7RS-small] Simple vector iterator: applies f to the corresponding list of parallel elements from vec1 vec2 … in the range [0, length), where length is the length of the smallest vector argument passed, In contrast with vector-map, f is reliably applied to each subsequent element, starting at index 0, in the vectors.</p>
<p>Example:</p>
<div class="sourceCode" id="cb699"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb699-1"><a href="#cb699-1" aria-hidden="true"></a>    (vector-for-each (λ (x) (<span class="kw">display</span> x) (<span class="kw">newline</span>))</span>
<span id="cb699-2"><a href="#cb699-2" aria-hidden="true"></a>                     &#39;#(<span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span> <span class="st">&quot;baz&quot;</span> <span class="st">&quot;quux&quot;</span> <span class="st">&quot;zot&quot;</span>))</span></code></pre></div>
<p>Displays:</p>
<pre><code>foo
bar
baz
quux
zot</code></pre>
<h2 id="vector-count-pred-vec1-vec2-..."><code>(vector-count pred? vec1 vec2 ...)</code></h2>
<p>Counts the number of parallel elements in the vectors that satisfy pred?, which is applied, for each index i in the range [0, length) where length is the length of the smallest vector argument, to each parallel element in the vectors, in order.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb701"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb701-1"><a href="#cb701-1" aria-hidden="true"></a>(vector-count <span class="kw">even?</span> &#39;#(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>))</span>
<span id="cb701-2"><a href="#cb701-2" aria-hidden="true"></a><span class="dv">3</span></span>
<span id="cb701-3"><a href="#cb701-3" aria-hidden="true"></a></span>
<span id="cb701-4"><a href="#cb701-4" aria-hidden="true"></a>(vector-count <span class="op">&lt;</span> &#39;#(<span class="dv">1</span> <span class="dv">3</span> <span class="dv">6</span> <span class="dv">9</span>) &#39;#(<span class="dv">2</span> <span class="dv">4</span> <span class="dv">6</span> <span class="dv">8</span> <span class="dv">10</span> <span class="dv">12</span>))</span>
<span id="cb701-5"><a href="#cb701-5" aria-hidden="true"></a><span class="dv">2</span></span></code></pre></div>
<h2 id="vector-cumulate-f-knil-vec"><code>(vector-cumulate f knil vec)</code></h2>
<p>Returns a newly allocated vector new with the same length as vec. Each element i of new is set to the result of invoking f on newi-1 and veci, except that for the first call on f, the first argument is knil. The new vector is returned.</p>
<p>Note that the order of arguments to vector-cumulate was changed by errata-3 on 2016-09-02.</p>
<p>Example:</p>
<div class="sourceCode" id="cb702"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb702-1"><a href="#cb702-1" aria-hidden="true"></a>(vector-cumulate <span class="op">+</span> <span class="dv">0</span> &#39;#(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>))</span>
<span id="cb702-2"><a href="#cb702-2" aria-hidden="true"></a>#(<span class="dv">3</span> <span class="dv">4</span> <span class="dv">8</span> <span class="dv">9</span> <span class="dv">14</span> <span class="dv">23</span> <span class="dv">25</span> <span class="dv">30</span> <span class="dv">36</span>)</span></code></pre></div>
<h2 id="vector-index-pred-vec1-vec2-..."><code>(vector-index pred? vec1 vec2 ...)</code></h2>
<p>Finds &amp; returns the index of the first elements in vec1 vec2 … that satisfy pred?. If no matching element is found by the end of the shortest vector, #f is returned.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb703"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb703-1"><a href="#cb703-1" aria-hidden="true"></a>(vector-index <span class="kw">even?</span> &#39;#(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>))</span>
<span id="cb703-2"><a href="#cb703-2" aria-hidden="true"></a><span class="dv">2</span></span>
<span id="cb703-3"><a href="#cb703-3" aria-hidden="true"></a></span>
<span id="cb703-4"><a href="#cb703-4" aria-hidden="true"></a>(vector-index <span class="op">&lt;</span> &#39;#(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) &#39;#(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>))</span>
<span id="cb703-5"><a href="#cb703-5" aria-hidden="true"></a><span class="dv">1</span></span>
<span id="cb703-6"><a href="#cb703-6" aria-hidden="true"></a></span>
<span id="cb703-7"><a href="#cb703-7" aria-hidden="true"></a>(vector-index <span class="op">=</span> &#39;#(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) &#39;#(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>))</span>
<span id="cb703-8"><a href="#cb703-8" aria-hidden="true"></a><span class="dv">#f</span></span></code></pre></div>
<h2 id="vector-index-right-pred-vec1-vec2-..."><code>(vector-index-right pred? vec1 vec2 ...)</code></h2>
<p>Like vector-index, but it searches right-to-left, rather than left-to-right, and all of the vectors must have the same length.</p>
<h2 id="vector-skip-pred-vec1-vec2-..."><code>(vector-skip pred? vec1 vec2 ...)</code></h2>
<p>Finds &amp; returns the index of the first elements in vec1 vec2 … that do not satisfy pred?. If all the values in the vectors satisfy pred? until the end of the shortest vector, this returns #f. This is equivalent to:</p>
<p>``scheme (vector-index (λ (x1 x2 …) (not (pred? x1 x1 …))) vec1 vec2 …)</p>
<pre><code>
Example:

```scheme
(vector-skip number? &#39;#(1 2 a b 3 4 c d))
2</code></pre>
<h2 id="vector-skip-right-pred-vec1-vec2-..."><code>(vector-skip-right pred? vec1 vec2 ...)</code></h2>
<p>Like vector-skip, but it searches for a non-matching element right-to-left, rather than left-to-right, and it is an error if all of the vectors do not have the same length. This is equivalent to:</p>
<div class="sourceCode" id="cb705"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb705-1"><a href="#cb705-1" aria-hidden="true"></a>    (vector-index-right (λ (x1 x2 ...) (<span class="kw">not</span> (pred? x1 x1 ...)))</span>
<span id="cb705-2"><a href="#cb705-2" aria-hidden="true"></a>                              vec1 vec2 ...)</span></code></pre></div>
<h2 id="vector-binary-search-vec-value-cmp"><code>(vector-binary-search vec value cmp)</code></h2>
<p>Similar to vector-index and vector-index-right, but instead of searching left to right or right to left, this performs a binary search. If there is more than one element of vec that matches value in the sense of cmp, vector-binary-search may return the index of any of them.</p>
<p>cmp should be a procedure of two arguments and return a negative integer, which indicates that its first argument is less than its second, zero, which indicates that they are equal, or a positive integer, which indicates that the first argument is greater than the second argument. An example cmp might be:</p>
<div class="sourceCode" id="cb706"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb706-1"><a href="#cb706-1" aria-hidden="true"></a>    (λ (char1 char2)</span>
<span id="cb706-2"><a href="#cb706-2" aria-hidden="true"></a>      (<span class="kw">cond</span> ((char&lt;? char1 char2) <span class="dv">-1</span>)</span>
<span id="cb706-3"><a href="#cb706-3" aria-hidden="true"></a>            ((<span class="kw">char=?</span> char1 char2) <span class="dv">0</span>)</span>
<span id="cb706-4"><a href="#cb706-4" aria-hidden="true"></a>            (<span class="kw">else</span> <span class="dv">1</span>)))</span></code></pre></div>
<h2 id="vector-any-pred-vec1-vec2-..."><code>(vector-any pred? vec1 vec2 ...)</code></h2>
<p>Finds the first set of elements in parallel from vec1 vec2 … for which pred? returns a true value. If such a parallel set of elements exists, vector-any returns the value that pred? returned for that set of elements. The iteration is strictly left-to-right.</p>
<h2 id="vector-every-pred-vec1-vec2-..."><code>(vector-every pred? vec1 vec2 ...)</code></h2>
<p>If, for every index i between 0 and the length of the shortest vector argument, the set of elements (vector-ref vec1 i) (vector-ref vec2 i) … satisfies pred?, vector-every returns the value that pred? returned for the last set of elements, at the last index of the shortest vector. The iteration is strictly left-to-right.</p>
<h2 id="vector-partition-pred-vec"><code>(vector-partition pred? vec)</code></h2>
<p>A vector the same size as vec is newly allocated and filled with all the elements of vec that satisfy pred? in their original order followed by all the elements that do not satisfy pred?, also in their original order.</p>
<p>Two values are returned, the newly allocated vector and the index of the leftmost element that does not satisfy pred?.</p>
<h2 id="vector-set-vec-i-value"><code>(vector-set! vec i value)</code></h2>
<p>[R7RS-small] Assigns the contents of the location at i in vec to value.</p>
<h2 id="vector-swap-vec-i-j"><code>(vector-swap! vec i j)</code></h2>
<p>Swaps or exchanges the values of the locations in vec at i &amp; j.</p>
<h2 id="vector-fill-vec-fill-start-end"><code>(vector-fill! vec fill [start [end]])</code></h2>
<p>[R7RS-small] Assigns the value of every location in vec between start, which defaults to 0 and end, which defaults to the length of vec, to fill.</p>
<h2 id="vector-reverse-vec-start-end"><code>(vector-reverse! vec [start [end]])</code></h2>
<p>Destructively reverses the contents of the sequence of locations in vec between start and end. Start defaults to 0 and end defaults to the length of vec. Note that this does not deeply reverse.</p>
<h2 id="vector-copy-to-at-from-start-end"><code>(vector-copy! to at from [start [end]])</code></h2>
<p>[R7RS-small] Copies the elements of vector from between start and end to vector to, starting at at. The order in which elements are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary vector and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances.</p>
<h2 id="vector-reverse-copy-to-at-from-start-end"><code>(vector-reverse-copy! to at from [start [end]])</code></h2>
<p>Like vector-copy!, but the elements appear in to in reverse order.</p>
<h2 id="vector-unfold-f-vec-start-end-initial-seed-..."><code>(vector-unfold! f vec start end initial-seed ...)</code></h2>
<p>Like vector-unfold, but the elements are copied into the vector vec starting at element start rather than into a newly allocated vector. Terminates when end-start elements have been generated.</p>
<h2 id="vector-unfold-right-f-vec-start-end-initial-seed-..."><code>(vector-unfold-right! f vec start end initial-seed ...)</code></h2>
<p>Like vector-unfold!, but the elements are copied in reverse order into the vector vec starting at the index preceding end.</p>
<h2 id="vector-list-vec-start-end"><code>(vector-&gt;list vec [start [end]])</code></h2>
<p>[R7RS-small] Creates a list containing the elements in vec between start, which defaults to 0, and end, which defaults to the length of vec.</p>
<h2 id="reverse-vector-list-vec-start-end"><code>(reverse-vector-&gt;list vec [start [end]])</code></h2>
<p>Like vector-&gt;list, but the resulting list contains the elements in reverse of vec.</p>
<h2 id="list-vector-proper-list"><code>(list-&gt;vector proper-list)</code></h2>
<p>[R7RS-small] Creates a vector of elements from proper-list.</p>
<h2 id="reverse-list-vector-proper-list"><code>(reverse-list-&gt;vector proper-list)</code></h2>
<p>Like list-&gt;vector, but the resulting vector contains the elements in reverse of proper-list.</p>
<h2 id="string-vector-string-start-end"><code>(string-&gt;vector string [start [end]])</code></h2>
<p>[R7RS-small] Creates a vector containing the elements in string between start, which defaults to 0, and end, which defaults to the length of string.</p>
<h2 id="vector-string-vec-start-end"><code>(vector-&gt;string vec [start [end]])</code></h2>
<p>[R7RS-small] Creates a string containing the elements in vec between start, which defaults to 0, and end, which defaults to the length of vec. It is an error if the elements are not characters. # <code>(scheme repl)</code></p>
<h2 id="interaction-environment"><code>(interaction-environment)</code></h2>
<p>This procedure returns a specifier for a mutable environment that contains an implementation-defined set of bindings, typically a superset of those exported by <code>(arew scheme base)</code>. The intent is that this procedure will return the environment in which the implementation would evaluate expressions entered by the user into a REPL. # <code>(scheme base)</code></p>
<h2 id="section"><code>_</code></h2>
<p>TODO (missing in r7rs?)</p>
<h2 id="section-1"><code>...</code></h2>
<p>It is called ellipsis. It signify that a pattern must be repeated.</p>
<h2 id="section-2"><code>=&gt;</code></h2>
<p>TODO</p>
<h2 id="else"><code>else</code></h2>
<p>Used in <code>cond</code> and <code>case</code> form as in the last clause as a fallback.</p>
<h2 id="number-..."><code>(* number ...)</code></h2>
<p>Multiplication procedure.</p>
<h2 id="number-...-1"><code>(+ number ...)</code></h2>
<p>Addition procedure.</p>
<h2 id="number-...-2"><code>(- number ...)</code></h2>
<p>Substraction procedure.</p>
<h2 id="number-...-3"><code>(/ number ...)</code></h2>
<p>Division procedure. Raise <code>'numerical-overflow</code> condition in case where denominator is zero.</p>
<h2 id="number-number-..."><code>(&lt; number number ...)</code></h2>
<p>Less than procedure. Return a boolean.</p>
<h2 id="number-number-...-1"><code>(&lt;= number number ...)</code></h2>
<p>Less than or equal procedure. Return a boolean.</p>
<h2 id="number-number-...-2"><code>(= number number ...)</code></h2>
<p>Return <code>#t</code> if the numbers passed as parameters are equal. And <code>#f</code> otherwise.</p>
<h2 id="number-number-...-3"><code>(&gt; number number ...)</code></h2>
<p>Greater than procedure. Return a boolean.</p>
<h2 id="number-number-...-4"><code>(&gt;= number number ...)</code></h2>
<p>Greater than or equal. Return a boolean.</p>
<h2 id="abs-number"><code>(abs number)</code></h2>
<p>Return the absolute value of <code>NUMBER</code>.</p>
<h2 id="and-test1-..."><code>(and test1 ...)</code></h2>
<p>The <code>test</code> expressions are evaluated from left to right, and if any expression evaluates to <code>#f</code>, then <code>#f</code> is returned. Any remaining expressions are not evaluated. If all the expressions evaluate to true values, the values of the last expression are returned. If there are no expressions, then <code>#t</code> is returned.</p>
<h2 id="append-lst-..."><code>(append lst ...)</code></h2>
<p>Return the list made of the list passed as parameters in the same order.</p>
<h2 id="apply-proc-arg1-...-args"><code>(apply proc arg1 ... args)</code></h2>
<p>The apply procedure calls proc with the elements of the list <code>(append (list arg1 ...) args)</code> as the actual arguments.</p>
<h2 id="assoc-obj-alist"><code>(assoc obj alist)</code></h2>
<p>Return the first pair which <code>car</code> is equal to <code>OBJ</code> according to the predicate <code>equal?</code>. Or it returns <code>#f</code>.</p>
<h2 id="assq-obj-alist"><code>(assq obj alist)</code></h2>
<p>Return the first pair which <code>car</code> is equal to <code>OBJ</code> according to the predicate <code>eq?</code>. Or it returns <code>#f</code>.</p>
<h2 id="assv-obj-alist"><code>(assv obj alist)</code></h2>
<p>Return the first pair which <code>car</code> is equal to <code>OBJ</code> according to the predicate <code>eqv?</code>. Or it returns <code>#f</code>.</p>
<h2 id="begin-syntax"><code>begin</code> syntax</h2>
<p>There is two uses of <code>begin</code>.</p>
<h3 id="begin-expression-or-definition-..."><code>(begin expression-or-definition ...)</code></h3>
<p>This form of begin can appear as part of a body, or at the outermost level of a program, or at the REPL, or directly nested in a begin that is itself of this form. It causes the contained expressions and definitions to be evaluated exactly as if the enclosing begin construct were not present.</p>
<p>TODO: example</p>
<h3 id="begin-expression1-expression2-..."><code>(begin expression1 expression2 ...)</code></h3>
<p>This form of begin can be used as an ordinary expression. The expressions are evaluated sequentially from left to right, and the values of the last expression are returned. This expression type is used to sequence side effects such as assignments or input and output.</p>
<p>TODO: example</p>
<h2 id="binary-port"><code>binary-port?</code></h2>
<p>TODO: not implemented</p>
<h2 id="boolean-obj-..."><code>(boolean=? obj ...)</code></h2>
<p>Return <code>#t</code> if the scheme objects passed as arguments are the same boolean. Otherwise it return <code>#f</code>.</p>
<h2 id="boolean-obj"><code>(boolean? obj)</code></h2>
<p>Return <code>#t</code> if <code>OBJ</code> is a boolean. Otherwise <code>#f</code>.</p>
<h2 id="bytevector-byte-..."><code>(bytevector byte ...)</code></h2>
<p>Returns a newly allocated bytevector containing its arguments.</p>
<h2 id="bytevector-append-bytevector-..."><code>(bytevector-append bytevector ...)</code></h2>
<p>Returns a newly allocated bytevector whose elements arethe concatenation of the elements in the given bytevectors.</p>
<h2 id="bytevector-copy-bytevector-start-end"><code>(bytevector-copy bytevector [start [end]])</code></h2>
<p>Returns a newly allocated bytevector containing the bytes in bytevector between start and end.</p>
<h2 id="bytevector-copy-to-at-from-start-end"><code>(bytevector-copy! to at from [start [end]])</code></h2>
<p>Copies the bytes of bytevector <code>from</code> between <code>start</code> and <code>end</code> to bytevector <code>TO</code>, starting at <code>at</code>. The order in which bytes are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary bytevector and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances.</p>
<h2 id="bytevector-length-bytevector-1"><code>(bytevector-length bytevector)</code></h2>
<p>Returns the length of bytevector in bytes as an exact integer.</p>
<h2 id="bytevector-u8-ref"><code>bytevector-u8-ref</code></h2>
<p>Returns the <code>K</code>th byte of <code>BYTEVECTOR</code>. It is an error if <code>K</code> is not a valid index of <code>BYTEVECTOR</code>.</p>
<h2 id="bytevector-u8-set"><code>bytevector-u8-set!</code></h2>
<p>Stores <code>BYTE</code> as the <code>K</code>th byte of <code>BYTEVECTOR</code>.</p>
<p>It is an error if <code>K</code> is not a valid index of <code>BYTEVECTOR</code>.</p>
<h2 id="bytevector-obj-1"><code>(bytevector? obj)</code></h2>
<p>Returns <code>#t</code> if <code>OBJ</code> is a bytevector. Otherwise, <code>#f</code> is returned.</p>
<h2 id="caar"><code>caar</code></h2>
<p>TODO</p>
<h2 id="cadr"><code>cadr</code></h2>
<p>TODO</p>
<h2 id="call-with-current-continuation-proc"><code>(call-with-current-continuation proc)</code></h2>
<p>It is an error if proc does not accept one argument.</p>
<p>The procedure call-with-current-continuation (or its equivalent abbreviation call/cc) packages the current continuation (see the rationale below) as an “escape procedure” and passes it as an argument to proc. The escape procedure is a Scheme procedure that, if it is later called, will abandon whatever continuation is in effect at that later time and will instead use the continuation that was in effect when the escape procedure was created. Calling the escape procedure will cause the invocation of before and after thunks installed using dynamic-wind.</p>
<p>The escape procedure accepts the same number of arguments as the continuation to the original call to call-with-current-continuation. Most continuations take only one value. Continuations created by the call-with-values procedure (including the initialization expressions of define-values, let-values, and let<em>-values expressions), take the number of values that the consumer expects. The continuations of all non-final expressions within a sequence of expressions, such as in lambda, case-lambda, begin, let, let</em>, letrec, letrec<em>, let-values, let</em>-values, let-syntax, letrec-syntax, parameterize, guard, case, cond, when, and unless expressions, take an arbitrary number of values because they discard the values passed to them in any event. The effect of passing no values or more than one value to continuations that were not created in one of these ways is unspecified.</p>
<p>The escape procedure that is passed to proc has unlimited extent just like any other procedure in Scheme. It can be stored in variables or data structures and can be called as many times as desired. However, like the raise and error procedures, it never returns to its caller.</p>
<p>TODO: example</p>
<h2 id="call-with-port-port-proc"><code>(call-with-port port proc)</code></h2>
<p>The <code>call-with-port</code> procedure calls <code>PROC</code> with <code>PORT</code> as an argument. If <code>PROC</code> returns, then the <code>PORT</code> is closed automatically and the values yielded by the <code>PROC</code> are returned. If <code>PROC</code> does not return, then the <code>PORT</code> must not be closed automatically unless it is possible to prove that the port will never again be used for a read or write operation.</p>
<p>It is an error if <code>PROC</code> does not accept one argument.</p>
<h2 id="call-with-values-producer-consumer"><code>(call-with-values producer consumer)</code></h2>
<p>Calls its producer argument with no arguments and a continuation that, when passed some values, calls the consumer procedure with those values as arguments. The continuation for the call to consumer is the continuation of the call to <code>call-with-values</code>.</p>
<h2 id="callcc-proc"><code>(call/cc proc)</code></h2>
<p>Abbreviation for <code>call-with-continuation</code>.</p>
<h2 id="car-pair-1"><code>(car pair)</code></h2>
<p>Returns the contents of the car field of pair. Note that it is an error to take the <code>car</code> of the empty list.</p>
<h2 id="case-key-clause1-clause2-...-syntax"><code>(case &lt;key&gt; &lt;clause1&gt; &lt;clause2&gt; ...)</code> syntax</h2>
<p>TODO</p>
<h2 id="cdar"><code>cdar</code></h2>
<p>TODO</p>
<h2 id="cddr"><code>cddr</code></h2>
<p>TODO</p>
<h2 id="cdr"><code>cdr</code></h2>
<p>Returns the contents of the <code>cdr</code> field of pair. Note that it is an error to take the <code>cdr</code> of the empty list.</p>
<h2 id="ceiling-x"><code>(ceiling x)</code></h2>
<p>The ceiling procedure returns the smallest integer not smaller than x.</p>
<h2 id="char-integer-char"><code>(char-&gt;integer char)</code></h2>
<p>Given a Unicode character, <code>char-&gt;integer</code> returns an exact integer between 0 and #xD7FF or between #xE000 and #x10FFFF which is equal to the Unicode scalar value of that character. Given a non-Unicode character, it returns an exact integer greater than #x10FFFF.</p>
<h2 id="char-ready-port"><code>(char-ready? [port])</code></h2>
<p>Returns #t if a character is ready on the textual input port and returns #f otherwise. If char-ready returns #t then the next read-char operation on the given port is guaranteed not to hang. If the port is at end of file then char-ready? returns #t.</p>
<h2 id="char-2"><code>char&lt;=?</code></h2>
<p>TODO</p>
<h2 id="char-3"><code>char&lt;?</code></h2>
<p>TODO</p>
<h2 id="char-4"><code>char=?</code></h2>
<p>TODO</p>
<h2 id="char-5"><code>char&gt;=?</code></h2>
<p>TODO</p>
<h2 id="char-6"><code>char&gt;?</code></h2>
<p>TODO</p>
<h2 id="char-7"><code>char?</code></h2>
<p>Returns #t if obj is a character, otherwise returns #f.</p>
<h2 id="close-input-port-port"><code>(close-input-port port)</code></h2>
<p>Closes the resource associated with port, rendering the port incapable of delivering or accepting data.</p>
<h2 id="close-output-port-port"><code>(close-output-port port)</code></h2>
<p>Closes the resource associated with port, rendering the port incapable of delivering or accepting data.</p>
<h2 id="close-port-port"><code>(close-port port)</code></h2>
<p>Closes the resource associated with port, rendering the port incapable of delivering or accepting data.</p>
<h2 id="complex-obj"><code>(complex? obj)</code></h2>
<p>Returns #t if obj is a complex number, otherwise returns #f.</p>
<h2 id="cond-clause1-..."><code>(cond &lt;clause1&gt; ...)</code></h2>
<p>TODO</p>
<h2 id="cond-expand"><code>cond-expand</code></h2>
<p>TODO: not implemented</p>
<h2 id="cons-obj1-obj2"><code>(cons obj1 obj2)</code></h2>
<p>Returns a newly allocated pair whose car is obj1 and whose cdr is obj2. The pair is guaranteed to be different (in the sense of eqv?) from every existing object.</p>
<h2 id="current-error-port-port"><code>(current-error-port [port])</code></h2>
<p>Returns the current default error port (an output port). That procedure is also a parameter object, which can be overridden with <code>parameterize</code>.</p>
<h2 id="current-input-port-port"><code>(current-input-port [port])</code></h2>
<p>Returns the current default input port. That procedure is also a parameter object, which can be overridden with <code>parameterize</code>.</p>
<h2 id="current-output-port"><code>current-output-port</code></h2>
<p>Returns the current default output port. That procedure is also a parameter object, which can be overridden with <code>parameterize</code>.</p>
<h2 id="define-name-expr"><code>(define &lt;name&gt; &lt;expr&gt;)</code></h2>
<p>TODO</p>
<h2 id="define-name-variable-...-expr-..."><code>(define (&lt;name&gt; &lt;variable&gt; ...) &lt;expr&gt; ...)</code></h2>
<p>TODO</p>
<h2 id="define-record-type-syntax"><code>define-record-type</code> syntax</h2>
<p>TODO</p>
<h2 id="define-syntax"><code>define-syntax</code></h2>
<p>TODO</p>
<h2 id="define-values-var1-...-expr-syntax"><code>(define-values var1 ... expr)</code> syntax</h2>
<p>creates multiple definitions from a single expression returning multiple values. It is allowed wherever define is allowed.</p>
<h2 id="denominator-q"><code>(denominator q)</code></h2>
<p>Return the denominator of their argument; the result is computed as if the argument was represented as a fraction in lowest terms. The denominator is always positive. The denominator of 0 is defined to be 1.</p>
<h2 id="do"><code>do</code></h2>
<p>TODO</p>
<h2 id="dynamic-wind-before-thunk-after"><code>(dynamic-wind before thunk after)</code></h2>
<p>TODO</p>
<h2 id="eof-object"><code>(eof-object)</code></h2>
<p>Returns an end-of-file object, not necessarily unique.</p>
<h2 id="eof-object-obj"><code>(eof-object? obj)</code></h2>
<p>Returns #t if obj is an end-of-file object, otherwise returns #f. A end-of-file object will ever be an object that can be read in using read.</p>
<h2 id="eq-obj1-obj2"><code>(eq? obj1 obj2)</code></h2>
<p>The eq? procedure is similar to eqv? except that in some cases it is capable of discerning distinctions finer than those detectable by eqv?. It must always return #f when eqv? also would, but may return #f in some cases where eqv? would return #t.</p>
<p>On symbols, booleans, the empty list, pairs, and records, and also on non-empty strings, vectors, and bytevectors, eq? and eqv? are guaranteed to have the same behavior. On procedures, eq? must return true if the arguments’ location tags are equal. On numbers and characters, eq?’s behavior is implementation-dependent, but it will always return either true or false. On empty strings, empty vectors, and empty bytevectors, eq? may also behave differently from eqv?.</p>
<h2 id="equal-obj1-obj2"><code>(equal? obj1 obj2)</code></h2>
<p>The equal? procedure, when applied to pairs, vectors, strings and bytevectors, recursively compares them, returning #t when the unfoldings of its arguments into (possibly infinite) trees are equal (in the sense of equal?) as ordered trees, and #f otherwise. It returns the same as eqv? when applied to booleans, symbols, numbers, characters, ports, procedures, and the empty list. If two objects are eqv?, they must be equal? as well. In all other cases, equal? may return either #t or #f.</p>
<p>Even if its arguments are circular data structures, equal? must always terminate.</p>
<h2 id="eqv-obj1-obj2"><code>(eqv? obj1 obj2)</code></h2>
<p>The eqv? procedure defines a useful equivalence relation on objects. Briefly, it returns #t if obj1 and obj2 are normally regarded as the same object.</p>
<p>TODO: complete based on r7rs small and guile.</p>
<h2 id="error-who-message-.-irritants"><code>(error [who] message . irritants)</code></h2>
<p>Raises an exception as if by calling raise on a newly allocated implementation-defined object which encapsulates the information provided by message, as well as any objs, known as the irritants. The procedure error-object? must return #t on such objects.</p>
<h2 id="error-object-irritants-error"><code>(error-object-irritants error)</code></h2>
<p>Returns a list of the irritants encapsulated by error.</p>
<h2 id="error-object-message-error"><code>(error-object-message error)</code></h2>
<p>Returns the message encapsulated by error.</p>
<h2 id="error-object-obj"><code>(error-object? obj)</code></h2>
<p>Returns #t if obj is an object created by <code>error</code> or one of an implementation-defined set of objects. Otherwise, it returns #f. The objects used to signal errors, including those which satisfy the predicates <code>file-error?</code> and <code>read-error?</code>, may or may not satisfy <code>error-object?</code>.</p>
<h2 id="even-number"><code>(even? number)</code></h2>
<p>Return <code>#t</code> if <code>NUMBER</code> is even. Otherwise <code>#f</code>.</p>
<h2 id="exact-z"><code>(exact z)</code></h2>
<p>TODO: FIXME</p>
<p>The procedure exact returns an exact representation of z. The value returned is the exact number that is numerically closest to the argument. For exact arguments, the result is the same as the argument. For inexact non-integral real arguments, the implementation may return a rational approximation, or may report an implementation violation. For inexact complex arguments, the result is a complex number whose real and imaginary parts are the result of applying exact to the real and imaginary parts of the argument, respectively. If an inexact argument has no reasonably close exact equivalent, (in the sense of <code>=</code>), then a violation of an implementation restriction may be reported.</p>
<h2 id="exact-integer-sqrt-k"><code>(exact-integer-sqrt k)</code></h2>
<p>TODO</p>
<h2 id="exact-integer-z"><code>(exact-integer? z)</code></h2>
<p>Returns #t if z is both exact and an integer; otherwise returns #f.</p>
<h2 id="exact-z-1"><code>(exact? z)</code></h2>
<p>Return <code>#t</code> if <code>Z</code> is exact. Otherwise <code>#f</code>.</p>
<h2 id="expt-z1-z2"><code>(expt z1 z2)</code></h2>
<p>Returns <code>z1</code> raised to the power <code>z2</code>.</p>
<h2 id="features"><code>features</code></h2>
<p>TODO: no implemented</p>
<h2 id="file-error-error"><code>(file-error? error)</code></h2>
<p>TODO: not implemented?</p>
<h2 id="floor-x"><code>(floor x)</code></h2>
<p>The floor procedure returns the largest integer not larger than x.</p>
<h2 id="floor-quotient"><code>floor-quotient</code></h2>
<p>TODO</p>
<h2 id="floor-remainder"><code>floor-remainder</code></h2>
<p>TODO</p>
<h2 id="floor"><code>floor/</code></h2>
<p>TODO</p>
<h2 id="flush-output-port-port"><code>(flush-output-port [port])</code></h2>
<p>Flushes any buffered output from the buffer of output-port to the underlying file or device and returns an unspecified value.</p>
<h2 id="for-each-proc-list1-..."><code>(for-each proc list1 ...)</code></h2>
<p>It is an error if proc does not accept as many arguments as there are lists.</p>
<p>The arguments to for-each are like the arguments to map, but for-each calls proc for its side effects rather than for its values. Unlike map, for-each is guaranteed to call proc on the elements of the lists in order from the first element(s) to the last, and the value returned by for-each is unspecified. If more than one list is given and not all lists have the same length, for-each terminates when the shortest list runs out. The lists can be circular, but it is an error if all of them are circular.</p>
<h2 id="gcd-n1-..."><code>(gcd n1 ...)</code></h2>
<p>Return the greatest common divisor.</p>
<h2 id="get-output-bytevector-port"><code>(get-output-bytevector port)</code></h2>
<p>It is an error if port was not created with <code>open-output-bytevector</code>.</p>
<p>Returns a bytevector consisting of the bytes that have been output to the port so far in the order they were output.</p>
<h2 id="get-output-string-port"><code>(get-output-string port)</code></h2>
<p>It is an error if port was not created with open-output-string.</p>
<p>Returns a string consisting of the characters that have been output to the port so far in the order they were output.</p>
<h2 id="guard-clause-...-syntax"><code>(guard &lt;clause&gt; ...)</code> syntax</h2>
<p>TODO</p>
<h2 id="if-expr-then-else"><code>(if &lt;expr&gt; &lt;then&gt; [&lt;else&gt;])</code></h2>
<p>TODO</p>
<h2 id="include"><code>include</code></h2>
<p>TODO</p>
<h2 id="include-ci"><code>include-ci</code></h2>
<p>TODO: not implemented</p>
<h2 id="inexact-z"><code>(inexact z)</code></h2>
<p>The procedure inexact returns an inexact representation of z. The value returned is the inexact number that is numerically closest to the argument. For inexact arguments, the result is the same as the argument. For exact complex numbers, the result is a complex number whose real and imaginary parts are the result of applying inexact to the real and imaginary parts of the argument, respectively. If an exact argument has no reasonably close inexact equivalent (in the sense of <code>=</code>), then a violation of an implementation restriction may be reported.</p>
<h2 id="inexact-z-1"><code>(inexact? z)</code></h2>
<p>Return <code>#t</code> if <code>Z</code> is inexact. Otherwise <code>#f</code>.</p>
<h2 id="input-port-open-port"><code>(input-port-open? port)</code></h2>
<p>Returns #t if port is still open and capable of performing input, and <code>#f</code> otherwise.</p>
<h2 id="input-port-obj"><code>(input-port? obj)</code></h2>
<p>Return <code>#t</code> if obj is an input port. Otherwise it return <code>#f</code>.</p>
<h2 id="integer-char-integer"><code>(integer-&gt;char integer)</code></h2>
<p>Given an exact integer that is the value returned by a character when char-&gt;integer is applied to it, integer-&gt;char returns that character.</p>
<h2 id="integer-obj"><code>(integer? obj)</code></h2>
<p>Return <code>#t</code> if <code>OBJ</code> is an integer. Otherwise <code>#f</code>.</p>
<h2 id="lambda-formals-expr-..."><code>(lambda &lt;formals&gt; &lt;expr&gt; ...)</code></h2>
<p>TODO</p>
<h2 id="lcm-n1-..."><code>(lcm n1 ...)</code></h2>
<p>Return the least common multiple of its arguments.</p>
<h2 id="length-list-1"><code>(length list)</code></h2>
<p>Returns the length of list.</p>
<h2 id="let"><code>let</code></h2>
<p>TODO</p>
<h2 id="let-1"><code>let*</code></h2>
<p>TODO</p>
<h2 id="let-values"><code>let*-values</code></h2>
<p>TODO</p>
<h2 id="let-syntax"><code>let-syntax</code></h2>
<p>TODO</p>
<h2 id="let-values-1"><code>let-values</code></h2>
<p>TODO</p>
<h2 id="letrec"><code>letrec</code></h2>
<p>TODO</p>
<h2 id="letrec-1"><code>letrec*</code></h2>
<p>TODO</p>
<h2 id="letrec-syntax"><code>letrec-syntax</code></h2>
<p>TODO</p>
<h2 id="list-obj-..."><code>(list obj ...)</code></h2>
<p>Returns a newly allocated list of its arguments.</p>
<h2 id="list-string-list"><code>(list-&gt;string list)</code></h2>
<p>It is an error if any element of list is not a character.</p>
<p>list-&gt;string returns a newly allocated string formed from the elements in the list list.</p>
<h2 id="list-vector-list"><code>(list-&gt;vector list)</code></h2>
<p>The list-&gt;vector procedure returns a newly created vector initialized to the elements of the list list.</p>
<h2 id="list-copy-obj"><code>(list-copy obj)</code></h2>
<p>Returns a newly allocated copy of the given obj if it is a list. Only the pairs themselves are copied; the cars of the result are the same (in the sense of eqv?) as the cars of list. If obj is an improper list, so is the result, and the final cdrs are the same in the sense of eqv?. An obj which is not a list is returned unchanged. It is an error if obj is a circular list.</p>
<h2 id="list-ref-list-k"><code>(list-ref list k)</code></h2>
<p>The list argument can be circular, but it is an error if list has fewer than k elements.</p>
<p>Returns the kth element of list. (This is the same as the car of (list-tail list k).)</p>
<h2 id="list-set-list-k-obj"><code>(list-set! list k obj)</code></h2>
<p>It is an error if k is not a valid index of list.</p>
<p>The list-set! procedure stores obj in element k of list.</p>
<h2 id="list-tail-list-k"><code>(list-tail list k)</code></h2>
<p>It is an error if list has fewer than k elements.</p>
<p>Returns the sublist of list obtained by omitting the first k elements.</p>
<h2 id="list-obj"><code>(list? obj)</code></h2>
<p>Return <code>#t</code> if <code>OBJ</code> is a list. Otherwise <code>#f</code>.</p>
<h2 id="make-bytevector-k-byte"><code>(make-bytevector k [byte])</code></h2>
<p>The make-bytevector procedure returns a newly allocated bytevector of length k. If byte is given, then all elements of the bytevector are initialized to byte, otherwise the contents of each element are unspecified.</p>
<h2 id="make-list-k-fill"><code>(make-list k [fill])</code></h2>
<p>Returns a newly allocated list of k elements. If a second argument is given, then each element is initialized to fill. Otherwise the initial contents of each element is unspecified.</p>
<h2 id="make-parameter-init-converter"><code>(make-parameter init [converter])</code></h2>
<p>Returns a newly allocated parameter object, which is a procedure that accepts zero arguments and returns the value associated with the parameter object. Initially, this value is the value of (converter init), or of init if the conversion procedure converter is not specified. The associated value can be temporarily changed using parameterize, which is described below.</p>
<h2 id="make-string-k-char"><code>(make-string k [char])</code></h2>
<p>The make-string procedure returns a newly allocated string of length k. If char is given, then all the characters of the string are initialized to char, otherwise the contents of the string are unspecified.</p>
<h2 id="make-vector-k-fill"><code>(make-vector k [fill])</code></h2>
<p>Returns a newly allocated vector of k elements. If a second argument is given, then each element is initialized to fill. Otherwise the initial contents of each element is unspecified.</p>
<h2 id="map-proc-list1-...-1"><code>(map proc list1 ...)</code></h2>
<p>It is an error if proc does not accept as many arguments as there are lists and return a single value.</p>
<p>The map procedure applies proc element-wise to the elements of the lists and returns a list of the results, in order. If more than one list is given and not all lists have the same length, map terminates when the shortest list runs out. The lists can be circular, but it is an error if all of them are circular. It is an error for proc to mutate any of the lists. The dynamic order in which proc is applied to the elements of the lists is unspecified. If multiple returns occur from map, the values returned by earlier returns are not mutated.</p>
<h2 id="max-x1-..."><code>(max x1 ...)</code></h2>
<p>Return the maximum of its arguments.</p>
<h2 id="member-obj-list-compare"><code>(member obj list [compare])</code></h2>
<p>Return the first sublist of list whose <code>car</code> is <code>obj</code>, where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list. If <code>obj</code> does not occur in <code>list</code>, then <code>#f</code> (not the empty list) is returned.</p>
<p>Uses <code>compare</code>, if given, and <code>equal?</code> otherwise.</p>
<h2 id="memq-obj-list"><code>(memq obj list)</code></h2>
<p>Return the first sublist of list whose <code>car</code> is <code>obj</code>, where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list. If <code>obj</code> does not occur in <code>list</code>, then <code>#f</code> (not the empty list) is returned.</p>
<p>Use <code>eq?</code> for comparison.</p>
<h2 id="memv-obj-list"><code>(memv obj list)</code></h2>
<p>Return the first sublist of list whose <code>car</code> is <code>obj</code>, where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list. If <code>obj</code> does not occur in <code>list</code>, then <code>#f</code> (not the empty list) is returned.</p>
<p>Uses <code>eqv?</code> for comparison.</p>
<h2 id="min-x1-..."><code>(min x1 ...)</code></h2>
<p>Return the minimum of its arguments.</p>
<h2 id="modulo-n1-n2"><code>(modulo n1 n2)</code></h2>
<p><code>modulo</code> is equivalent to <code>floor-remainder</code>. Provided for backward compatibility.</p>
<h2 id="negative-x"><code>(negative? x)</code></h2>
<p>Return <code>#t</code> if <code>X</code> is negative. Otherwise <code>#f</code>.</p>
<h2 id="newline-port"><code>(newline [port])</code></h2>
<p>Writes an end of line to output port.</p>
<h2 id="not-obj"><code>(not obj)</code></h2>
<p>The not procedure returns #t if obj is false, and returns #f otherwise.</p>
<h2 id="null-obj-1"><code>(null? obj)</code></h2>
<p>Returns #t if obj is the empty list, otherwise returns #f.</p>
<h2 id="number-string-z-radix"><code>(number-&gt;string z [radix])</code></h2>
<p>It is an error if radix is not one of 2, 8, 10, or 16.</p>
<h2 id="number-obj"><code>(number? obj)</code></h2>
<p>Return <code>#t</code> if <code>OBJ</code> is a number. Otherwise <code>#f</code>.</p>
<h2 id="numerator-q"><code>(numerator q)</code></h2>
<p>TODO</p>
<h2 id="odd-number"><code>(odd? number)</code></h2>
<p>Return <code>#t</code> if <code>NUMBER</code> is odd. Otherwise <code>#f</code>.</p>
<h2 id="open-input-bytevector-bytevector"><code>(open-input-bytevector bytevector)</code></h2>
<p>Takes a bytevector and returns a binary input port that delivers bytes from the bytevector.</p>
<h2 id="open-input-string-string"><code>(open-input-string string)</code></h2>
<p>Takes a string and returns a textual input port that delivers characters from the string. If the string is modified, the effect is unspecified.</p>
<h2 id="open-output-bytevector"><code>(open-output-bytevector)</code></h2>
<p>Returns a binary output port that will accumulate bytes for retrieval by <code>get-output-bytevector</code>.</p>
<h2 id="open-output-string"><code>(open-output-string)</code></h2>
<p>Returns a textual output port that will accumulate characters for retrieval by <code>get-output-string</code>.</p>
<h2 id="or-test1-...-syntax"><code>(or test1 ...)</code> syntax</h2>
<p>The <code>test</code> expressions are evaluated from left to right, and the value of the first expression that evaluates to a true value is returned. Any remaining expressions are not evaluated. If all expressions evaluate to #f or if there are no expressions, then #f is returned.</p>
<h2 id="output-port-open-port"><code>(output-port-open? port)</code></h2>
<p>Returns #t if port is still open and capable of performing output, and #f otherwise.</p>
<h2 id="output-port-obj"><code>(output-port? obj)</code></h2>
<p>Return #t if obj is an output port. Otherwise return #f.</p>
<h2 id="pair-obj-1"><code>(pair? obj)</code></h2>
<p>The pair? predicate returns #t if obj is a pair, and otherwise returns #f.</p>
<h2 id="parameterize-param1-value1-...-expr-..."><code>(parameterize ((param1 value1) ...) expr ...)</code></h2>
<p>A parameterize expression is used to change the values returned by specified parameter objects during the evaluation of the body.</p>
<p>The param and value expressions are evaluated in an unspecified order. The body is evaluated in a dynamic environment in which calls to the parameters return the results of passing the corresponding values to the conversion procedure specified when the parameters were created. Then the previous values of the parameters are restored without passing them to the conversion procedure. The results of the last expression in the body are returned as the results of the entire parameterize expression.</p>
<p>Note: If the conversion procedure is not idempotent, the results of (parameterize ((x (x))) …), which appears to bind the parameter x to its current value, might not be what the user expects.</p>
<p>If an implementation supports multiple threads of execution, then parameterize must not change the associated values of any parameters in any thread other than the current thread and threads created inside body.</p>
<p>Parameter objects can be used to specify configurable settings for a computation without the need to pass the value to every procedure in the call chain explicitly.</p>
<h2 id="peek-char-port"><code>(peek-char [port])</code></h2>
<p>Returns the next character available from the textual input port, but without updating the port to point to the following character. If no more characters are available, an end-of-file object is returned.</p>
<p>Note: The value returned by a call to peek-char is the same as the value that would have been returned by a call to read-char with the same port. The only difference is that the very next call to read-char or peek-char on that port will return the value returned by the preceding call to peek-char. In particular, a call to peek-char on an interactive port will hang waiting for input whenever a call to read-char would have hung.</p>
<h2 id="peek-u8-port"><code>(peek-u8 [port])</code></h2>
<p>Returns the next byte available from the binary input port, but without updating the port to point to the following byte. If no more bytes are available, an end-of-file object is returned.</p>
<h2 id="port-obj"><code>(port? obj)</code></h2>
<p>Return <code>#t</code> if <code>OBJ</code> is port. Otherwise <code>#f</code>.</p>
<h2 id="positive-x"><code>(positive? x)</code></h2>
<p>Return <code>#t</code> if <code>X</code> is positive. Otherwise <code>#f</code>.</p>
<h2 id="procedure-obj"><code>(procedure? obj)</code></h2>
<p>Return <code>#t</code> if <code>OBJ</code> is a procedure. Otherwise <code>#f</code>.</p>
<h2 id="quasiquote"><code>quasiquote</code></h2>
<p>TODO</p>
<h2 id="quote"><code>quote</code></h2>
<p>TODO</p>
<h2 id="quotient"><code>quotient</code></h2>
<p>TODO</p>
<h2 id="raise-obj"><code>(raise obj)</code></h2>
<p>Raises an exception by invoking the current exception handler on obj. The handler is called with the same dynamic environment as that of the call to raise, except that the current exception handler is the one that was in place when the handler being called was installed. If the handler returns, a secondary exception is raised in the same dynamic environment as the handler. The relationship between obj and the object raised by the secondary exception is unspecified.</p>
<h2 id="raise-continuable-obj"><code>(raise-continuable obj)</code></h2>
<p>Raises an exception by invoking the current exception handler on obj. The handler is called with the same dynamic environment as the call to raise-continuable, except that: (1) the current exception handler is the one that was in place when the handler being called was installed, and (2) if the handler being called returns, then it will again become the current exception handler. If the handler returns, the values it returns become the values returned by the call to raise-continuable.</p>
<h2 id="rational-obj"><code>(rational? obj)</code></h2>
<p>Return <code>#t</code> if <code>OBJ</code> is a rational number. Otherwise <code>#f</code>.</p>
<h2 id="rationalize-x-y"><code>(rationalize x y)</code></h2>
<p>The rationalize procedure returns the simplest rational number differing from x by no more than y.</p>
<h2 id="read-bytevector-k-port"><code>(read-bytevector k [port])</code></h2>
<p>Reads the next k bytes, or as many as are available before the end of file, from the binary input port into a newly allocated bytevector in left-to-right order and returns the bytevector. If no bytes are available before the end of file, an end-of-file object is returned.</p>
<h2 id="read-bytevector-bytevector-port-start-end"><code>(read-bytevector! bytevector [port [start [end]]])</code></h2>
<p>Reads the next end - start bytes, or as many as are available before the end of file, from the binary input port into bytevector in left-to-right order beginning at the start position. If end is not supplied, reads until the end of bytevector has been reached. If start is not supplied, reads beginning at position 0. Returns the number of bytes read. If no bytes are available, an end-of-file object is returned.</p>
<h2 id="read-char-port"><code>(read-char [port])</code></h2>
<p>Returns the next character available from the textual input port, updating the port to point to the following character. If no more characters are available, an end-of-file object is returned.</p>
<h2 id="read-error-obj"><code>(read-error? obj)</code></h2>
<p>Error type predicates. Returns #t if obj is an object raised by the read procedure. Otherwise, it returns #f.</p>
<h2 id="read-line-port"><code>(read-line [port])</code></h2>
<p>Returns the next line of text available from the textual input port, updating the port to point to the following character. If an end of line is read, a string containing all of the text up to (but not including) the end of line is returned, and the port is updated to point just past the end of line. If an end of file is encountered before any end of line is read, but some characters have been read, a string containing those characters is returned. If an end of file is encountered before any characters are read, an end-of-file object is returned. For the purpose of this procedure, an end of line consists of either a linefeed character, a carriage return character, or a sequence of a carriage return character followed by a linefeed character. Implementations may also recognize other end of line characters or sequences.</p>
<h2 id="read-string-k-port"><code>(read-string k [port])</code></h2>
<p>Reads the next k characters, or as many as are available before the end of file, from the textual input port into a newly allocated string in left-to-right order and returns the string. If no characters are available before the end of file, an end-of-file object is returned.</p>
<h2 id="read-u8-port"><code>(read-u8 [port])</code></h2>
<p>Returns the next byte available from the binary input port, updating the port to point to the following byte. If no more bytes are available, an end-of-file object is returned.</p>
<h2 id="real-obj"><code>(real? obj)</code></h2>
<p>Return #t if <code>OBJ</code> is real number. Otherwise <code>#f</code>.</p>
<h2 id="remainder-n1-n2"><code>(remainder n1 n2)</code></h2>
<p>TODO</p>
<h2 id="reverse-list-2"><code>(reverse list)</code></h2>
<p>Returns a newly allocated list consisting of the elements of list in reverse order.</p>
<h2 id="round-x"><code>(round x)</code></h2>
<p>TODO</p>
<h2 id="set-variable-expression-syntax"><code>(set! &lt;variable&gt; &lt;expression&gt;)</code> syntax</h2>
<p>Expression is evaluated, and the resulting value is stored in the location to which variable is bound. It is an error if variable is not bound either in some region enclosing the set! expression or else globally. The result of the set! expression is unspecified.</p>
<h2 id="set-car-pair-obj"><code>(set-car! pair obj)</code></h2>
<p>Stores <code>obj</code> in the car field of <code>pair</code>.</p>
<h2 id="set-cdr-pair-obj"><code>(set-cdr! pair obj)</code></h2>
<p>Stores obj in the cdr field of pair.</p>
<h2 id="square-z"><code>(square z)</code></h2>
<p>Returns the square of z. This is equivalent to (* z z).</p>
<h2 id="string-char-..."><code>(string char ...)</code></h2>
<p>Returns a newly allocated string composed of the arguments. It is analogous to list.</p>
<h2 id="string-list-string-start-end"><code>(string-&gt;list string [start [end]])</code></h2>
<p>The string-&gt;list procedure returns a newly allocated list of the characters of string between start and end.</p>
<h2 id="string-number-string-radix"><code>(string-&gt;number string [radix])</code></h2>
<p>Returns a number of the maximally precise representation expressed by the given string. It is an error if radix is not 2, 8, 10, or 16.</p>
<p>If supplied, radix is a default radix that will be overridden if an explicit radix prefix is present in string (e.g. “#o177”). If radix is not supplied, then the default radix is 10. If string is not a syntactically valid notation for a number, or would result in a number that the implementation cannot represent, then string-&gt;number returns #f. An error is never signaled due to the content of string.</p>
<h2 id="string-symbol-string"><code>(string-&gt;symbol string)</code></h2>
<p>Returns the symbol whose name is string. This procedure can create symbols with names containing special characters that would require escaping when written, but does not interpret escapes in its input.</p>
<h2 id="string-utf8-string-start-end"><code>(string-&gt;utf8 string [start [end]])</code></h2>
<p>The string-&gt;utf8 procedure encodes the characters of a string between start and end and returns the corresponding bytevector.</p>
<h2 id="string-vector-string-start-end-1"><code>(string-&gt;vector string [start [end]])</code></h2>
<p>The string-&gt;vector procedure returns a newly created vector initialized to the elements of the string string between start and end.</p>
<h2 id="string-append-string-..."><code>(string-append string ...)</code></h2>
<p>Returns a newly allocated string whose characters are the concatenation of the characters in the given strings.</p>
<h2 id="string-copy-string-start-end"><code>(string-copy string [start [end]])</code></h2>
<p>Returns a newly allocated copy of the part of the given string between start and end.</p>
<h2 id="string-copy-to-at-from-start-end"><code>(string-copy! to at from [start [end]])</code></h2>
<p>It is an error if at is less than zero or greater than the length of to. It is also an error if (- (string-length to) at) is less than (- end start).</p>
<p>Copies the characters of string from between start and end to string to, starting at at. The order in which characters are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary string and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances.</p>
<h2 id="string-fill-string-fill-start-end"><code>(string-fill! string fill [start [end]])</code></h2>
<p>It is an error if fill is not a character.</p>
<p>The string-fill! procedure stores fill in the elements of string between start and end.</p>
<h2 id="string-for-each-proc-string1-..."><code>(string-for-each proc string1 ...)</code></h2>
<p>It is an error if proc does not accept as many arguments as there are strings.</p>
<p>The arguments to string-for-each are like the arguments to string-map, but string-for-each calls proc for its side effects rather than for its values. Unlike string-map, string-for-each is guaranteed to call proc on the elements of the lists in order from the first element(s) to the last, and the value returned by string-for-each is unspecified. If more than one string is given and not all strings have the same length, string-for-each terminates when the shortest string runs out. It is an error for proc to mutate any of the strings.</p>
<h2 id="string-length-string"><code>(string-length string)</code></h2>
<p>Returns the number of characters in the given string.</p>
<h2 id="string-map-proc-string1-..."><code>(string-map proc string1 ...)</code></h2>
<p>It is an error if proc does not accept as many arguments as there are strings and return a single character.</p>
<p>The string-map procedure applies proc element-wise to the elements of the strings and returns a string of the results, in order. If more than one string is given and not all strings have the same length, string-map terminates when the shortest string runs out. The dynamic order in which proc is applied to the elements of the strings is unspecified. If multiple returns occur from string-map, the values returned by earlier returns are not mutated.</p>
<h2 id="string-ref-string-k"><code>(string-ref string k)</code></h2>
<p>It is an error if k is not a valid index of string.</p>
<p>The string-ref procedure returns character k of string using zero-origin indexing. There is no requirement for this procedure to execute in constant time.</p>
<h2 id="string-set-string-k-char"><code>(string-set! string k char)</code></h2>
<p>It is an error if k is not a valid index of string.</p>
<p>The string-set! procedure stores char in element k of string. There is no requirement for this procedure to execute in constant time.</p>
<h2 id="string-3"><code>string&lt;=?</code></h2>
<p>TODO</p>
<h2 id="string-4"><code>string&lt;?</code></h2>
<p>TODO</p>
<h2 id="string-string1-string2-..."><code>(string=? string1 string2 ...)</code></h2>
<p>Returns #t if all the strings are the same length and contain exactly the same characters in the same positions, otherwise returns #f.</p>
<h2 id="string-5"><code>string&gt;=?</code></h2>
<p>TODO</p>
<h2 id="string-6"><code>string&gt;?</code></h2>
<p>TODO</p>
<h2 id="string-obj"><code>(string? obj)</code></h2>
<p>Return <code>#t</code> if <code>OBJ</code> is string. Otherwise <code>#f</code>.</p>
<h2 id="substring-string-start-end"><code>(substring string start end)</code></h2>
<p>The substring procedure returns a newly allocated string formed from the characters of string beginning with index start and ending with index end. This is equivalent to calling string-copy with the same arguments, but is provided for backward compatibility and stylistic flexibility.</p>
<h2 id="symbol-string-symbol"><code>(symbol-&gt;string symbol)</code></h2>
<p>Returns the name of symbol as a string, but without adding escapes. It is an error to apply mutation procedures like string-set! to strings returned by this procedure.</p>
<h2 id="symbol-symbol1-symbol2-..."><code>(symbol=? symbol1 symbol2 ...)</code></h2>
<p>Returns #t if all the arguments are symbols and all have the same names in the sense of string=?.</p>
<h2 id="symbol-obj"><code>(symbol? obj)</code></h2>
<p>Returns #t if obj is a symbol, otherwise returns #f.</p>
<h2 id="syntax-error"><code>syntax-error</code></h2>
<p>TODO</p>
<h2 id="syntax-rules"><code>syntax-rules</code></h2>
<p>TODO</p>
<h2 id="textual-port"><code>textual-port?</code></h2>
<p>TODO</p>
<h2 id="truncate-x"><code>(truncate x)</code></h2>
<p>TODO</p>
<h2 id="truncate-quotient"><code>truncate-quotient</code></h2>
<p>TODO</p>
<h2 id="truncate-remainder"><code>truncate-remainder</code></h2>
<p>TODO</p>
<h2 id="truncate"><code>truncate/</code></h2>
<p>TODO</p>
<h2 id="u8-ready-port"><code>(u8-ready? [port])</code></h2>
<p>Returns #t if a byte is ready on the binary input port and returns #f otherwise. If u8-ready? returns #t then the next read-u8 operation on the given port is guaranteed not to hang. If the port is at end of file then u8-ready? returns #t.</p>
<h2 id="unless-test-expr-...-syntax"><code>(unless &lt;test&gt; &lt;expr&gt; ...)</code> syntax</h2>
<p>The test is evaluated, and if it evaluates to #f, the expressions are evaluated in order. The result of the unless expression is unspecified.</p>
<h2 id="unquote"><code>unquote</code></h2>
<p>TODO</p>
<h2 id="unquote-splicing"><code>unquote-splicing</code></h2>
<p>TODO</p>
<h2 id="utf8-string-bytevector-start-end"><code>(utf8-&gt;string bytevector [start [end]])</code></h2>
<p>It is an error for bytevector to contain invalid UTF-8 byte sequences.</p>
<p>The utf8-&gt;string procedure decodes the bytes of a bytevector between start and end and returns the corresponding string.</p>
<h2 id="values-obj-..."><code>(values obj ...)</code></h2>
<p>Delivers all of its arguments to its continuation.</p>
<h2 id="vector-obj-..."><code>(vector obj ...)</code></h2>
<p>Returns a newly allocated vector whose elements contain the given arguments. It is analogous to list.</p>
<h2 id="vector-list-vector-start-end"><code>(vector-&gt;list vector [start [end]])</code></h2>
<p>The vector-&gt;list procedure returns a newly allocated list of the objects contained in the elements of vector between start and end. The list-&gt;vector procedure returns a newly created vector initialized to the elements of the list list.</p>
<h2 id="vector-string-vector-start-end"><code>(vector-&gt;string vector [start [end]])</code></h2>
<p>It is an error if any element of vector between start and end is not a character.</p>
<p>The vector-&gt;string procedure returns a newly allocated string of the objects contained in the elements of vector between start and end. The string-&gt;vector procedure returns a newly created vector initialized to the elements of the string string between start and end.</p>
<h2 id="vector-append-vector-..."><code>(vector-append vector ...)</code></h2>
<p>Returns a newly allocated vector whose elements are the concatenation of the elements of the given vectors.</p>
<h2 id="vector-copy-vector-start-end"><code>(vector-copy vector [start [end]])</code></h2>
<p>Returns a newly allocated copy of the elements of the given vector between start and end. The elements of the new vector are the same (in the sense of eqv?) as the elements of the old.</p>
<h2 id="vector-copy-to-at-from-start-end-1"><code>(vector-copy! to at from [start [end]])</code></h2>
<p>It is an error if at is less than zero or greater than the length of to. It is also an error if (- (vector-length to) at) is less than (- end start).</p>
<p>Copies the elements of vector from between start and end to vector to, starting at at. The order in which elements are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary vector and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances.</p>
<h2 id="vector-fill-vector-fill-start-end"><code>(vector-fill! vector fill [start [end]])</code></h2>
<p>The vector-fill! procedure stores fill in the elements of vector between start and end.</p>
<h2 id="vector-for-each-proc-vector1-..."><code>(vector-for-each proc vector1 ...)</code></h2>
<p>It is an error if proc does not accept as many arguments as there are vectors.</p>
<p>The arguments to vector-for-each are like the arguments to vector-map, but vector-for-each calls proc for its side effects rather than for its values. Unlike vector-map, vector-for-each is guaranteed to call proc on the elements of the vectors in order from the first element(s) to the last, and the value returned by vector-for-each is unspecified. If more than one vector is given and not all vectors have the same length, vector-for-each terminates when the shortest vector runs out. It is an error for proc to mutate any of the vectors.</p>
<h2 id="vector-length-vector"><code>(vector-length vector)</code></h2>
<p>Returns the number of elements in vector as an exact integer.</p>
<h2 id="vector-map-proc-vector1-..."><code>(vector-map proc vector1 ...)</code></h2>
<p>It is an error if proc does not accept as many arguments as there are vectors and return a single value.</p>
<p>The vector-map procedure applies proc element-wise to the elements of the vectors and returns a vector of the results, in order. If more than one vector is given and not all vectors have the same length, vector-map terminates when the shortest vector runs out. The dynamic order in which proc is applied to the elements of the vectors is unspecified. If multiple returns occur from vector-map, the values returned by earlier returns are not mutated.</p>
<h2 id="vector-ref-vector-k"><code>(vector-ref vector k)</code></h2>
<p>It is an error if k is not a valid index of vector.</p>
<p>The vector-ref procedure returns the contents of element k of vector.</p>
<h2 id="vector-set-vector-k-obj"><code>(vector-set! vector k obj)</code></h2>
<p>It is an error if k is not a valid index of vector.</p>
<p>The vector-set! procedure stores obj in element k of vector.</p>
<h2 id="vector-1"><code>vector?</code></h2>
<p>Returns #t if obj is a bytevector. Otherwise, #f is returned.</p>
<h2 id="when-test-expr-...-syntax"><code>(when &lt;test&gt; &lt;expr&gt; ...)</code> syntax</h2>
<p>The test is evaluated, and if it evaluates to a true value, the expressions are evaluated in order. The result of the when expression is unspecified.</p>
<h2 id="with-exception-handler"><code>with-exception-handler</code></h2>
<p>TODO</p>
<h2 id="write-bytevector-bytevector-port-start-end"><code>(write-bytevector bytevector [port [start [end]]])</code></h2>
<p>Writes the bytes of bytevector from start to end in left-to-right order to the binary output port.</p>
<h2 id="write-char-char-port"><code>(write-char char [port])</code></h2>
<p>Writes the character char (not an external representation of the character) to the given textual output port and returns an unspecified value.</p>
<h2 id="write-string-string-port-start-end"><code>(write-string string [port [start [end]]])</code></h2>
<p>Writes the characters of string from start to end in left-to-right order to the textual output port.</p>
<h2 id="write-u8-byte-port"><code>(write-u8 byte [port])</code></h2>
<p>Writes the byte to the given binary output port and returns an unspecified value.</p>
<h2 id="zero-z"><code>(zero? z)</code></h2>
<p>Return <code>#t</code> if z is zero. Otherwise <code>#f</code>.</p>
</body>
</html>
