<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="/static/normalize.css">
    <link rel="stylesheet" href="/static/styles.css">
    <link rel="stylesheet" href="/static/highlight.css">
    <title>scheme.rs</title>
  </head>
  <body>
    <div id="container">
      <div><h1>R<sup><small>7</small></sup>RS small specification</h1>
<p>Note: This is a port of R<sup><small>7</small></sup>RS specification
from tex to markdown that is rendered to html. It does not include
formal semantics.</p>
<h2>Summary</h2>
<p>The report gives a defining description of the programming language
Scheme. Scheme is a statically scoped and properly tail recursive
dialect of the Lisp programming language <span class="citation"
cites="McCarthy"></span> invented by Guy Lewis Steele Jr. and Gerald
Jay Sussman. It was designed to have exceptionally clear and simple
semantics and few different ways to form expressions. A wide variety
of programming paradigms, including imperative, functional, and
object-oriented styles, find convenient expression in Scheme.</p>
<p>The introduction offers a brief history of the language and of the
report.</p>
<p>The first three chapters present the fundamental ideas of the language
and describe the notational conventions used for describing the
language and for writing programs in the language.</p>
<p>Chapters <a href="#expressionchapter">[expressionchapter]</a>
and <a href="#programchapter">[programchapter]</a> describe the syntax and
semantics of expressions, definitions, programs, and libraries.</p>
<p>Chapter <a href="#builtinchapter">[builtinchapter]</a> describes Scheme’s
built-in procedures, which include all of the language’s data
manipulation and input/output primitives.</p>
<p>Chapter <a href="#formalchapter">[formalchapter]</a> provides a formal syntax for
Scheme written in extended BNF, along with a formal denotational
semantics. An example of the use of the language follows the formal
syntax and semantics.</p>
<p>Appendix <a href="#stdlibraries">[stdlibraries]</a> provides a list of the
standard libraries and the identifiers that they export.</p>
<p>Appendix <a href="#stdfeatures">[stdfeatures]</a> provides a list of optional but
standardized implementation feature names.</p>
<p>The report concludes with a list of references and an alphabetic index.</p>
<p><em>Note:</em> The editors of the R<sup><small>5</small></sup>RS and
R<sup><small>6</small></sup>RS reports are listed as authors of this
report in recognition of the substantial portions of this report that
are copied directly from R<sup><small>5</small></sup>RS and
R<sup><small>6</small></sup>RS. There is no intended implication that
those editors, individually or collectively, support or do not support
this report.</p>
<h2>Contents</h2>
<p>Programming languages should be designed not by piling feature on top of
feature, but by removing the weaknesses and restrictions that make
additional features appear necessary. Scheme demonstrates that a very
small number of rules for forming expressions, with no restrictions on
how they are composed, suffice to form a practical and efficient
programming language that is flexible enough to support most of the
major programming paradigms in use today.</p>
<p>Scheme was one of the first programming languages to incorporate
first-class procedures as in the lambda calculus, thereby proving the
usefulness of static scope rules and block structure in a dynamically
typed language. Scheme was the first major dialect of Lisp to
distinguish procedures from lambda expressions and symbols, to use a
single lexical environment for all variables, and to evaluate the
operator position of a procedure call in the same way as an operand
position. By relying entirely on procedure calls to express iteration,
Scheme emphasized the fact that tail-recursive procedure calls are
essentially GOTOs that pass arguments, thus allowing a programming style
that is both coherent and efficient. Scheme was the first widely used
programming language to embrace first-class escape procedures, from
which all previously known sequential control structures can be
synthesized. A subsequent version of Scheme introduced the concept of
exact and inexact numbers, an extension of Common Lisp’s generic
arithmetic. More recently, Scheme became the first programming language
to support hygienic macros, which permit the syntax of a
block-structured language to be extended in a consistent and reliable
manner.</p>
<h3>Background</h3>
<p>The first description of Scheme was written in 1975 <span
class="citation" cites="Scheme75"></span>. A revised report <span
class="citation" cites="Scheme78"></span> appeared in 1978, which
described the evolution of the language as its MIT implementation was
upgraded to support an innovative compiler <span class="citation"
cites="Rabbit"></span>. Three distinct projects began in 1981 and 1982
to use variants of Scheme for courses at MIT, Yale, and Indiana
University <span class="citation"
cites="Rees82 MITScheme Scheme311"></span>. An introductory computer
science textbook using Scheme was published in 1984 <span
class="citation" cites="SICP"></span>.</p>
<p>As Scheme became more widespread, local dialects began to diverge until
students and researchers occasionally found it difficult to understand
code written at other sites. Fifteen representatives of the major
implementations of Scheme therefore met in October 1984 to work toward a
better and more widely accepted standard for Scheme. Their report, the
RRRS <span class="citation" cites="RRRS"></span>, was published at MIT
and Indiana University in the summer of 1985. Further revision took
place in the spring of 1986, resulting in the R<sup><small>3</small></sup>RS <span
class="citation" cites="R3RS"></span>. Work in the spring of 1988
resulted in R<sup><small>4</small></sup>RS <span class="citation" cites="R4RS"></span>,
which became the basis for the IEEE Standard for the Scheme Programming
Language in 1991 <span class="citation" cites="IEEEScheme"></span>. In
1998, several additions to the IEEE standard, including high-level
hygienic macros, multiple return values, and eval, were finalized as the
R<sup><small>5</small></sup>RS <span class="citation" cites="R5RS"></span>.</p>
<p>In the fall of 2006, work began on a more ambitious standard, including
many new improvements and stricter requirements made in the interest of
improved portability. The resulting standard, the R<sup><small>6</small></sup>RS, was
completed in August 2007 <span class="citation" cites="R6RS"></span>,
and was organized as a core language and set of mandatory standard
libraries. Several new implementations of Scheme conforming to it were
created. However, most existing R<sup><small>5</small></sup>RS implementations (even
excluding those which are essentially unmaintained) did not adopt
R<sup><small>6</small></sup>RS, or adopted only selected parts of it.</p>
<p>In consequence, the Scheme Steering Committee decided in August 2009 to
divide the standard into two separate but compatible languages — a
“small” language, suitable for educators, researchers, and users of
embedded languages, focused on R<sup><small>5</small></sup>RS compatibility, and a
“large” language focused on the practical needs of mainstream software
development, intended to become a replacement for R<sup><small>6</small></sup>RS. The
present report describes the “small” language of that effort: therefore
it cannot be considered in isolation as the successor to
R<sup><small>6</small></sup>RS.</p>
<p>We intend this report to belong to the entire Scheme community, and so
we grant permission to copy it in whole or in part without fee. In
particular, we encourage implementers of Scheme to use this report as a
starting point for manuals and other documentation, modifying it as
necessary.</p>
<h3>Acknowledgments</h3>
<p>We would like to thank the members of the Steering Committee, William
Clinger, Marc Feeley, Chris Hanson, Jonathan Rees, and Olin Shivers, for
their support and guidance.</p>
<p>This report is very much a community effort, and we’d like to thank
everyone who provided comments and feedback, including the following
people: David Adler, Eli Barzilay, Taylan Ulrich Bayırlı/Kammer, Marco
Benelli, Pierpaolo Bernardi, Peter Bex, Per Bothner, John Boyle, Taylor
Campbell, Raffael Cavallaro, Ray Dillinger, Biep Durieux, Sztefan
Edwards, Helmut Eller, Justin Ethier, Jay Reynolds Freeman, Tony
Garnock-Jones, Alan Manuel Gloria, Steve Hafner, Sven Hartrumpf, Brian
Harvey, Moritz Heidkamp, Jean-Michel Hufflen, Aubrey Jaffer, Takashi
Kato, Shiro Kawai, Richard Kelsey, Oleg Kiselyov, Pjotr Kourzanov,
Jonathan Kraut, Daniel Krueger, Christian Stigen Larsen, Noah Lavine,
Stephen Leach, Larry D. Lee, Kun Liang, Thomas Lord, Vincent Stewart
Manis, Perry Metzger, Michael Montague, Mikael More, Vitaly Magerya,
Vincent Manis, Vassil Nikolov, Joseph Wayne Norton, Yuki Okumura, Daichi
Oohashi, Jeronimo Pellegrini, Jussi Piitulainen, Alex Queiroz, Jim Rees,
Grant Rettke, Andrew Robbins, Devon Schudy, Bakul Shah, Robert Smith,
Arthur Smyles, Michael Sperber, John David Stone, Jay Sulzberger,
Malcolm Tredinnick, Sam Tobin-Hochstadt, Andre van Tonder, Daniel
Villeneuve, Denis Washington, Alan Watson, Mark H. Weaver, Göran
Weinholt, David A. Wheeler, Andy Wingo, James Wise, Jörg F.
Wittenberger, Kevin A. Wortman, Sascha Ziemann.</p>
<p>In addition we would like to thank all the past editors, and the people
who helped them in turn: Hal Abelson, Norman Adams, David Bartley, Alan
Bawden, Michael Blair, Gary Brooks, George Carrette, Andy Cromarty,
Pavel Curtis, Jeff Dalton, Olivier Danvy, Ken Dickey, Bruce Duba, Robert
Findler, Andy Freeman, Richard Gabriel, Yekta Gürsel, Ken Haase, Robert
Halstead, Robert Hieb, Paul Hudak, Morry Katz, Eugene Kohlbecker, Chris
Lindblad, Jacob Matthews, Mark Meyer, Jim Miller, Don Oxley, Jim
Philbin, Kent Pitman, John Ramsdell, Guillermo Rozas, Mike Shaff,
Jonathan Shapiro, Guy Steele, Julie Sussman, Perry Wagle, Mitchel Wand,
Daniel Weise, Henry Wu, and Ozan Yigit. We thank Carol Fessenden, Daniel
Friedman, and Christopher Haynes for permission to use text from the
Scheme 311 version 4 reference manual. We thank Texas Instruments,
Inc. for permission to use text from the <em>TI Scheme Language Reference
Manual</em> <span class="citation" cites="TImanual85"></span>. We gladly
acknowledge the influence of manuals for MIT Scheme <span
class="citation" cites="MITScheme"></span>, T <span class="citation"
cites="Rees84"></span>, Scheme 84 <span class="citation"
cites="Scheme84"></span>, Common Lisp <span class="citation"
cites="CLtL"></span>, and Algol 60 <span class="citation"
cites="Naur63"></span>, as well as the following SRFIs: 0, 1, 4, 6, 9,
11, 13, 16, 30, 34, 39, 43, 46, 62, and 87, all of which are available
at <a href="http://srfi.schemers.org">http://srfi.schemers.org</a>.</p>
<h2>Overview of Scheme</h2>
<h3>Semantics</h3>
<p>This section gives an overview of Scheme’s semantics. A detailed
informal semantics is the subject of
chapters <a href="#basicchapter">[basicchapter]</a>
through <a href="#builtinchapter">[builtinchapter]</a>. For reference purposes,
section <a href="#formalsemanticssection">[formalsemanticssection]</a> provides a
formal semantics of Scheme.</p>
<p>Scheme is a statically scoped programming language. Each use of a
variable is associated with a lexically apparent binding of that
variable.</p>
<p>Scheme is a dynamically typed language. Types are associated with values
(also called objects) rather than with variables. Statically typed
languages, by contrast, associate types with variables and expressions
as well as with values.</p>
<p>All objects created in the course of a Scheme computation, including
procedures and continuations, have unlimited extent. No Scheme object is
ever destroyed. The reason that implementations of Scheme do not
(usually!) run out of storage is that they are permitted to reclaim the
storage occupied by an object if they can prove that the object cannot
possibly matter to any future computation.</p>
<p>Implementations of Scheme are required to be properly tail-recursive.
This allows the execution of an iterative computation in constant space,
even if the iterative computation is described by a syntactically
recursive procedure. Thus with a properly tail-recursive implementation,
iteration can be expressed using the ordinary procedure-call mechanics,
so that special iteration constructs are useful only as syntactic sugar.
See section <a href="#proper%20tail%20recursion">[proper tail recursion]</a>.</p>
<p>Scheme procedures are objects in their own right. Procedures can be
created dynamically, stored in data structures, returned as results of
procedures, and so on.</p>
<p>One distinguishing feature of Scheme is that continuations, which in
most other languages only operate behind the scenes, also have
“first-class” status. Continuations are useful for implementing a wide
variety of advanced control constructs, including non-local exits,
backtracking, and coroutines. See
section <a href="#continuations">[continuations]</a>.</p>
<p>Arguments to Scheme procedures are always passed by value, which means
that the actual argument expressions are evaluated before the procedure
gains control, regardless of whether the procedure needs the result of
the evaluation.</p>
<p>Scheme’s model of arithmetic is designed to remain as independent as
possible of the particular ways in which numbers are represented within
a computer. In Scheme, every integer is a rational number, every
rational is a real, and every real is a complex number. Thus the
distinction between integer and real arithmetic, so important to many
programming languages, does not appear in Scheme. In its place is a
distinction between exact arithmetic, which corresponds to the
mathematical ideal, and inexact arithmetic on approximations. Exact
arithmetic is not limited to integers.</p>
<h3>Syntax</h3>
<p>Scheme, like most dialects of Lisp, employs a fully parenthesized prefix
notation for programs and other data; the grammar of Scheme generates a
sublanguage of the language used for data. An important consequence of
this simple, uniform representation is that Scheme programs and data can
easily be treated uniformly by other Scheme programs. For example, the
eval procedure evaluates a Scheme program expressed as data.</p>
<p>The read procedure performs syntactic as well as lexical decomposition
of the data it reads. The read procedure parses its input as data
(section <a href="#datumsyntax">[datumsyntax]</a>), not as program.</p>
<p>The formal syntax of Scheme is described in section <a href="#BNF">[BNF]</a>.</p>
<h3>Notation and terminology</h3>
<h4>Base and optional features</h4>
<p>Every identifier defined in this report appears in one or more of
several <code>libraries</code>. Identifiers defined in the <em>base library</em> are not
marked specially in the body of the report. This library includes the
core syntax of Scheme and generally useful procedures that manipulate
data. For example, the variable abs is bound to a procedure of one
argument that computes the absolute value of a number, and the
variable + is bound to a procedure that computes sums. The full list all
the standard libraries and the identifiers they export is given in
Appendix <a href="#stdlibraries">[stdlibraries]</a>.</p>
<p>All implementations of Scheme:</p>
<ul>
<li><p>Must provide the base library and all the identifiers exported from
it.</p>
</li>
<li><p>May provide or omit the other libraries given in this report, but
each library must either be provided in its entirety, exporting no
additional identifiers, or else omitted altogether.</p>
</li>
<li><p>May provide other libraries not described in this report.</p>
</li>
<li><p>May also extend the function of any identifier in this report,
provided the extensions are not in conflict with the language
reported here.</p>
</li>
<li><p>Must support portable code by providing a mode of operation in which
the lexical syntax does not conflict with the lexical syntax
described in this report.</p>
</li>
</ul>
<h4>Error situations and unspecified behavior</h4>
<p>When speaking of an error situation, this report uses the phrase “an
error is signaled” to indicate that implementations must detect and
report the error. An error is signaled by raising a non-continuable
exception, as if by the procedure raise as described in
section <a href="#exceptionsection">[exceptionsection]</a>. The object raised is
implementation-dependent and need not be distinct from objects
previously used for the same purpose. In addition to errors signaled in
situations described in this report, programmers can signal their own
errors and handle signaled errors.</p>
<p>The phrase “an error that satisfies <em>predicate</em> is signaled” means
that an error is signaled as above. Furthermore, if the object that is
signaled is passed to the specified predicate (such as file-error? or
read-error?), the predicate returns <code>#t</code>.</p>
<p>If such wording does not appear in the discussion of an error, then
implementations are not required to detect or report the error, though
they are encouraged to do so. Such a situation is sometimes, but not
always, referred to with the phrase “an error.” In such a situation, an
implementation may or may not signal an error; if it does signal an
error, the object that is signaled may or may not satisfy the predicates
error-object?, file-error?, or read-error?. Alternatively,
implementations may provide non-portable extensions.</p>
<p>For example, it is an error for a procedure to be passed an argument of
a type that the procedure is not explicitly specified to handle, even
though such domain errors are seldom mentioned in this report.
Implementations may signal an error, extend a procedure’s domain of
definition to include such arguments, or fail catastrophically.</p>
<p>This report uses the phrase “may report a violation of an implementation
restriction” to indicate circumstances under which an implementation is
permitted to report that it is unable to continue execution of a correct
program because of some restriction imposed by the implementation.
Implementation restrictions are discouraged, but implementations are
encouraged to report violations of implementation restrictions.</p>
<p>For example, an implementation may report a violation of an
implementation restriction if it does not have enough storage to run a
program, or if an arithmetic operation would produce an exact number
that is too large for the implementation to represent.</p>
<p>If the value of an expression is said to be “unspecified,” then the
expression must evaluate to some object without signaling an error, but
the value depends on the implementation; this report explicitly does not
say what value is returned.</p>
<p>Finally, the words and phrases “must,” “must not,” “shall,” “shall not,”
“should,” “should not,” “may,” “required,” “recommended,” and
“optional,” although not capitalized in this report, are to be
interpreted as described in RFC 2119 <span class="citation"
cites="rfc2119"></span>. They are used only with reference to
implementer or implementation behavior, not with reference to programmer
or program behavior.</p>
<h4>Entry format</h4>
<p>Chapters <a href="#expressionchapter">[expressionchapter]</a>
and <a href="#builtinchapter">[builtinchapter]</a> are organized into entries.
Each entry describes one language feature or a group of related
features, where a feature is either a syntactic construct or a
procedure. An entry begins with one or more header lines of the form</p>
<blockquote><p><em>template</em>  <em>category</em></p>
</blockquote>
<p>for identifiers in the base library, or</p>
<blockquote><p><em>template</em>  <em>name</em> library <em>category</em></p>
</blockquote>
<p>where <code>name</code> is the short name of a library as defined in
Appendix <a href="#stdlibraries">[stdlibraries]</a>.</p>
<p>If <code>category</code> is “syntax,” the entry describes an expression type, and
the template gives the syntax of the expression type. Components of
expressions are designated by syntactic variables, which are written
using angle brackets, for example expression and variable. Syntactic
variables are intended to denote segments of program text; for example,
expression stands for any string of characters which is a syntactically
valid expression. The notation</p>

<div><pre>thing ...</pre></div>
<p>indicates zero or more occurrences of a <code>thing</code>, and</p>

<div><pre>thing thing ...</pre></div>
<p>indicates one or more occurrences of a thing.</p>
<p>If <code>category</code> is “auxiliary syntax,” then the entry describes a syntax
binding that occurs only as part of specific surrounding expressions.
Any use as an independent syntactic construct or variable is an error.</p>
<p>If <code>category</code> is “procedure,” then the entry describes a procedure, and
the header line gives a template for a call to the procedure. Argument
names in the template are <em>italicized</em>. Thus the header line</p>
<blockquote><p><code>(vector-ref vector k)</code> <em>procedure</em></p>
</blockquote>
<p>indicates that the procedure bound to the <code>vector-ref</code> variable takes
two arguments, a vector <code>vector</code> and an exact non-negative integer <code>k</code>
(see below). The header lines</p>
<blockquote><p>(make-vector <em>k</em>)  procedure</p>
<p>(make-vector <em>k</em> <em>fill</em>)  procedure</p>
</blockquote>
<p>indicate that the <code>make-vector</code> procedure must be defined to take either
one or two arguments.</p>
<p>It is an error for a procedure to be presented with an argument that it
is not specified to handle. For succinctness, we follow the convention
that if an argument name is also the name of a type listed in
section <a href="#disjointness">[disjointness]</a>, then it is an error if that
argument is not of the named type. For example, the header line for
<code>vector-ref</code> given above dictates that the first argument to
<code>vector-ref</code> is a vector. The following naming conventions also imply
type restrictions:</p>
<table>
<thead><tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><em>a<strong>l</strong>i<strong>s</strong>t</em></td>
<td style="text-align:left">association list (list of pairs)</td>
</tr>
<tr>
<td style="text-align:left"><em>b<strong>o</strong>o<strong>l</strong>e<strong>a</strong>n</em></td>
<td style="text-align:left">boolean value (<code>#t</code> or <code>#f</code>)</td>
</tr>
<tr>
<td style="text-align:left"><em>b<strong>y</strong>t**e</em></td>
<td style="text-align:left">exact integer 0 ≤ <em>b<strong>y</strong>t**e</em> \&lt; 256</td>
</tr>
<tr>
<td style="text-align:left"><em>b<strong>y</strong>t<strong>e</strong>v<strong>e</strong>c<strong>t</strong>o**r</em></td>
<td style="text-align:left">bytevector</td>
</tr>
<tr>
<td style="text-align:left"><em>c<strong>h</strong>a**r</em></td>
<td style="text-align:left">character</td>
</tr>
<tr>
<td style="text-align:left"><em>e<strong>n</strong>d</em></td>
<td style="text-align:left">exact non-negative integer</td>
</tr>
<tr>
<td style="text-align:left"><em>k</em>, <em>k</em><sub>1</sub>, … <em>k</em><sub>*j*</sub>, …</td>
<td style="text-align:left">exact non-negative integer</td>
</tr>
<tr>
<td style="text-align:left"><em>l<strong>e</strong>t<strong>t</strong>e**r</em></td>
<td style="text-align:left">alphabetic character</td>
</tr>
<tr>
<td style="text-align:left"><em>l<strong>i</strong>s**t</em>, <em>l<strong>i</strong>s**t</em><sub>1</sub>, … <em>l<strong>i</strong>s**t</em><sub>*j*</sub>, …</td>
<td style="text-align:left">list (see section <a href="#listsection">[listsection]</a>)</td>
</tr>
<tr>
<td style="text-align:left"><em>n</em>, <em>n</em><sub>1</sub>, … <em>n</em><sub>*j*</sub>, …</td>
<td style="text-align:left">integer</td>
</tr>
<tr>
<td style="text-align:left"><em>obj</em></td>
<td style="text-align:left">any object</td>
</tr>
<tr>
<td style="text-align:left"><em>p<strong>a</strong>i**r</em></td>
<td style="text-align:left">pair</td>
</tr>
<tr>
<td style="text-align:left"><em>p<strong>o</strong>r**t</em></td>
<td style="text-align:left">port</td>
</tr>
<tr>
<td style="text-align:left"><em>p<strong>r</strong>o**c</em></td>
<td style="text-align:left">procedure</td>
</tr>
<tr>
<td style="text-align:left"><em>q</em>, <em>q</em><sub>1</sub>, … <em>q</em><sub>*j*</sub>, …</td>
<td style="text-align:left">rational number</td>
</tr>
<tr>
<td style="text-align:left"><em>s<strong>t</strong>a<strong>r</strong>t</em></td>
<td style="text-align:left">exact non-negative integer</td>
</tr>
<tr>
<td style="text-align:left"><em>s<strong>t</strong>r<strong>i</strong>n**g</em></td>
<td style="text-align:left">string</td>
</tr>
<tr>
<td style="text-align:left"><em>s<strong>y</strong>m<strong>b</strong>o**l</em></td>
<td style="text-align:left">symbol</td>
</tr>
<tr>
<td style="text-align:left"><em>t<strong>h</strong>u<strong>n</strong>k</em></td>
<td style="text-align:left">zero-argument procedure</td>
</tr>
<tr>
<td style="text-align:left"><em>v<strong>e</strong>c<strong>t</strong>o**r</em></td>
<td style="text-align:left">vector</td>
</tr>
<tr>
<td style="text-align:left"><em>x</em>, <em>x</em><sub>1</sub>, … <em>x</em><sub>*j*</sub>, …</td>
<td style="text-align:left">real number</td>
</tr>
<tr>
<td style="text-align:left"><em>y</em>, <em>y</em><sub>1</sub>, … <em>y</em><sub>*j*</sub>, …</td>
<td style="text-align:left">real number</td>
</tr>
<tr>
<td style="text-align:left"><em>z</em>, <em>z</em><sub>1</sub>, … <em>z</em><sub>*j*</sub>, …</td>
<td style="text-align:left">complex number</td>
</tr>
</tbody>
</table>
<p>The names <em>s<strong>t</strong>a<strong>r</strong>t</em> and <em>e<strong>n</strong>d</em> are used as indexes into
strings, vectors, and bytevectors. Their use implies the following:</p>
<ul>
<li><p>It is an error if <code>start</code> is greater than <code>end</code>.</p>
</li>
<li><p>It is an error if <code>end</code> is greater than the length of the string,
vector, or bytevector.</p>
</li>
<li><p>If <code>start</code> is omitted, it is assumed to be zero.</p>
</li>
<li><p>If <code>end</code> is omitted, it assumed to be the length of the string,
vector, or bytevector.</p>
</li>
<li><p>The index <code>start</code> is always inclusive and the index <code>end</code> is always
exclusive. As an example, consider a string. If <code>start</code> and <code>end</code>
are the same, an empty substring is referred to, and if <code>start</code> is
zero and <code>end</code> is the length of <code>string</code>, then the entire string is
referred to.</p>
</li>
</ul>
<h4>Evaluation examples</h4>
<p>The symbol “⟶” used in program examples is read “evaluates to.” For
example,</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">* </span><span class="mi">5</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">;; =&gt; 40</span>
</pre></div>
<p>means that the expression <code>(* 5 8)</code> evaluates to the object <code>40</code>. Or,
more precisely: the expression given by the sequence of characters
“<code>(* 5 8)</code>” evaluates, in an environment containing the base library, to
an object that can be represented externally by the sequence of
characters “<code>40</code>.” See section <a href="#externalreps">[externalreps]</a> for a
discussion of external representations of objects.</p>
<h4>Naming conventions</h4>
<p>By convention, <code>?</code> is the final character of the names of procedures
that always return a boolean value. Such procedures are called
<em>predicates</em>. Predicates are generally understood to be side-effect
free, except that they may raise an exception when passed the wrong type
of argument.</p>
<p>Similarly, <code>!</code> is the final character of the names of procedures that
store values into previously allocated locations (see
section <a href="#storagemodel">[storagemodel]</a>). Such procedures are called
<em>mutation procedures</em>. The value returned by a mutation procedure is
unspecified.</p>
<p>By convention, “<code>-&gt;</code>” appears within the names of procedures that take
an object of one type and return an analogous object of another type.
For example, list-&gt;vector takes a list and returns a vector whose
elements are the same as those of the list.</p>
<p>A <em>command</em> is a procedure that does not return useful values to its
continuation.</p>
<p>A <em>thunk</em> is a procedure that does not accept arguments.</p>
<h2>Lexical conventions</h2>
<p>This section gives an informal account of some of the lexical
conventions used in writing Scheme programs. For a formal syntax of
Scheme, see section <a href="#BNF">[BNF]</a>.</p>
<h3>Identifiers</h3>
<p>An identifier is any sequence of letters, digits, and “extended
identifier characters” provided that it does not have a prefix which is
a valid number. However, the <code>.</code> token (a single period) used in the
list syntax is not an identifier.</p>
<p>All implementations of Scheme must support the following extended
identifier characters:</p>

<div><pre>!\ \$ \% \verb"&amp;" * + - . / :\ &lt; = &gt; ? @ \verb"^" \verb"_" \verb"~" %</pre></div>
<p>Alternatively, an identifier can be represented by a sequence of zero or
more characters enclosed within vertical lines (|), analogous to string
literals. Any character, including whitespace characters, but excluding
the backslash and vertical line characters, can appear verbatim in such
an identifier. In addition, characters can be specified using either an
inline hex escape or the same escapes available in strings.</p>
<p>For example, the identifier <code>|H\x65;llo|</code> is the same identifier as
<code>Hello</code>, and in an implementation that supports the appropriate Unicode
character the identifier <code>|\x3BB;|</code> is the same as the identifier <code>λ</code>.
What is more, <code>|\t\t|</code> and <code>|\x9;\x9;|</code> are the same. Note that <code>||</code> is
a valid identifier that is different from any other identifier.</p>
<p>Here are some examples of identifiers:</p>

<div><pre>...                      {+}
    +soup+                   &lt;=?
    -&gt;string                 a34kTMNs
    lambda                   list-&gt;vector
    q                        V17a
    |two words|              |two\x20;words|
    the-word-recursion-has-many-meanings</pre></div>
<p>See section <a href="#extendedalphas">[extendedalphas]</a> for the formal syntax
of identifiers.</p>
<p>Identifiers have two uses within Scheme programs:</p>
<ul>
<li><p>Any identifier can be used as a variable or as a syntactic keyword
(see sections <a href="#variablesection">[variablesection]</a>
and <a href="#macrosection">[macrosection]</a>).</p>
</li>
<li><p>When an identifier appears as a literal or within a literal (see
section <a href="#quote">[quote]</a>), it is being used to denote a <em>symbol</em>
(see section <a href="#symbolsection">[symbolsection]</a>).</p>
</li>
</ul>
<p>In contrast with earlier revisions of the report <span class="citation"
cites="R5RS"></span>, the syntax distinguishes between upper and lower
case in identifiers and in characters specified using their names.
However, it does not distinguish between upper and lower case in
numbers, nor in inline hex escapes used in the syntax of identifiers,
characters, or strings. None of the identifiers defined in this report
contain upper-case characters, even when they appear to do so as a
result of the English-language convention of capitalizing the first word
of a sentence.</p>
<p>The following directives give explicit control over case folding.</p>
<div class="highlight"><pre><span></span><span class="o">#</span><span class="nv">!fold-case</span>
<span class="o">#</span><span class="nv">!no-fold-case</span>
</pre></div>
<p>These directives can appear anywhere comments are permitted (see
section <a href="#wscommentsection">[wscommentsection]</a>) but must be followed
by a delimiter. They are treated as comments, except that they affect
the reading of subsequent data from the same port. The #!fold-case
directive causes subsequent identifiers and character names to be
case-folded as if by string-foldcase (see
section <a href="#stringsection">[stringsection]</a>). It has no effect on
character literals. The #!no-fold-case directive causes a return to the
default, non-folding behavior.</p>
<h3>Whitespace and comments</h3>
<p><em>Whitespace</em> characters include the space, tab, and newline characters.
(Implementations may provide additional whitespace characters such as
page break.) Whitespace is used for improved readability and as
necessary to separate tokens from each other, a token being an
indivisible lexical unit such as an identifier or number, but is
otherwise insignificant. Whitespace can occur between any two tokens,
but not within a token. Whitespace occurring inside a string or inside a
symbol delimited by vertical lines is significant.</p>
<p>The lexical syntax includes several comment forms. Comments are treated
exactly like whitespace.</p>
<p>A semicolon (<code>;</code>) indicates the start of a line comment. The comment
continues to the end of the line on which the semicolon appears.</p>
<p>Another way to indicate a comment is to prefix a datum
(cf. section <a href="#datumsyntax">[datumsyntax]</a>) with <code>#;</code> and optional
whitespace. The comment consists of the comment prefix <code>#;</code>, the space,
and the datum together. This notation is useful for “commenting out”
sections of code.</p>
<p>Block comments are indicated with properly nested <code>#|</code> and <code>|#</code> pairs.</p>
<div class="highlight"><pre><span></span><span class="cm">#|</span>
<span class="cm">The FACT procedure computes the factorial</span>
<span class="cm">of a non-negative integer.</span>
<span class="cm">|#</span>
<span class="p">(</span><span class="k">define </span><span class="nv">fact</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c">#;(= n 1)</span>
        <span class="mi">1</span>        <span class="c1">;Base case: return 1</span>
        <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">fact</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))))))</span>
</pre></div>
<h3>Other notations</h3>
<p>For a description of the notations used for numbers, see
section <a href="#numbersection">[numbersection]</a>.</p>
<ul>
<li><p><code>. + -</code> These are used in numbers, and can also occur anywhere in an
identifier.  A delimited plus or minus sign by itself is also an
identifier. A delimited period (not occurring within a number or
identifier) is used in the notation for pairs
(section <a href="#listsection">[listsection]</a>), and to indicate a
rest-parameter in a formal parameter list
(section <a href="#lambda">[lambda]</a>). Note that a sequence of two or more
periods <em>is</em> an identifier.</p>
</li>
<li><p><code>( )</code> Parentheses are used for grouping and to notate lists
(section <a href="#listsection">[listsection]</a>).</p>
</li>
<li><p><code>’</code> The apostrophe (single quote) character is used to indicate
literal data (section <a href="#quote">[quote]</a>).</p>
</li>
<li><p>``` The grave accent (backquote) character is used to indicate
partly constant data (section <a href="#quasiquote">[quasiquote]</a>).</p>
</li>
<li><p><code>, ,@</code> The character comma and the sequence comma at-sign are used
in conjunction with quasiquotation
(section <a href="#quasiquote">[quasiquote]</a>).</p>
</li>
<li><p><code>"</code> The quotation mark character is used to delimit strings
(section <a href="#stringsection">[stringsection]</a>).</p>
</li>
<li><p><code>\</code> Backslash is used in the syntax for character constants
(section <a href="#charactersection">[charactersection]</a>) and as an escape
character within string constants
(section <a href="#stringsection">[stringsection]</a>) and identifiers
(section <a href="#extendedalphas">[extendedalphas]</a>).</p>
</li>
<li><p><code>[ ] { }</code> Left and right square and curly brackets (braces) are
reserved for possible future extensions to the language.</p>
</li>
<li><p><code>#</code> The number sign is used for a variety of purposes depending on
the character that immediately follows it:</p>
</li>
<li><p><code>#t</code> <code>#f</code> These are the boolean constants
(section <a href="#booleansection">[booleansection]</a>), along with the
alternatives <code>#true</code> and <code>#false</code>.</p>
</li>
<li><p><code>#``'</code> This introduces a character constant
(section <a href="#charactersection">[charactersection]</a>).</p>
</li>
<li><p><code>#``(</code> This introduces a vector constant
(section <a href="#vectorsection">[vectorsection]</a>). Vector constants are
terminated by <code>)</code> .</p>
</li>
<li><p><code>#``u8(</code> This introduces a bytevector constant
(section <a href="#bytevectorsection">[bytevectorsection]</a>). Bytevector
constants are terminated by <code>)</code> .</p>
</li>
<li><p><code>#e #i #b #o #d #x</code> These are used in the notation for numbers
(section <a href="#numbernotations">[numbernotations]</a>).</p>
</li>
<li><p><code>#n= #n#</code> These are used for labeling and referencing other literal
data (section <a href="#labelsection">[labelsection]</a>).</p>
</li>
</ul>
<h3>Datum labels</h3>
<h1>n=datum  lexical syntax</h1>
<h1>n#  lexical syntax</h1>
<p>The lexical syntax #n=datum reads the same as datum, but also results in
datum being labelled by n. It is an error if n is not a sequence of
digits.</p>
<p>The lexical syntax #n# serves as a reference to some object labelled by</p>
<h1>n=; the result is the same object as the #n= (see</h1>
<p>section <a href="#equivalencesection">[equivalencesection]</a>).</p>
<p>Together, these syntaxes permit the notation of structures with shared
or circular substructure.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">set-cdr! </span><span class="p">(</span><span class="nb">cddr </span><span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
  <span class="nv">x</span><span class="p">)</span> <span class="c1">;; =&gt; #0=(a b c . #0#)</span>
</pre></div>
<p>The scope of a datum label is the portion of the outermost datum in
which it appears that is to the right of the label. Consequently, a
reference #n# can occur only after a label #n=; it is an error to
attempt a forward reference. In addition, it is an error if the
reference appears as the labelled object itself (as in #n= #n#), because
the object labelled by #n= is not well defined in this case.</p>
<p>It is an error for a program or library to include circular references
except in literals. In particular, it is an error for quasiquote
(section <a href="#quasiquote">[quasiquote]</a>) to contain them.</p>
<div class="highlight"><pre><span></span><span class="o">#</span><span class="mi">1</span><span class="nv">=</span><span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="nb">display </span><span class="sc">#\x</span><span class="p">)</span> <span class="o">#</span><span class="mi">1</span><span class="o">#</span><span class="p">)</span>
<span class="c1">;; =&gt; error</span>
</pre></div>
<h2>Basic concepts</h2>
<h3>Variables, syntactic keywords, and regions</h3>
<p>An identifier can name either a type of syntax or a location where a
value can be stored. An identifier that names a type of syntax is called
a <em>syntactic keyword</em> and is said to be <em>bound</em> to a transformer for
that syntax. An identifier that names a location is called a <em>variable</em>
and is said to be <em>bound</em> to that location. The set of all visible
bindings in effect at some point in a program is known as the
<em>environment</em> in effect at that point. The value stored in the location
to which a variable is bound is called the variable’s value. By abuse of
terminology, the variable is sometimes said to name the value or to be
bound to the value. This is not quite accurate, but confusion rarely
results from this practice.</p>
<p>Certain expression types are used to create new kinds of syntax and to
bind syntactic keywords to those new syntaxes, while other expression
types create new locations and bind variables to those locations. These
expression types are called <em>binding constructs</em>.</p>
<p>Those that bind syntactic keywords are listed in
section <a href="#macrosection">[macrosection]</a>. The most fundamental of the
variable binding constructs is the lambda expression, because all other
variable binding constructs (except top-level bindings) can be explained
in terms of lambda expressions. The other variable binding constructs
are let, let*, letrec, letrec*, let-values, let*-values, and do
expressions (see sections <a href="#lambda">[lambda]</a>, <a href="#letrec">[letrec]</a>,
and <a href="#do">[do]</a>).</p>
<p>Scheme is a language with block structure. To each place where an
identifier is bound in a program there corresponds a <em>region</em> of the
program text within which the binding is visible. The region is
determined by the particular binding construct that establishes the
binding; if the binding is established by a lambda expression, for
example, then its region is the entire lambda expression. Every mention
of an identifier refers to the binding of the identifier that
established the innermost of the regions containing the use. If there is
no binding of the identifier whose region contains the use, then the use
refers to the binding for the variable in the global environment, if any
(chapters <a href="#expressionchapter">[expressionchapter]</a> and
<a href="#initialenv">[initialenv]</a>); if there is no binding for the
identifier, it is said to be <em>unbound</em>.</p>
<h3>Disjointness of types</h3>
<p>No object satisfies more than one of the following predicates:</p>
<div class="highlight"><pre><span></span><span class="nv">boolean?</span>          <span class="nv">bytevector?</span>
<span class="nv">char?</span>             <span class="nv">eof-object?</span>
<span class="nv">null?</span>             <span class="nv">number?</span>
<span class="nv">pair?</span>             <span class="nv">port?</span>
<span class="nv">procedure?</span>        <span class="nv">string?</span>
<span class="nv">symbol?</span>           <span class="nv">vector?</span>
</pre></div>
<p>and all predicates created by define-record-type.</p>
<p>These predicates define the types <em>boolean, bytevector, character</em>, the
empty list object, <em>eof-object, number, pair, port, procedure, string,
symbol, vector</em>, and all record types.</p>
<p>Although there is a separate boolean type, any Scheme value can be
used as a boolean value for the purpose of a conditional test. As
explained in section <a href="#booleansection">[booleansection]</a>, all values
count as true in such a test except for #f. This report uses the word
“true” to refer to any Scheme value except #f, and the word “false” to
refer to #f.</p>
<h3>External representations</h3>
<p>An important concept in Scheme (and Lisp) is that of the <em>external
representation</em> of an object as a sequence of characters. For example,
an external representation of the integer 28 is the sequence of
characters “<code>28</code>”, and an external representation of a list consisting
of the integers 8 and 13 is the sequence of characters “<code>(8 13)</code>”.</p>
<p>The external representation of an object is not necessarily unique. The
integer 28 also has representations “<code>#e28.000</code>” and “<code>#x1c</code>”, and the
list in the previous paragraph also has the representations
“<code>( 08 13 )</code>” and “<code>(8 . (13 . ()))</code>” (see
section <a href="#listsection">[listsection]</a>).</p>
<p>Many objects have standard external representations, but some, such as
procedures, do not have standard representations (although particular
implementations may define representations for them).</p>
<p>An external representation can be written in a program to obtain the
corresponding object (see quote, section <a href="#quote">[quote]</a>).</p>
<p>External representations can also be used for input and output. The
procedure read (section <a href="#read">[read]</a>) parses external
representations, and the procedure write (section <a href="#write">[write]</a>)
generates them. Together, they provide an elegant and powerful
input/output facility.</p>
<p>Note that the sequence of characters “<code>(+ 2 6)</code>” is <em>not</em> an external
representation of the integer 8, even though it <em>is</em> an expression
evaluating to the integer 8; rather, it is an external representation of
a three-element list, the elements of which are the symbol <code>+</code> and the
integers 2 and 6. Scheme’s syntax has the property that any sequence of
characters that is an expression is also the external representation of
some object. This can lead to confusion, since it is not always obvious
out of context whether a given sequence of characters is intended to
denote data or program, but it is also a source of power, since it
facilitates writing programs such as interpreters and compilers that
treat programs as data (or vice versa).</p>
<p>The syntax of external representations of various kinds of objects
accompanies the description of the primitives for manipulating the
objects in the appropriate sections of
chapter <a href="#initialenv">[initialenv]</a>.</p>
<h3>Storage model</h3>
<p>Variables and objects such as pairs, strings, vectors, and bytevectors
implicitly denote locations or sequences of locations. A string, for
example, denotes as many locations as there are characters in the
string. A new value can be stored into one of these locations using the
<code>string-set!</code> procedure, but the string continues to denote the same
locations as before.</p>
<p>An object fetched from a location, by a variable reference or by a
procedure such as car, vector-ref, or string-ref, is equivalent in the
sense of <code>eqv?</code> (section <a href="#equivalencesection">[equivalencesection]</a>)
to the object last stored in the location before the fetch.</p>
<p>Every location is marked to show whether it is in use. No variable or
object ever refers to a location that is not in use.</p>
<p>Whenever this report speaks of storage being newly allocated for a
variable or object, what is meant is that an appropriate number of
locations are chosen from the set of locations that are not in use, and
the chosen locations are marked to indicate that they are now in use
before the variable or object is made to denote them. Notwithstanding
this, it is understood that the empty list cannot be newly allocated,
because it is a unique object. It is also understood that empty strings,
empty vectors, and empty bytevectors, which contain no locations, may or
may not be newly allocated.</p>
<p>Every object that denotes locations is either mutable or immutable.
Literal constants, the strings returned by <code>symbol-&gt;string</code>, and
possibly the environment returned by scheme-report-environment are
immutable objects. All objects created by the other procedures listed in
this report are mutable. It is an error to attempt to store a new value
into a location that is denoted by an immutable object.</p>
<p>These locations are to be understood as conceptual, not physical. Hence,
they do not necessarily correspond to memory addresses, and even if they
do, the memory address might not be constant.</p>
<p><em>Rationale:</em> In many systems it is desirable for constants (i.e. the
values of literal expressions) to reside in read-only memory. Making it
an error to alter constants permits this implementation strategy, while
not requiring other systems to distinguish between mutable and immutable
objects.</p>
<h3>Proper tail recursion</h3>
<p>Implementations of Scheme are required to be <em>properly tail-recursive</em>.
Procedure calls that occur in certain syntactic contexts defined below
are <em>tail calls</em>. A Scheme implementation is properly tail-recursive if
it supports an unbounded number of active tail calls. A call is <em>active</em>
if the called procedure might still return. Note that this includes
calls that might be returned from either by the current continuation or
by continuations captured earlier by call-with-current-continuation that
are later invoked. In the absence of captured continuations, calls could
return at most once and the active calls would be those that had not yet
returned. A formal definition of proper tail recursion can be found
in <span class="citation" cites="propertailrecursion"></span>.</p>
<p><em>Rationale:</em></p>
<p>Intuitively, no space is needed for an active tail call because the
continuation that is used in the tail call has the same semantics as the
continuation passed to the procedure containing the call. Although an
improper implementation might use a new continuation in the call, a
return to this new continuation would be followed immediately by a
return to the continuation passed to the procedure. A properly
tail-recursive implementation returns to that continuation directly.</p>
<p>Proper tail recursion was one of the central ideas in Steele and
Sussman’s original version of Scheme. Their first Scheme interpreter
implemented both functions and actors. Control flow was expressed using
actors, which differed from functions in that they passed their results
on to another actor instead of returning to a caller. In the terminology
of this section, each actor finished with a tail call to another actor.</p>
<p>Steele and Sussman later observed that in their interpreter the code for
dealing with actors was identical to that for functions and thus there
was no need to include both in the language.</p>
<p>A <em>tail call</em> is a procedure call that occurs in a <em>tail context</em>. Tail
contexts are defined inductively. Note that a tail context is always
determined with respect to a particular lambda expression.</p>
<ul>
<li><p>The last expression within the body of a lambda expression, shown as
tail expression below, occurs in a tail context. The same is true of
all the bodies of case-lambda expressions. ̄ | ̄ (lāmbda formals
expression tail expression)</p>
<p>(case-lambda (formals tail body))</p>
</li>
<li><p>If one of the following expressions is in a tail context, then the
subexpressions shown as tail expression are in a tail context. These
were derived from rules in the grammar given in
chapter <a href="#formalchapter">[formalchapter]</a> by replacing some
occurrences of body with tail body, some occurrences of expression
with tail expression, and some occurrences of sequence with
tail sequence. Only those rules that contain tail contexts are shown
here.</p>
<div class="highlight"><pre><span></span><span class="err">̄</span> <span class="err">\</span><span class="nv">|</span> <span class="err">̄</span> <span class="p">(</span><span class="k">if </span><span class="nv">expression</span> <span class="nv">tail</span> <span class="nv">expression</span> <span class="nv">tail</span> <span class="nv">expression</span><span class="p">)</span> <span class="p">(</span><span class="nf">if</span>
<span class="nv">expression</span> <span class="nv">tail</span> <span class="nv">expression</span><span class="p">)</span>

<span class="p">(</span><span class="k">cond </span><span class="nv">cond</span> <span class="nv">clause&lt;sup&gt;+&lt;/sup&gt;</span><span class="p">)</span> <span class="p">(</span><span class="k">cond </span><span class="nv">cond</span> <span class="nv">clause</span> <span class="p">(</span><span class="nf">else</span>
<span class="nv">tail</span> <span class="nv">sequence</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cāse</span> <span class="nv">expression</span> <span class="nv">&lt;sup&gt;+&lt;/sup&gt;</span><span class="p">)</span> <span class="p">(</span><span class="nf">cāse</span> <span class="nv">expression</span> <span class="p">(</span><span class="nf">else</span>
<span class="nv">tail</span> <span class="nv">sequence</span><span class="p">))</span>

<span class="p">(</span><span class="k">and </span><span class="nv">expression</span> <span class="nv">tail</span> <span class="nv">expression</span><span class="p">)</span> <span class="p">(</span><span class="k">or </span><span class="nv">expression</span> <span class="nv">tail</span> <span class="nv">expression</span><span class="p">)</span>

<span class="p">(</span><span class="nf">when</span> <span class="nv">test</span> <span class="nv">tail</span> <span class="nv">sequence</span><span class="p">)</span> <span class="p">(</span><span class="nf">unless</span> <span class="nv">test</span> <span class="nv">tail</span> <span class="nv">sequence</span><span class="p">)</span>

<span class="p">(</span><span class="k">let </span><span class="p">(</span><span class="nf">binding</span> <span class="nv">spec</span><span class="p">)</span> <span class="nv">tail</span> <span class="nv">body</span><span class="p">)</span> <span class="p">(</span><span class="k">let </span><span class="nv">variable</span> <span class="p">(</span><span class="nf">binding</span> <span class="nv">spec</span><span class="p">)</span>
<span class="nv">tail</span> <span class="nv">body</span><span class="p">)</span> <span class="p">(</span><span class="nf">let</span><span class="err">\</span><span class="nv">*</span> <span class="p">(</span><span class="nf">binding</span> <span class="nv">spec</span><span class="p">)</span> <span class="nv">tail</span> <span class="nv">body</span><span class="p">)</span> <span class="p">(</span><span class="k">letrec </span><span class="p">(</span><span class="nf">binding</span> <span class="nv">spec</span><span class="p">)</span>
<span class="nv">tail</span> <span class="nv">body</span><span class="p">)</span> <span class="p">(</span><span class="nf">letrec</span><span class="err">\</span><span class="nv">*</span> <span class="p">(</span><span class="nf">binding</span> <span class="nv">spec</span><span class="p">)</span> <span class="nv">tail</span> <span class="nv">body</span><span class="p">)</span> <span class="p">(</span><span class="nf">let-values</span>
<span class="p">(</span><span class="nf">mv</span> <span class="nv">binding</span> <span class="nv">spec</span><span class="p">)</span> <span class="nv">tail</span> <span class="nv">body</span><span class="p">)</span> <span class="p">(</span><span class="nf">let</span><span class="err">\</span><span class="nv">*-values</span> <span class="p">(</span><span class="nf">mv</span> <span class="nv">binding</span> <span class="nv">spec</span><span class="p">)</span>
<span class="nv">tail</span> <span class="nv">body</span><span class="p">)</span>

<span class="p">(</span><span class="k">let-syntax </span><span class="p">(</span><span class="nf">syntax</span> <span class="nv">spec</span><span class="p">)</span> <span class="nv">tail</span> <span class="nv">body</span><span class="p">)</span> <span class="p">(</span><span class="k">letrec-syntax </span><span class="p">(</span><span class="nf">syntax</span> <span class="nv">spec</span><span class="p">)</span>
<span class="nv">tail</span> <span class="nv">body</span><span class="p">)</span>

<span class="p">(</span><span class="k">begin </span><span class="nv">tail</span> <span class="nv">sequence</span><span class="p">)</span>

<span class="p">(</span><span class="nf">dō</span> <span class="p">(</span><span class="err">̄</span><span class="nv">iteration</span> <span class="nv">spec</span><span class="p">)</span> <span class="p">(</span><span class="nf">test</span> <span class="nv">tail</span> <span class="nv">sequence</span><span class="p">)</span> <span class="p">)</span>

<span class="nv">where</span>

<span class="nv">cond</span> <span class="nv">clause</span> <span class="err">⟶</span> <span class="p">(</span><span class="nf">test</span> <span class="nv">tail</span> <span class="nv">sequence</span><span class="p">)</span> <span class="nv">case</span> <span class="nv">clause</span> <span class="err">⟶</span> <span class="p">((</span><span class="nf">datum</span><span class="p">)</span>
<span class="nv">tail</span> <span class="nv">sequence</span><span class="p">)</span>

<span class="nv">tail</span> <span class="nv">body</span> <span class="err">⟶</span> <span class="nv">definition</span> <span class="nv">tail</span> <span class="nv">sequence</span> <span class="nv">tail</span> <span class="nv">sequence</span> <span class="err">⟶</span> <span class="nv">expression</span>
<span class="nv">tail</span> <span class="nv">expression</span>
</pre></div>
</li>
<li><p>If a cond or case expression is in a tail context, and has a clause
of the form (expression<sub>1</sub> =&gt; expression<sub>2</sub>) then
the (implied) call to the procedure that results from the evaluation
of expression<sub>2</sub> is in a tail context.
expression<sub>2</sub> itself is not in a tail context.</p>
</li>
</ul>
<p>Certain procedures defined in this report are also required to perform
tail calls. The first argument passed to <code>apply</code> and to
<code>call-with-current-continuation</code>, and the second argument passed to
<code>call-with-values</code>, must be called via a tail call. Similarly, <code>eval</code>
must evaluate its first argument as if it were in tail position within
the <code>eval</code> procedure.</p>
<p>In the following example the only tail call is the call to f. None of
the calls to g or h are tail calls. The reference to x is in a tail
context, but it is not a call and thus is not a tail call.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">g</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="p">(</span><span class="nf">h</span><span class="p">)))</span>
        <span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nf">g</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span><span class="p">))))</span>
</pre></div>
<p><em>Note:</em> Implementations may recognize that some non-tail calls, such as
the call to h above, can be evaluated as though they were tail calls. In
the example above, the let expression could be compiled as a tail call
to h. (The possibility of h returning an unexpected number of values can
be ignored, because in that case the effect of the let is explicitly
unspecified and implementation-dependent.)</p>
<h2>Expressions</h2>
<p>Expression types are categorized as <em>primitive</em> or <em>derived</em>. Primitive
expression types include variables and procedure calls. Derived
expression types are not semantically primitive, but can instead be
defined as macros. Suitable syntax definitions of some of the derived
expressions are given in section <a href="#derivedsection">[derivedsection]</a>.</p>
<p>The procedures force, promise?, make-promise, and make-parameter are
also described in this chapter because they are intimately associated
with the delay, delay-force, and parameterize expression types.</p>
<h3>Primitive expression types</h3>
<h4>Variable references</h4>
<p>variable  syntax
An expression consisting of a variable
(section <a href="#variablesection">[variablesection]</a>) is a variable
reference. The value of the variable reference is the value stored in
the location to which the variable is bound. It is an error to reference
an unbound variable.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="mi">28</span><span class="p">)</span>
<span class="nv">x</span> <span class="c1">;; =&gt; 28</span>
</pre></div>
<h4>Literal expressions</h4>
<p>(quote <em>datum</em>)  syntax
<code>’</code>datum  syntax
constant  syntax
(quote datum) evaluates to datum. Datum can be any external
representation of a Scheme object (see
section <a href="#externalreps">[externalreps]</a>). This notation is used to
include literal constants in Scheme code.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">quote </span><span class="nv">a</span><span class="p">)</span> <span class="c1">;; =&gt; a</span>
<span class="p">(</span><span class="k">quote </span><span class="o">#</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span> <span class="c1">;; =&gt; #(a b c)</span>
<span class="p">(</span><span class="k">quote </span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">;; =&gt; (+ 1 2)</span>
</pre></div>
<p>(quote datum) can be abbreviated as <code>’</code>datum. The two notations are
equivalent in all respects.</p>
<div class="highlight"><pre><span></span><span class="ss">&#39;a</span> <span class="c1">;; =&gt; a</span>
<span class="o">&#39;#</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="c1">;; =&gt; #(a b c)</span>
<span class="o">&#39;</span><span class="p">()</span> <span class="c1">;; =&gt; ()</span>
<span class="o">&#39;</span><span class="p">(</span><span class="nv">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; =&gt; (+ 1 2)</span>
<span class="o">&#39;</span><span class="p">(</span><span class="k">quote </span><span class="nv">a</span><span class="p">)</span> <span class="c1">;; =&gt; (quote a)</span>
<span class="o">&#39;</span><span class="ss">&#39;a</span> <span class="c1">;; =&gt; (quote a)</span>
</pre></div>
<p>Numerical constants, string constants, character constants, vector
constants, bytevector constants, and boolean constants evaluate to
themselves; they need not be quoted.</p>
<div class="highlight"><pre><span></span><span class="ss">&#39;145932</span> <span class="c1">;; =&gt; 145932</span>
<span class="mi">145932</span> <span class="c1">;; =&gt; 145932</span>
<span class="o">&#39;</span><span class="s">&quot;abc&quot;</span> <span class="c1">;; =&gt; &quot;abc&quot;</span>
<span class="s">&quot;abc&quot;</span> <span class="c1">;; =&gt; &quot;abc&quot;</span>
<span class="o">&#39;</span><span class="sc">#\a</span> <span class="c1">;; =&gt; #\a</span>
<span class="sc">#\a</span> <span class="c1">;; =&gt; #\a</span>
<span class="o">&#39;#</span><span class="p">(</span><span class="nv">a</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">;; =&gt; #(a 10)</span>
<span class="o">#</span><span class="p">(</span><span class="nv">a</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">;; =&gt; #(a 10)</span>
<span class="o">&#39;#</span><span class="nv">u8</span><span class="p">(</span><span class="mi">64</span> <span class="mi">65</span><span class="p">)</span> <span class="c1">;; =&gt; #u8(64 65)</span>
<span class="o">#</span><span class="nv">u8</span><span class="p">(</span><span class="mi">64</span> <span class="mi">65</span><span class="p">)</span> <span class="c1">;; =&gt; #u8(64 65)</span>
<span class="o">&#39;</span><span class="no">#t</span> <span class="c1">;; =&gt; #t</span>
<span class="no">#t</span> <span class="c1">;; =&gt; #t</span>
</pre></div>
<p>As noted in section <a href="#storagemodel">[storagemodel]</a>, it is an error to
attempt to alter a constant (i.e. the value of a literal expression)
using a mutation procedure like set-car! or string-set!.</p>
<h4>Procedure calls</h4>
<p>(operator operand<sub>1</sub> … )  syntax
A procedure call is written by enclosing in parentheses an expression
for the procedure to be called followed by expressions for the arguments
to be passed to it. The operator and operand expressions are evaluated
(in an unspecified order) and the resulting procedure is passed the
resulting arguments.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">+ </span><span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">;; =&gt; 7</span>
<span class="p">((</span><span class="k">if </span><span class="no">#f</span> <span class="nv">+</span> <span class="nv">*</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">;; =&gt; 12</span>
</pre></div>
<p>The procedures in this document are available as the values of variables
exported by the standard libraries. For example, the addition and
multiplication procedures in the above examples are the values of the
variables + and * in the base library. New procedures are created by
evaluating lambda expressions (see section <a href="#lambda">[lambda]</a>).</p>
<p>Procedure calls can return any number of values (see <code>values</code> in
section <a href="#proceduresection">[proceduresection]</a>). Most of the
procedures defined in this report return one value or, for procedures
such as apply, pass on the values returned by a call to one of their
arguments. Exceptions are noted in the individual descriptions.</p>
<p><em>Note:</em> In contrast to other dialects of Lisp, the order of evaluation
is unspecified, and the operator expression and the operand expressions
are always evaluated with the same evaluation rules.</p>
<p><em>Note:</em> Although the order of evaluation is otherwise unspecified, the
effect of any concurrent evaluation of the operator and operand
expressions is constrained to be consistent with some sequential order
of evaluation. The order of evaluation may be chosen differently for
each procedure call.</p>
<p><em>Note:</em> In many dialects of Lisp, the empty list, <code>()</code>, is a legitimate
expression evaluating to itself. In Scheme, it is an error.</p>
<h4>Procedures</h4>
<p>(lambda <em>formals body</em>)  syntax
<em>Syntax:</em> Formals is a formal arguments list as described below, and
body is a sequence of zero or more definitions followed by one or more
expressions.</p>
<p><em>Semantics:</em> A lambda expression evaluates to a procedure. The
environment in effect when the lambda expression was evaluated is
remembered as part of the procedure. When the procedure is later called
with some actual arguments, the environment in which the lambda
expression was evaluated will be extended by binding the variables in
the formal argument list to fresh locations, and the corresponding
actual argument values will be stored in those locations. (A <em>fresh</em>
location is one that is distinct from every previously existing
location.) Next, the expressions in the body of the lambda expression
(which, if it contains definitions, represents a letrec* form — see
section <a href="#letrecstar">[letrecstar]</a>) will be evaluated sequentially in
the extended environment. The results of the last expression in the body
will be returned as the results of the procedure call.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span> <span class="c1">;; =&gt; a procedure</span>
<span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">;; =&gt; 8</span>

<span class="p">(</span><span class="k">define </span><span class="nv">reverse-subtract</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">y</span> <span class="nv">x</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">reverse-subtract</span> <span class="mi">7</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">;; =&gt; 3</span>

<span class="p">(</span><span class="k">define </span><span class="nv">add4</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="mi">4</span><span class="p">))</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">add4</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">;; =&gt; 10</span>
</pre></div>
<p>Formals have one of the following forms:</p>
<ul>
<li><p><code>(variable_1 ...)</code>: The procedure takes a fixed number of
arguments; when the procedure is called, the arguments will be
stored in fresh locations that are bound to the corresponding
variables.</p>
</li>
<li><p>variable: The procedure takes any number of arguments; when the
procedure is called, the sequence of actual arguments is converted
into a newly allocated list, and the list is stored in a fresh
location that is bound to variable.</p>
</li>
<li><p><code>(variable_1 ... variable_{n} . variable_{n+1})</code>: If a
space-delimited period precedes the last variable, then the
procedure takes <em>n</em> or more arguments, where <em>n</em> is the number of
formal arguments before the period (it is an error if there is not
at least one). The value stored in the binding of the last variable
will be a newly allocated list of the actual arguments left over
after all the other actual arguments have been matched up against
the other formal arguments.</p>
</li>
</ul>
<p>It is an error for a variable to appear more than once in formals.</p>
<div class="highlight"><pre><span></span><span class="p">((</span><span class="k">lambda </span><span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">;; =&gt; (3 4 5 6)</span>
<span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span> <span class="o">.</span> <span class="nv">z</span><span class="p">)</span> <span class="nv">z</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">;; =&gt; (5 6)</span>
</pre></div>
<p>Each procedure created as the result of evaluating a lambda expression
is (conceptually) tagged with a storage location, in order to make
<code>eqv?</code> and <code>eq?</code> work on procedures (see
section <a href="#equivalencesection">[equivalencesection]</a>).</p>
<h4>Conditionals</h4>
<p>(if <em>test consequent alternate</em>)  syntax
(if <em>test consequent</em>)  syntax
<em>Syntax:</em> Test, consequent, and alternate are expressions.</p>
<p><em>Semantics:</em> An if expression is evaluated as follows: first, test is
evaluated. If it yields a true value (see
section <a href="#booleansection">[booleansection]</a>), then consequent is
evaluated and its values are returned. Otherwise alternate is evaluated
and its values are returned. If test yields a false value and no
alternate is specified, then the result of the expression is
unspecified.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="mi">3</span> <span class="mi">2</span><span class="p">)</span> <span class="ss">&#39;yes</span> <span class="ss">&#39;no</span><span class="p">)</span> <span class="c1">;; =&gt; yes</span>
<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="ss">&#39;yes</span> <span class="ss">&#39;no</span><span class="p">)</span> <span class="c1">;; =&gt; no</span>
<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="mi">3</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">- </span><span class="mi">3</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">+ </span><span class="mi">3</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">;; =&gt; 1</span>
</pre></div>
<h4>Assignments</h4>
<p>(set! <em>variable expression</em>)  syntax
<em>Semantics:</em> Expression is evaluated, and the resulting value is stored
in the location to which variable is bound. It is an error if variable
is not bound either in some region enclosing the set! expression or else
globally. The result of the set! expression is unspecified.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">;; =&gt; 3</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">x</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">;; =&gt; 5</span>
</pre></div>
<h4>Inclusion</h4>
<p>(include <em>string<sub>1</sub> string<sub>2</sub> … </em>)  syntax
(include-ci <em>string<sub>1</sub> string<sub>2</sub> … </em>)  syntax
<em>Semantics:</em> Both <code>include</code> and <code>include-ci</code> take one or more filenames
expressed as string literals, apply an implementation-specific algorithm
to find corresponding files, read the contents of the files in the
specified order as if by repeated applications of read, and effectively
replace the include or include-ci expression with a begin expression
containing what was read from the files. The difference between the two
is that <code>include-ci</code> reads each file as if it began with the #!fold-case
directive, while <code>include</code> does not.</p>
<p><em>Note:</em> Implementations are encouraged to search for files in the
directory which contains the including file, and to provide a way for
users to specify other directories to search.</p>
<h3>Derived expression types</h3>
<p>The constructs in this section are hygienic, as discussed in
section <a href="#macrosection">[macrosection]</a>. For reference purposes,
section <a href="#derivedsection">[derivedsection]</a> gives syntax definitions
that will convert most of the constructs described in this section into
the primitive constructs described in the previous section.</p>
<h4>Conditionals</h4>
<p>(cond <em>clause<sub>1</sub> clause<sub>2</sub> … </em>)  syntax
else  auxiliary syntax
=&gt;  auxiliary syntax
<em>Syntax:</em> Clauses take one of two forms, either</p>

<div><pre>(&lt;test&gt; &lt;expression&gt; ...)</pre></div>
<p>where test is any expression, or</p>

<div><pre>(&lt;test&gt; =&gt; &lt;expression&gt;)</pre></div>
<p>The last clause can be an “else clause,” which has the form</p>

<div><pre>(else &lt;expression&gt; &lt;expression&gt; ...)</pre></div>
<p><em>Semantics:</em> A cond expression is evaluated by evaluating the test
expressions of successive clauses in order until one of them evaluates
to a true value (see section <a href="#booleansection">[booleansection]</a>).
When a test evaluates to a true value, the remaining expressions in its
clause are evaluated in order, and the results of the last expression in
the clause are returned as the results of the entire cond expression.</p>
<p>If the selected clause contains only the test and no expressions, then
the value of the test is returned as the result. If the selected clause
uses the <code>=&gt;</code> alternate form, then the expression is evaluated. It is an
error if its value is not a procedure that accepts one argument. This
procedure is then called on the value of the test and the values
returned by this procedure are returned by the cond expression.</p>
<p>If all tests evaluate to #f, and there is no else clause, then the
result of the conditional expression is unspecified; if there is an else
clause, then its expressions are evaluated in order, and the values of
the last one are returned.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">&gt; </span><span class="mi">3</span> <span class="mi">2</span><span class="p">)</span> <span class="ss">&#39;greater</span><span class="p">)</span>
      <span class="p">((</span><span class="nb">&lt; </span><span class="mi">3</span> <span class="mi">2</span><span class="p">)</span> <span class="ss">&#39;less</span><span class="p">))</span> <span class="c1">;; =&gt; greater</span>

<span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">&gt; </span><span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="ss">&#39;greater</span><span class="p">)</span>
      <span class="p">((</span><span class="nb">&lt; </span><span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="ss">&#39;less</span><span class="p">)</span>
      <span class="p">(</span><span class="k">else </span><span class="ss">&#39;equal</span><span class="p">))</span> <span class="c1">;; =&gt; equal</span>

<span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">assv </span><span class="ss">&#39;b</span> <span class="o">&#39;</span><span class="p">((</span><span class="nf">a</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">b</span> <span class="mi">2</span><span class="p">)))</span> <span class="k">=&gt; </span><span class="nv">cadr</span><span class="p">)</span>
      <span class="p">(</span><span class="k">else </span><span class="no">#f</span><span class="p">))</span> <span class="c1">;; =&gt; 2</span>
</pre></div>
<p>(case <em>key clause<sub>1</sub> clause<sub>2</sub> … </em>)  syntax
<em>Syntax:</em> Key can be any expression. Each clause has the form</p>

<div><pre>((&lt;datum&gt; ...) &lt;expression&gt; &lt;expression&gt; ...)</pre></div>
<p>where each datum is an external representation of some object. It is an
error if any of the datums are the same anywhere in the expression.
Alternatively, a clause can be of the form</p>

<div><pre>((&lt;datum&gt; ...) =&gt; &lt;expression&gt;)</pre></div>
<p>The last clause can be an “else clause,” which has one of the forms</p>

<div><pre>(else &lt;expression&gt; &lt;expression&gt; ...)</pre></div>
<p>or</p>

<div><pre>(else =&gt; &lt;expression&gt;)</pre></div>
<p><em>Semantics:</em> A case expression is evaluated as follows. Key is evaluated
and its result is compared against each datum. If the result of
evaluating key is the same (in the sense of eqv?; see
section <a href="#eqv?">[eqv?]</a>) to a datum, then the expressions in the
corresponding clause are evaluated in order and the results of the last
expression in the clause are returned as the results of the case
expression.</p>
<p>If the result of evaluating key is different from every datum, then if
there is an else clause, its expressions are evaluated and the results
of the last are the results of the case expression; otherwise the result
of the case expression is unspecified.</p>
<p>If the selected clause or else clause uses the <code>=&gt;</code> alternate form, then
the expression is evaluated. It is an error if its value is not a
procedure accepting one argument. This procedure is then called on the
value of the key and the values returned by this procedure are returned
by the case expression.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">case </span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
  <span class="p">((</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span><span class="p">)</span> <span class="ss">&#39;prime</span><span class="p">)</span>
  <span class="p">((</span><span class="mi">1</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span> <span class="ss">&#39;composite</span><span class="p">))</span> <span class="c1">;; =&gt; composite</span>
<span class="p">(</span><span class="k">case </span><span class="p">(</span><span class="nb">car </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
  <span class="p">((</span><span class="nf">a</span><span class="p">)</span> <span class="ss">&#39;a</span><span class="p">)</span>
  <span class="p">((</span><span class="nf">b</span><span class="p">)</span> <span class="ss">&#39;b</span><span class="p">))</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="k">case </span><span class="p">(</span><span class="nb">car </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
  <span class="p">((</span><span class="nf">a</span> <span class="nv">e</span> <span class="nv">i</span> <span class="nv">o</span> <span class="nv">u</span><span class="p">)</span> <span class="ss">&#39;vowel</span><span class="p">)</span>
  <span class="p">((</span><span class="nf">w</span> <span class="nv">y</span><span class="p">)</span> <span class="ss">&#39;semivowel</span><span class="p">)</span>
  <span class="p">(</span><span class="k">else =&gt; </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))</span> <span class="c1">;; =&gt; c</span>
</pre></div>
<p>(and <em>test<sub>1</sub> … </em>)  syntax
<em>Semantics:</em> The test expressions are evaluated from left to right, and
if any expression evaluates to <code>#f</code> (see
section <a href="#booleansection">[booleansection]</a>), then <code>#f</code> is returned. Any
remaining expressions are not evaluated. If all the expressions evaluate
to true values, the values of the last expression are returned. If there
are no expressions, then <code>#t</code> is returned.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">= </span><span class="mi">2</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt; </span><span class="mi">2</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">= </span><span class="mi">2</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt; </span><span class="mi">2</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="k">and </span><span class="mi">1</span> <span class="mi">2</span> <span class="ss">&#39;c</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">f</span> <span class="nv">g</span><span class="p">))</span> <span class="c1">;; =&gt; (f g)</span>
<span class="p">(</span><span class="nf">and</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
</pre></div>
<p>(or <em>test<sub>1</sub> … </em>)  syntax
<em>Semantics:</em> The test expressions are evaluated from left to right, and
the value of the first expression that evaluates to a true value (see
section <a href="#booleansection">[booleansection]</a>) is returned. Any
remaining expressions are not evaluated. If all expressions evaluate to <code>#f</code>
or if there are no expressions, then <code>#f</code> is returned.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nb">= </span><span class="mi">2</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt; </span><span class="mi">2</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nb">= </span><span class="mi">2</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt; </span><span class="mi">2</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="k">or </span><span class="no">#f</span> <span class="no">#f</span> <span class="no">#f</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nb">memq </span><span class="ss">&#39;b</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">/ </span><span class="mi">3</span> <span class="mi">0</span><span class="p">))</span> <span class="c1">;; =&gt; (b c)</span>
</pre></div>
<p>(when <em>test expression<sub>1</sub> expression<sub>2</sub> … </em>)  syntax
<em>Syntax:</em> The test is an expression.</p>
<p><em>Semantics:</em> The test is evaluated, and if it evaluates to a true value,
the expressions are evaluated in order. The result of the when
expression is unspecified.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">when</span> <span class="p">(</span><span class="nb">= </span><span class="mi">1</span> <span class="mf">1.0</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display </span><span class="s">&quot;1&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display </span><span class="s">&quot;2&quot;</span><span class="p">))</span> <span class="c1">;; =&gt; unspecified</span>
<span class="c1">;; and prints 12</span>
</pre></div>
<p>(unless <em>test expression<sub>1</sub> expression<sub>2</sub> … </em>)
 syntax
<em>Syntax:</em> The test is an expression.</p>
<p><em>Semantics:</em> The test is evaluated, and if it evaluates to #f, the
expressions are evaluated in order. The result of the unless
expression is unspecified.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">unless</span> <span class="p">(</span><span class="nb">= </span><span class="mi">1</span> <span class="mf">1.0</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display </span><span class="s">&quot;1&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display </span><span class="s">&quot;2&quot;</span><span class="p">))</span> <span class="c1">;; =&gt; unspecified</span>
<span class="c1">;; and prints nothing</span>
</pre></div>
<p>(cond-expand <em>ce-clause<sub>1</sub> ce-clause<sub>2</sub> … </em>)  syntax
<em>Syntax:</em> The <code>cond-expand</code> expression type provides a way to statically
expand different expressions depending on the implementation. A
ce-clause takes the following form:</p>
<p><code>(feature requirement expression ...)</code></p>
<p>The last clause can be an “else clause,” which has the form</p>
<p><code>(else expression ...)</code></p>
<p>A feature requirement takes one of the following forms:</p>
<ul>
<li><p><code>feature identifier</code></p>
</li>
<li><p><code>(library library name)</code></p>
</li>
<li><p><code>(and feature requirement ...)</code></p>
</li>
<li><p><code>(or feature requirement ...)</code></p>
</li>
<li><p><code>(not feature requirement)</code></p>
</li>
</ul>
<p><em>Semantics:</em> Each implementation maintains a list of feature identifiers
which are present, as well as a list of libraries which can be imported.
The value of a feature requirement is determined by replacing each
feature identifier and <code>(library library name)</code> on the implementation’s
lists with <code>#t</code>, and all other feature identifiers and library names with #f,
then evaluating the resulting expression as a Scheme boolean
expression under the normal interpretation of and, or, and not.</p>
<p>A <code>cond-expand</code> is then expanded by evaluating the feature requirements
of successive ce-clauses in order until one of them returns <code>#t</code>. When a
true clause is found, the corresponding expressions are expanded to a
begin, and the remaining clauses are ignored. If none of the
feature requirements evaluate to #t, then if there is an else clause,
its expressions are included. Otherwise, the behavior of the
<code>cond-expand</code> is unspecified. Unlike cond, cond-expand does not depend
on the value of any variables.</p>
<p>The exact features provided are implementation-defined, but for
portability a core set of features is given in
appendix <a href="#stdfeatures">[stdfeatures]</a>.</p>
<h4>Binding constructs</h4>
<p>The binding constructs let, let*, letrec, letrec*, let-values, and
let*-values give Scheme a block structure, like Algol 60. The syntax of
the first four constructs is identical, but they differ in the regions
they establish for their variable bindings. In a let expression, the
initial values are computed before any of the variables become bound; in
a let* expression, the bindings and evaluations are performed
sequentially; while in letrec and letrec* expressions, all the bindings
are in effect while their initial values are being computed, thus
allowing mutually recursive definitions. The let-values and let*-values
constructs are analogous to let and let* respectively, but are designed
to handle multiple-valued expressions, binding different identifiers to
the returned values.</p>
<p>(let <em>bindings body</em>)  syntax
<em>Syntax:</em> Bindings has the form</p>

<div><pre>((&lt;variable&gt; &lt;init&gt;) ...)</pre></div>
<p>where each init is an expression, and body is a sequence of zero or more
definitions followed by a sequence of one or more expressions as
described in section <a href="#lambda">[lambda]</a>. It is an error for a
variable to appear more than once in the list of variables being bound.</p>
<p><em>Semantics:</em> The inits are evaluated in the current environment (in some
unspecified order), the variables are bound to fresh locations holding
the results, the body is evaluated in the extended environment, and the
values of the last expression of body are returned. Each binding of a
variable has body as its region.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span> <span class="mi">3</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="c1">;; =&gt; 6</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span> <span class="mi">3</span><span class="p">))</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="mi">7</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">z</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">* </span><span class="nv">z</span> <span class="nv">x</span><span class="p">)))</span> <span class="c1">;; =&gt; 35</span>
</pre></div>
<p>See also “named let,” section <a href="#namedlet">[namedlet]</a>.</p>
<p>(let* <em>bindings body</em>)  syntax</p>
<p><em>Syntax:</em> Bindings has the form</p>

<div><pre>((&lt;variable&gt; &lt;init&gt;) ...)</pre></div>
<p>and body is a sequence of zero or more definitions followed by one or
more expressions as described in section <a href="#lambda">[lambda]</a>.</p>
<p><em>Semantics:</em> The let* binding construct is similar to let, but the
bindings are performed sequentially from left to right, and the region
of a binding indicated by (variable init) is that part of the let*
expression to the right of the binding. Thus the second binding is done
in an environment in which the first binding is visible, and so on. The
variables need not be distinct.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span> <span class="mi">3</span><span class="p">))</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">x</span> <span class="mi">7</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">z</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">* </span><span class="nv">z</span> <span class="nv">x</span><span class="p">)))</span> <span class="c1">;; =&gt; 70</span>
</pre></div>
<p>(letrec <em>bindings body</em>)  syntax
<em>Syntax:</em> Bindings has the form</p>

<div><pre>((&lt;variable&gt; &lt;init&gt;) ...)</pre></div>
<p>and body is a sequence of zero or more definitions followed by one or
more expressions as described in section <a href="#lambda">[lambda]</a>. It is an
error for a variable to appear more than once in the list of variables
being bound.</p>
<p><em>Semantics:</em> The variables are bound to fresh locations holding
unspecified values, the inits are evaluated in the resulting environment
(in some unspecified order), each variable is assigned to the result of
the corresponding init, the body is evaluated in the resulting
environment, and the values of the last expression in body are returned.
Each binding of a variable has the entire letrec expression as its
region, making it possible to define mutually recursive procedures.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">letrec </span><span class="p">((</span><span class="nf">even?</span>
          <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
            <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span>
                <span class="no">#t</span>
                <span class="p">(</span><span class="nb">odd? </span><span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))))</span>
         <span class="p">(</span><span class="nf">odd?</span>
          <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
            <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span>
                <span class="no">#f</span>
                <span class="p">(</span><span class="nb">even? </span><span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))))))</span>
  <span class="p">(</span><span class="nb">even? </span><span class="mi">88</span><span class="p">))</span>
<span class="c1">;; =&gt; #t</span>
</pre></div>
<p>One restriction on letrec is very important: if it is not possible to
evaluate each init without assigning or referring to the value of any
variable, it is an error. The restriction is necessary because letrec is
defined in terms of a procedure call where a lambda expression binds the
variables to the values of the inits. In the most common uses of letrec,
all the inits are lambda expressions and the restriction is satisfied
automatically.</p>
<p>(letrec* <em>bindings body</em>)  syntax
<em>Syntax:</em> Bindings has the form</p>

<div><pre>((&lt;variable&gt; &lt;init&gt;) ...)</pre></div>
<p>and body is a sequence of zero or more definitions followed by one or
more expressions as described in section <a href="#lambda">[lambda]</a>. It is an
error for a variable to appear more than once in the list of variables
being bound.</p>
<p><em>Semantics:</em> The variables are bound to fresh locations, each variable
is assigned in left-to-right order to the result of evaluating the
corresponding init (interleaving evaluations and assignments), the body
is evaluated in the resulting environment, and the values of the last
expression in body are returned. Despite the left-to-right evaluation
and assignment order, each binding of a variable has the entire letrec*
expression as its region, making it possible to define mutually
recursive procedures.</p>
<p>If it is not possible to evaluate each init without assigning or
referring to the value of the corresponding variable or the variable of
any of the bindings that follow it in bindings, it is an error. Another
restriction is that it is an error to invoke the continuation of an init
more than once.</p>
<div class="highlight"><pre><span></span><span class="c1">;; Returns the arithmetic, geometric, and</span>
<span class="c1">;; harmonic means of a nested list of numbers</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">means</span> <span class="nv">ton</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">letrec*</span>
      <span class="p">((</span><span class="nf">mean</span>
        <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">f</span> <span class="nv">g</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">sum</span> <span class="nv">g</span> <span class="nv">ton</span><span class="p">)</span> <span class="nv">n</span><span class="p">))))</span>
       <span class="p">(</span><span class="nf">sum</span>
        <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">g</span> <span class="nv">ton</span><span class="p">)</span>
          <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">ton</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">+</span><span class="p">)</span>
              <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">number? </span><span class="nv">ton</span><span class="p">)</span>
                  <span class="p">(</span><span class="nf">g</span> <span class="nv">ton</span><span class="p">)</span>
                  <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">sum</span> <span class="nv">g</span> <span class="p">(</span><span class="nb">car </span><span class="nv">ton</span><span class="p">))</span>
                     <span class="p">(</span><span class="nf">sum</span> <span class="nv">g</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">ton</span><span class="p">)))))))</span>
       <span class="p">(</span><span class="nf">n</span> <span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">ton</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">values </span><span class="p">(</span><span class="nf">mean</span> <span class="nv">values</span> <span class="nv">values</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">mean</span> <span class="nv">exp</span> <span class="nv">log</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">mean</span> <span class="nv">/</span> <span class="nv">/</span><span class="p">))))</span>
</pre></div>
<p>Evaluating (means ’(3 (1 4))) returns three values: 8/3,
2.28942848510666 (approximately), and 36/19.</p>
<p>(let-values <em>mv binding spec body</em>)  syntax
<em>Syntax:</em> Mv binding spec has the form</p>

<div><pre>((&lt;formals&gt; &lt;init&gt;) ...)</pre></div>
<p>where each init is an expression, and body is zero or more definitions
followed by a sequence of one or more expressions as described in
section <a href="#lambda">[lambda]</a>. It is an error for a variable to appear
more than once in the set of formals.</p>
<p><em>Semantics:</em> The inits are evaluated in the current environment (in some
unspecified order) as if by invoking call-with-values, and the variables
occurring in the formals are bound to fresh locations holding the values
returned by the inits, where the formals are matched to the return
values in the same way that the formals in a lambda expression are
matched to the arguments in a procedure call. Then, the body is
evaluated in the extended environment, and the values of the last
expression of body are returned. Each binding of a variable has body as
its region.</p>
<p>It is an error if the formals do not match the number of values returned
by the corresponding init.</p>

<div><pre>(let-values (((root rem) (exact-integer-sqrt 32)))
  (* root rem)) ;; =&gt; 35</pre></div>
<p>(let*-values <em>mv binding spec body</em>)  syntax</p>
<p><em>Syntax:</em> Mv binding spec has the form</p>

<div><pre>((&lt;formals&gt; &lt;init&gt;) ...)</pre></div>
<p>and body is a sequence of zero or more definitions followed by one or
more expressions as described in section <a href="#lambda">[lambda]</a>. In each
formals, it is an error if any variable appears more than once.</p>
<p><em>Semantics:</em> The let*-values construct is similar to let-values, but
the inits are evaluated and bindings created sequentially from left to
right, with the region of the bindings of each formals including the
inits to its right as well as body. Thus the second init is evaluated in
an environment in which the first set of bindings is visible and
initialized, and so on.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">a</span> <span class="ss">&#39;a</span><span class="p">)</span> <span class="p">(</span><span class="nf">b</span> <span class="ss">&#39;b</span><span class="p">)</span> <span class="p">(</span><span class="nf">x</span> <span class="ss">&#39;x</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span> <span class="ss">&#39;y</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">let*-values</span> <span class="p">(((</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">values </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
                <span class="p">((</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">values </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">list </span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span> <span class="c1">;; =&gt; (x y x y)</span>
</pre></div>
<h4>Sequencing</h4>
<p>Both of Scheme’s sequencing constructs are named begin, but the two have
slightly different forms and uses:</p>
<p>(begin <em>expression or definition … </em>)  syntax
This form of begin can appear as part of a body, or at the outermost
level of a program, or at the REPL, or directly nested in a begin that
is itself of this form. It causes the contained expressions and
definitions to be evaluated exactly as if the enclosing begin construct
were not present.</p>
<p><em>Rationale:</em> This form is commonly used in the output of macros (see
section <a href="#macrosection">[macrosection]</a>) which need to generate
multiple definitions and splice them into the context in which they are
expanded.</p>
<p>(begin <em>expression<sub>1</sub> expression<sub>2</sub> … </em>)  syntax
This form of begin can be used as an ordinary expression. The
expressions are evaluated sequentially from left to right, and the
values of the last expression are returned. This expression type is used
to sequence side effects such as assignments or input and output.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>

<span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
     <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">x</span> <span class="mi">5</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)))</span> <span class="c1">;; =&gt; 6</span>

<span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="nb">display </span><span class="s">&quot;4 plus 1 equals &quot;</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nb">+ </span><span class="mi">4</span> <span class="mi">1</span><span class="p">)))</span> <span class="c1">;; =&gt; unspecified</span>
<span class="c1">;; and prints 4 plus 1 equals 5</span>
</pre></div>
<p>Note that there is a third form of begin used as a library declaration:
see section <a href="#librarydeclarations">[librarydeclarations]</a>.</p>
<h4>Iteration</h4>
<p>(do ((variable<sub>1</sub> init<sub>1</sub> step<sub>1</sub>)  syntax
<code>...) (test expression ...) command ...)</code></p>
<p><em>Syntax:</em> All of init, step, test, and command are expressions.</p>
<p><em>Semantics:</em> A do expression is an iteration construct. It specifies a
set of variables to be bound, how they are to be initialized at the
start, and how they are to be updated on each iteration. When a
termination condition is met, the loop exits after evaluating the
expressions.</p>
<p>A do expression is evaluated as follows: The init expressions are
evaluated (in some unspecified order), the variables are bound to fresh
locations, the results of the init expressions are stored in the
bindings of the variables, and then the iteration phase begins.</p>
<p>Each iteration begins by evaluating test; if the result is false (see
section <a href="#booleansection">[booleansection]</a>), then the command
expressions are evaluated in order for effect, the step expressions are
evaluated in some unspecified order, the variables are bound to fresh
locations, the results of the steps are stored in the bindings of the
variables, and the next iteration begins.</p>
<p>If test evaluates to a true value, then the expressions are evaluated
from left to right and the values of the last expression are returned.
If no expressions are present, then the value of the do expression is
unspecified.</p>
<p>The region of the binding of a variable consists of the entire do
expression except for the inits. It is an error for a variable to appear
more than once in the list of do variables.</p>
<p>A step can be omitted, in which case the effect is the same as if
(variable init variable) had been written instead of (variable init).</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">make-vector </span><span class="mi">5</span><span class="p">))</span>
     <span class="p">(</span><span class="nf">i</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="mi">5</span><span class="p">)</span> <span class="nv">vec</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">vec</span> <span class="nv">i</span> <span class="nv">i</span><span class="p">))</span> <span class="c1">;; =&gt; #(0 1 2 3 4)</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">x</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">sum</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">sum</span> <span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">))))</span>
      <span class="p">((</span><span class="nb">null? </span><span class="nv">x</span><span class="p">)</span> <span class="nv">sum</span><span class="p">)))</span> <span class="c1">;; =&gt; 25</span>
</pre></div>
<p>(let <em>variable bindings body</em>)  syntax
<em>Semantics:</em> “Named let” is a variant on the syntax of <code>let</code> which
provides a more general looping construct than do and can also be used
to express recursion. It has the same syntax and semantics as ordinary
let except that variable is bound within body to a procedure whose
formal arguments are the bound variables and whose body is body. Thus
the execution of body can be repeated by invoking the procedure named by
variable.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">numbers</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span> <span class="mi">-2</span> <span class="mi">1</span> <span class="mi">6</span> <span class="mi">-5</span><span class="p">))</span>
           <span class="p">(</span><span class="nf">nonneg</span> <span class="o">&#39;</span><span class="p">())</span>
           <span class="p">(</span><span class="nf">neg</span> <span class="o">&#39;</span><span class="p">()))</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">numbers</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">nonneg</span> <span class="nv">neg</span><span class="p">))</span>
        <span class="p">((</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nb">car </span><span class="nv">numbers</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">numbers</span><span class="p">)</span>
               <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">numbers</span><span class="p">)</span> <span class="nv">nonneg</span><span class="p">)</span>
               <span class="nv">neg</span><span class="p">))</span>
        <span class="p">((</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">car </span><span class="nv">numbers</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">numbers</span><span class="p">)</span>
               <span class="nv">nonneg</span>
               <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">numbers</span><span class="p">)</span> <span class="nv">neg</span><span class="p">)))))</span>
<span class="c1">;; =&gt; ((6 1 3) (-5 -2))</span>
</pre></div>
<h4>Delayed evaluation</h4>
<p>(delay <em>expression</em>)  lazy library syntax
<em>Semantics:</em> The delay construct is used together with the procedure
<code>force</code> to implement <em>lazy evaluation</em> or <em>call by need</em>.
<code>(delay expression)</code> returns an object called a <em>promise</em> which at some
point in the future can be asked (by the force procedure) to evaluate
expression, and deliver the resulting value.</p>
<p>The effect of expression returning multiple values is unspecified.</p>
<p>(delay-force <em>expression</em>)  lazy library syntax
<em>Semantics:</em> The expression (delay-force <em>expression</em>) is conceptually
similar to (delay (force <em>expression</em>)), with the difference that
forcing the result of delay-force will in effect result in a tail call
to (force <em>expression</em>), while forcing the result of (delay (force
<em>expression</em>)) might not. Thus iterative lazy algorithms that might
result in a long series of chains of delay and force can be rewritten
using delay-force to prevent consuming unbounded space during
evaluation.</p>
<p>(force <em>promise</em>)  lazy library procedure
The force procedure forces the value of a <em>promise</em> created by <code>delay</code>,
<code>delay-force</code>, or <code>make-promise</code>. If no value has been computed for the
promise, then a value is computed and returned. The value of the promise
must be cached (or “memoized”) so that if it is forced a second time,
the previously computed value is returned. Consequently, a delayed
expression is evaluated using the parameter values and exception handler
of the call to force which first requested its value. If <code>promise</code> is
not a promise, it may be returned unchanged.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">force </span><span class="p">(</span><span class="k">delay </span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span> <span class="c1">;; =&gt; 3</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">p</span> <span class="p">(</span><span class="k">delay </span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">force </span><span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">force </span><span class="nv">p</span><span class="p">)))</span>
<span class="c1">;; =&gt; (3 3)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">integers</span>
  <span class="p">(</span><span class="k">letrec </span><span class="p">((</span><span class="nf">next</span>
            <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
              <span class="p">(</span><span class="k">delay </span><span class="p">(</span><span class="nb">cons </span><span class="nv">n</span> <span class="p">(</span><span class="nf">next</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))))))</span>
    <span class="p">(</span><span class="nf">next</span> <span class="mi">0</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">head</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">stream</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">force </span><span class="nv">stream</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">tail</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">stream</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">force </span><span class="nv">stream</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">head</span> <span class="p">(</span><span class="nf">tail</span> <span class="p">(</span><span class="nf">tail</span> <span class="nv">integers</span><span class="p">)))</span>
<span class="c1">;; =&gt; 2</span>
</pre></div>
<p>The following example is a mechanical transformation of a lazy
stream-filtering algorithm into Scheme. Each call to a constructor is
wrapped in delay, and each argument passed to a deconstructor is wrapped
in force. The use of (delay-force ...) instead of (delay (force ...))
around the body of the procedure ensures that an ever-growing sequence
of pending promises does not exhaust available storage, because force
will in effect force such sequences iteratively.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">stream-filter</span> <span class="nv">p?</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">delay-force</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="p">(</span><span class="nb">force </span><span class="nv">s</span><span class="p">))</span>
       <span class="p">(</span><span class="k">delay </span><span class="o">&#39;</span><span class="p">())</span>
       <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">h</span> <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">force </span><span class="nv">s</span><span class="p">)))</span>
             <span class="p">(</span><span class="nf">t</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">force </span><span class="nv">s</span><span class="p">))))</span>
         <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">p?</span> <span class="nv">h</span><span class="p">)</span>
             <span class="p">(</span><span class="k">delay </span><span class="p">(</span><span class="nb">cons </span><span class="nv">h</span> <span class="p">(</span><span class="nf">stream-filter</span> <span class="nv">p?</span> <span class="nv">t</span><span class="p">)))</span>
             <span class="p">(</span><span class="nf">stream-filter</span> <span class="nv">p?</span> <span class="nv">t</span><span class="p">))))))</span>

<span class="p">(</span><span class="nf">head</span> <span class="p">(</span><span class="nf">tail</span> <span class="p">(</span><span class="nf">tail</span> <span class="p">(</span><span class="nf">stream-filter</span> <span class="nv">odd?</span> <span class="nv">integers</span><span class="p">))))</span>
<span class="c1">;; =&gt; 5</span>
</pre></div>
<p>The following examples are not intended to illustrate good programming
style, as delay, force, and delay-force are mainly intended for programs
written in the functional style. However, they do illustrate the
property that only one value is computed for a promise, no matter how
many times it is forced.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">count</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p</span>
  <span class="p">(</span><span class="k">delay </span><span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">count</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">count</span> <span class="mi">1</span><span class="p">))</span>
                <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">count</span> <span class="nv">x</span><span class="p">)</span>
                    <span class="nv">count</span>
                    <span class="p">(</span><span class="nb">force </span><span class="nv">p</span><span class="p">)))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="mi">5</span><span class="p">)</span>
<span class="nv">p</span> <span class="c1">;; =&gt; a promise</span>
<span class="p">(</span><span class="nb">force </span><span class="nv">p</span><span class="p">)</span> <span class="c1">;; =&gt; 6</span>
<span class="nv">p</span> <span class="c1">;; =&gt; a promise, still</span>
<span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">x</span> <span class="mi">10</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">force </span><span class="nv">p</span><span class="p">))</span> <span class="c1">;; =&gt; 6</span>
</pre></div>
<p>Various extensions to this semantics of delay, force and delay-force are
supported in some implementations:</p>
<ul>
<li><p>Calling force on an object that is not a promise may simply return
the object.</p>
</li>
<li><p>It may be the case that there is no means by which a promise can be
operationally distinguished from its forced value. That is,
expressions like the following may evaluate to either <code>#t</code> or to #f,
depending on the implementation:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">eqv? </span><span class="p">(</span><span class="k">delay </span><span class="mi">1</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">pair? </span><span class="p">(</span><span class="k">delay </span><span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span> <span class="c1">;; =&gt; unspecified</span>
</pre></div>
</li>
<li><p>Implementations may implement “implicit forcing,” where the value of
a promise is forced by procedures that operate only on arguments of
a certain type, like cdr and *. However, procedures that operate
uniformly on their arguments, like list, must not force them.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="k">delay </span><span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="mi">7</span><span class="p">))</span> <span class="mi">13</span><span class="p">)</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nf">car</span>
 <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="k">delay </span><span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="mi">7</span><span class="p">))</span> <span class="mi">13</span><span class="p">))</span> <span class="c1">;; =&gt; a promise</span>
</pre></div>
</li>
</ul>
<p>(promise? <strong>obj</strong>)  lazy library procedure
The promise? procedure returns <code>#t</code> if its argument is a promise, and #f
otherwise. Note that promises are not necessarily disjoint from other
Scheme types such as procedures.</p>
<p>(make-promise <strong>obj</strong>)  lazy library procedure
The make-promise procedure returns a promise which, when forced, will
return <code>obj</code>. It is similar to delay, but does not delay its argument:
it is a procedure rather than syntax. If <code>obj</code> is already a promise, it
is returned.</p>
<h4>Dynamic bindings</h4>
<p>The <em>dynamic extent</em> of a procedure call is the time between when it is
initiated and when it returns. In Scheme, call-with-current-continuation
(section <a href="#continuations">[continuations]</a>) allows reentering a
dynamic extent after its procedure call has returned. Thus, the dynamic
extent of a call might not be a single, continuous time period.</p>
<p>This sections introduces <em>parameter objects</em>, which can be bound to new
values for the duration of a dynamic extent. The set of all parameter
bindings at a given time is called the <em>dynamic environment</em>.</p>
<p>(make-parameter <em>init</em>)  procedure
(make-parameter <em>init converter</em>)  procedure
Returns a newly allocated parameter object, which is a procedure that
accepts zero arguments and returns the value associated with the
parameter object. Initially, this value is the value of (<code>converter</code>
<code>init</code>), or of <code>init</code> if the conversion procedure <code>converter</code> is not
specified. The associated value can be temporarily changed using
parameterize, which is described below.</p>
<p>The effect of passing arguments to a parameter object is
implementation-dependent.</p>
<p>(parameterize ((param<sub>1</sub> value<sub>1</sub>) … )  syntax
<code>)</code></p>
<p><em>Syntax:</em> Both param<sub>1</sub> and value<sub>1</sub> are expressions.</p>
<p>It is an error if the value of any param expression is not a parameter
object.</p>
<p><em>Semantics:</em> A parameterize expression is used to change the values
returned by specified parameter objects during the evaluation of the
body.</p>
<p>The param and value expressions are evaluated in an unspecified order.
The body is evaluated in a dynamic environment in which calls to the
parameters return the results of passing the corresponding values to the
conversion procedure specified when the parameters were created. Then
the previous values of the parameters are restored without passing them
to the conversion procedure. The results of the last expression in the
body are returned as the results of the entire parameterize expression.</p>
<p><em>Note:</em> If the conversion procedure is not idempotent, the results of
(parameterize ((x (x))) ...), which appears to bind the parameter <code>x</code> to
its current value, might not be what the user expects.</p>
<p>If an implementation supports multiple threads of execution, then
parameterize must not change the associated values of any parameters in
any thread other than the current thread and threads created inside
body.</p>
<p>Parameter objects can be used to specify configurable settings for a
computation without the need to pass the value to every procedure in the
call chain explicitly.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">radix</span>
  <span class="p">(</span><span class="nf">make-parameter</span>
   <span class="mi">10</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nf">exact-integer?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;= </span><span class="mi">2</span> <span class="nv">x</span> <span class="mi">16</span><span class="p">))</span>
         <span class="nv">x</span>
         <span class="p">(</span><span class="nf">error</span> <span class="s">&quot;invalid radix&quot;</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">f</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">number-&gt;string </span><span class="nv">n</span> <span class="p">(</span><span class="nf">radix</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">f</span> <span class="mi">12</span><span class="p">)</span> <span class="c1">;; =&gt; &quot;12&quot;</span>
<span class="p">(</span><span class="nf">parameterize</span> <span class="p">((</span><span class="nf">radix</span> <span class="mi">2</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">f</span> <span class="mi">12</span><span class="p">))</span> <span class="c1">;; =&gt; &quot;1100&quot;</span>
<span class="p">(</span><span class="nf">f</span> <span class="mi">12</span><span class="p">)</span> <span class="c1">;; =&gt; &quot;12&quot;</span>

<span class="p">(</span><span class="nf">radix</span> <span class="mi">16</span><span class="p">)</span> <span class="c1">;; =&gt; unspecified</span>

<span class="p">(</span><span class="nf">parameterize</span> <span class="p">((</span><span class="nf">radix</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">f</span> <span class="mi">12</span><span class="p">))</span> <span class="c1">;; =&gt; error</span>
</pre></div>
<h4>Exception handling</h4>
<p>(guard (variable  syntax
<code>cond clause_2 ...) )</code>
<em>Syntax:</em> Each cond clause is as in the specification of cond.</p>
<p><em>Semantics:</em> The body is evaluated with an exception handler that binds
the raised object (see <code>raise</code> in
section <a href="#exceptionsection">[exceptionsection]</a>) to variable and,
within the scope of that binding, evaluates the clauses as if they were
the clauses of a cond expression. That implicit cond expression is
evaluated with the continuation and dynamic environment of the guard
expression. If every cond clause’s test evaluates to <code>#f</code> and there is no
else clause, then raise-continuable is invoked on the raised object
within the dynamic environment of the original call to raise or
raise-continuable, except that the current exception handler is that of
the guard expression.</p>
<p>See section <a href="#exceptionsection">[exceptionsection]</a> for a more
complete discussion of exceptions.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">guard</span> <span class="p">(</span><span class="nf">condition</span>
        <span class="p">((</span><span class="nb">assq </span><span class="ss">&#39;a</span> <span class="nv">condition</span><span class="p">)</span> <span class="k">=&gt; </span><span class="nv">cdr</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">assq </span><span class="ss">&#39;b</span> <span class="nv">condition</span><span class="p">)))</span>
       <span class="p">(</span><span class="nf">raise</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;a</span> <span class="mi">42</span><span class="p">))))</span>
<span class="c1">;; =&gt; 42</span>

<span class="p">(</span><span class="nf">guard</span> <span class="p">(</span><span class="nf">condition</span>
        <span class="p">((</span><span class="nb">assq </span><span class="ss">&#39;a</span> <span class="nv">condition</span><span class="p">)</span> <span class="k">=&gt; </span><span class="nv">cdr</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">assq </span><span class="ss">&#39;b</span> <span class="nv">condition</span><span class="p">)))</span>
       <span class="p">(</span><span class="nf">raise</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;b</span> <span class="mi">23</span><span class="p">))))</span>
<span class="c1">;; =&gt; (b . 23)</span>
</pre></div>
<h4>Quasiquotation</h4>
<p>(quasiquote <em>qq template</em>)  syntax
<code>qq template  syntax
unquote  auxiliary syntax
`' `  auxiliary syntax
unquote-splicing  auxiliary syntax
`'</code>'<code>auxiliary syntax
“Quasiquote” expressions are useful for constructing a list or vector
structure when some but not all of the desired structure is known in
advance. If no commas appear within the qq template, the result of
evaluating ``qq template is equivalent to the result of evaluating</code>’<code>qq template. If a comma appears within the qq template, however, the
expression following the comma is evaluated (“unquoted”) and its result
is inserted into the structure instead of the comma and the expression.
If a comma appears followed without intervening whitespace by a
commercial at-sign (</code>'`), then it is an error if the following
expression does not evaluate to a list; the opening and closing
parentheses of the list are then “stripped away” and the elements of the
list are inserted in place of the comma at-sign expression sequence. A
comma at-sign normally appears only within a list or vector qq template.</p>
<p><em>Note:</em> In order to unquote an identifier beginning with @, it is
necessary to use either an explicit unquote or to put whitespace after
the comma, to avoid colliding with the comma at-sign sequence.</p>
<div class="highlight"><pre><span></span><span class="o">`</span><span class="p">(</span><span class="nb">list </span><span class="o">,</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">;; =&gt; (list 3 4)</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">name</span> <span class="ss">&#39;a</span><span class="p">))</span> <span class="o">`</span><span class="p">(</span><span class="nb">list </span><span class="o">,</span><span class="nv">name</span> <span class="ss">&#39;,name</span><span class="p">))</span>
<span class="c1">;; =&gt; (list a (quote a))</span>
<span class="o">`</span><span class="p">(</span><span class="nf">a</span> <span class="o">,</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="o">,@</span><span class="p">(</span><span class="nb">map </span><span class="nv">abs</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span> <span class="mi">-5</span> <span class="mi">6</span><span class="p">))</span> <span class="nv">b</span><span class="p">)</span>
<span class="c1">;; =&gt; (a 3 4 5 6 b)</span>
<span class="o">`</span><span class="p">((</span><span class="nf">foo</span> <span class="o">,</span><span class="p">(</span><span class="nb">- </span><span class="mi">10</span> <span class="mi">3</span><span class="p">))</span> <span class="o">,@</span><span class="p">(</span><span class="nb">cdr </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span><span class="p">))</span> <span class="o">.</span> <span class="o">,</span><span class="p">(</span><span class="nb">car </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">cons</span><span class="p">)))</span>
<span class="c1">;; =&gt; ((foo 7) . cons)</span>
<span class="o">`#</span><span class="p">(</span><span class="mi">10</span> <span class="mi">5</span> <span class="o">,</span><span class="p">(</span><span class="nb">sqrt </span><span class="mi">4</span><span class="p">)</span> <span class="o">,@</span><span class="p">(</span><span class="nb">map </span><span class="nv">sqrt</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">16</span> <span class="mi">9</span><span class="p">))</span> <span class="mi">8</span><span class="p">)</span>
<span class="c1">;; =&gt; #(10 5 2 4 3 8)</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">foo</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">foo</span> <span class="nv">bar</span><span class="p">))</span> <span class="p">(</span><span class="nf">@baz</span> <span class="ss">&#39;baz</span><span class="p">))</span>
  <span class="o">`</span><span class="p">(</span><span class="nb">list </span><span class="o">,@</span><span class="nv">foo</span> <span class="o">,</span> <span class="nv">@baz</span><span class="p">))</span>
<span class="c1">;; =&gt; (list foo bar baz)</span>
</pre></div>
<p>Quasiquote expressions can be nested. Substitutions are made only for
unquoted components appearing at the same nesting level as the outermost
quasiquote. The nesting level increases by one inside each successive
quasiquotation, and decreases by one inside each unquotation.</p>
<div class="highlight"><pre><span></span><span class="o">`</span><span class="p">(</span><span class="nf">a</span> <span class="o">`</span><span class="p">(</span><span class="nf">b</span> <span class="o">,</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="o">,</span><span class="p">(</span><span class="nf">foo</span> <span class="o">,</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">3</span><span class="p">)</span> <span class="nv">d</span><span class="p">)</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">f</span><span class="p">)</span>
<span class="c1">;; =&gt; (a `(b ,(+ 1 2) ,(foo 4 d) e) f)</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">name1</span> <span class="ss">&#39;x</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">name2</span> <span class="ss">&#39;y</span><span class="p">))</span>
  <span class="o">`</span><span class="p">(</span><span class="nf">a</span> <span class="o">`</span><span class="p">(</span><span class="nf">b</span> <span class="o">,,</span><span class="nv">name1</span> <span class="o">,</span><span class="ss">&#39;,name2</span> <span class="nv">d</span><span class="p">)</span> <span class="nv">e</span><span class="p">))</span>
<span class="c1">;; =&gt; (a `(b ,x ,&#39;y d) e)</span>
</pre></div>
<p>A quasiquote expression may return either newly allocated, mutable
objects or literal structure for any structure that is constructed at
run time during the evaluation of the expression. Portions that do not
need to be rebuilt are always literal. Thus,</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">a</span> <span class="mi">3</span><span class="p">))</span> <span class="o">`</span><span class="p">((</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="o">,</span><span class="nv">a</span> <span class="o">,</span><span class="mi">4</span> <span class="o">,</span><span class="ss">&#39;five</span> <span class="mi">6</span><span class="p">))</span>
</pre></div>
<p>may be treated as equivalent to either of the following expressions:</p>
<div class="highlight"><pre><span></span><span class="o">`</span><span class="p">((</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span> <span class="nv">five</span> <span class="mi">6</span><span class="p">)</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">a</span> <span class="mi">3</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">cons </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">cons </span><span class="nv">a</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">4</span> <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;five</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">6</span><span class="p">))))))</span>
</pre></div>
<p>However, it is not equivalent to this expression:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">a</span> <span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">a</span> <span class="mi">4</span> <span class="ss">&#39;five</span> <span class="mi">6</span><span class="p">))</span>
</pre></div>
<p>The two notations <code>`qq template and</code>(quasiquote qq template)<code>are
identical in all respects. ,expression is identical to (unquote
expression), and ,@expression is identical to (unquote-splicing
expression). The</code>write` procedure may output either format.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">quasiquote </span><span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="k">unquote </span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="mi">4</span><span class="p">))</span>
<span class="c1">;; =&gt; (list 3 4)</span>
<span class="o">&#39;</span><span class="p">(</span><span class="k">quasiquote </span><span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="k">unquote </span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="mi">4</span><span class="p">))</span>
<span class="c1">;; =&gt; `(list ,(+ 1 2) 4)</span>
<span class="c1">;; i.e., (quasiquote (list (unquote (+ 1 2)) 4))</span>
</pre></div>
<p>It is an error if any of the identifiers quasiquote, unquote, or
unquote-splicing appear in positions within a qq template otherwise than
as described above.</p>
<h4>Case-lambda</h4>
<p>(case-lambda <em>clause … </em>)  case-lambda library syntax
<em>Syntax:</em> Each clause is of the form (formals body), where formals and
body have the same syntax as in a lambda expression.</p>
<p><em>Semantics:</em> A case-lambda expression evaluates to a procedure that
accepts a variable number of arguments and is lexically scoped in the
same manner as a procedure resulting from a lambda expression. When the
procedure is called, the first clause for which the arguments agree with
formals is selected, where agreement is specified as for the formals of
a lambda expression. The variables of formals are bound to fresh
locations, the values of the arguments are stored in those locations,
the body is evaluated in the extended environment, and the results of
body are returned as the results of the procedure call.</p>
<p>It is an error for the arguments not to agree with the formals of any
clause.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">range</span>
  <span class="p">(</span><span class="nf">case-lambda</span>
   <span class="p">((</span><span class="nf">e</span><span class="p">)</span> <span class="p">(</span><span class="nf">range</span> <span class="mi">0</span> <span class="nv">e</span><span class="p">))</span>
   <span class="p">((</span><span class="nf">b</span> <span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">r</span> <span class="o">&#39;</span><span class="p">()</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">e</span> <span class="nv">r</span><span class="p">))</span>
               <span class="p">(</span><span class="nf">e</span> <span class="p">(</span><span class="nb">- </span><span class="nv">e</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">e</span> <span class="mi">1</span><span class="p">)))</span>
              <span class="p">((</span><span class="nb">&lt; </span><span class="nv">e</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">r</span><span class="p">)))))</span>

<span class="p">(</span><span class="nf">range</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">;; =&gt; (0 1 2)</span>
<span class="p">(</span><span class="nf">range</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">;; =&gt; (3 4)</span>
</pre></div>
<h3>Macros</h3>
<p>Scheme programs can define and use new derived expression types, called
<em>macros</em>. Program-defined expression types have the syntax</p>

<div><pre>(&lt;keyword&gt; &lt;datum&gt; ...)</pre></div>
<p>where keyword is an identifier that uniquely determines the expression
type. This identifier is called the <em>syntactic keyword</em>, or simply
<code>keyword</code>, of the macro. The number of the datums, and their syntax,
depends on the expression type.</p>
<p>Each instance of a macro is called a <em>use</em> of the macro. The set of
rules that specifies how a use of a macro is transcribed into a more
primitive expression is called the <code>transformer</code> of the macro.</p>
<p>The macro definition facility consists of two parts:</p>
<ul>
<li><p>A set of expressions used to establish that certain identifiers are
macro keywords, associate them with macro transformers, and control
the scope within which a macro is defined, and</p>
</li>
<li><p>a pattern language for specifying macro transformers.</p>
</li>
</ul>
<p>The syntactic keyword of a macro can shadow variable bindings, and local
variable bindings can shadow syntactic bindings. Two mechanisms are
provided to prevent unintended conflicts:</p>
<ul>
<li><p>If a macro transformer inserts a binding for an identifier (variable
or keyword), the identifier will in effect be renamed throughout its
scope to avoid conflicts with other identifiers. Note that a global
variable definition may or may not introduce a binding; see
section <a href="#defines">[defines]</a>.</p>
</li>
<li><p>If a macro transformer inserts a free reference to an identifier,
the reference refers to the binding that was visible where the
transformer was specified, regardless of any local bindings that
surround the use of the macro.</p>
</li>
</ul>
<p>In consequence, all macros defined using the pattern language are
“hygienic” and “referentially transparent” and thus preserve Scheme’s
lexical scoping. <span class="citation"
cites="Kohlbecker86 hygienic Bawden88 macrosthatwork syntacticabstraction"></span></p>
<p>Implementations may provide macro facilities of other types.</p>
<h4>Binding constructs for syntactic keywords</h4>
<p>The let-syntax and letrec-syntax binding constructs are analogous to let
and letrec, but they bind syntactic keywords to macro transformers
instead of binding variables to locations that contain values. Syntactic
keywords can also be bound globally or locally with define-syntax; see
section <a href="#define-syntax">[define-syntax]</a>.</p>
<p>(let-syntax <em>bindings body</em>)  syntax
<em>Syntax:</em> Bindings has the form</p>

<div><pre>((&lt;keyword&gt; &lt;transformer-spec&gt;) ...)</pre></div>
<p>Each keyword is an identifier, each transformer spec is an instance of
syntax-rules, and body is a sequence of zero or more definitions
followed by one or more expressions. It is an error for a keyword to
appear more than once in the list of keywords being bound.</p>
<p><em>Semantics:</em> The body is expanded in the syntactic environment obtained
by extending the syntactic environment of the let-syntax expression with
macros whose keywords are the keywords, bound to the specified
transformers. Each binding of a keyword has body as its region.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let-syntax </span><span class="p">((</span><span class="nf">given-that</span> <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
                           <span class="p">((</span><span class="nf">given-that</span> <span class="nv">test</span> <span class="nv">stmt1</span> <span class="nv">stmt2</span> <span class="o">...</span><span class="p">)</span>
                            <span class="p">(</span><span class="k">if </span><span class="nv">test</span>
                                <span class="p">(</span><span class="k">begin </span><span class="nv">stmt1</span>
                                       <span class="nv">stmt2</span> <span class="o">...</span><span class="p">))))))</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="k">if </span><span class="no">#t</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">given-that</span> <span class="k">if </span><span class="p">(</span><span class="k">set! if </span><span class="ss">&#39;now</span><span class="p">))</span>
    <span class="nv">if</span><span class="p">))</span> <span class="c1">;; =&gt; now</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="ss">&#39;outer</span><span class="p">))</span>
  <span class="p">(</span><span class="k">let-syntax </span><span class="p">((</span><span class="nf">m</span> <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span> <span class="p">((</span><span class="nf">m</span><span class="p">)</span> <span class="nv">x</span><span class="p">))))</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="ss">&#39;inner</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">m</span><span class="p">))))</span> <span class="c1">;; =&gt; outer</span>
</pre></div>
<p>(letrec-syntax <em>bindings body</em>)  syntax
<em>Syntax:</em> Same as for let-syntax.</p>
<p><em>Semantics:</em> The body is expanded in the syntactic environment obtained
by extending the syntactic environment of the letrec-syntax expression
with macros whose keywords are the keywords, bound to the specified
transformers. Each binding of a keyword has the transformer specs as
well as the body within its region, so the transformers can transcribe
expressions into uses of the macros introduced by the letrec-syntax
expression.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">letrec-syntax</span>
    <span class="p">((</span><span class="nf">my-or</span> <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
              <span class="p">((</span><span class="nf">my-or</span><span class="p">)</span> <span class="no">#f</span><span class="p">)</span>
              <span class="p">((</span><span class="nf">my-or</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">e</span><span class="p">)</span>
              <span class="p">((</span><span class="nf">my-or</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="o">...</span><span class="p">)</span>
               <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">temp</span> <span class="nv">e1</span><span class="p">))</span>
                 <span class="p">(</span><span class="k">if </span><span class="nv">temp</span>
                     <span class="nv">temp</span>
                     <span class="p">(</span><span class="nf">my-or</span> <span class="nv">e2</span> <span class="o">...</span><span class="p">)))))))</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="no">#f</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">y</span> <span class="mi">7</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">temp</span> <span class="mi">8</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let </span><span class="nv">odd?</span><span class="p">)</span>
        <span class="p">(</span><span class="k">if </span><span class="nv">even?</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">my-or</span> <span class="nv">x</span>
           <span class="p">(</span><span class="k">let </span><span class="nv">temp</span><span class="p">)</span>
           <span class="p">(</span><span class="k">if </span><span class="nv">y</span><span class="p">)</span>
           <span class="nv">y</span><span class="p">)))</span> <span class="c1">;; =&gt; 7</span>
</pre></div>
<h4>Pattern language</h4>
<p>A transformer spec has one of the following forms:</p>
<p>(syntax-rules (pattern literal … )  syntax
<code>...)</code> (syntax-rules ellipsis (pattern literal … )  syntax
<code>...)</code>
_  auxiliary syntax
…   auxiliary syntax
<em>Syntax:</em> It is an error if any of the pattern literals, or the ellipsis
in the second form, is not an identifier. It is also an error if
syntax rule is not of the form</p>

<div><pre>(&lt;pattern&gt; &lt;template&gt;)</pre></div>
<p>The pattern in a syntax rule is a list pattern whose first element is an
identifier.</p>
<p>A pattern is either an identifier, a constant, or one of the following</p>

<div><pre>(&lt;pattern&gt; ...)
(&lt;pattern&gt; &lt;pattern&gt; ... . &lt;pattern&gt;)
(&lt;pattern&gt; ... &lt;pattern&gt; ... &lt;pattern&gt; ...)
(&lt;pattern&gt; ... &lt;pattern&gt; ... &lt;pattern&gt; ...
  . &lt;pattern&gt;)
#(&lt;pattern&gt; ...)
#(&lt;pattern&gt; ... &lt;pattern&gt; ... &lt;pattern&gt; ...)</pre></div>
<p>and a template is either an identifier, a constant, or one of the
following</p>

<div><pre>(&lt;element&gt; ...)
(&lt;element&gt; &lt;element&gt; ... . &lt;template&gt;)
(... &lt;template&gt;)
#(&lt;element&gt; ...)</pre></div>
<p>where an element is a template optionally followed by an ellipsis. An
ellipsis is the identifier specified in the second form of syntax-rules,
or the default identifier ... (three consecutive periods) otherwise.</p>
<p><em>Semantics:</em> An instance of syntax-rules produces a new macro
transformer by specifying a sequence of hygienic rewrite rules. A use of
a macro whose keyword is associated with a transformer specified by
syntax-rules is matched against the patterns contained in the
syntax rules, beginning with the leftmost syntax rule. When a match is
found, the macro use is transcribed hygienically according to the
template.</p>
<p>An identifier appearing within a pattern can be an underscore (_), a
literal identifier listed in the list of pattern literals, or the
ellipsis. All other identifiers appearing within a pattern are <em>pattern
variables</em>.</p>
<p>The keyword at the beginning of the pattern in a syntax rule is not
involved in the matching and is considered neither a pattern variable
nor a literal identifier.</p>
<p>Pattern variables match arbitrary input elements and are used to refer
to elements of the input in the template. It is an error for the same
pattern variable to appear more than once in a pattern.</p>
<p>Underscores also match arbitrary input elements but are not pattern
variables and so cannot be used to refer to those elements. If an
underscore appears in the pattern literals list, then that takes
precedence and underscores in the pattern match as literals. Multiple
underscores can appear in a pattern.</p>
<p>Identifiers that appear in (pattern literal … ) are interpreted as
literal identifiers to be matched against corresponding elements of the
input. An element in the input matches a literal identifier if and only
if it is an identifier and either both its occurrence in the macro
expression and its occurrence in the macro definition have the same
lexical binding, or the two identifiers are the same and both have no
lexical binding.</p>
<p>A subpattern followed by ellipsis can match zero or more elements of the
input, unless ellipsis appears in the pattern literals, in which case it
is matched as a literal.</p>
<p>More formally, an input expression <em>E</em> matches a pattern <em>P</em> if and only
if:</p>
<ul>
<li><p><em>P</em> is an underscore (_).</p>
</li>
<li><p><em>P</em> is a non-literal identifier; or</p>
</li>
<li><p><em>P</em> is a literal identifier and <em>E</em> is an identifier with the same
binding; or</p>
</li>
<li><p><em>P</em> is a list (<em>P</em><sub>1</sub> … <em>P</em><sub>*n*</sub>) and <em>E</em> is a
list of <em>n</em> elements that match <em>P</em><sub>1</sub> through
<em>P</em><sub>*n*</sub>, respectively; or</p>
</li>
<li><p><em>P</em> is an improper list (<em>P</em><sub>1</sub> <em>P</em><sub>2</sub> …
<em>P</em><sub>*n*</sub> . <em>P</em><sub>*n* + 1</sub>) and <em>E</em> is a list or
improper list of <em>n</em> or more elements that match <em>P</em><sub>1</sub>
through <em>P</em><sub>*n*</sub>, respectively, and whose <em>n</em>th tail
matches <em>P</em><sub>*n* + 1</sub>; or</p>
</li>
<li><p><em>P</em> is of the form (<em>P</em><sub>1</sub> … <em>P</em><sub>*k*</sub>
<em>P</em><sub>*e*</sub> ellipsis <em>P</em><sub>*m* + 1</sub> … 
<em>P</em><sub>*n*</sub>) where <em>E</em> is a proper list of <em>n</em> elements, the
first <em>k</em> of which match <em>P</em><sub>1</sub> through <em>P</em><sub>*k*</sub>,
respectively, whose next <em>m</em> − <em>k</em> elements each match
<em>P</em><sub>*e*</sub>, whose remaining <em>n</em> − <em>m</em> elements match
<em>P</em><sub>*m* + 1</sub> through <em>P</em><sub>*n*</sub>; or</p>
</li>
<li><p><em>P</em> is of the form (<em>P</em><sub>1</sub> … <em>P</em><sub>*k*</sub>
<em>P</em><sub>*e*</sub> ellipsis <em>P</em><sub>*m* + 1</sub> … 
<em>P</em><sub>*n*</sub> . <em>P</em><sub>*x*</sub>) where <em>E</em> is a list or
improper list of <em>n</em> elements, the first <em>k</em> of which match
<em>P</em><sub>1</sub> through <em>P</em><sub>*k*</sub>, whose next <em>m</em> − <em>k</em>
elements each match <em>P</em><sub>*e*</sub>, whose remaining <em>n</em> − <em>m</em>
elements match <em>P</em><sub>*m* + 1</sub> through <em>P</em><sub>*n*</sub>, and
whose <em>n</em>th and final cdr matches <em>P</em><sub>*x*</sub>; or</p>
</li>
<li><p><em>P</em> is a vector of the form #(<em>P</em><sub>1</sub> … <em>P</em><sub>*n*</sub>)
and <em>E</em> is a vector of <em>n</em> elements that match <em>P</em><sub>1</sub>
through <em>P</em><sub>*n*</sub>; or</p>
</li>
<li><p><em>P</em> is of the form #(<em>P</em><sub>1</sub> … <em>P</em><sub>*k*</sub>
<em>P</em><sub>*e*</sub> ellipsis <em>P</em><sub>*m* + 1</sub>
… <em>P</em><sub>*n*</sub>) where <em>E</em> is a vector of <em>n</em> elements the first
<em>k</em> of which match <em>P</em><sub>1</sub> through <em>P</em><sub>*k*</sub>, whose
next <em>m</em> − <em>k</em> elements each match <em>P</em><sub>*e*</sub>, and whose
remaining <em>n</em> − <em>m</em> elements match <em>P</em><sub>*m* + 1</sub> through
<em>P</em><sub>*n*</sub>; or</p>
</li>
<li><p><em>P</em> is a constant and <em>E</em> is equal to <em>P</em> in the sense of the equal?
procedure.</p>
</li>
</ul>
<p>It is an error to use a macro keyword, within the scope of its binding,
in an expression that does not match any of the patterns.</p>
<p>When a macro use is transcribed according to the template of the
matching syntax rule, pattern variables that occur in the template are
replaced by the elements they match in the input. Pattern variables that
occur in subpatterns followed by one or more instances of the identifier
ellipsis are allowed only in subtemplates that are followed by as many
instances of ellipsis. They are replaced in the output by all of the
elements they match in the input, distributed as indicated. It is an
error if the output cannot be built up as specified.</p>
<p>Identifiers that appear in the template but are not pattern variables or
the identifier ellipsis are inserted into the output as literal
identifiers. If a literal identifier is inserted as a free identifier
then it refers to the binding of that identifier within whose scope the
instance of syntax-rules appears. If a literal identifier is inserted as
a bound identifier then it is in effect renamed to prevent inadvertent
captures of free identifiers.</p>
<p>A template of the form (ellipsis template) is identical to template,
except that ellipses within the template have no special meaning. That
is, any ellipses contained within template are treated as ordinary
identifiers. In particular, the template (ellipsis ellipsis) produces a
single ellipsis. This allows syntactic abstractions to expand into code
containing ellipses.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define-syntax </span><span class="nv">be-like-begin</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="nf">be-like-begin</span> <span class="nv">name</span><span class="p">)</span>
     <span class="p">(</span><span class="k">define-syntax </span><span class="nv">name</span>
       <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
         <span class="p">((</span><span class="nf">name</span> <span class="nv">expr</span> <span class="p">(</span><span class="o">...</span> <span class="o">...</span><span class="p">))</span>
          <span class="p">(</span><span class="k">begin </span><span class="nv">expr</span> <span class="p">(</span><span class="o">...</span> <span class="o">...</span><span class="p">))))))))</span>

<span class="p">(</span><span class="nf">be-like-begin</span> <span class="nv">sequence</span><span class="p">)</span>
<span class="p">(</span><span class="nf">sequence</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">;; =&gt; 4</span>
</pre></div>
<p>As an example, if <code>let</code> and <code>cond</code> are defined as in
section <a href="#derivedsection">[derivedsection]</a> then they are hygienic (as
required) and the following is not an error.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="k">=&gt; </span><span class="no">#f</span><span class="p">))</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">(</span><span class="no">#t</span> <span class="k">=&gt; </span><span class="ss">&#39;ok</span><span class="p">)))</span> <span class="c1">;; =&gt; ok</span>
</pre></div>
<p>The macro transformer for cond recognizes =&gt; as a local variable, and
hence an expression, and not as the base identifier =&gt;, which the macro
transformer treats as a syntactic keyword. Thus the example expands into</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="k">=&gt; </span><span class="no">#f</span><span class="p">))</span>
  <span class="p">(</span><span class="k">if </span><span class="no">#t</span> <span class="p">(</span><span class="k">begin =&gt; </span><span class="ss">&#39;ok</span><span class="p">)))</span>
</pre></div>
<p>instead of</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="k">=&gt; </span><span class="no">#f</span><span class="p">))</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">temp</span> <span class="no">#t</span><span class="p">))</span>
    <span class="p">(</span><span class="k">if </span><span class="nv">temp</span> <span class="p">(</span><span class="ss">&#39;ok</span> <span class="nv">temp</span><span class="p">))))</span>
</pre></div>
<p>which would result in an invalid procedure call.</p>
<h4>Signaling errors in macro transformers</h4>
<p>(syntax-error message args … )  syntax
syntax-error behaves similarly to error
(<a href="#exceptionsection">[exceptionsection]</a>) except that implementations
with an expansion pass separate from evaluation should signal an error
as soon as syntax-error is expanded. This can be used as a syntax-rules
template for a pattern that is an invalid use of the macro, which can
provide more descriptive error messages. message is a string literal,
and args arbitrary expressions providing additional information.
Applications cannot count on being able to catch syntax errors with
exception handlers or guards.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define-syntax </span><span class="nv">simple-let</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="nf">_</span> <span class="p">(</span><span class="nf">head</span> <span class="o">...</span> <span class="p">((</span><span class="nf">x</span> <span class="o">.</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">val</span><span class="p">)</span> <span class="o">.</span> <span class="nv">tail</span><span class="p">)</span>
      <span class="nv">body1</span> <span class="nv">body2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">syntax-error</span>
      <span class="s">&quot;expected an identifier but got&quot;</span>
      <span class="p">(</span><span class="nf">x</span> <span class="o">.</span> <span class="nv">y</span><span class="p">)))</span>
    <span class="p">((</span><span class="nf">_</span> <span class="p">((</span><span class="nf">name</span> <span class="nv">val</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span> <span class="nv">body1</span> <span class="nv">body2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">name</span> <span class="o">...</span><span class="p">)</span> <span class="nv">body1</span> <span class="nv">body2</span> <span class="o">...</span><span class="p">)</span>
      <span class="nv">val</span> <span class="o">...</span><span class="p">))))</span>
</pre></div>
<h2>Program structure</h2>
<h3>Programs</h3>
<p>A Scheme program consists of one or more import declarations followed by
a sequence of expressions and definitions. Import declarations specify
the libraries on which a program or library depends; a subset of the
identifiers exported by the libraries are made available to the program.
Expressions are described in
chapter <a href="#expressionchapter">[expressionchapter]</a>. Definitions are
either variable definitions, syntax definitions, or record-type
definitions, all of which are explained in this chapter. They are valid
in some, but not all, contexts where expressions are allowed,
specifically at the outermost level of a program and at the beginning of
a body.</p>
<p>At the outermost level of a program,
<code>(begin expression or definition_1 ...)</code> is equivalent to the
sequence of expressions and definitions in the <code>begin</code>. Similarly, in a
body, <code>(begin definition_1 ...)</code> is equivalent to the sequence
definition<sub>1</sub> … . Macros can expand into such begin forms. For
the formal definition, see <a href="#sequencing">[sequencing]</a>.</p>
<p>Import declarations and definitions cause bindings to be created in the
global environment or modify the value of existing global bindings. The
initial environment of a program is empty, so at least one import
declaration is needed to introduce initial bindings.</p>
<p>Expressions occurring at the outermost level of a program do not create
any bindings. They are executed in order when the program is invoked or
loaded, and typically perform some kind of initialization.</p>
<p>Programs and libraries are typically stored in files, although in some
implementations they can be entered interactively into a running Scheme
system. Other paradigms are possible. Implementations which store
libraries in files should document the mapping from the name of a
library to its location in the file system.</p>
<h3>Import declarations</h3>
<p>An import declaration takes the following form:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">import</span> <span class="nv">&lt;import-set&gt;</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
<p>An import declaration provides a way to import identifiers exported by a
library. Each import set names a set of bindings from a library and
possibly specifies local names for the imported bindings. It takes one
of the following forms:</p>
<ul>
<li><p><code>library name</code></p>
</li>
<li><p><code>(only import set identifier ...)</code></p>
</li>
<li><p><code>(except import set identifier ...)</code></p>
</li>
<li><p><code>(prefix import set identifier)</code></p>
</li>
<li><p><code>(rename import set  (identifier_1 identifier_2) ...)</code></p>
</li>
</ul>
<p>In the first form, all of the identifiers in the named library’s export
clauses are imported with the same names (or the exported names if
exported with <code>rename</code>). The additional import set forms modify this set
as follows:</p>
<ul>
<li><p><code>only</code> produces a subset of the given import set including only the
listed identifiers (after any renaming). It is an error if any of
the listed identifiers are not found in the original set.</p>
</li>
<li><p><code>except</code> produces a subset of the given import set, excluding the
listed identifiers (after any renaming). It is an error if any of
the listed identifiers are not found in the original set.</p>
</li>
<li><p><code>rename</code> modifies the given import set, replacing each instance of
identifier<sub>1</sub> with identifier<sub>2</sub>. It is an error
if any of the listed identifier<sub>1</sub>s are not found in the
original set.</p>
</li>
<li><p><code>prefix</code> automatically renames all identifiers in the given
import set, prefixing each with the specified identifier.</p>
</li>
</ul>
<p>In a program or library declaration, it is an error to import the same
identifier more than once with different bindings, or to redefine or
mutate an imported binding with a definition or with set!, or to refer
to an identifier before it is imported. However, a REPL should permit
these actions.</p>
<h3>Variable definitions</h3>
<p>A variable definition binds one or more identifiers and specifies an
initial value for each of them. The simplest kind of variable definition
takes one of the following forms:</p>
<ul>
<li><p><code>(define variable expression)</code></p>
</li>
<li><p><code>(define (variable formals) body)</code></p>
<p>Formals are either a sequence of zero or more variables, or a
sequence of one or more variables followed by a space-delimited
period and another variable (as in a lambda expression). This form
is equivalent to</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">&lt;variable&gt;</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">&lt;formals&gt;</span><span class="p">)</span> <span class="nv">&lt;body&gt;</span><span class="p">))</span>
</pre></div>
</li>
<li><p><code>(define (variable . formal) body)</code></p>
<p>Formal is a single variable. This form is equivalent to</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">&lt;variable&gt;</span>
  <span class="p">(</span><span class="k">lambda </span><span class="nv">&lt;formal&gt;</span> <span class="nv">&lt;body&gt;</span><span class="p">))</span>
</pre></div>
</li>
</ul>
<h4>Top level definitions</h4>
<p>At the outermost level of a program, a definition</p>

<div><pre>(define &lt;variable&gt; &lt;expression&gt;)</pre></div>
<p>has essentially the same effect as the assignment expression</p>

<div><pre>(set! &lt;variable&gt; &lt;expression&gt;)</pre></div>
<p>if variable is bound to a non-syntax value. However, if variable is not
bound, or is a syntactic keyword, then the definition will bind variable
to a new location before performing the assignment, whereas it would be
an error to perform a set! on an unbound variable.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">add3</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">3</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">add3</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">;; =&gt; 6</span>
<span class="p">(</span><span class="k">define </span><span class="nv">first</span> <span class="nv">car</span><span class="p">)</span>
<span class="p">(</span><span class="nf">first</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">;; =&gt; 1</span>
</pre></div>
<h4>Internal definitions</h4>
<p>Definitions can occur at the beginning of a body (that is, the body of a
<code>lambda</code>, <code>let</code>, <code>let*</code>, <code>letrec</code>, <code>letrec*</code>, <code>let-values</code>,
<code>let*-values</code>, <code>let-syntax</code>, <code>letrec-syntax</code>, <code>parameterize</code>, <code>guard</code>,
or <code>case-lambda</code>). Note that such a body might not be apparent until
after expansion of other syntax. Such definitions are known as <em>internal
definitions</em> as opposed to the global definitions described above. The
variables defined by internal definitions are local to the body. That
is, variable is bound rather than assigned, and the region of the
binding is the entire body. For example,</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="mi">5</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="nv">foo</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">bar</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">define </span><span class="nv">bar</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">a</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">foo</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">3</span><span class="p">)))</span> <span class="c1">;; =&gt; 45</span>
</pre></div>
<p>An expanded body containing internal definitions can always be converted
into a completely equivalent letrec* expression. For example, the let
expression in the above example is equivalent to</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="mi">5</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">letrec*</span> <span class="p">((</span><span class="nf">foo</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">bar</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
            <span class="p">(</span><span class="nf">bar</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">a</span><span class="p">))))</span>
    <span class="p">(</span><span class="nf">foo</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">3</span><span class="p">))))</span>
</pre></div>
<p>Just as for the equivalent letrec* expression, it is an error if it is
not possible to evaluate each expression of every internal definition in
a body without assigning or referring to the value of the corresponding
variable or the variable of any of the definitions that follow it in
body.</p>
<p>It is an error to define the same identifier more than once in the same
body.</p>
<p>Wherever an internal definition can occur,
<code>(begin definition_1 ...)</code> is equivalent to the sequence of
definitions that form the body of the <code>begin</code>.</p>
<h4>Multiple-value definitions</h4>
<p>Another kind of definition is provided by define-values, which creates
multiple definitions from a single expression returning multiple values.
It is allowed wherever define is allowed.</p>
<p>(define-values <em>formals expression</em>)  syntax</p>
<p>It is an error if a variable appears more than once in the set of
formals.</p>
<p><em>Semantics:</em> Expression is evaluated, and the formals are bound to the
return values in the same way that the formals in a lambda expression
are matched to the arguments in a procedure call.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">define-values</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">exact-integer-sqrt</span> <span class="mi">17</span><span class="p">))</span>
<span class="p">(</span><span class="nb">list </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="c1">;; =&gt; (4 1)</span>

<span class="p">(</span><span class="k">let </span><span class="p">()</span>
  <span class="p">(</span><span class="nf">define-values</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">values </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="c1">;; =&gt; 3</span>
</pre></div>
<h3>Syntax definitions</h3>
<p>Syntax definitions have this form:</p>
<p><code>(define-syntax keyword transformer spec)</code></p>
<p>Keyword is an identifier, and the transformer spec is an instance of
<code>syntax-rules</code>. Like variable definitions, syntax definitions can appear
at the outermost level or nested within a <code>body</code>.</p>
<p>If the define-syntax occurs at the outermost level, then the global
syntactic environment is extended by binding the keyword to the
specified transformer, but previous expansions of any global binding for
keyword remain unchanged. Otherwise, it is an <em>internal syntax
definition</em>, and is local to the body in which it is defined. Any use of
a syntax keyword before its corresponding definition is an error. In
particular, a use that precedes an inner definition will not apply an
outer definition.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span> <span class="mi">2</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define-syntax </span><span class="nv">swap!</span>
    <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
      <span class="p">((</span><span class="nf">swap!</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
       <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">tmp</span> <span class="nv">a</span><span class="p">))</span>
         <span class="p">(</span><span class="k">set! </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
         <span class="p">(</span><span class="k">set! </span><span class="nv">b</span> <span class="nv">tmp</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">swap!</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">list </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="c1">;; =&gt; (2 1)</span>
</pre></div>
<p>Macros can expand into definitions in any context that permits them.
However, it is an error for a definition to define an identifier whose
binding has to be known in order to determine the meaning of the
definition itself, or of any preceding definition that belongs to the
same group of internal definitions. Similarly, it is an error for an
internal definition to define an identifier whose binding has to be
known in order to determine the boundary between the internal
definitions and the expressions of the body it belongs to. For example,
the following are errors:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define define </span><span class="mi">3</span><span class="p">)</span>

<span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">define begin </span><span class="nv">list</span><span class="p">))</span>

<span class="p">(</span><span class="nf">let-syntax</span>
    <span class="p">((</span><span class="nf">foo</span> <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
            <span class="p">((</span><span class="nf">foo</span> <span class="p">(</span><span class="nf">proc</span> <span class="nv">args</span> <span class="o">...</span><span class="p">)</span> <span class="nv">body</span> <span class="o">...</span><span class="p">)</span>
             <span class="p">(</span><span class="k">define </span><span class="nv">proc</span>
               <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">args</span> <span class="o">...</span><span class="p">)</span>
                 <span class="nv">body</span> <span class="o">...</span><span class="p">))))))</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="mi">3</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">foo</span> <span class="p">(</span><span class="nf">plus</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
    <span class="p">(</span><span class="k">define </span><span class="nv">foo</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">plus</span> <span class="nv">foo</span> <span class="nv">x</span><span class="p">)))</span>
</pre></div>
<h3>Record-type definitions</h3>
<p><em>Record-type definitions</em> are used to introduce new data types, called
<em>record types</em>. Like other definitions, they can appear either at the
outermost level or in a body. The values of a record type are called
<em>records</em> and are aggregations of zero or more <em>fields</em>, each of which
holds a single location. A predicate, a constructor, and field accessors
and mutators are defined for each record type.</p>
<p>(define-record-type name  syntax
)</p>
<p><em>Syntax:</em> name and pred are identifiers. The constructor is of the form</p>

<div><pre>(&lt;constructore-name&gt; &lt;field-name&gt; ...)</pre></div>
<p>and each field is either of the form</p>

<div><pre>(&lt;field-name&gt; &lt;accessor-name&gt;)</pre></div>
<p>or of the form</p>

<div><pre>(&lt;field-name&gt; &lt;accessor-name&gt; &lt;modified-name&gt;)</pre></div>
<p>It is an error for the same identifier to occur more than once as a
field name. It is also an error for the same identifier to occur more
than once as an accessor or mutator name.</p>
<p>The define-record-type construct is generative: each use creates a new
record type that is distinct from all existing types, including Scheme’s
predefined types and other record types — even record types of the same
name or structure.</p>
<p>An instance of define-record-type is equivalent to the following
definitions:</p>
<ul>
<li><p>name is bound to a representation of the record type itself. This
may be a run-time object or a purely syntactic representation. The
representation is not utilized in this report, but it serves as a
means to identify the record type for use by further language
extensions.</p>
</li>
<li><p>constructor name is bound to a procedure that takes as many
arguments as there are field names in the (constructor name … )
subexpression and returns a new record of type name. Fields whose
names are listed with constructor name have the corresponding
argument as their initial value. The initial values of all other
fields are unspecified. It is an error for a field name to appear in
constructor but not as a field name.</p>
</li>
<li><p>pred is bound to a predicate that returns <code>#t</code> when given a value
returned by the procedure bound to constructor name and <code>#f</code> for
everything else.</p>
</li>
<li><p>Each accessor name is bound to a procedure that takes a record of
type name and returns the current value of the corresponding field.
It is an error to pass an accessor a value which is not a record of
the appropriate type.</p>
</li>
<li><p>Each modifier name is bound to a procedure that takes a record of
type name and a value which becomes the new value of the
corresponding field; an unspecified value is returned. It is an
error to pass a modifier a first argument which is not a record of
the appropriate type.</p>
</li>
</ul>
<p>For instance, the following record-type definition</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">define-record-type</span> <span class="nv">&lt;pare&gt;</span>
  <span class="p">(</span><span class="nf">kons</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="nv">pare?</span>
  <span class="p">(</span><span class="nf">x</span> <span class="nv">kar</span> <span class="nv">set-kar!</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">y</span> <span class="nv">kdr</span><span class="p">))</span>
</pre></div>
<p>defines kons to be a constructor, kar and kdr to be accessors, set-kar!
to be a modifier, and pare? to be a predicate for instances of \<pare>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">pare?</span> <span class="p">(</span><span class="nf">kons</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nf">pare?</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nf">kar</span> <span class="p">(</span><span class="nf">kons</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">;; =&gt; 1</span>
<span class="p">(</span><span class="nf">kdr</span> <span class="p">(</span><span class="nf">kons</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">;; =&gt; 2</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">k</span> <span class="p">(</span><span class="nf">kons</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">set-kar!</span> <span class="nv">k</span> <span class="mi">3</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">kar</span> <span class="nv">k</span><span class="p">))</span> <span class="c1">;; =&gt; 3</span>
</pre></div>
<h3>Libraries</h3>
<p>Libraries provide a way to organize Scheme programs into reusable parts
with explicitly defined interfaces to the rest of the program. This
section defines the notation and semantics for libraries.</p>
<h4>Library Syntax</h4>
<p>A library definition takes the following form:</p>

<div><pre>(define-library &lt;library-name&gt;
  &lt;library-declaration&gt; ...)</pre></div>
<p>library name is a list whose members are identifiers and exact
non-negative integers. It is used to identify the library uniquely when
importing from other programs or libraries. Libraries whose first
identifier is scheme are reserved for use by this report and future
versions of this report. Libraries whose first identifier is srfi are
reserved for libraries implementing Scheme Requests for Implementation.
It is inadvisable, but not an error, for identifiers in library names to
contain any of the characters | <code>'</code> ? * \&lt; " : &gt; + [ ] / or
control characters after escapes are expanded.</p>
<p>A library declaration is any of:</p>
<ul>
<li><p><code>(export export spec ...)</code></p>
</li>
<li><p><code>(import import set ...)</code></p>
</li>
<li><p><code>(begin command or definition ...)</code></p>
</li>
<li><p><code>(include filename_1 filename_2 ...)</code></p>
</li>
<li><p><code>(include-ci filename_1 filename_2 ...)</code></p>
</li>
<li><p><code>(include-library-declarations filename_1 filename_2 ...)</code></p>
</li>
<li><p><code>(cond-expand ce-clause_1 ce-clause_2 ...)</code></p>
</li>
</ul>
<p>An <code>export</code> declaration specifies a list of identifiers which can be
made visible to other libraries or programs. An export spec takes one of
the following forms:</p>
<ul>
<li><p>identifier</p>
</li>
<li><p><code>(rename identifier_1 identifier_2)</code></p>
</li>
</ul>
<p>In an export spec, an identifier names a single binding defined within
or imported into the library, where the external name for the export is
the same as the name of the binding within the library. A <code>rename</code> spec
exports the binding defined within or imported into the library and
named by identifier<sub>1</sub> in each <code>(identifier_1 identifier_2)</code>
pairing, using identifier<sub>2</sub> as the external name.</p>
<p>An <code>import</code> declaration provides a way to import the identifiers
exported by another library. It has the same syntax and semantics as an
import declaration used in a program or at the REPL (see
section <a href="#import">[import]</a>).</p>
<p>The <code>begin</code>, <code>include</code>, and <code>include-ci</code> declarations are used to
specify the body of the library. They have the same syntax and semantics
as the corresponding expression types. This form of begin is analogous
to, but not the same as, the two types of begin defined in
section <a href="#sequencing">[sequencing]</a>.</p>
<p>The <code>include-library-declarations</code> declaration is similar to <code>include</code>
except that the contents of the file are spliced directly into the
current library definition. This can be used, for example, to share the
same <code>export</code> declaration among multiple libraries as a simple form of
library interface.</p>
<p>The <code>cond-expand</code> declaration has the same syntax and semantics as the
<code>cond-expand</code> expression type, except that it expands to spliced-in
library declarations rather than expressions enclosed in begin.</p>
<p>One possible implementation of libraries is as follows: After all
<code>cond-expand</code> library declarations are expanded, a new environment is
constructed for the library consisting of all imported bindings. The
expressions from all <code>begin</code>, <code>include</code> and <code>include-ci</code> library
declarations are expanded in that environment in the order in which they
occur in the library. Alternatively, <code>cond-expand</code> and <code>import</code>
declarations may be processed in left to right order interspersed with
the processing of other declarations, with the environment growing as
imported bindings are added to it by each <code>import</code> declaration.</p>
<p>When a library is loaded, its expressions are executed in textual order.
If a library’s definitions are referenced in the expanded form of a
program or library body, then that library must be loaded before the
expanded program or library body is evaluated. This rule applies
transitively. If a library is imported by more than one program or
library, it may possibly be loaded additional times.</p>
<p>Similarly, during the expansion of a library (foo), if any syntax
keywords imported from another library (bar) are needed to expand the
library, then the library (bar) must be expanded and its syntax
definitions evaluated before the expansion of (foo).</p>
<p>Regardless of the number of times that a library is loaded, each program
or library that imports bindings from a library must do so from a single
loading of that library, regardless of the number of import declarations
in which it appears. That is, (import (only (foo) a)) followed by
(import (only (foo) b)) has the same effect as (import (only (foo) a
b)).</p>
<h4>Library example</h4>
<p>The following example shows how a program can be divided into libraries
plus a relatively small main program <span class="citation"
cites="life"></span>. If the main program is entered into a REPL, it is
not necessary to import the base library.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">define-library</span> <span class="p">(</span><span class="nf">example</span> <span class="nv">grid</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">export</span> <span class="nv">make</span> <span class="nv">rows</span> <span class="nv">cols</span> <span class="nv">ref</span> <span class="nv">each</span>
          <span class="p">(</span><span class="nf">rename</span> <span class="nv">put!</span> <span class="nv">set!</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">import</span> <span class="p">(</span><span class="nf">scheme</span> <span class="nv">base</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">begin</span>
    <span class="c1">;; Create an NxM grid.</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make</span> <span class="nv">n</span> <span class="nv">m</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">grid</span> <span class="p">(</span><span class="nb">make-vector </span><span class="nv">n</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">i</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">grid</span><span class="p">)</span>
          <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">v</span> <span class="p">(</span><span class="nb">make-vector </span><span class="nv">m</span> <span class="err">\</span><span class="nv">sharpfalse</span><span class="err">{}</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">grid</span> <span class="nv">i</span> <span class="nv">v</span><span class="p">)))))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">rows</span> <span class="nv">grid</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">vector-length </span><span class="nv">grid</span><span class="p">))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">cols</span> <span class="nv">grid</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">vector-length </span><span class="p">(</span><span class="nb">vector-ref </span><span class="nv">grid</span> <span class="mi">0</span><span class="p">)))</span>
    <span class="c1">;; Return \sharpfalse{} if out of range.</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">ref</span> <span class="nv">grid</span> <span class="nv">n</span> <span class="nv">m</span><span class="p">)</span>
      <span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">&lt; </span><span class="mi">-1</span> <span class="nv">n</span> <span class="p">(</span><span class="nf">rows</span> <span class="nv">grid</span><span class="p">))</span>
           <span class="p">(</span><span class="nb">&lt; </span><span class="mi">-1</span> <span class="nv">m</span> <span class="p">(</span><span class="nf">cols</span> <span class="nv">grid</span><span class="p">))</span>
           <span class="p">(</span><span class="nb">vector-ref </span><span class="p">(</span><span class="nb">vector-ref </span><span class="nv">grid</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">m</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">put!</span> <span class="nv">grid</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">v</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">vector-set! </span><span class="p">(</span><span class="nb">vector-ref </span><span class="nv">grid</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">m</span> <span class="nv">v</span><span class="p">))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">each</span> <span class="nv">grid</span> <span class="nv">proc</span><span class="p">)</span>
      <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">j</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">j</span> <span class="mi">1</span><span class="p">)))</span>
          <span class="p">((</span><span class="nb">= </span><span class="nv">j</span> <span class="p">(</span><span class="nf">rows</span> <span class="nv">grid</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">k</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">k</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="p">((</span><span class="nb">= </span><span class="nv">k</span> <span class="p">(</span><span class="nf">cols</span> <span class="nv">grid</span><span class="p">)))</span>
          <span class="p">(</span><span class="nf">proc</span> <span class="nv">j</span> <span class="nv">k</span> <span class="p">(</span><span class="nf">ref</span> <span class="nv">grid</span> <span class="nv">j</span> <span class="nv">k</span><span class="p">)))))))</span>

<span class="p">(</span><span class="nf">define-library</span> <span class="p">(</span><span class="nf">example</span> <span class="nv">life</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">export</span> <span class="nv">life</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">import</span> <span class="p">(</span><span class="nf">except</span> <span class="p">(</span><span class="nf">scheme</span> <span class="nv">base</span><span class="p">)</span> <span class="nv">set!</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">scheme</span> <span class="nv">write</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">example</span> <span class="nv">grid</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">begin</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">life-count</span> <span class="nv">grid</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">)</span>
      <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">count</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">)</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">ref</span> <span class="nv">grid</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">count</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">j</span> <span class="mi">1</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">count</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">j</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">count</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">j</span> <span class="mi">1</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">count</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">- </span><span class="nv">j</span> <span class="mi">1</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">count</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">j</span> <span class="mi">1</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">count</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">j</span> <span class="mi">1</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">count</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">j</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">count</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">j</span> <span class="mi">1</span><span class="p">))))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">life-alive?</span> <span class="nv">grid</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">)</span>
      <span class="p">(</span><span class="k">case </span><span class="p">(</span><span class="nf">life-count</span> <span class="nv">grid</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">)</span>
        <span class="p">((</span><span class="mi">3</span><span class="p">)</span> <span class="err">\</span><span class="nv">sharptrue</span><span class="err">{}</span><span class="p">)</span>
        <span class="p">((</span><span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">ref</span> <span class="nv">grid</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">))</span>
        <span class="p">(</span><span class="k">else </span><span class="err">\</span><span class="nv">sharpfalse</span><span class="err">{}</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">life-print</span> <span class="nv">grid</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">display </span><span class="s">&quot;\x1B;[1H\x1B;[J&quot;</span><span class="p">)</span>  <span class="c1">; clear vt100</span>
      <span class="p">(</span><span class="nf">each</span> <span class="nv">grid</span>
            <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">i</span> <span class="nv">j</span> <span class="nv">v</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="k">if </span><span class="nv">v</span> <span class="s">&quot;*&quot;</span> <span class="s">&quot; &quot;</span><span class="p">))</span>
              <span class="p">(</span><span class="nf">when</span> <span class="p">(</span><span class="nb">= </span><span class="nv">j</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">cols</span> <span class="nv">grid</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>
                <span class="p">(</span><span class="nf">newline</span><span class="p">)))))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">life</span> <span class="nv">grid</span> <span class="nv">iterations</span><span class="p">)</span>
      <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">i</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">))</span>
           <span class="p">(</span><span class="nf">grid0</span> <span class="nv">grid</span> <span class="nv">grid1</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">grid1</span> <span class="p">(</span><span class="nf">make</span> <span class="p">(</span><span class="nf">rows</span> <span class="nv">grid</span><span class="p">)</span> <span class="p">(</span><span class="nf">cols</span> <span class="nv">grid</span><span class="p">))</span>
                  <span class="nv">grid0</span><span class="p">))</span>
          <span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="nv">iterations</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">each</span> <span class="nv">grid0</span>
              <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">j</span> <span class="nv">k</span> <span class="nv">v</span><span class="p">)</span>
                <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">a</span> <span class="p">(</span><span class="nf">life-alive?</span> <span class="nv">grid0</span> <span class="nv">j</span> <span class="nv">k</span><span class="p">)))</span>
                  <span class="p">(</span><span class="k">set! </span><span class="nv">grid1</span> <span class="nv">j</span> <span class="nv">k</span> <span class="nv">a</span><span class="p">))))</span>
        <span class="p">(</span><span class="nf">life-print</span> <span class="nv">grid1</span><span class="p">)))))</span>

<span class="c1">;; Main program.</span>
<span class="p">(</span><span class="nf">import</span> <span class="p">(</span><span class="nf">scheme</span> <span class="nv">base</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">only</span> <span class="p">(</span><span class="nf">example</span> <span class="nv">life</span><span class="p">)</span> <span class="nv">life</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">rename</span> <span class="p">(</span><span class="nf">prefix</span> <span class="p">(</span><span class="nf">example</span> <span class="nv">grid</span><span class="p">)</span> <span class="nv">grid-</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">grid-make</span> <span class="nv">make-grid</span><span class="p">)))</span>

<span class="c1">;; Initialize a grid with a glider.</span>
<span class="p">(</span><span class="k">define </span><span class="nv">grid</span> <span class="p">(</span><span class="nf">make-grid</span> <span class="mi">24</span> <span class="mi">24</span><span class="p">))</span>
<span class="p">(</span><span class="nf">grid-set!</span> <span class="nv">grid</span> <span class="mi">1</span> <span class="mi">1</span> <span class="err">\</span><span class="nv">sharptrue</span><span class="err">{}</span><span class="p">)</span>
<span class="p">(</span><span class="nf">grid-set!</span> <span class="nv">grid</span> <span class="mi">2</span> <span class="mi">2</span> <span class="err">\</span><span class="nv">sharptrue</span><span class="err">{}</span><span class="p">)</span>
<span class="p">(</span><span class="nf">grid-set!</span> <span class="nv">grid</span> <span class="mi">3</span> <span class="mi">0</span> <span class="err">\</span><span class="nv">sharptrue</span><span class="err">{}</span><span class="p">)</span>
<span class="p">(</span><span class="nf">grid-set!</span> <span class="nv">grid</span> <span class="mi">3</span> <span class="mi">1</span> <span class="err">\</span><span class="nv">sharptrue</span><span class="err">{}</span><span class="p">)</span>
<span class="p">(</span><span class="nf">grid-set!</span> <span class="nv">grid</span> <span class="mi">3</span> <span class="mi">2</span> <span class="err">\</span><span class="nv">sharptrue</span><span class="err">{}</span><span class="p">)</span>

<span class="c1">;; Run for 80 iterations.</span>
<span class="p">(</span><span class="nf">life</span> <span class="nv">grid</span> <span class="mi">80</span><span class="p">)</span>
</pre></div>
<h3>The REPL</h3>
<p>Implementations may provide an interactive session called a <em>REPL</em>
(Read-Eval-Print Loop), where import declarations, expressions and
definitions can be entered and evaluated one at a time. For convenience
and ease of use, the global Scheme environment in a REPL must not be
empty, but must start out with at least the bindings provided by the
base library. This library includes the core syntax of Scheme and
generally useful procedures that manipulate data. For example, the
variable abs is bound to a procedure of one argument that computes the
absolute value of a number, and the variable + is bound to a procedure
that computes sums. The full list of <code>(scheme base)</code> bindings can be found
in Appendix <a href="#stdlibraries">[stdlibraries]</a>.</p>
<p>Implementations may provide an initial REPL environment which behaves as
if all possible variables are bound to locations, most of which contain
unspecified values. Top level REPL definitions in such an implementation
are truly equivalent to assignments, unless the identifier is defined as
a syntax keyword.</p>
<p>An implementation may provide a mode of operation in which the REPL
reads its input from a file. Such a file is not, in general, the same as
a program, because it can contain import declarations in places other
than the beginning.</p>
<h2>Standard procedures</h2>
<p>This chapter describes Scheme’s built-in procedures.</p>
<p>The procedures force, promise?, and make-promise are intimately
associated with the expression types delay and delay-force, and are
described with them in section <a href="#force">[force]</a>. In the same way, the
procedure make-parameter is intimately associated with the expression
type parameterize, and is described with it in
section <a href="#make-parameter">[make-parameter]</a>.</p>
<p>A program can use a global variable definition to bind any variable. It
may subsequently alter any such binding by an assignment (see
section <a href="#assignment">[assignment]</a>). These operations do not modify
the behavior of any procedure defined in this report or imported from a
library (see section <a href="#libraries">[libraries]</a>). Altering any global
binding that has not been introduced by a definition has an unspecified
effect on the behavior of the procedures defined in this chapter.</p>
<p>When a procedure is said to return a <em>newly allocated</em> object, it means
that the locations in the object are fresh.</p>
<h3>Equivalence predicates</h3>
<p>A <em>predicate</em> is a procedure that always returns a boolean value (#t or</p>
<h1>f). An <em>equivalence predicate</em> is the computational analogue of a</h1>
<p>mathematical equivalence relation; it is symmetric, reflexive, and
transitive. Of the equivalence predicates described in this section,
eq? is the finest or most discriminating, equal? is the coarsest, and
eqv? is slightly less discriminating than eq?.</p>
<p>(eqv? <strong>obj<sub>1</sub><em> </em>obj<sub>2</sub></strong>)  procedure
The eqv? procedure defines a useful equivalence relation on objects.
Briefly, it returns <code>#t</code> if <em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are
normally regarded as the same object. This relation is left slightly
open to interpretation, but the following partial specification of eqv?
holds for all implementations of Scheme.</p>
<p>The eqv? procedure returns <code>#t</code> if:</p>
<ul>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are both <code>#t</code> or both #f.</p>
</li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are both symbols and are the
same symbol according to the symbol=? procedure
(section <a href="#symbolsection">[symbolsection]</a>).</p>
</li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are both exact numbers and
are numerically equal (in the sense of =).</p>
</li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are both inexact numbers
such that they are numerically equal (in the sense of =) and they
yield the same results (in the sense of eqv?) when passed as
arguments to any other procedure that can be defined as a finite
composition of Scheme’s standard arithmetic procedures, provided it
does not result in a NaN value.</p>
</li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are both characters and are
the same character according to the char=? procedure
(section <a href="#charactersection">[charactersection]</a>).</p>
</li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are both the empty list.</p>
</li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are pairs, vectors,
bytevectors, records, or strings that denote the same location in
the store (section <a href="#storagemodel">[storagemodel]</a>).</p>
</li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are procedures whose
location tags are equal (section <a href="#lambda">[lambda]</a>).</p>
</li>
</ul>
<p>The eqv? procedure returns <code>#f</code> if:</p>
<ul>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are of different types
(section <a href="#disjointness">[disjointness]</a>).</p>
</li>
<li><p>one of <em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> is <code>#t</code> but the other
is #f.</p>
</li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are symbols but are not the
same symbol according to the symbol=? procedure
(section <a href="#symbolsection">[symbolsection]</a>).</p>
</li>
<li><p>one of <em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> is an exact number
but the other is an inexact number.</p>
</li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are both exact numbers and
are numerically unequal (in the sense of =).</p>
</li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are both inexact numbers
such that either they are numerically unequal (in the sense of =),
or they do not yield the same results (in the sense of eqv?) when
passed as arguments to any other procedure that can be defined as a
finite composition of Scheme’s standard arithmetic procedures,
provided it does not result in a NaN value. As an exception, the
behavior of eqv? is unspecified when both <em>obj<sub>1</sub></em> and
<em>obj<sub>2</sub></em> are NaN.</p>
</li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are characters for which the
char=? procedure returns #f.</p>
</li>
<li><p>one of <em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> is the empty list but
the other is not.</p>
</li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are pairs, vectors,
bytevectors, records, or strings that denote distinct locations.</p>
</li>
<li><p><em>obj<sub>1</sub></em> and <em>obj<sub>2</sub></em> are procedures that would
behave differently (return different values or have different side
effects) for some arguments.</p>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">eqv? </span><span class="ss">&#39;a</span> <span class="ss">&#39;a</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="mi">2</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="mi">2</span> <span class="mf">2.0</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="o">&#39;</span><span class="p">()</span> <span class="o">&#39;</span><span class="p">())</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="mi">100000000</span> <span class="mi">100000000</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="mf">0.0</span> <span class="nv">+nan</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">p</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">eqv? </span><span class="nv">p</span> <span class="nv">p</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="no">#f</span> <span class="ss">&#39;nil</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
</pre></div>
<p>The following examples illustrate cases in which the above rules do not
fully specify the behavior of eqv?. All that can be said about such
cases is that the value returned by eqv? must be a boolean.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">eqv? </span><span class="s">&quot;&quot;</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="o">&#39;#</span><span class="p">()</span> <span class="o">&#39;#</span><span class="p">())</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="nv">y</span><span class="p">))</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="mf">1.0</span><span class="nv">e0</span> <span class="mf">1.0</span><span class="nv">f0</span><span class="p">)</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="nv">+nan</span><span class="o">.</span><span class="mi">0</span> <span class="nv">+nan</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span> <span class="c1">;; =&gt; unspecified</span>
</pre></div>
<p>Note that (eqv? 0.0 -0.0) will return <code>#f</code> if negative zero is
distinguished, and <code>#t</code> if negative zero is not distinguished.</p>
<p>The next set of examples shows the use of eqv? with procedures that have
local state. The gen-counter procedure must return a distinct procedure
every time, since each procedure has its own internal counter. The
gen-loser procedure, however, returns operationally equivalent
procedures each time, since the local state does not affect the value or
side effects of the procedures. However, eqv? may or may not detect this
equivalence.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">gen-counter</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">n</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">n</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">n</span><span class="p">))))</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">g</span> <span class="p">(</span><span class="nf">gen-counter</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">eqv? </span><span class="nv">g</span> <span class="nv">g</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="p">(</span><span class="nf">gen-counter</span><span class="p">)</span> <span class="p">(</span><span class="nf">gen-counter</span><span class="p">))</span>
<span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="k">define </span><span class="nv">gen-loser</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">n</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">n</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))</span> <span class="mi">27</span><span class="p">))))</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">g</span> <span class="p">(</span><span class="nf">gen-loser</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">eqv? </span><span class="nv">g</span> <span class="nv">g</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="p">(</span><span class="nf">gen-loser</span><span class="p">)</span> <span class="p">(</span><span class="nf">gen-loser</span><span class="p">))</span>
<span class="c1">;; =&gt; unspecified</span>

<span class="p">(</span><span class="k">letrec </span><span class="p">((</span><span class="nf">f</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eqv? </span><span class="nv">f</span> <span class="nv">g</span><span class="p">)</span> <span class="ss">&#39;both</span> <span class="ss">&#39;f</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">g</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eqv? </span><span class="nv">f</span> <span class="nv">g</span><span class="p">)</span> <span class="ss">&#39;both</span> <span class="ss">&#39;g</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">eqv? </span><span class="nv">f</span> <span class="nv">g</span><span class="p">))</span>
<span class="c1">;; =&gt; unspecified</span>

<span class="p">(</span><span class="k">letrec </span><span class="p">((</span><span class="nf">f</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eqv? </span><span class="nv">f</span> <span class="nv">g</span><span class="p">)</span> <span class="ss">&#39;f</span> <span class="ss">&#39;both</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">g</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eqv? </span><span class="nv">f</span> <span class="nv">g</span><span class="p">)</span> <span class="ss">&#39;g</span> <span class="ss">&#39;both</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">eqv? </span><span class="nv">f</span> <span class="nv">g</span><span class="p">))</span>
<span class="c1">;; =&gt; #f</span>
</pre></div>
<p>Since it is an error to modify constant objects (those returned by
literal expressions), implementations may share structure between
constants where appropriate. Thus the value of eqv? on constants is
sometimes implementation-dependent.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">eqv? </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span><span class="p">))</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="s">&quot;a&quot;</span> <span class="s">&quot;a&quot;</span><span class="p">)</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">eqv? </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
</pre></div>
<p>The above definition of eqv? allows implementations latitude in their
treatment of procedures and literals: implementations may either detect
or fail to detect that two procedures or two literals are equivalent to
each other, and can decide whether or not to merge representations of
equivalent objects by using the same pointer or bit pattern to represent
both.</p>
<p><em>Note:</em> If inexact numbers are represented as IEEE binary floating-point
numbers, then an implementation of eqv? that simply compares equal-sized
inexact numbers for bitwise equality is correct by the above definition.</p>
<p>(eq? <strong>obj<sub>1</sub><em> </em>obj<sub>2</sub></strong>)  procedure
The eq? procedure is similar to eqv? except that in some cases it is
capable of discerning distinctions finer than those detectable by eqv?.
It must always return <code>#f</code> when eqv? also would, but may return <code>#f</code> in some
cases where eqv? would return #t.</p>
<p>On symbols, booleans, the empty list, pairs, and records, and also on
non-empty strings, vectors, and bytevectors, eq? and eqv? are guaranteed
to have the same behavior. On procedures, eq? must return true if the
arguments’ location tags are equal. On numbers and characters, eq?’s
behavior is implementation-dependent, but it will always return either
true or false. On empty strings, empty vectors, and empty bytevectors,
eq? may also behave differently from eqv?.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">eq? </span><span class="ss">&#39;a</span> <span class="ss">&#39;a</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">eq? </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span><span class="p">))</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a</span><span class="p">))</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">eq? </span><span class="s">&quot;a&quot;</span> <span class="s">&quot;a&quot;</span><span class="p">)</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">eq? </span><span class="s">&quot;&quot;</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">eq? </span><span class="o">&#39;</span><span class="p">()</span> <span class="o">&#39;</span><span class="p">())</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">eq? </span><span class="mi">2</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">eq? </span><span class="sc">#\A</span> <span class="sc">#\A</span><span class="p">)</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">eq? </span><span class="nv">car</span> <span class="nv">car</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">n</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="mi">3</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">eq? </span><span class="nv">n</span> <span class="nv">n</span><span class="p">))</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">eq? </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="o">&#39;#</span><span class="p">()))</span>
  <span class="p">(</span><span class="nb">eq? </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">p</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">eq? </span><span class="nv">p</span> <span class="nv">p</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
</pre></div>
<p><em>Rationale:</em> It will usually be possible to implement eq? much more
efficiently than eqv?, for example, as a simple pointer comparison
instead of as some more complicated operation. One reason is that it is
not always possible to compute eqv? of two numbers in constant time,
whereas eq? implemented as pointer comparison will always finish in
constant time.</p>
<p>(equal? <strong>obj<sub>1</sub><em> </em>obj<sub>2</sub></strong>)  procedure
The equal? procedure, when applied to pairs, vectors, strings and
bytevectors, recursively compares them, returning <code>#t</code> when the unfoldings
of its arguments into (possibly infinite) trees are equal (in the sense
of equal?) as ordered trees, and <code>#f</code> otherwise. It returns the same as
eqv? when applied to booleans, symbols, numbers, characters, ports,
procedures, and the empty list. If two objects are eqv?, they must be
equal? as well. In all other cases, equal? may return either <code>#t</code> or #f.</p>
<p>Even if its arguments are circular data structures, equal? must always
terminate.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">equal? </span><span class="ss">&#39;a</span> <span class="ss">&#39;a</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">equal? </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">equal? </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nf">b</span><span class="p">)</span> <span class="nv">c</span><span class="p">)</span>
        <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nf">b</span><span class="p">)</span> <span class="nv">c</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">equal? </span><span class="s">&quot;abc&quot;</span> <span class="s">&quot;abc&quot;</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">equal? </span><span class="mi">2</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">equal? </span><span class="p">(</span><span class="nb">make-vector </span><span class="mi">5</span> <span class="ss">&#39;a</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">make-vector </span><span class="mi">5</span> <span class="ss">&#39;a</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">equal? </span><span class="o">&#39;#</span><span class="mi">1</span><span class="nv">=</span><span class="p">(</span><span class="nf">a</span> <span class="nv">b</span> <span class="o">.</span> <span class="o">#</span><span class="mi">1</span><span class="o">#</span><span class="p">)</span>
        <span class="o">&#39;#</span><span class="mi">2</span><span class="nv">=</span><span class="p">(</span><span class="nf">a</span> <span class="nv">b</span> <span class="nv">a</span> <span class="nv">b</span> <span class="o">.</span> <span class="o">#</span><span class="mi">2</span><span class="o">#</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">equal? </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
        <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="nv">y</span><span class="p">))</span> <span class="c1">;; =&gt; unspecified</span>
</pre></div>
<p><em>Note:</em> A rule of thumb is that objects are generally equal? if they
print the same.</p>
<h3>Numbers</h3>
<p>It is important to distinguish between mathematical numbers, the Scheme
numbers that attempt to model them, the machine representations used to
implement the Scheme numbers, and notations used to write numbers. This
report uses the types <em>number</em>, <em>complex</em>, <em>real</em>, <em>rational</em>, and
<em>integer</em> to refer to both mathematical numbers and Scheme numbers.</p>
<h4>Numerical types</h4>
<p>Mathematically, numbers are arranged into a tower of subtypes in which
each level is a subset of the level above it:</p>
<div class="tabbing">

         n̄umber
complex number
real number
rational number
integer

</div><p>For example, 3 is an integer. Therefore 3 is also a rational, a real,
and a complex number. The same is true of the Scheme numbers that model</p>
<ol>
<li>For Scheme numbers, these types are defined by the predicates
<code>number?</code>, <code>complex?</code>, <code>real?</code>, <code>rational?</code>, and <code>integer?</code>.</li>
</ol>
<p>There is no simple relationship between a number’s type and its
representation inside a computer. Although most implementations of
Scheme will offer at least two different representations of 3, these
different representations denote the same integer.</p>
<p>Scheme’s numerical operations treat numbers as abstract data, as
independent of their representation as possible. Although an
implementation of Scheme may use multiple internal representations of
numbers, this ought not to be apparent to a casual programmer writing
simple programs.</p>
<h4>Exactness</h4>
<p>It is useful to distinguish between numbers that are represented exactly
and those that might not be. For example, indexes into data structures
must be known exactly, as must some polynomial coefficients in a
symbolic algebra system. On the other hand, the results of measurements
are inherently inexact, and irrational numbers may be approximated by
rational and therefore inexact approximations. In order to catch uses of
inexact numbers where exact numbers are required, Scheme explicitly
distinguishes exact from inexact numbers. This distinction is orthogonal
to the dimension of type.</p>
<p>A Scheme number is <em>exact</em> if it was written as an exact constant or was
derived from exact numbers using only exact operations. A number is
<em>inexact</em> if it was written as an inexact constant, if it was derived
using inexact ingredients, or if it was derived using inexact
operations. Thus inexactness is a contagious property of a number. In
particular, an <em>exact complex number</em> has an exact real part and an
exact imaginary part; all other complex numbers are <em>inexact complex
numbers</em>.</p>
<p>If two implementations produce exact results for a computation that did
not involve inexact intermediate results, the two ultimate results will
be mathematically equal. This is generally not true of computations
involving inexact numbers since approximate methods such as
floating-point arithmetic may be used, but it is the duty of each
implementation to make the result as close as practical to the
mathematically ideal result.</p>
<p>Rational operations such as + should always produce exact results when
given exact arguments. If the operation is unable to produce an exact
result, then it may either report the violation of an implementation
restriction or it may silently coerce its result to an inexact value.
However, (/ 3 4) must not return the mathematically incorrect value 0.
See section <a href="#restrictions">[restrictions]</a>.</p>
<p>Except for <code>exact</code>, the operations described in this section must
generally return inexact results when given any inexact arguments. An
operation may, however, return an exact result if it can prove that the
value of the result is unaffected by the inexactness of its arguments.
For example, multiplication of any number by an exact zero may produce
an exact zero result, even if the other argument is inexact.</p>
<p>Specifically, the expression (* 0 +inf.0) may return 0, or +nan.0, or
report that inexact numbers are not supported, or report that
non-rational real numbers are not supported, or fail silently or noisily
in other implementation-specific ways.</p>
<h4>Implementation restrictions</h4>
<p>Implementations of Scheme are not required to implement the whole tower
of subtypes given in section <a href="#numericaltypes">[numericaltypes]</a>, but
they must implement a coherent subset consistent with both the purposes
of the implementation and the spirit of the Scheme language. For
example, implementations in which all numbers are real, or in which
non-real numbers are always inexact, or in which exact numbers are
always integer, are still quite useful.</p>
<p>Implementations may also support only a limited range of numbers of any
type, subject to the requirements of this section. The supported range
for exact numbers of any type may be different from the supported range
for inexact numbers of that type. For example, an implementation that
uses IEEE binary double-precision floating-point numbers to represent
all its inexact real numbers may also support a practically unbounded
range of exact integers and rationals while limiting the range of
inexact reals (and therefore the range of inexact integers and
rationals) to the dynamic range of the IEEE binary double format.
Furthermore, the gaps between the representable inexact integers and
rationals are likely to be very large in such an implementation as the
limits of this range are approached.</p>
<p>An implementation of Scheme must support exact integers throughout the
range of numbers permitted as indexes of lists, vectors, bytevectors,
and strings or that result from computing the length of one of these.
The <code>length</code>, <code>vector-length</code>, <code>bytevector-length</code>, and <code>string-length</code>
procedures must return an exact integer, and it is an error to use
anything but an exact integer as an index. Furthermore, any integer
constant within the index range, if expressed by an exact integer
syntax, must be read as an exact integer, regardless of any
implementation restrictions that apply outside this range. Finally, the
procedures listed below will always return exact integer results
provided all their arguments are exact integers and the mathematically
expected results are representable as exact integers within the
implementation:</p>
<div class="highlight"><pre><span></span><span class="nv">-</span>                     <span class="nv">*</span>
<span class="nv">+</span>                     <span class="nv">abs</span>
<span class="nv">ceiling</span>               <span class="nv">denominator</span>
<span class="nv">exact-integer-sqrt</span>    <span class="nv">expt</span>
<span class="nv">floor</span>                 <span class="nv">floor/</span>
<span class="nv">floor-quotient</span>        <span class="nv">floor-remainder</span>
<span class="nv">gcd</span>                   <span class="nv">lcm</span>
<span class="nv">max</span>                   <span class="nv">min</span>
<span class="nv">modulo</span>                <span class="nv">numerator</span>
<span class="nv">quotient</span>              <span class="nv">rationalize</span>
<span class="nv">remainder</span>             <span class="nv">round</span>
<span class="nv">square</span>                <span class="nv">truncate</span>
<span class="nv">truncate/</span>             <span class="nv">truncate-quotient</span>
<span class="nv">truncate-remainder</span>
</pre></div>
<p>It is recommended, but not required, that implementations support exact
integers and exact rationals of practically unlimited size and
precision, and to implement the above procedures and the / procedure in
such a way that they always return exact results when given exact
arguments. If one of these procedures is unable to deliver an exact
result when given exact arguments, then it may either report a violation
of an implementation restriction or it may silently coerce its result to
an inexact number; such a coercion can cause an error later.
Nevertheless, implementations that do not provide exact rational numbers
should return inexact rational numbers rather than reporting an
implementation restriction.</p>
<p>An implementation may use floating-point and other approximate
representation strategies for inexact numbers. This report recommends,
but does not require, that implementations that use floating-point
representations follow the IEEE 754 standard, and that implementations
using other representations should match or exceed the precision
achievable using these floating-point standards <span class="citation"
cites="IEEE"></span>. In particular, the description of transcendental
functions in IEEE 754-2008 should be followed by such implementations,
particularly with respect to infinities and NaNs.</p>
<p>Although Scheme allows a variety of written notations for numbers, any
particular implementation may support only some of them. For example, an
implementation in which all numbers are real need not support the
rectangular and polar notations for complex numbers. If an
implementation encounters an exact numerical constant that it cannot
represent as an exact number, then it may either report a violation of
an implementation restriction or it may silently represent the constant
by an inexact number.</p>
<h4>Implementation extensions</h4>
<p>Implementations may provide more than one representation of
floating-point numbers with differing precisions. In an implementation
which does so, an inexact result must be represented with at least as
much precision as is used to express any of the inexact arguments to
that operation. Although it is desirable for potentially inexact
operations such as sqrt to produce exact answers when applied to exact
arguments, if an exact number is operated upon so as to produce an
inexact result, then the most precise representation available must be
used. For example, the value of (sqrt 4) should be 2, but in an
implementation that provides both single and double precision floating
point numbers it may be the latter but must not be the former.</p>
<p>It is the programmer’s responsibility to avoid using inexact number
objects with magnitude or significand too large to be represented in the
implementation.</p>
<p>In addition, implementations may distinguish special numbers called
positive infinity, negative infinity, NaN, and negative zero.</p>
<p>Positive infinity is regarded as an inexact real (but not rational)
number that represents an indeterminate value greater than the numbers
represented by all rational numbers. Negative infinity is regarded as an
inexact real (but not rational) number that represents an indeterminate
value less than the numbers represented by all rational numbers.</p>
<p>Adding or multiplying an infinite value by any finite real value results
in an appropriately signed infinity; however, the sum of positive and
negative infinities is a NaN. Positive infinity is the reciprocal of
zero, and negative infinity is the reciprocal of negative zero. The
behavior of the transcendental functions is sensitive to infinity in
accordance with IEEE 754.</p>
<p>A NaN is regarded as an inexact real (but not rational) number so
indeterminate that it might represent any real value, including positive
or negative infinity, and might even be greater than positive infinity
or less than negative infinity. An implementation that does not support
non-real numbers may use NaN to represent non-real values like (sqrt
-1.0) and (asin 2.0).</p>
<p>A NaN always compares false to any number, including a NaN. An
arithmetic operation where one operand is NaN returns NaN, unless the
implementation can prove that the result would be the same if the NaN
were replaced by any rational number. Dividing zero by zero results in
NaN unless both zeros are exact.</p>
<p>Negative zero is an inexact real value written -0.0 and is distinct (in
the sense of eqv?) from 0.0. A Scheme implementation is not required to
distinguish negative zero. If it does, however, the behavior of the
transcendental functions is sensitive to the distinction in accordance
with IEEE 754. Specifically, in a Scheme implementing both complex
numbers and negative zero, the branch cut of the complex logarithm
function is such that (imag-part (log -1.0-0.0i)) is  − <em>π</em> rather than
<em>π</em>.</p>
<p>Furthermore, the negation of negative zero is ordinary zero and vice
versa. This implies that the sum of two or more negative zeros is
negative, and the result of subtracting (positive) zero from a negative
zero is likewise negative. However, numerical comparisons treat negative
zero as equal to zero.</p>
<p>Note that both the real and the imaginary parts of a complex number can
be infinities, NaNs, or negative zero.</p>
<h4>Syntax of numerical constants</h4>
<p>The syntax of the written representations for numbers is described
formally in section <a href="#numbersyntax">[numbersyntax]</a>. Note that case is
not significant in numerical constants.</p>
<p>A number can be written in binary, octal, decimal, or hexadecimal by the
use of a radix prefix. The radix prefixes are #b (binary), #o (octal),</p>
<h1>d (decimal), and #x (hexadecimal). With no radix prefix, a number is</h1>
<p>assumed to be expressed in decimal.</p>
<p>A numerical constant can be specified to be either exact or inexact by a
prefix. The prefixes are #e for exact, and #i for inexact. An exactness
prefix can appear before or after any radix prefix that is used. If the
written representation of a number has no exactness prefix, the constant
is inexact if it contains a decimal point or an exponent. Otherwise, it
is exact.</p>
<p>In systems with inexact numbers of varying precisions it can be useful
to specify the precision of a constant. For this purpose,
implementations may accept numerical constants written with an exponent
marker that indicates the desired precision of the inexact
representation. If so, the letter s, f, d, or l, meaning <em>short</em>,
<em>single</em>, <em>double</em>, or <em>long</em> precision, respectively, can be used in
place of e. The default precision has at least as much precision as
<em>double</em>, but implementations may allow this default to be set by the
user.</p>
<div class="highlight"><pre><span></span><span class="mf">3.14159265358979</span><span class="nv">F0</span>
<span class="c1">;; Round to single --- 3.141593</span>
<span class="mf">0.6</span><span class="nv">L0</span>
<span class="c1">;; Extend to long --- .600000000000000</span>
</pre></div>
<p>The numbers positive infinity, negative infinity, and NaN are written
+inf.0, -inf.0 and +nan.0 respectively. NaN may also be written -nan.0.
The use of signs in the written representation does not necessarily
reflect the underlying sign of the NaN value, if any. Implementations
are not required to support these numbers, but if they do, they must do
so in general conformance with IEEE 754. However, implementations are
not required to support signaling NaNs, nor to provide a way to
distinguish between different NaNs.</p>
<p>There are two notations provided for non-real complex numbers: the
<em>rectangular notation</em> <em>a</em>+<em>b</em>i, where <em>a</em> is the real part and <em>b</em> is
the imaginary part; and the <em>polar notation</em> <em>r</em>@<em>θ</em>, where <em>r</em> is the
magnitude and <em>θ</em> is the phase (angle) in radians. These are related by
the equation <em>a</em> + <em>b**i</em> = <em>r</em>cos <em>θ</em> + (<em>r</em>sin<em>θ</em>)<em>i</em>. All of <em>a</em>,
<em>b</em>, <em>r</em>, and <em>θ</em> are real numbers.</p>
<h4>Numerical operations</h4>
<p>The reader is referred to
section <a href="#typeconventions">[typeconventions]</a> for a summary of the
naming conventions used to specify restrictions on the types of
arguments to numerical routines. The examples used in this section
assume that any numerical constant written using an exact notation is
indeed represented as an exact number. Some examples also assume that
certain numerical constants written using an inexact notation can be
represented without loss of accuracy; the inexact constants were chosen
so that this is likely to be true in implementations that use IEEE
binary doubles to represent inexact numbers.</p>
<p>(number? <em>obj</em>)  procedure
(complex? <em>obj</em>)  procedure
(real? <em>obj</em>)  procedure
(rational? <em>obj</em>)  procedure
(integer? <em>obj</em>)  procedure
These numerical type predicates can be applied to any kind of argument,
including non-numbers. They return <code>#t</code> if the object is of the named
type, and otherwise they return #f. In general, if a type predicate is
true of a number then all higher type predicates are also true of that
number. Consequently, if a type predicate is false of a number, then all
lower type predicates are also false of that number.</p>
<p>If <em>z</em> is a complex number, then (real? <em>z</em>) is true if and only if
(zero? (imag-part <em>z</em>)) is true. If <em>x</em> is an inexact real number, then
(integer? <em>x</em>) is true if and only if (= <em>x</em> (round <em>x</em>)).</p>
<p>The numbers +inf.0, -inf.0, and +nan.0 are real but not rational.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">complex? </span><span class="mi">3</span><span class="nv">+4i</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">complex? </span><span class="mi">3</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">real? </span><span class="mi">3</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">real? </span><span class="mf">-2.5</span><span class="nv">+0i</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">real? </span><span class="mf">-2.5</span><span class="nv">+0</span><span class="o">.</span><span class="mi">0</span><span class="nv">i</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">real? </span><span class="o">#</span><span class="nv">e1e10</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">real? </span><span class="nv">+inf</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">real? </span><span class="nv">+nan</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">rational? </span><span class="nv">-inf</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">rational? </span><span class="mf">3.5</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">rational? </span><span class="mi">6</span><span class="nv">/10</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">rational? </span><span class="mi">6</span><span class="nv">/3</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">integer? </span><span class="mi">3</span><span class="nv">+0i</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">integer? </span><span class="mf">3.0</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">integer? </span><span class="mi">8</span><span class="nv">/4</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
</pre></div>
<p><em>Note:</em> The behavior of these type predicates on inexact numbers is
unreliable, since any inaccuracy might affect the result.</p>
<p><em>Note:</em> In many implementations the <code>complex?</code> procedure will be the
same as <code>number?</code>, but unusual implementations may represent some
irrational numbers exactly or may extend the number system to support
some kind of non-complex numbers.</p>
<p>(exact? <strong>z</strong>)  procedure
(inexact? <strong>z</strong>)  procedure
These numerical predicates provide tests for the exactness of a
quantity. For any Scheme number, precisely one of these predicates is
true.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">exact? </span><span class="mf">3.0</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">exact? </span><span class="o">#</span><span class="nv">e3</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">inexact? </span><span class="mi">3</span><span class="o">.</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
</pre></div>
<p>(exact-integer? <strong>z</strong>)  procedure
Returns <code>#t</code> if <em>z</em> is both exact and an integer; otherwise returns #f.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">exact-integer?</span> <span class="mi">32</span><span class="p">)</span> <span class="c1">;; =&gt; #t{}</span>
<span class="p">(</span><span class="nf">exact-integer?</span> <span class="mf">32.0</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nf">exact-integer?</span> <span class="mi">32</span><span class="nv">/5</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
</pre></div>
<p>(finite? <strong>z</strong>)  inexact library procedure
The finite? procedure returns <code>#t</code> on all real numbers except +inf.0,
-inf.0, and +nan.0, and on complex numbers if their real and imaginary
parts are both finite. Otherwise it returns #f.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">finite?</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nf">finite?</span> <span class="nv">+inf</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nf">finite?</span> <span class="mf">3.0</span><span class="nv">+inf</span><span class="o">.</span><span class="mi">0</span><span class="nv">i</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
</pre></div>
<p>(infinite? <strong>z</strong>)  inexact library procedure
The infinite? procedure returns <code>#t</code> on the real numbers +inf.0 and
-inf.0, and on complex numbers if their real or imaginary parts or both
are infinite. Otherwise it returns #f.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">infinite?</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nf">infinite?</span> <span class="nv">+inf</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nf">infinite?</span> <span class="nv">+nan</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nf">infinite?</span> <span class="mf">3.0</span><span class="nv">+inf</span><span class="o">.</span><span class="mi">0</span><span class="nv">i</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
</pre></div>
<p>(nan? <strong>z</strong>)  inexact library procedure
The nan? procedure returns <code>#t</code> on +nan.0, and on complex numbers if their
real or imaginary parts or both are +nan.0. Otherwise it returns #f.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">nan?</span> <span class="nv">+nan</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nf">nan?</span> <span class="mi">32</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nf">nan?</span> <span class="nv">+nan</span><span class="o">.</span><span class="mi">0</span><span class="nv">+5</span><span class="o">.</span><span class="mi">0</span><span class="nv">i</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nf">nan?</span> <span class="mi">1</span><span class="nv">+2i</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
</pre></div>
<p>(= <strong>z<em><sub>1</sub> </em>z<em><sub>2</sub> </em>z<em><sub>3</sub> … </em>)  procedure
(\&lt; </strong>x<em><sub>1</sub> </em>x<em><sub>2</sub> </em>x<em><sub>3</sub> … </em>)  procedure
(&gt; <strong>x<em><sub>1</sub> </em>x<em><sub>2</sub> </em>x<em><sub>3</sub> … </em>)  procedure
(\&lt;= </strong>x<em><sub>1</sub> </em>x<em><sub>2</sub> </em>x<em><sub>3</sub> … </em>)  procedure
(&gt;= *<em>x</em><sub>1</sub> <em>x</em><sub>2</sub> <em>x</em><sub>3</sub> … *)  procedure
These procedures return <code>#t</code> if their arguments are (respectively): equal,
monotonically increasing, monotonically decreasing, monotonically
non-decreasing, or monotonically non-increasing, and <code>#f</code> otherwise. If
any of the arguments are +nan.0, all the predicates return #f. They do
not distinguish between inexact zero and inexact negative zero.</p>
<p>These predicates are required to be transitive.</p>
<p><em>Note:</em> The implementation approach of converting all arguments to
inexact numbers if any argument is inexact is not transitive. For
example, let big be (expt 2 1000), and assume that big is exact and that
inexact numbers are represented by 64-bit IEEE binary floating point
numbers. Then (= (- big 1) (inexact big)) and (= (inexact big) (+ big
1)) would both be true with this approach, because of the limitations of
IEEE representations of large integers, whereas (= (- big 1) (+ big 1))
is false. Converting inexact values to exact numbers that are the same
(in the sense of =) to them will avoid this problem, though special care
must be taken with infinities.</p>
<p><em>Note:</em> While it is not an error to compare inexact numbers using these
predicates, the results are unreliable because a small inaccuracy can
affect the result; this is especially true of <code>=</code> and <code>zero?</code>. When in
doubt, consult a numerical analyst.</p>
<p>(zero? <strong>z</strong>)  procedure
(positive? <strong>x</strong>)  procedure
(negative? <strong>x</strong>)  procedure
(odd? <strong>n</strong>)  procedure
(even? <strong>n</strong>)  procedure
These numerical predicates test a number for a particular property,
returning <code>#t</code> or #f. See note above.</p>
<p>(max <strong>x<em><sub>1</sub> </em>x<em><sub>2</sub> … </em>)  procedure
(min </strong>x<em><sub>1</sub> </em>x<em><sub>2</sub> … </em>)  procedure
These procedures return the maximum or minimum of their arguments.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">max </span><span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">;; =&gt; 4    ; exact</span>
<span class="p">(</span><span class="nb">max </span><span class="mf">3.9</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">;; =&gt; 4.0  ; inexact</span>
</pre></div>
<p><em>Note:</em> If any argument is inexact, then the result will also be inexact
(unless the procedure can prove that the inaccuracy is not large enough
to affect the result, which is possible only in unusual
implementations). If min or max is used to compare numbers of mixed
exactness, and the numerical value of the result cannot be represented
as an inexact number without loss of accuracy, then the procedure may
report a violation of an implementation restriction.</p>
<p>(+ <strong>z<em><sub>1</sub> … </em>)  procedure
(* </strong>z<em><sub>1</sub> … </em>)  procedure
These procedures return the sum or product of their arguments.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">+ </span><span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">;; =&gt; 7</span>
<span class="p">(</span><span class="nb">+ </span><span class="mi">3</span><span class="p">)</span> <span class="c1">;; =&gt; 3</span>
<span class="p">(</span><span class="nf">+</span><span class="p">)</span> <span class="c1">;; =&gt; 0</span>
<span class="p">(</span><span class="nb">* </span><span class="mi">4</span><span class="p">)</span> <span class="c1">;; =&gt; 4</span>
<span class="p">(</span><span class="nf">*</span><span class="p">)</span> <span class="c1">;; =&gt; 1</span>
</pre></div>
<p>(- <strong>z</strong>)  procedure
(- <strong>z<em><sub>1</sub> </em>z<em><sub>2</sub> … </em>)  procedure
(/ </strong>z<strong>)  procedure
(/ </strong>z<em><sub>1</sub> </em>z<em><sub>2</sub> … </em>)  procedure
With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left. With one argument,
however, they return the additive or multiplicative inverse of their
argument.</p>
<p>It is an error if any argument of / other than the first is an exact
zero. If the first argument is an exact zero, an implementation may
return an exact zero unless one of the other arguments is a NaN.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">- </span><span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">;; =&gt; -1</span>
<span class="p">(</span><span class="nb">- </span><span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">;; =&gt; -6</span>
<span class="p">(</span><span class="nb">- </span><span class="mi">3</span><span class="p">)</span> <span class="c1">;; =&gt; -3</span>
<span class="p">(</span><span class="nb">/ </span><span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">;; =&gt; 3/20</span>
<span class="p">(</span><span class="nb">/ </span><span class="mi">3</span><span class="p">)</span> <span class="c1">;; =&gt; 1/3</span>
</pre></div>
<p>(abs <em>x</em>)  procedure
The abs procedure returns the absolute value of its argument.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">abs </span><span class="mi">-7</span><span class="p">)</span> <span class="c1">;; =&gt; 7</span>
</pre></div>
<p>(floor/ <strong>n<em><sub>1</sub> </em>n<em><sub>2</sub></em>)  procedure
(floor-quotient </strong>n<em><sub>1</sub> </em>n<em><sub>2</sub></em>)  procedure
(floor-remainder <strong>n<em><sub>1</sub> </em>n<em><sub>2</sub></em>)  procedure
(truncate/ </strong>n<em><sub>1</sub> </em>n<em><sub>2</sub></em>)  procedure
(truncate-quotient <strong>n<em><sub>1</sub> </em>n<em><sub>2</sub></em>)  procedure
(truncate-remainder </strong>n<em><sub>1</sub> </em>n<em><sub>2</sub></em>)  procedure
These procedures implement number-theoretic (integer) division. It is an
error if <em>n</em><sub>2</sub> is zero. The procedures ending in / return two
integers; the other procedures return an integer. All the procedures
compute a quotient <em>n</em><sub>*q*</sub> and remainder <em>n</em><sub>*r*</sub>
such that <span class="math inline">${\\hbox{$n_1$\\/}} =
{\\hbox{$n_2$\\/}} {\\hbox{$n_q$\\/}} + {\\hbox{$n_r$\\/}}$</span>. For
each of the division operators, there are three procedures defined as
follows:</p>

<div><pre>(&lt;operator&gt;/ \vri{n} \vrii{n}) ;; =&gt; \vr{n_q} \vr{n_r}
(&lt;operator&gt;-quotient \vri{n} \vrii{n}) ;; =&gt; \vr{n_q}
(&lt;operator&gt;-remainder \vri{n} \vrii{n}) ;; =&gt; \vr{n_r}</pre></div>
<p>The remainder <em>n</em><sub>*r*</sub> is determined by the choice of integer
<em>n</em><sub>*q*</sub>: <span class="math inline">${\\hbox{$n_r$\\/}} =
{\\hbox{$n_1$\\/}} - {\\hbox{$n_2$\\/}} {\\hbox{$n_q$\\/}}$</span>. Each
set of operators uses a different choice of <em>n</em><sub>*q*</sub>:</p>
<table>
<thead><tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">floor</td>
<td style="text-align:left"><span class="math inline">${\\hbox{$n_q$\\/}} = \\lfloor{\\hbox{$n_1$\\/}} / {\\hbox{$n_2$\\/}}\\rfloor$</span></td>
</tr>
<tr>
<td style="text-align:left">truncate</td>
<td style="text-align:left"><span class="math inline">${\\hbox{$n_q$\\/}} = \\text{truncate}({\\hbox{$n_1$\\/}} / {\\hbox{$n_2$\\/}})$</span></td>
</tr>
</tbody>
</table>
<p>For any of the operators, and for integers <em>n</em><sub>1</sub> and
<em>n</em><sub>2</sub> with <em>n</em><sub>2</sub> not equal to 0,</p>

<div><pre>(= \vri{n} (+ (* \vrii{n} (&lt;operator&gt;-quotient \vri{n} \vrii{n}))
           (&lt;operator&gt;-remainder \vri{n} \vrii{n})))</pre></div>
<p>;; =&gt; #t</p>
<p>provided all numbers involved in that computation are exact.</p>
<p>Examples:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">floor/</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; =&gt; 2 1</span>
<span class="p">(</span><span class="nf">floor/</span> <span class="mi">-5</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; =&gt; -3 1</span>
<span class="p">(</span><span class="nf">floor/</span> <span class="mi">5</span> <span class="mi">-2</span><span class="p">)</span> <span class="c1">;; =&gt; -3 -1</span>
<span class="p">(</span><span class="nf">floor/</span> <span class="mi">-5</span> <span class="mi">-2</span><span class="p">)</span> <span class="c1">;; =&gt; 2 -1</span>
<span class="p">(</span><span class="nf">truncate/</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; =&gt; 2 1</span>
<span class="p">(</span><span class="nf">truncate/</span> <span class="mi">-5</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; =&gt; -2 -1</span>
<span class="p">(</span><span class="nf">truncate/</span> <span class="mi">5</span> <span class="mi">-2</span><span class="p">)</span> <span class="c1">;; =&gt; -2 1</span>
<span class="p">(</span><span class="nf">truncate/</span> <span class="mi">-5</span> <span class="mi">-2</span><span class="p">)</span> <span class="c1">;; =&gt; 2 -1</span>
<span class="p">(</span><span class="nf">truncate/</span> <span class="mf">-5.0</span> <span class="mi">-2</span><span class="p">)</span> <span class="c1">;; =&gt; 2.0 -1.0</span>
</pre></div>
<p>(quotient <strong>n<em><sub>1</sub> </em>n<em><sub>2</sub></em>)  procedure
(remainder </strong>n<em><sub>1</sub> </em>n<em><sub>2</sub></em>)  procedure
(modulo *<em>n</em><sub>1</sub> <em>n</em><sub>2</sub>*)  procedure
The quotient and remainder procedures are equivalent to
truncate-quotient and truncate-remainder, respectively, and modulo is
equivalent to floor-remainder.</p>
<p><em>Note:</em> These procedures are provided for backward compatibility with
earlier versions of this report.</p>
<p>(gcd <strong>n<em><sub>1</sub> … </em>)  procedure
(lcm </strong>n<em><sub>1</sub> … </em>)  procedure
These procedures return the greatest common divisor or least common
multiple of their arguments. The result is always non-negative.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">gcd </span><span class="mi">32</span> <span class="mi">-36</span><span class="p">)</span> <span class="c1">;; =&gt; 4</span>
<span class="p">(</span><span class="nf">gcd</span><span class="p">)</span> <span class="c1">;; =&gt; 0</span>
<span class="p">(</span><span class="nb">lcm </span><span class="mi">32</span> <span class="mi">-36</span><span class="p">)</span> <span class="c1">;; =&gt; 288</span>
<span class="p">(</span><span class="nb">lcm </span><span class="mf">32.0</span> <span class="mi">-36</span><span class="p">)</span> <span class="c1">;; =&gt; 288.0  ; inexact</span>
<span class="p">(</span><span class="nf">lcm</span><span class="p">)</span> <span class="c1">;; =&gt; 1</span>
</pre></div>
<p>(numerator <strong>q</strong>)  procedure
(denominator <strong>q</strong>)  procedure
These procedures return the numerator or denominator of their argument;
the result is computed as if the argument was represented as a fraction
in lowest terms. The denominator is always positive. The denominator of
0 is defined to be 1.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">numerator </span><span class="p">(</span><span class="nb">/ </span><span class="mi">6</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">;; =&gt; 3</span>
<span class="p">(</span><span class="nb">denominator </span><span class="p">(</span><span class="nb">/ </span><span class="mi">6</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">;; =&gt; 2</span>
<span class="p">(</span><span class="nf">denominator</span>
 <span class="p">(</span><span class="nf">inexact</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">6</span> <span class="mi">4</span><span class="p">)))</span> <span class="c1">;; =&gt; 2.0</span>
</pre></div>
<p>(floor <em>x</em>)  procedure
(ceiling <em>x</em>)  procedure
(truncate <em>x</em>)  procedure
(round <em>x</em>)  procedure
These procedures return integers. The floor procedure returns the
largest integer not larger than <em>x</em>. The ceiling procedure returns the
smallest integer not smaller than <em>x</em>, truncate returns the integer
closest to <em>x</em> whose absolute value is not larger than the absolute
value of <em>x</em>, and round returns the closest integer to <em>x</em>, rounding to
even when <em>x</em> is halfway between two integers.</p>
<p><em>Rationale:</em> The round procedure rounds to even for consistency with the
default rounding mode specified by the IEEE 754 IEEE floating-point
standard.</p>
<p><em>Note:</em> If the argument to one of these procedures is inexact, then the
result will also be inexact. If an exact value is needed, the result can
be passed to the exact procedure. If the argument is infinite or a NaN,
then it is returned.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">floor </span><span class="mf">-4.3</span><span class="p">)</span> <span class="c1">;; =&gt; -5.0</span>
<span class="p">(</span><span class="nb">ceiling </span><span class="mf">-4.3</span><span class="p">)</span> <span class="c1">;; =&gt; -4.0</span>
<span class="p">(</span><span class="nb">truncate </span><span class="mf">-4.3</span><span class="p">)</span> <span class="c1">;; =&gt; -4.0</span>
<span class="p">(</span><span class="nb">round </span><span class="mf">-4.3</span><span class="p">)</span> <span class="c1">;; =&gt; -4.0</span>

<span class="p">(</span><span class="nb">floor </span><span class="mf">3.5</span><span class="p">)</span> <span class="c1">;; =&gt; 3.0</span>
<span class="p">(</span><span class="nb">ceiling </span><span class="mf">3.5</span><span class="p">)</span> <span class="c1">;; =&gt; 4.0</span>
<span class="p">(</span><span class="nb">truncate </span><span class="mf">3.5</span><span class="p">)</span> <span class="c1">;; =&gt; 3.0</span>
<span class="p">(</span><span class="nb">round </span><span class="mf">3.5</span><span class="p">)</span> <span class="c1">;; =&gt; 4.0  ; inexact</span>

<span class="p">(</span><span class="nb">round </span><span class="mi">7</span><span class="nv">/2</span><span class="p">)</span> <span class="c1">;; =&gt; 4    ; exact</span>
<span class="p">(</span><span class="nb">round </span><span class="mi">7</span><span class="p">)</span> <span class="c1">;; =&gt; 7</span>
</pre></div>
<p>(rationalize <em>x y</em>)  procedure
The rationalize procedure returns the <em>simplest</em> rational number
differing from <em>x</em> by no more than <em>y</em>. A rational number
<em>r</em><sub>1</sub> is <em>simpler</em> than another rational number
<em>r</em><sub>2</sub> if <em>r</em><sub>1</sub> = <em>p</em><sub>1</sub>/<em>q</em><sub>1</sub> and
<em>r</em><sub>2</sub> = <em>p</em><sub>2</sub>/<em>q</em><sub>2</sub> (in lowest terms) and
|<em>p</em><sub>1</sub>| ≤ |<em>p</em><sub>2</sub>| and
|<em>q</em><sub>1</sub>| ≤ |<em>q</em><sub>2</sub>|. Thus 3/5 is simpler than 4/7.
Although not all rationals are comparable in this ordering (consider 2/7
and 3/5), any interval contains a rational number that is simpler than
every other rational number in that interval (the simpler 2/5 lies
between 2/7 and 3/5). Note that 0 = 0/1 is the simplest rational of all.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">rationalize</span>
 <span class="p">(</span><span class="nf">exact</span> <span class="o">.</span><span class="mi">3</span><span class="p">)</span> <span class="mi">1</span><span class="nv">/10</span><span class="p">)</span> <span class="c1">;; =&gt; 1/3    ; exact</span>
<span class="p">(</span><span class="nb">rationalize </span><span class="o">.</span><span class="mi">3</span> <span class="mi">1</span><span class="nv">/10</span><span class="p">)</span> <span class="c1">;; =&gt; #i1/3  ; inexact</span>
</pre></div>
<p>(exp <strong>z</strong>)  inexact library procedure
(log <strong>z</strong>)  inexact library procedure
(log <strong>z<em><sub>1</sub> </em>z<em><sub>2</sub></em>)  inexact library procedure
(sin </strong>z<strong>)  inexact library procedure
(cos </strong>z<strong>)  inexact library procedure
(tan </strong>z<strong>)  inexact library procedure
(asin </strong>z<strong>)  inexact library procedure
(acos </strong>z<strong>)  inexact library procedure
(atan </strong>z<strong>)  inexact library procedure
(atan </strong>y<em> </em>x*<em>)  inexact library procedure
These procedures compute the usual transcendental functions. The log
procedure computes the natural logarithm of </em>z<em> (not the base ten
logarithm) if a single argument is given, or the base-</em>z<em><sub>2</sub>
logarithm of </em>z*<sub>1</sub> if two arguments are given. The asin, acos,
and atan procedures compute arcsine (sin<sup>−1</sup>), arc-cosine
(cos<sup>−1</sup>), and arctangent (tan<sup>−1</sup>), respectively. The
two-argument variant of atan computes <code>(angle (make-rectangular x y))</code>
(see below), even in implementations that don’t support complex numbers.</p>
<p>In general, the mathematical functions log, arcsine, arc-cosine, and
arctangent are multiply defined. The value of log <em>z</em> is defined to be
the one whose imaginary part lies in the range from  − <em>π</em> (inclusive if
-0.0 is distinguished, exclusive otherwise) to <em>π</em> (inclusive). The
value of log 0 is mathematically undefined. With log  defined this way,
the values of sin<sup>−1</sup><em>z</em>, cos<sup>−1</sup><em>z</em>, and
tan<sup>−1</sup><em>z</em> are according to the following formulæ:
$$\sin^{- 1}z = - i\log\left( iz + \sqrt{1 - z^{2}} \right)$$
cos<sup>−1</sup><em>z</em> = <em>π</em>/2 − sin<sup>−1</sup><em>z</em>
tan<sup>−1</sup><em>z</em> = (log(1+<em>i**z</em>)−log(1−<em>i**z</em>))/(2<em>i</em>)</p>
<p>However, (log 0.0) returns -inf.0 (and (log -0.0) returns -inf.0+<em>π</em>i)
if the implementation supports infinities (and -0.0).</p>
<p>The range of (atan <em>y</em> <em>x</em>) is as in the following table. The asterisk
(*) indicates that the entry applies to implementations that
distinguish minus zero.</p>
<div class="center">

|     | *y* condition | *x* condition | range of result *r*                |
|:---:|:--------------|:--------------|:-----------------------------------|
|     | *y* = 0.0     | *x* \> 0.0    | 0.0                                |
| \*  | *y* =  + 0.0  | *x* \> 0.0    |  + 0.0                             |
| \*  | *y* =  − 0.0  | *x* \> 0.0    |  − 0.0                             |
|     | *y* \> 0.0    | *x* \> 0.0    | $0.0 \< r \< \\frac{\\pi}{2}$      |
|     | *y* \> 0.0    | *x* = 0.0     | $\\frac{\\pi}{2}$                  |
|     | *y* \> 0.0    | *x* \< 0.0    | $\\frac{\\pi}{2} \< r \< \\pi$     |
|     | *y* = 0.0     | *x* \< 0      | *π*                                |
| \*  | *y* =  + 0.0  | *x* \< 0.0    | *π*                                |
| \*  | *y* =  − 0.0  | *x* \< 0.0    |  − *π*                             |
|     | *y* \< 0.0    | *x* \< 0.0    | $- \\pi \< r \< - \\frac{\\pi}{2}$ |
|     | *y* \< 0.0    | *x* = 0.0     | $- \\frac{\\pi}{2}$                |
|     | *y* \< 0.0    | *x* \> 0.0    | $- \\frac{\\pi}{2} \< r \< 0.0$    |
|     | *y* = 0.0     | *x* = 0.0     | undefined                          |
| \*  | *y* =  + 0.0  | *x* =  + 0.0  |  + 0.0                             |
| \*  | *y* =  − 0.0  | *x* =  + 0.0  |  − 0.0                             |
| \*  | *y* =  + 0.0  | *x* =  − 0.0  | *π*                                |
| \*  | *y* =  − 0.0  | *x* =  − 0.0  |  − *π*                             |
| \*  | *y* =  + 0.0  | *x* = 0       | $\\frac{\\pi}{2}$                  |
| \*  | *y* =  − 0.0  | *x* = 0       | $- \\frac{\\pi}{2}$                |

</div><p>The above specification follows <span class="citation"
cites="CLtL"></span>, which in turn cites <span class="citation"
cites="Penfield81"></span>; refer to these sources for more detailed
discussion of branch cuts, boundary conditions, and implementation of
these functions. When it is possible, these procedures produce a real
result from a real argument.</p>
<p>(square <strong>z</strong>)  procedure
Returns the square of <em>z</em>. This is equivalent to (* <em>z</em> <em>z</em>).</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">square</span> <span class="mi">42</span><span class="p">)</span> <span class="c1">;; =&gt; 1764</span>
<span class="p">(</span><span class="nf">square</span> <span class="mf">2.0</span><span class="p">)</span> <span class="c1">;; =&gt; 4.0</span>
</pre></div>
<p>(sqrt <strong>z</strong>)  inexact library procedure
Returns the principal square root of <em>z</em>. The result will have either a
positive real part, or a zero real part and a non-negative imaginary
part.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">sqrt </span><span class="mi">9</span><span class="p">)</span> <span class="c1">;; =&gt; 3</span>
<span class="p">(</span><span class="nb">sqrt </span><span class="mi">-1</span><span class="p">)</span> <span class="c1">;; =&gt; +i</span>
</pre></div>
<p>(exact-integer-sqrt <em>k</em>)  procedure
Returns two non-negative exact integers <em>s</em> and <em>r</em> where <span
class="math inline">$\\hbox{\\it{}k\\/} = s^2 + r$</span> and <span
class="math inline">$\\hbox{\\it{}k\\/} \< (s+1)^2$</span>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">exact-integer-sqrt</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">;; =&gt; 2 0</span>
<span class="p">(</span><span class="nf">exact-integer-sqrt</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">;; =&gt; 2 1</span>
</pre></div>
<p>(expt *<em>z</em><sub>1</sub> <em>z</em><sub>2</sub><em>)  procedure
Returns </em>z<em><sub>1</sub> raised to the power </em>z<em><sub>2</sub>. For nonzero</em>z<em><sub>1</sub>, this is</em>z<em><sub>1</sub><sup></em>z<em><sub>2</sub>&lt;/sup&gt; = </em>e<em><sup></em>z<em><sub>2</sub>log </em>z<em><sub>1</sub>&lt;/sup&gt;
The value of 0<sup></em>z<em>&lt;/sup&gt; is 1 if (zero? z), 0 if (real-part z) is
positive, and an error otherwise. Similarly for 0.0<sup></em>z*&lt;/sup&gt;, with
inexact results.</p>
<p>(make-rectangular <strong>x<em><sub>1</sub> </em>x<em><sub>2</sub></em>)
 complex library procedure
(make-polar </strong>x<em><sub>3</sub> </em>x<em><sub>4</sub></em>)
 complex library procedure
(real-part <strong>z</strong>)  complex library procedure
(imag-part <strong>z</strong>)  complex library procedure
(magnitude <strong>z</strong>)  complex library procedure
(angle <strong>z</strong>)  complex library procedure
Let <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>, and
<em>x</em><sub>4</sub> be real numbers and <em>z</em> be a complex number such that
<span class="math display">$${\\hbox{$z$\\/}} = {\\hbox{$x_1$\\/}} +
{\\hbox{$x_2$\\/}}\\hbox{$i$} = {\\hbox{$x_3$\\/}} \\cdot e^{i
x_4}$$</span> Then all of</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">make-rectangular </span><span class="err">\</span><span class="nv">vri</span><span class="err">{</span><span class="nv">x</span><span class="err">}</span> <span class="err">\</span><span class="nv">vrii</span><span class="err">{</span><span class="nv">x</span><span class="err">}</span><span class="p">)</span> <span class="c1">;; =&gt; \vr{z}</span>
<span class="p">(</span><span class="nb">make-polar </span><span class="err">\</span><span class="nv">vriii</span><span class="err">{</span><span class="nv">x</span><span class="err">}</span> <span class="err">\</span><span class="nv">vriv</span><span class="err">{</span><span class="nv">x</span><span class="err">}</span><span class="p">)</span> <span class="c1">;; =&gt; \vr{z}</span>
<span class="p">(</span><span class="nb">real-part </span><span class="err">\</span><span class="nv">vr</span><span class="err">{</span><span class="nv">z</span><span class="err">}</span><span class="p">)</span> <span class="c1">;; =&gt; \vri{x}</span>
<span class="p">(</span><span class="nb">imag-part </span><span class="err">\</span><span class="nv">vr</span><span class="err">{</span><span class="nv">z</span><span class="err">}</span><span class="p">)</span> <span class="c1">;; =&gt; \vrii{x}</span>
<span class="p">(</span><span class="nb">magnitude </span><span class="err">\</span><span class="nv">vr</span><span class="err">{</span><span class="nv">z</span><span class="err">}</span><span class="p">)</span> <span class="c1">;; =&gt; $|\vriii{x}|$</span>
<span class="p">(</span><span class="nb">angle </span><span class="err">\</span><span class="nv">vr</span><span class="err">{</span><span class="nv">z</span><span class="err">}</span><span class="p">)</span> <span class="c1">;; =&gt; $x_{angle}$</span>
</pre></div>
<p>are true, where  − <em>π</em> ≤ <em>x</em><sub>*a**n**g**l**e*</sub> ≤ <em>π</em> with <span
class="math inline">$x_{angle} = {\\hbox{$x_4$\\/}} + 2\\pi n$</span>
for some integer <em>n</em>.</p>
<p>The make-polar procedure may return an inexact complex number even if
its arguments are exact. The real-part and imag-part procedures may
return exact real numbers when applied to an inexact complex number if
the corresponding argument passed to make-rectangular was exact.</p>
<p><em>Rationale:</em> The magnitude procedure is the same as <code>abs</code> for a real
argument, but abs is in the base library, whereas magnitude is in the
optional complex library.</p>
<p>(inexact <strong>z</strong>)  procedure
(exact <strong>z</strong>)  procedure
The procedure inexact returns an inexact representation of <em>z</em>. The
value returned is the inexact number that is numerically closest to the
argument. For inexact arguments, the result is the same as the argument.
For exact complex numbers, the result is a complex number whose real and
imaginary parts are the result of applying inexact to the real and
imaginary parts of the argument, respectively. If an exact argument has
no reasonably close inexact equivalent (in the sense of =), then a
violation of an implementation restriction may be reported.</p>
<p>The procedure exact returns an exact representation of <em>z</em>. The value
returned is the exact number that is numerically closest to the
argument. For exact arguments, the result is the same as the argument.
For inexact non-integral real arguments, the implementation may return a
rational approximation, or may report an implementation violation. For
inexact complex arguments, the result is a complex number whose real and
imaginary parts are the result of applying exact to the real and
imaginary parts of the argument, respectively. If an inexact argument
has no reasonably close exact equivalent, (in the sense of =), then a
violation of an implementation restriction may be reported.</p>
<p>These procedures implement the natural one-to-one correspondence between
exact and inexact integers throughout an implementation-dependent range.
See section <a href="#restrictions">[restrictions]</a>.</p>
<p><em>Note:</em> These procedures were known in R<sup><small>5</small></sup>RS as exact-&gt;inexact
and inexact-&gt;exact, respectively, but they have always accepted
arguments of any exactness. The new names are clearer and shorter, as
well as being compatible with R<sup><small>6</small></sup>RS.</p>
<h4>Numerical input and output</h4>
<p>(number-&gt;string <em>z</em>)  procedure
(number-&gt;string <em>z radix</em>)  procedure
It is an error if <em>r<strong>a</strong>d<strong>i</strong>x</em> is not one of 2, 8, 10, or 16.</p>
<p>The procedure numberstring takes a number and a radix and returns as a
string an external representation of the given number in the given radix
such that</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">number</span> <span class="err">\</span><span class="nv">vr</span><span class="err">{</span><span class="nv">number</span><span class="err">}</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">radix</span> <span class="err">\</span><span class="nv">vr</span><span class="err">{</span><span class="nv">radix</span><span class="err">}</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">eqv? </span><span class="nv">number</span>
        <span class="p">(</span><span class="nb">string-&gt;number </span><span class="p">(</span><span class="nb">number-&gt;string </span><span class="nv">number</span>
                                        <span class="nv">radix</span><span class="p">)</span>
                        <span class="nv">radix</span><span class="p">)))</span>
</pre></div>
<p>is true. It is an error if no possible result makes this expression
true. If omitted, <em>r<strong>a</strong>d<strong>i</strong>x</em> defaults to 10.</p>
<p>If <em>z</em> is inexact, the radix is 10, and the above expression can be
satisfied by a result that contains a decimal point, then the result
contains a decimal point and is expressed using the minimum number of
digits (exclusive of exponent and trailing zeroes) needed to make the
above expression true <span class="citation"
cites="howtoprint howtoread"></span>; otherwise the format of the result
is unspecified.</p>
<p>The result returned by numberstring never contains an explicit radix
prefix.</p>
<p><em>Note:</em> The error case can occur only when <em>z</em> is not a complex number
or is a complex number with a non-rational real or imaginary part.</p>
<p><em>Rationale:</em> If <em>z</em> is an inexact number and the radix is 10, then the
above expression is normally satisfied by a result containing a decimal
point. The unspecified case allows for infinities, NaNs, and unusual
representations.</p>
<p>(string-&gt;number <em>string</em>)  procedure
(string-&gt;number <em>string radix</em>)  procedure
Returns a number of the maximally precise representation expressed by
the given <em>s<strong>t</strong>r<strong>i</strong>n**g</em>. It is an error if <em>r<strong>a</strong>d<strong>i</strong>x</em> is not
2, 8, 10, or 16.</p>
<p>If supplied, <em>r<strong>a</strong>d<strong>i</strong>x</em> is a default radix that will be overridden
if an explicit radix prefix is present in <em>s<strong>t</strong>r<strong>i</strong>n**g</em> (e.g.
<code>"#o177"</code>). If <em>r<strong>a</strong>d<strong>i</strong>x</em> is not supplied, then the default radix
is 10. If <em>s<strong>t</strong>r<strong>i</strong>n**g</em> is not a syntactically valid notation for a
number, or would result in a number that the implementation cannot
represent, then string-&gt;number returns #f. An error is never signaled
due to the content of <em>s<strong>t</strong>r<strong>i</strong>n**g</em>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">string-&gt;number </span><span class="s">&quot;100&quot;</span><span class="p">)</span> <span class="c1">;; =&gt; 100</span>
<span class="p">(</span><span class="nb">string-&gt;number </span><span class="s">&quot;100&quot;</span> <span class="mi">16</span><span class="p">)</span> <span class="c1">;; =&gt; 256</span>
<span class="p">(</span><span class="nb">string-&gt;number </span><span class="s">&quot;1e2&quot;</span><span class="p">)</span> <span class="c1">;; =&gt; 100.0</span>
</pre></div>
<p><em>Note:</em> The domain of string-&gt;number may be restricted by
implementations in the following ways. If all numbers supported by an
implementation are real, then string-&gt;number is permitted to return #f
whenever <em>s<strong>t</strong>r<strong>i</strong>n**g</em> uses the polar or rectangular notations for
complex numbers. If all numbers are integers, then string-&gt;number may
return <code>#f</code> whenever the fractional notation is used. If all numbers are
exact, then string-&gt;number may return <code>#f</code> whenever an exponent marker or
explicit exactness prefix is used. If all inexact numbers are integers,
then string-&gt;number may return <code>#f</code> whenever a decimal point is used.</p>
<p>The rules used by a particular implementation for string-&gt;number must
also be applied to read and to the routine that reads programs, in order
to maintain consistency between internal numeric processing, I/O, and
the processing of programs. As a consequence, the
R<sup><small>5</small></sup>RS permission to return <code>#f</code> when <em>string</em> has an explicit
radix prefix has been withdrawn.</p>
<h3>Booleans</h3>
<p>The standard boolean objects for true and false are written as <code>#t</code> and</p>
<h1>f. Alternatively, they can be written #true and #false, respectively.</h1>
<p>What really matters, though, are the objects that the Scheme conditional
expressions (if, cond, and, or, when, unless, do) treat as true or
false. The phrase “a true value” (or sometimes just “true”) means any
object treated as true by the conditional expressions, and the phrase “a
false value” (or “false”) means any object treated as false by the
conditional expressions.</p>
<p>Of all the Scheme values, only <code>#f</code> counts as false in conditional
expressions. All other Scheme values, including #t, count as true.</p>
<p><em>Note:</em> Unlike some other dialects of Lisp, Scheme distinguishes <code>#f</code> and
the empty list from each other and from the symbol <code>nil</code>.</p>
<p>Boolean constants evaluate to themselves, so they do not need to be
quoted in programs.</p>
<div class="highlight"><pre><span></span><span class="no">#t</span> <span class="c1">;; =&gt; #t</span>
<span class="no">#f</span> <span class="c1">;; =&gt; #f</span>
<span class="o">&#39;</span><span class="no">#f</span> <span class="c1">;; =&gt; #f</span>
</pre></div>
<p>(not <em>obj</em>)  procedure
The not procedure returns <code>#t</code> if <em>obj</em> is false, and returns #f
otherwise.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">not </span><span class="no">#t</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">not </span><span class="mi">3</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">list </span><span class="mi">3</span><span class="p">))</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">not </span><span class="no">#f</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">not </span><span class="o">&#39;</span><span class="p">())</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">list</span><span class="p">))</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">not </span><span class="ss">&#39;nil</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
</pre></div>
<p>(boolean? <em>obj</em>)  procedure
The boolean? predicate returns <code>#t</code> if <em>obj</em> is either <code>#t</code> or <code>#f</code> and
returns <code>#f</code> otherwise.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">boolean? </span><span class="no">#f</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">boolean? </span><span class="mi">0</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">boolean? </span><span class="o">&#39;</span><span class="p">())</span> <span class="c1">;; =&gt; #f</span>
</pre></div>
<p>(boolean=? *<em>boolean<sub>1</sub></em> <em>boolean<sub>2</sub></em> <em>boolean<sub>3</sub></em> … *)
 procedure
Returns <code>#t</code> if all the arguments are <code>#t</code> or all are #f.</p>
<h3>Pairs and lists</h3>
<p>A <em>pair</em> (sometimes called a <em>dotted pair</em>) is a record structure with
two fields called the car and cdr fields (for historical reasons). Pairs
are created by the procedure cons. The car and cdr fields are accessed
by the procedures car and cdr. The car and cdr fields are assigned by
the procedures set-car! and set-cdr!.</p>
<p>Pairs are used primarily to represent lists. A <em>list</em> can be defined
recursively as either the empty list or a pair whose cdr is a list. More
precisely, the set of lists is defined as the smallest set <em>X</em> such that</p>
<ul>
<li><p>The empty list is in <em>X</em>.</p>
</li>
<li><p>If <em>list</em> is in <em>X</em>, then any pair whose cdr field contains <em>list</em>
is also in <em>X</em>.</p>
</li>
</ul>
<p>The objects in the car fields of successive pairs of a list are the
elements of the list. For example, a two-element list is a pair whose
car is the first element and whose cdr is a pair whose car is the second
element and whose cdr is the empty list. The length of a list is the
number of elements, which is the same as the number of pairs.</p>
<p>The empty list is a special object of its own type. It is not a pair, it
has no elements, and its length is zero.</p>
<p><em>Note:</em> The above definitions imply that all lists have finite length
and are terminated by the empty list.</p>
<p>The most general notation (external representation) for Scheme pairs is
the “dotted” notation (<em>c<sub>1</sub></em> . <em>c<sub>2</sub></em>) where
<em>c<sub>1</sub></em> is the value of the car field and <em>c<sub>2</sub></em> is the
value of the cdr field. For example (4 . 5) is a pair whose car is 4 and
whose cdr is 5. Note that (4 . 5) is the external representation of a
pair, not an expression that evaluates to a pair.</p>
<p>A more streamlined notation can be used for lists: the elements of the
list are simply enclosed in parentheses and separated by spaces. The
empty list is written <code>()</code>. For example,</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span><span class="p">)</span>
</pre></div>
<p>and</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">a</span> <span class="o">.</span> <span class="p">(</span><span class="nf">b</span> <span class="o">.</span> <span class="p">(</span><span class="nf">c</span> <span class="o">.</span> <span class="p">(</span><span class="nf">d</span> <span class="o">.</span> <span class="p">(</span><span class="nf">e</span> <span class="o">.</span> <span class="p">())))))</span>
</pre></div>
<p>are equivalent notations for a list of symbols.</p>
<p>A chain of pairs not ending in the empty list is called an <em>improper
list</em>. Note that an improper list is not a list. The list and dotted
notations can be combined to represent improper lists:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="o">.</span> <span class="nv">d</span><span class="p">)</span>
</pre></div>
<p>is equivalent to</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">a</span> <span class="o">.</span> <span class="p">(</span><span class="nf">b</span> <span class="o">.</span> <span class="p">(</span><span class="nf">c</span> <span class="o">.</span> <span class="nv">d</span><span class="p">)))</span>
</pre></div>
<p>Whether a given pair is a list depends upon what is stored in the cdr
field. When the <code>set-cdr!</code> procedure is used, an object can be a list
one moment and not the next:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">y</span> <span class="nv">x</span><span class="p">)</span>
<span class="nv">y</span> <span class="c1">;; =&gt; (a b c)</span>
<span class="p">(</span><span class="nb">list? </span><span class="nv">y</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">x</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">;; =&gt; unspecified</span>
<span class="nv">x</span> <span class="c1">;; =&gt; (a . 4)</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="nv">y</span> <span class="c1">;; =&gt; (a . 4)</span>
<span class="p">(</span><span class="nb">list? </span><span class="nv">y</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">list? </span><span class="nv">x</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
</pre></div>
<p>Within literal expressions and representations of objects read by the
<code>read</code> procedure, the forms <code>’</code>datum, <code>`datum,</code>,<code>datum, and</code>,@<code>datum
denote two-element lists whose first elements are the symbols</code>quote<code>,</code>quasiquote<code>,</code>unquote<code>, and</code>unquote-splicing`, respectively. The
second element in each case is datum. This convention is supported so
that arbitrary Scheme programs can be represented as lists. That is,
according to Scheme’s grammar, every expression is also a datum (see
section <a href="#datum">[datum]</a>). Among other things, this permits the use
of the read procedure to parse Scheme programs. See
section <a href="#externalreps">[externalreps]</a>.</p>
<p>(pair? <em>obj</em>)  procedure
The pair? predicate returns <code>#t</code> if <em>obj</em> is a pair, and otherwise returns</p>
<h1>f.</h1>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">pair? </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="o">.</span> <span class="nv">b</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">pair? </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">pair? </span><span class="o">&#39;</span><span class="p">())</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">pair? </span><span class="o">&#39;#</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span> <span class="c1">;; =&gt; #f</span>
</pre></div>
<p>(cons <strong>obj<sub>1</sub><em> </em>obj<sub>2</sub></strong>)  procedure
Returns a newly allocated pair whose car is <em>obj<sub>1</sub></em> and whose
cdr is <em>obj<sub>2</sub></em>. The pair is guaranteed to be different (in the
sense of eqv?) from every existing object.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">())</span> <span class="c1">;; =&gt; (a)</span>
<span class="p">(</span><span class="nb">cons </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span> <span class="c1">;; =&gt; ((a) b c d)</span>
<span class="p">(</span><span class="nb">cons </span><span class="s">&quot;a&quot;</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">))</span> <span class="c1">;; =&gt; (&quot;a&quot; b c)</span>
<span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;a</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">;; =&gt; (a . 3)</span>
<span class="p">(</span><span class="nb">cons </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="ss">&#39;c</span><span class="p">)</span> <span class="c1">;; =&gt; ((a b) . c)</span>
</pre></div>
<p>(car <em>pair</em>)  procedure
Returns the contents of the car field of <em>pair</em>. Note that it is an
error to take the car of the empty list.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">car </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span> <span class="c1">;; =&gt; a</span>
<span class="p">(</span><span class="nb">car </span><span class="o">&#39;</span><span class="p">((</span><span class="nf">a</span><span class="p">)</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span> <span class="c1">;; =&gt; (a)</span>
<span class="p">(</span><span class="nb">car </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="o">.</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">;; =&gt; 1</span>
<span class="p">(</span><span class="nb">car </span><span class="o">&#39;</span><span class="p">())</span> <span class="c1">;; =&gt; error</span>
</pre></div>
<p>(cdr <em>pair</em>)  procedure
Returns the contents of the cdr field of <em>pair</em>. Note that it is an
error to take the cdr of the empty list.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">cdr </span><span class="o">&#39;</span><span class="p">((</span><span class="nf">a</span><span class="p">)</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span> <span class="c1">;; =&gt; (b c d)</span>
<span class="p">(</span><span class="nb">cdr </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="o">.</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">;; =&gt; 2</span>
<span class="p">(</span><span class="nb">cdr </span><span class="o">&#39;</span><span class="p">())</span> <span class="c1">;; =&gt; error</span>
</pre></div>
<p>(set-car! <em>pair obj</em>)  procedure
Stores <em>obj</em> in the car field of <em>pair</em>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;not-a-constant-list</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">g</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">constant-list</span><span class="p">))</span>
<span class="p">(</span><span class="nb">set-car! </span><span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">set-car! </span><span class="p">(</span><span class="nf">g</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">;; =&gt; error</span>
</pre></div>
<p>(set-cdr! <em>pair obj</em>)  procedure
Stores <em>obj</em> in the cdr field of <em>pair</em>.</p>
<p><code>(cadr pair)</code> procedure</p>
<p>(caar <em>pair</em>)  procedure
(cadr <em>pair</em>)  procedure
(cdar <em>pair</em>)  procedure
(cddr <em>pair</em>)  procedure
These procedures are compositions of car and cdr as follows:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">caar </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">cdar </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">cddr </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">)))</span>
</pre></div>
<p>(caaar <em>pair</em>)  cxr library procedure
(caadr <em>pair</em>)  cxr library procedure
to 1 ⋮  to 1 ⋮
(cdddar <em>pair</em>)  cxr library procedure
(cddddr <em>pair</em>)  cxr library procedure
These twenty-four procedures are further compositions of car and cdr on
the same principles. For example, caddr could be defined by</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">caddr</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">)))))</span>
</pre></div>
<p>Arbitrary compositions up to four deep are provided.</p>
<p>(null? <em>obj</em>)  procedure
Returns <code>#t</code> if <em>obj</em> is the empty list, otherwise returns #f.</p>
<p>(list? <em>obj</em>)  procedure
Returns <code>#t</code> if <em>obj</em> is a list. Otherwise, it returns #f. By definition,
all lists have finite length and are terminated by the empty list.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">list? </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">list? </span><span class="o">&#39;</span><span class="p">())</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">list? </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="o">.</span> <span class="nv">b</span><span class="p">))</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">x</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">list? </span><span class="nv">x</span><span class="p">))</span> <span class="c1">;; =&gt; #f</span>
</pre></div>
<p>(make-list <em>k</em>)  procedure
(make-list <em>k fill</em>)  procedure
Returns a newly allocated list of <em>k</em> elements. If a second argument is
given, then each element is initialized to <em>fill</em>. Otherwise the initial
contents of each element is unspecified.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">make-list</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">;; =&gt; (3 3)</span>
</pre></div>
<p>(list *<em>obj</em> … *)  procedure
Returns a newly allocated list of its arguments.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="ss">&#39;c</span><span class="p">)</span> <span class="c1">;; =&gt; (a 7 c)</span>
<span class="p">(</span><span class="nf">list</span><span class="p">)</span> <span class="c1">;; =&gt; ()</span>
</pre></div>
<p>(length <em>list</em>)  procedure
Returns the length of <em>list</em>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">length </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span> <span class="c1">;; =&gt; 3</span>
<span class="p">(</span><span class="nb">length </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nf">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">c</span> <span class="nv">d</span> <span class="nv">e</span><span class="p">)))</span> <span class="c1">;; =&gt; 3</span>
<span class="p">(</span><span class="nb">length </span><span class="o">&#39;</span><span class="p">())</span> <span class="c1">;; =&gt; 0</span>
</pre></div>
<p>(append <em>list … </em>)  procedure
The last argument, if there is one, can be of any type.</p>
<p>Returns a list consisting of the elements of the first <em>list</em> followed
by the elements of the other <em>list</em>s. If there are no arguments, the
empty list is returned. If there is exactly one argument, it is
returned. Otherwise the resulting list is always newly allocated, except
that it shares structure with the last argument. An improper list
results if the last argument is not a proper list.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">append </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">y</span><span class="p">))</span> <span class="c1">;; =&gt; (x y)</span>
<span class="p">(</span><span class="nb">append </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span> <span class="c1">;; =&gt; (a b c d)</span>
<span class="p">(</span><span class="nb">append </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nf">b</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">((</span><span class="nf">c</span><span class="p">)))</span> <span class="c1">;; =&gt; (a (b) (c))</span>

<span class="p">(</span><span class="nb">append </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="o">.</span> <span class="nv">d</span><span class="p">))</span> <span class="c1">;; =&gt; (a b c . d)</span>
<span class="p">(</span><span class="nb">append </span><span class="o">&#39;</span><span class="p">()</span> <span class="ss">&#39;a</span><span class="p">)</span> <span class="c1">;; =&gt; a</span>
</pre></div>
<p>(reverse <em>list</em>)  procedure
Returns a newly allocated list consisting of the elements of <em>list</em> in
reverse order.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">reverse </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span> <span class="c1">;; =&gt; (c b a)</span>
<span class="p">(</span><span class="nb">reverse </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nf">b</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">d</span> <span class="p">(</span><span class="nf">e</span> <span class="p">(</span><span class="nf">f</span><span class="p">))))</span> <span class="c1">;; =&gt; ((e (f)) d (b c) a)</span>
</pre></div>
<p>(list-tail <em>list </em>k*<em>)  procedure
It is an error if </em>list<em> has fewer than </em>k* elements.</p>
<p>Returns the sublist of <em>list</em> obtained by omitting the first <em>k</em>
elements. The list-tail procedure could be defined by</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">list-tail</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">k</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">zero? </span><span class="nv">k</span><span class="p">)</span>
        <span class="nv">x</span>
        <span class="p">(</span><span class="nb">list-tail </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">k</span> <span class="mi">1</span><span class="p">)))))</span>
</pre></div>
<p>(list-ref <em>list </em>k*<em>)  procedure
The </em>list<em> argument can be circular, but it is an error if </em>list<em> has</em>k* or fewer elements.</p>
<p>Returns the <em>k</em>th element of <em>list</em>. (This is the same as the car of
<code>(list-tail list k)</code>.)</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">list-ref </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; =&gt; c</span>
<span class="p">(</span><span class="nb">list-ref </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">exact</span> <span class="p">(</span><span class="nb">round </span><span class="mf">1.8</span><span class="p">)))</span> <span class="c1">;; =&gt; c</span>
</pre></div>
<p>(list-set! <em>list k obj</em>)  procedure
It is an error if <em>k</em> is not a valid index of <em>list</em>.</p>
<p>The list-set! procedure stores <em>obj</em> in element <em>k</em> of <em>list</em>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">ls</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;one</span> <span class="ss">&#39;two</span> <span class="ss">&#39;five!</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">list-set!</span> <span class="nv">ls</span> <span class="mi">2</span> <span class="ss">&#39;three</span><span class="p">)</span>
  <span class="nv">ls</span><span class="p">)</span> <span class="c1">;; =&gt; (one two three)</span>

<span class="p">(</span><span class="nf">list-set!</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">1</span> <span class="s">&quot;oops&quot;</span><span class="p">)</span> <span class="c1">;; =&gt; error  ; constant list</span>
</pre></div>
<p>(memq <em>obj list</em>)  procedure
(memv <em>obj list</em>)  procedure
(member <em>obj list</em>)  procedure
(member <em>obj list compare</em>)  procedure
These procedures return the first sublist of <em>list</em> whose car is <em>obj</em>,
where the sublists of <em>list</em> are the non-empty lists returned by
<code>(list-tail list k)</code> for <em>k</em> less than the length of <em>list</em>. If <em>obj</em>
does not occur in <em>list</em>, then <code>#f</code> (not the empty list) is returned. The
memq procedure uses eq? to compare <em>obj</em> with the elements of <em>list</em>,
while memv uses eqv? and member uses <em>compare</em>, if given, and equal?
otherwise.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">memq </span><span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span> <span class="c1">;; =&gt; (a b c)</span>
<span class="p">(</span><span class="nb">memq </span><span class="ss">&#39;b</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span> <span class="c1">;; =&gt; (b c)</span>
<span class="p">(</span><span class="nb">memq </span><span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">memq </span><span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="p">(</span><span class="nf">a</span><span class="p">)</span> <span class="nv">c</span><span class="p">))</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">member </span><span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a</span><span class="p">)</span>
        <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="p">(</span><span class="nf">a</span><span class="p">)</span> <span class="nv">c</span><span class="p">))</span> <span class="c1">;; =&gt; ((a) c)</span>
<span class="p">(</span><span class="nb">member </span><span class="s">&quot;B&quot;</span>
        <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;a&quot;</span> <span class="s">&quot;b&quot;</span> <span class="s">&quot;c&quot;</span><span class="p">)</span>
        <span class="nv">string-ci=?</span><span class="p">)</span> <span class="c1">;; =&gt; (&quot;b&quot; &quot;c&quot;)</span>
<span class="p">(</span><span class="nb">memq </span><span class="mi">101</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">100</span> <span class="mi">101</span> <span class="mi">102</span><span class="p">))</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">memv </span><span class="mi">101</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">100</span> <span class="mi">101</span> <span class="mi">102</span><span class="p">))</span> <span class="c1">;; =&gt; (101 102)</span>
</pre></div>
<p>(assq <em>obj alist</em>)  procedure
(assv <em>obj alist</em>)  procedure
(assoc <em>obj alist</em>)  procedure
(assoc <em>obj alist compare</em>)  procedure
It is an error if <em>alist</em> (for “association list”) is not a list of
pairs.</p>
<p>These procedures find the first pair in <em>alist</em> whose car field is
<em>obj</em>, and returns that pair. If no pair in <em>alist</em> has <em>obj</em> as its
car, then <code>#f</code> (not the empty list) is returned. The assq procedure uses
eq? to compare <em>obj</em> with the car fields of the pairs in <em>alist</em>, while
assv uses eqv? and assoc uses <em>compare</em> if given and equal? otherwise.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">e</span> <span class="o">&#39;</span><span class="p">((</span><span class="nf">a</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">b</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">c</span> <span class="mi">3</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assq </span><span class="ss">&#39;a</span> <span class="nv">e</span><span class="p">)</span> <span class="c1">;; =&gt; (a 1)</span>
<span class="p">(</span><span class="nb">assq </span><span class="ss">&#39;b</span> <span class="nv">e</span><span class="p">)</span> <span class="c1">;; =&gt; (b 2)</span>
<span class="p">(</span><span class="nb">assq </span><span class="ss">&#39;d</span> <span class="nv">e</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">assq </span><span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(((</span><span class="nf">a</span><span class="p">))</span> <span class="p">((</span><span class="nf">b</span><span class="p">))</span> <span class="p">((</span><span class="nf">c</span><span class="p">))))</span>
<span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">assoc </span><span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(((</span><span class="nf">a</span><span class="p">))</span> <span class="p">((</span><span class="nf">b</span><span class="p">))</span> <span class="p">((</span><span class="nf">c</span><span class="p">))))</span>
<span class="c1">;; =&gt; ((a))</span>
<span class="p">(</span><span class="nb">assoc </span><span class="mf">2.0</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">9</span><span class="p">))</span> <span class="nv">=</span><span class="p">)</span>
<span class="c1">;; =&gt; (2 4)</span>
<span class="p">(</span><span class="nb">assq </span><span class="mi">5</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">11</span> <span class="mi">13</span><span class="p">)))</span>
<span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">assv </span><span class="mi">5</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">11</span> <span class="mi">13</span><span class="p">)))</span>
<span class="c1">;; =&gt; (5 7)</span>
</pre></div>
<p><em>Rationale:</em> Although they are often used as predicates, memq, memv,
member, assq, assv, and assoc do not have question marks in their names
because they return potentially useful values rather than just <code>#t</code> or #f.</p>
<p>(list-copy <em>obj</em>)  procedure
Returns a newly allocated copy of the given <em>obj</em> if it is a list. Only
the pairs themselves are copied; the cars of the result are the same (in
the sense of eqv?) as the cars of <em>list</em>. If <em>obj</em> is an improper list,
so is the result, and the final cdrs are the same in the sense of eqv?.
An <em>obj</em> which is not a list is returned unchanged. It is an error if
<em>obj</em> is a circular list.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">8</span> <span class="mi">2</span> <span class="mi">8</span><span class="p">))</span> <span class="c1">; a may be immutable</span>
<span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="p">(</span><span class="nf">list-copy</span> <span class="nv">a</span><span class="p">))</span>
<span class="p">(</span><span class="nb">set-car! </span><span class="nv">b</span> <span class="mi">3</span><span class="p">)</span>        <span class="c1">; b is mutable</span>
<span class="nv">b</span> <span class="c1">;; =&gt; (3 8 2 8)</span>
<span class="nv">a</span> <span class="c1">;; =&gt; (1 8 2 8)</span>
</pre></div>
<h3>Symbols</h3>
<p>Symbols are objects whose usefulness rests on the fact that two symbols
are identical (in the sense of eqv?) if and only if their names are
spelled the same way. For instance, they can be used the way enumerated
values are used in other languages.</p>
<p>The rules for writing a symbol are exactly the same as the rules for
writing an identifier; see sections <a href="#syntaxsection">[syntaxsection]</a>
and <a href="#identifiersyntax">[identifiersyntax]</a>.</p>
<p>It is guaranteed that any symbol that has been returned as part of a
literal expression, or read using the read procedure, and subsequently
written out using the write procedure, will read back in as the
identical symbol (in the sense of eqv?).</p>
<p><em>Note:</em> Some implementations have values known as “uninterned symbols,”
which defeat write/read invariance, and also violate the rule that two
symbols are the same if and only if their names are spelled the same.
This report does not specify the behavior of implementation-dependent
extensions.</p>
<p>(symbol? <em>obj</em>)  procedure
Returns <code>#t</code> if <em>obj</em> is a symbol, otherwise returns #f.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">symbol? </span><span class="ss">&#39;foo</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">symbol? </span><span class="p">(</span><span class="nb">car </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">symbol? </span><span class="s">&quot;bar&quot;</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">symbol? </span><span class="ss">&#39;nil</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">symbol? </span><span class="o">&#39;</span><span class="p">())</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">symbol? </span><span class="no">#f</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
</pre></div>
<p>(symbol=? *<em>symbol<sub>1</sub></em> <em>symbol<sub>2</sub></em> <em>symbol<sub>3</sub></em> … *)
 procedure
Returns <code>#t</code> if all the arguments all have the same names in the sense of
string=?.</p>
<p><em>Note:</em> The definition above assumes that none of the arguments are
uninterned symbols.</p>
<p>(symbol-&gt;string <em>symbol</em>)  procedure
Returns the name of <em>symbol</em> as a string, but without adding escapes. It
is an error to apply mutation procedures like <code>string-set!</code> to strings
returned by this procedure.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="ss">&#39;flying-fish</span><span class="p">)</span>
<span class="c1">;; =&gt; &quot;flying-fish&quot;</span>
<span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="ss">&#39;Martin</span><span class="p">)</span> <span class="c1">;; =&gt; &quot;Martin&quot;</span>
<span class="p">(</span><span class="nf">symbol-&gt;string</span>
 <span class="p">(</span><span class="nb">string-&gt;symbol </span><span class="s">&quot;Malvina&quot;</span><span class="p">))</span>
<span class="c1">;; =&gt; &quot;Malvina&quot;</span>
</pre></div>
<p>(string-&gt;symbol <em>string</em>)  procedure
Returns the symbol whose name is <em>string</em>. This procedure can create
symbols with names containing special characters that would require
escaping when written, but does not interpret escapes in its input.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">string-&gt;symbol </span><span class="s">&quot;mISSISSIppi&quot;</span><span class="p">)</span>  <span class="c1">;; =&gt; mISSISSIppi</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="ss">&#39;bitBlt</span> <span class="p">(</span><span class="nb">string-&gt;symbol </span><span class="s">&quot;bitBlt&quot;</span><span class="p">))</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">eqv? </span><span class="ss">&#39;LollyPop</span>
      <span class="p">(</span><span class="nf">string-&gt;symbol</span>
       <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="ss">&#39;LollyPop</span><span class="p">)))</span> <span class="c1">;; =&gt; #t</span>
    <span class="p">(</span><span class="nb">string=? </span><span class="s">&quot;K. Harper, M.D.&quot;</span>
              <span class="p">(</span><span class="nf">symbol-&gt;string</span>
               <span class="p">(</span><span class="nb">string-&gt;symbol </span><span class="s">&quot;K. Harper, M.D.&quot;</span><span class="p">)))</span> <span class="c1">;; =&gt; #t</span>
</pre></div>
<h3>Characters</h3>
<p>Characters are objects that represent printed characters such as letters
and digits. All Scheme implementations must support at least the ASCII
character repertoire: that is, Unicode characters U+0000 through U+007F.
Implementations may support any other Unicode characters they see fit,
and may also support non-Unicode characters as well. Except as otherwise
specified, the result of applying any of the following procedures to a
non-Unicode character is implementation-dependent.</p>
<p>Characters are written using the notation <code>#``'</code>character or
<code>#``'</code>character name or <code>#``'</code>xhex scalar value.</p>
<p>The following character names must be supported by all implementations
with the given values. Implementations may add other names provided they
cannot be interpreted as hex scalar values preceded by x.</p>
<table>
<thead><tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">; <span class="roman">U+0007</span></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">; <span class="roman">U+0008</span></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">; <span class="roman">U+007F</span></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">; <span class="roman">U+001B</span></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">; the linefeed character, <span class="roman">U+000A</span></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">; the null character, <span class="roman">U+0000</span></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">; the return character, <span class="roman">U+000D</span></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">; the preferred way to write a space</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">; the tab character, <span class="roman">U+0009</span></td>
</tr>
</tbody>
</table>
<p>Here are some additional examples:</p>
<table>
<thead><tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">; lower case letter</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">; upper case letter</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">; left parenthesis</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">; the space character</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">; <em>λ</em> (if character is supported)</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">; <em>ι</em> (if character and name are supported)</td>
</tr>
</tbody>
</table>
<p>Case is significant in <code>#``'</code>character, and in <code>#``'</code>⟨character name⟩,
but not in <code>#``'</code>xhex scalar value. If character in <code>#``'</code>character is
alphabetic, then any character immediately following character cannot be
one that can appear in an identifier. This rule resolves the ambiguous
case where, for example, the sequence of characters “<code>#' space</code>” could
be taken to be either a representation of the space character or a
representation of the character “<code>#' s</code>” followed by a representation of
the symbol “<code>pace</code>.”</p>
<p>Characters written in the <code>#``'</code> notation are self-evaluating. That is,
they do not have to be quoted in programs.</p>
<p>Some of the procedures that operate on characters ignore the difference
between upper case and lower case. The procedures that ignore case have
“<code>-ci</code>” (for “case insensitive”) embedded in their names.</p>
<p>(char? <em>obj</em>)  procedure
Returns <code>#t</code> if <em>obj</em> is a character, otherwise returns #f.</p>
<p>(char=? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>)
 procedure
(char\&lt;? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>)
 procedure
(char&gt;? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>)
 procedure
(char\&lt;=? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>)
 procedure
(char&gt;=? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>)
 procedure
These procedures return <code>#t</code> if the results of passing their arguments to
charinteger are respectively equal, monotonically increasing,
monotonically decreasing, monotonically non-decreasing, or monotonically
non-increasing.</p>
<p>These predicates are required to be transitive.</p>
<p>(char-ci=? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>)
 char library procedure
(char-ci\&lt;? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>)
 char library procedure
(char-ci&gt;? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>)
 char library procedure
(char-ci\&lt;=? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>)
 char library procedure
(char-ci&gt;=? <strong>c</strong>h<strong>a</strong>r<em><sub>1</sub> </em>c<strong>h</strong>a<strong>r<em><sub>2</sub> </em>c</strong>h<strong>a</strong>r<em><sub>3</sub> … </em>)
 char library procedure
These procedures are similar to char=? et cetera, but they treat upper
case and lower case letters as the same. For example, (char-ci=? #<code>'</code>A</p>
<h1><code>'</code>a) returns #t.</h1>
<p>Specifically, these procedures behave as if char-foldcase were applied
to their arguments before they were compared.</p>
<p>(char-alphabetic? <em>char</em>)  char library procedure
(char-numeric? <em>char</em>)  char library procedure
(char-whitespace? <em>char</em>)  char library procedure
(char-upper-case? <em>letter</em>)  char library procedure
(char-lower-case? <em>letter</em>)  char library procedure
These procedures return <code>#t</code> if their arguments are alphabetic, numeric,
whitespace, upper case, or lower case characters, respectively,
otherwise they return #f.</p>
<p>Specifically, they must return <code>#t</code> when applied to characters with the
Unicode properties Alphabetic, Numeric_Type=Decimal, White_Space,
Uppercase, and Lowercase respectively, and <code>#f</code> when applied to any other
Unicode characters. Note that many Unicode characters are alphabetic but
neither upper nor lower case.</p>
<p>(digit-value <em>char</em>)  char library procedure
This procedure returns the numeric value (0 to 9) of its argument if it
is a numeric digit (that is, if char-numeric? returns #t), or <code>#f</code> on any
other character.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">digit-value</span> <span class="sc">#\3</span><span class="p">)</span> <span class="c1">;; =&gt; 3</span>
<span class="p">(</span><span class="nf">digit-value</span> <span class="sc">#\x0664</span><span class="p">)</span> <span class="c1">;; =&gt; 4</span>
<span class="p">(</span><span class="nf">digit-value</span> <span class="sc">#\x0AE6</span><span class="p">)</span> <span class="c1">;; =&gt; 0</span>
<span class="p">(</span><span class="nf">digit-value</span> <span class="sc">#\x0EA6</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
</pre></div>
<p>(char-&gt;integer <em>char</em>)  procedure
(integer-&gt;char <strong>n</strong>)  procedure
Given a Unicode character, charinteger returns an exact integer between
0 and <code>#xD7FF</code> or between <code>#xE000</code> and <code>#x10FFFF</code> which is equal to the
Unicode scalar value of that character. Given a non-Unicode character,
it returns an exact integer greater than <code>#x10FFFF</code>. This is true
independent of whether the implementation uses the Unicode
representation internally.</p>
<p>Given an exact integer that is the value returned by a character when
charinteger is applied to it, integerchar returns that character.</p>
<p>(char-upcase <em>char</em>)  char library procedure
(char-downcase <em>char</em>)  char library procedure
(char-foldcase <em>char</em>)  char library procedure
The char-upcase procedure, given an argument that is the lowercase part
of a Unicode casing pair, returns the uppercase member of the pair,
provided that both characters are supported by the Scheme
implementation. Note that language-sensitive casing pairs are not used.
If the argument is not the lowercase member of such a pair, it is
returned.</p>
<p>The char-downcase procedure, given an argument that is the uppercase
part of a Unicode casing pair, returns the lowercase member of the pair,
provided that both characters are supported by the Scheme
implementation. Note that language-sensitive casing pairs are not used.
If the argument is not the uppercase member of such a pair, it is
returned.</p>
<p>The char-foldcase procedure applies the Unicode simple case-folding
algorithm to its argument and returns the result. Note that
language-sensitive folding is not used. If the character that results
from folding is not supported by the implementation, the argument is
returned. See UAX #44 <span class="citation" cites="uax44"></span> (part
of the Unicode Standard) for details.</p>
<p>Note that many Unicode lowercase characters do not have uppercase
equivalents.</p>
<h3>Strings</h3>
<p>Strings are sequences of characters. Strings are written as sequences of
characters enclosed within quotation marks ("). Within a string literal,
various escape sequences represent characters other than themselves.
Escape sequences always start with a backslash (<code>'</code>):</p>
<ul>
<li><p><code>'</code>a : alarm, U+0007</p>
</li>
<li><p><code>'</code>b : backspace, U+0008</p>
</li>
<li><p><code>'</code>t : character tabulation, U+0009</p>
</li>
<li><p><code>'</code>n : linefeed, U+000A</p>
</li>
<li><p><code>'</code>r : return, U+000D</p>
</li>
<li><p><code>' ``"</code> : double quote, U+0022</p>
</li>
<li><p><code>' ``'</code> : backslash, U+005C</p>
</li>
<li><p><code>'</code>| : vertical line, U+007C</p>
</li>
<li><p><code>'</code>intraline whitespaceline ending intraline whitespace : nothing</p>
</li>
<li><p><code>'</code>xhex scalar value; : specified character (note the terminating
semi-colon).</p>
</li>
</ul>
<p>The result is unspecified if any other character in a string occurs
after a backslash.</p>
<p>Except for a line ending, any character outside of an escape sequence
stands for itself in the string literal. A line ending which is preceded
by <code>'</code>intraline whitespace expands to nothing (along with any trailing
intraline whitespace), and can be used to indent strings for improved
legibility. Any other line ending has the same effect as inserting a
<code>'</code>n character into the string.</p>
<p>Examples:</p>
<div class="highlight"><pre><span></span><span class="s">&quot;The word \&quot;recursion\&quot; has many meanings.&quot;</span>
<span class="s">&quot;Another example:\ntwo lines of text&quot;</span>
<span class="s">&quot;Here&#39;s text \</span>
<span class="s">       containing just one line&quot;</span>
<span class="s">&quot;\x03B1; is named GREEK SMALL LETTER ALPHA.&quot;</span>
</pre></div>
<p>The <em>length</em> of a string is the number of characters that it contains.
This number is an exact, non-negative integer that is fixed when the
string is created. The <em>valid indexes</em> of a string are the exact
non-negative integers less than the length of the string. The first
character of a string has index 0, the second has index 1, and so on.</p>
<p>Some of the procedures that operate on strings ignore the difference
between upper and lower case. The names of the versions that ignore case
end with “-ci” (for “case insensitive”).</p>
<p>Implementations may forbid certain characters from appearing in strings.
However, with the exception of <code>#' null</code>, ASCII characters must not be
forbidden. For example, an implementation might support the entire
Unicode repertoire, but only allow characters U+0001 to U+00FF (the
Latin-1 repertoire without <code>#' null</code>) in strings.</p>
<p>It is an error to pass such a forbidden character to make-string,
string, string-set!, or string-fill!, as part of the list passed to
liststring, or as part of the vector passed to vectorstring (see
section <a href="#vectortostring">[vectortostring]</a>), or in UTF-8 encoded form
within a bytevector passed to utf8string (see
section <a href="#utf8tostring">[utf8tostring]</a>). It is also an error for a
procedure passed to string-map (see section <a href="#stringmap">[stringmap]</a>)
to return a forbidden character, or for read-string (see
section <a href="#readstring">[readstring]</a>) to attempt to read one.</p>
<p>(string? <em>obj</em>)  procedure
Returns <code>#t</code> if <em>obj</em> is a string, otherwise returns #f.</p>
<p>(make-string <strong>k</strong>)  procedure
(make-string *<em>k</em> char<em>)  procedure
The make-string procedure returns a newly allocated string of length</em>k<em>. If </em>char<em> is given, then all the characters of the string are
initialized to </em>char*, otherwise the contents of the string are
unspecified.</p>
<p>(string <em>char … </em>)  procedure
Returns a newly allocated string composed of the arguments. It is
analogous to list.</p>
<p>(string-length <em>string</em>)  procedure
Returns the number of characters in the given <em>string</em>.</p>
<p>(string-ref <em>string </em>k*<em>)  procedure
It is an error if </em>k<em> is not a valid index of </em>string*.</p>
<p>The string-ref procedure returns character <em>k</em> of <em>string</em> using
zero-origin indexing. There is no requirement for this procedure to
execute in constant time.</p>
<p>(string-set! <em>string k char</em>)  procedure
It is an error if <em>k</em> is not a valid index of <em>string</em>.</p>
<p>The string-set! procedure stores <em>char</em> in element <em>k</em> of <em>string</em>.
There is no requirement for this procedure to execute in constant time.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="nb">make-string </span><span class="mi">3</span> <span class="o">#</span><span class="err">\</span><span class="nv">*</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">g</span><span class="p">)</span> <span class="s">&quot;***&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">string-set! </span><span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="mi">0</span> <span class="sc">#\?</span><span class="p">)</span> <span class="c1">;; =&gt; unspecified</span>
<span class="p">(</span><span class="nb">string-set! </span><span class="p">(</span><span class="nf">g</span><span class="p">)</span> <span class="mi">0</span> <span class="sc">#\?</span><span class="p">)</span> <span class="c1">;; =&gt; error</span>
<span class="p">(</span><span class="nb">string-set! </span><span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="ss">&#39;immutable</span><span class="p">)</span>
             <span class="mi">0</span>
             <span class="sc">#\?</span><span class="p">)</span> <span class="c1">;; =&gt; error</span>
</pre></div>
<p>(string=? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>)
 procedure
Returns <code>#t</code> if all the strings are the same length and contain exactly
the same characters in the same positions, otherwise returns #f.</p>
<p>(string-ci=? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>)
 char library procedure
Returns <code>#t</code> if, after case-folding, all the strings are the same length
and contain the same characters in the same positions, otherwise returns</p>
<h1>f. Specifically, these procedures behave as if string-foldcase were</h1>
<p>applied to their arguments before comparing them.</p>
<p>(string\&lt;? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>)
 procedure
(string-ci\&lt;? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>)
 char library procedure
(string&gt;? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>)
 procedure
(string-ci&gt;? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>)
 char library procedure
(string\&lt;=? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>)
 procedure
(string-ci\&lt;=? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>)
 char library procedure
(string&gt;=? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>)
 procedure
(string-ci&gt;=? <strong>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>1</sub> </em>s<strong>t</strong>r<strong>i</strong>n<strong>g<em><sub>2</sub> </em>s</strong>t<strong>r</strong>i<strong>n</strong>g<em><sub>3</sub> … </em>)
 char library procedure
These procedures return <code>#t</code> if their arguments are (respectively):
monotonically increasing, monotonically decreasing, monotonically
non-decreasing, or monotonically non-increasing.</p>
<p>These predicates are required to be transitive.</p>
<p>These procedures compare strings in an implementation-defined way. One
approach is to make them the lexicographic extensions to strings of the
corresponding orderings on characters. In that case, string\&lt;? would be
the lexicographic ordering on strings induced by the ordering char\&lt;? on
characters, and if the two strings differ in length but are the same up
to the length of the shorter string, the shorter string would be
considered to be lexicographically less than the longer string. However,
it is also permitted to use the natural ordering imposed by the
implementation’s internal representation of strings, or a more complex
locale-specific ordering.</p>
<p>In all cases, a pair of strings must satisfy exactly one of string\&lt;?,
string=?, and string&gt;?, and must satisfy string\&lt;=? if and only if they
do not satisfy string&gt;? and string&gt;=? if and only if they do not satisfy
string\&lt;?.</p>
<p>The “<code>-ci</code>” procedures behave as if they applied string-foldcase to
their arguments before invoking the corresponding procedures without
“<code>-ci</code>”.</p>
<p>(string-upcase <em>string</em>)  char library procedure
(string-downcase <em>string</em>)  char library procedure
(string-foldcase <em>string</em>)  char library procedure
These procedures apply the Unicode full string uppercasing, lowercasing,
and case-folding algorithms to their arguments and return the result. In
certain cases, the result differs in length from the argument. If the
result is equal to the argument in the sense of string=?, the argument
may be returned. Note that language-sensitive mappings and foldings are
not used.</p>
<p>The Unicode Standard prescribes special treatment of the Greek letter
<em>Σ</em>, whose normal lower-case form is <em>σ</em> but which becomes ς at the end
of a word. See UAX #44 <span class="citation" cites="uax44"></span>
(part of the Unicode Standard) for details. However, implementations of
string-downcase are not required to provide this behavior, and may
choose to change <em>Σ</em> to <em>σ</em> in all cases.</p>
<p>(substring <em>string start end</em>)  procedure
The substring procedure returns a newly allocated string formed from the
characters of <em>string</em> beginning with index <em>start</em> and ending with
index <em>end</em>. This is equivalent to calling string-copy with the same
arguments, but is provided for backward compatibility and stylistic
flexibility.</p>
<p>(string-append *<em>string</em> … *)  procedure
Returns a newly allocated string whose characters are the concatenation
of the characters in the given strings.</p>
<p>(string-&gt;list <em>string</em>)  procedure
(string-&gt;list <em>string start</em>)  procedure
(string-&gt;list <em>string start end</em>)  procedure
(list-&gt;string <em>list</em>)  procedure
It is an error if any element of <em>list</em> is not a character.</p>
<p>The stringlist procedure returns a newly allocated list of the
characters of <em>string</em> between <em>start</em> and <em>end</em>. liststring returns a
newly allocated string formed from the elements in the list <em>list</em>. In
both procedures, order is preserved. stringlist and liststring are
inverses so far as equal? is concerned.</p>
<p>(string-copy <em>string</em>)  procedure
(string-copy <em>string start</em>)  procedure
(string-copy <em>string start end</em>)  procedure
Returns a newly allocated copy of the part of the given <em>string</em> between
<em>start</em> and <em>end</em>.</p>
<p>(string-copy! <em>to at from</em>)  procedure
(string-copy! <em>to at from start</em>)  procedure
(string-copy! <em>to at from start end</em>)  procedure
It is an error if <em>at</em> is less than zero or greater than the length of
<em>to</em>. It is also an error if (- (string-length <em>to</em>) <em>at</em>) is less than
(- <em>end</em> <em>start</em>).</p>
<p>Copies the characters of string <em>from</em> between <em>start</em> and <em>end</em> to
string <em>to</em>, starting at <em>at</em>. The order in which characters are copied
is unspecified, except that if the source and destination overlap,
copying takes place as if the source is first copied into a temporary
string and then into the destination. This can be achieved without
allocating storage by making sure to copy in the correct direction in
such circumstances.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="s">&quot;12345&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="p">(</span><span class="nb">string-copy </span><span class="s">&quot;abcde&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">string-copy!</span> <span class="nv">b</span> <span class="mi">1</span> <span class="nv">a</span> <span class="mi">0</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">b</span> <span class="c1">;; =&gt; &quot;a12de&quot;</span>
</pre></div>
<p>(string-fill! <em>string fill</em>)  procedure
(string-fill! <em>string fill start</em>)  procedure
(string-fill! <em>string fill start end</em>)  procedure
It is an error if <em>fill</em> is not a character.</p>
<p>The string-fill! procedure stores <em>fill</em> in the elements of <em>string</em>
between <em>start</em> and <em>end</em>.</p>
<h3>Vectors</h3>
<p>Vectors are heterogeneous structures whose elements are indexed by
integers. A vector typically occupies less space than a list of the same
length, and the average time needed to access a randomly chosen element
is typically less for the vector than for the list.</p>
<p>The <em>length</em> of a vector is the number of elements that it contains.
This number is a non-negative integer that is fixed when the vector is
created. The <em>valid indexes</em> of a vector are the exact non-negative
integers less than the length of the vector. The first element in a
vector is indexed by zero, and the last element is indexed by one less
than the length of the vector.</p>
<p>Vectors are written using the notation <code>#(obj ...)</code>. For example, a
vector of length 3 containing the number zero in element 0, the list (2
2 2 2) in element 1, and the string "Anna" in element 2 can be written
as follows:</p>
<div class="highlight"><pre><span></span><span class="o">#</span><span class="p">(</span><span class="mi">0</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span> <span class="s">&quot;Anna&quot;</span><span class="p">)</span>
</pre></div>
<p>Vector constants are self-evaluating, so they do not need to be quoted
in programs.</p>
<p>(vector? <em>obj</em>)  procedure
Returns <code>#t</code> if <em>obj</em> is a vector; otherwise returns #f.</p>
<p>(make-vector <em>k</em>)  procedure
(make-vector <em>k fill</em>)  procedure
Returns a newly allocated vector of <em>k</em> elements. If a second argument
is given, then each element is initialized to <em>fill</em>. Otherwise the
initial contents of each element is unspecified.</p>
<p>(vector <em>obj … </em>)  procedure
Returns a newly allocated vector whose elements contain the given
arguments. It is analogous to list.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">vector </span><span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">)</span> <span class="c1">;; =&gt; #(a b c)</span>
</pre></div>
<p>(vector-length <em>vector</em>)  procedure
Returns the number of elements in <em>vector</em> as an exact integer.</p>
<p>(vector-ref <em>vector k</em>)  procedure
It is an error if <em>k</em> is not a valid index of <em>vector</em>.</p>
<p>The vector-ref procedure returns the contents of element <em>k</em> of
<em>vector</em>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">vector-ref </span><span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">8</span> <span class="mi">13</span> <span class="mi">21</span><span class="p">)</span>
            <span class="mi">5</span><span class="p">)</span> <span class="c1">;; =&gt; 8</span>
<span class="p">(</span><span class="nb">vector-ref </span><span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">8</span> <span class="mi">13</span> <span class="mi">21</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">exact</span>
             <span class="p">(</span><span class="nb">round </span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="p">(</span><span class="nb">acos </span><span class="mi">-1</span><span class="p">)))))</span> <span class="c1">;; =&gt; 13</span>
</pre></div>
<p>(vector-set! <em>vector k obj</em>)  procedure
It is an error if <em>k</em> is not a valid index of <em>vector</em>.</p>
<p>The vector-set! procedure stores <em>obj</em> in element <em>k</em> of <em>vector</em>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">vector </span><span class="mi">0</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span> <span class="s">&quot;Anna&quot;</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">vec</span> <span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;Sue&quot;</span> <span class="s">&quot;Sue&quot;</span><span class="p">))</span>
  <span class="nv">vec</span><span class="p">)</span> <span class="c1">;; =&gt; #(0 (&quot;Sue&quot; &quot;Sue&quot;) &quot;Anna&quot;)</span>

<span class="p">(</span><span class="nb">vector-set! </span><span class="o">&#39;#</span><span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">1</span> <span class="s">&quot;doe&quot;</span><span class="p">)</span> <span class="c1">;; =&gt; error  ; constant vector</span>
</pre></div>
<p>(vector-&gt;list <em>vector</em>)  procedure
(vector-&gt;list <em>vector start</em>)  procedure
(vector-&gt;list <em>vector start end</em>)  procedure
(list-&gt;vector <em>list</em>)  procedure
The vector-&gt;list procedure returns a newly allocated list of the objects
contained in the elements of <em>vector</em> between <em>start</em> and <em>end</em>. The
list-&gt;vector procedure returns a newly created vector initialized to the
elements of the list <em>list</em>.</p>
<p>In both procedures, order is preserved.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">vector-&gt;list </span><span class="o">&#39;#</span><span class="p">(</span><span class="nv">dah</span> <span class="nv">dah</span> <span class="nv">didah</span><span class="p">))</span> <span class="c1">;; =&gt; (dah dah didah)</span>
<span class="p">(</span><span class="nb">vector-&gt;list </span><span class="o">&#39;#</span><span class="p">(</span><span class="nv">dah</span> <span class="nv">dah</span> <span class="nv">didah</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; =&gt; (dah)</span>
<span class="p">(</span><span class="nb">list-&gt;vector </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">dididit</span> <span class="nv">dah</span><span class="p">))</span> <span class="c1">;; =&gt; #(dididit dah)</span>
</pre></div>
<p>(vector-&gt;string <em>vector</em>)  procedure
(vector-&gt;string <em>vector start</em>)  procedure
(vector-&gt;string <em>vector start end</em>)  procedure
(string-&gt;vector <em>string</em>)  procedure
(string-&gt;vector <em>string start</em>)  procedure
(string-&gt;vector <em>string start end</em>)  procedure
It is an error if any element of <em>vector</em> between <em>start</em> and <em>end</em> is
not a character.</p>
<p>The vector-&gt;string procedure returns a newly allocated string of the
objects contained in the elements of <em>vector</em> between <em>start</em> and <em>end</em>.
The string-&gt;vector procedure returns a newly created vector initialized
to the elements of the string <em>string</em> between <em>start</em> and <em>end</em>.</p>
<p>In both procedures, order is preserved.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">string-&gt;vector</span> <span class="s">&quot;ABC&quot;</span><span class="p">)</span> <span class="c1">;; =&gt; #(#\A #\B #\C)</span>
<span class="p">(</span><span class="nf">vector-&gt;string</span>
 <span class="o">#</span><span class="p">(</span><span class="sc">#\1</span> <span class="sc">#\2</span> <span class="sc">#\3</span><span class="p">)</span> <span class="c1">;; =&gt; &quot;123&quot;</span>
</pre></div>
<p>(vector-copy <em>vector</em>)  procedure
(vector-copy <em>vector start</em>)  procedure
(vector-copy <em>vector start end</em>)  procedure
Returns a newly allocated copy of the elements of the given <em>vector</em>
between <em>start</em> and <em>end</em>. The elements of the new vector are the same
(in the sense of eqv?) as the elements of the old.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="o">#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">8</span> <span class="mi">2</span> <span class="mi">8</span><span class="p">))</span> <span class="c1">; a may be immutable</span>
<span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="p">(</span><span class="nf">vector-copy</span> <span class="nv">a</span><span class="p">))</span>
<span class="p">(</span><span class="nb">vector-set! </span><span class="nv">b</span> <span class="mi">0</span> <span class="mi">3</span><span class="p">)</span>   <span class="c1">; b is mutable</span>
<span class="nv">b</span> <span class="c1">;; =&gt; #(3 8 2 8)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">c</span> <span class="p">(</span><span class="nf">vector-copy</span> <span class="nv">b</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">))</span>
<span class="nv">c</span> <span class="c1">;; =&gt; #(8 2)</span>
</pre></div>
<p>(vector-copy! <em>to at from</em>)  procedure
(vector-copy! <em>to at from start</em>)  procedure
(vector-copy! <em>to at from start end</em>)  procedure
It is an error if <em>at</em> is less than zero or greater than the length of
<em>to</em>. It is also an error if (- (vector-length <em>to</em>) <em>at</em>) is less than
(- <em>end</em> <em>start</em>).</p>
<p>Copies the elements of vector <em>from</em> between <em>start</em> and <em>end</em> to vector
<em>to</em>, starting at <em>at</em>. The order in which elements are copied is
unspecified, except that if the source and destination overlap, copying
takes place as if the source is first copied into a temporary vector and
then into the destination. This can be achieved without allocating
storage by making sure to copy in the correct direction in such
circumstances.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="p">(</span><span class="nb">vector </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="p">(</span><span class="nb">vector </span><span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">))</span>
<span class="p">(</span><span class="nf">vector-copy!</span> <span class="nv">b</span> <span class="mi">1</span> <span class="nv">a</span> <span class="mi">0</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">b</span> <span class="c1">;; =&gt; #(10 1 2 40 50)</span>
</pre></div>
<p>(vector-append *<em>vector</em> … *)  procedure
Returns a newly allocated vector whose elements are the concatenation of
the elements of the given vectors.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">vector-append</span> <span class="o">#</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="o">#</span><span class="p">(</span><span class="nv">d</span> <span class="nv">e</span> <span class="nv">f</span><span class="p">))</span> <span class="c1">;; =&gt; #(a b c d e f)</span>
</pre></div>
<p>(vector-fill! <em>vector fill</em>)  procedure
(vector-fill! <em>vector fill start</em>)  procedure
(vector-fill! <em>vector fill start end</em>)  procedure
The vector-fill! procedure stores <em>fill</em> in the elements of <em>vector</em>
between <em>start</em> and <em>end</em>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="p">(</span><span class="nb">vector </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="nb">vector-fill! </span><span class="nv">a</span> <span class="ss">&#39;smash</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">)</span>
<span class="nv">a</span> <span class="c1">;; =&gt; #(1 2 smash smash 5)</span>
</pre></div>
<h3>Bytevectors</h3>
<p><em>Bytevectors</em> represent blocks of binary data. They are fixed-length
sequences of bytes, where a <em>byte</em> is an exact integer in the range from
0 to 255 inclusive. A bytevector is typically more space-efficient than
a vector containing the same values.</p>
<p>The <em>length</em> of a bytevector is the number of elements that it contains.
This number is a non-negative integer that is fixed when the bytevector
is created. The <em>valid indexes</em> of a bytevector are the exact
non-negative integers less than the length of the bytevector, starting
at index zero as with vectors.</p>
<p>Bytevectors are written using the notation <code>#u8(byte ...)</code>. For
example, a bytevector of length 3 containing the byte 0 in element 0,
the byte 10 in element 1, and the byte 5 in element 2 can be written as
follows:</p>
<div class="highlight"><pre><span></span><span class="o">#</span><span class="nv">u8</span><span class="p">(</span><span class="mi">0</span> <span class="mi">10</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
<p>Bytevector constants are self-evaluating, so they do not need to be
quoted in programs.</p>
<p>(bytevector? <em>obj</em>)  procedure
Returns <code>#t</code> if <em>obj</em> is a bytevector. Otherwise, <code>#f</code> is returned.</p>
<p>(make-bytevector <em>k</em>)  procedure
(make-bytevector <em>k byte</em>)  procedure
The make-bytevector procedure returns a newly allocated bytevector of
length <em>k</em>. If <em>byte</em> is given, then all elements of the bytevector are
initialized to <em>byte</em>, otherwise the contents of each element are
unspecified.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">make-bytevector</span> <span class="mi">2</span> <span class="mi">12</span><span class="p">)</span> <span class="c1">;; =&gt; #u8(12 12)</span>
</pre></div>
<p>(bytevector *<em>byte</em> … *)  procedure
Returns a newly allocated bytevector containing its arguments.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">bytevector</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">;; =&gt; #u8(1 3 5 1 3 5)</span>
<span class="p">(</span><span class="nf">bytevector</span><span class="p">)</span> <span class="c1">;; =&gt; #u8()</span>
</pre></div>
<p>(bytevector-length <em>bytevector</em>)  procedure
Returns the length of <em>bytevector</em> in bytes as an exact integer.</p>
<p>(bytevector-u8-ref <em>bytevector k</em>)  procedure
It is an error if <em>k</em> is not a valid index of <em>bytevector</em>.</p>
<p>Returns the <em>k</em>th byte of <em>bytevector</em>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">bytevector-u8-ref</span> <span class="o">&#39;#</span><span class="nv">u8</span><span class="p">(</span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">8</span> <span class="mi">13</span> <span class="mi">21</span><span class="p">)</span>
                   <span class="mi">5</span><span class="p">)</span> <span class="c1">;; =&gt; 8</span>
</pre></div>
<p>(bytevector-u8-set! <em>bytevector k byte</em>)  procedure
It is an error if <em>k</em> is not a valid index of <em>bytevector</em>.</p>
<p>Stores <em>byte</em> as the <em>k</em>th byte of <em>bytevector</em>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">bv</span> <span class="p">(</span><span class="nf">bytevector</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">bytevector-u8-set!</span> <span class="nv">bv</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">)</span>
  <span class="nv">bv</span><span class="p">)</span> <span class="c1">;; =&gt; #u8(1 3 3 4)</span>
</pre></div>
<p>(bytevector-copy <em>bytevector</em>)  procedure
(bytevector-copy <em>bytevector start</em>)  procedure
(bytevector-copy <em>bytevector start end</em>)  procedure
Returns a newly allocated bytevector containing the bytes in
<em>bytevector</em> between <em>start</em> and <em>end</em>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="o">#</span><span class="nv">u8</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="nf">bytevector-copy</span> <span class="nv">a</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">;; =&gt; #u8(3 4)</span>
</pre></div>
<p>(bytevector-copy! <em>to at from</em>)  procedure
(bytevector-copy! <em>to at from start</em>)  procedure
(bytevector-copy! <em>to at from start end</em>)  procedure
It is an error if <em>at</em> is less than zero or greater than the length of
<em>to</em>. It is also an error if (- (bytevector-length <em>to</em>) <em>at</em>) is less
than (- <em>end</em> <em>start</em>).</p>
<p>Copies the bytes of bytevector <em>from</em> between <em>start</em> and <em>end</em> to
bytevector <em>to</em>, starting at <em>at</em>. The order in which bytes are copied
is unspecified, except that if the source and destination overlap,
copying takes place as if the source is first copied into a temporary
bytevector and then into the destination. This can be achieved without
allocating storage by making sure to copy in the correct direction in
such circumstances.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="p">(</span><span class="nf">bytevector</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="p">(</span><span class="nf">bytevector</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">))</span>
<span class="p">(</span><span class="nf">bytevector-copy!</span> <span class="nv">b</span> <span class="mi">1</span> <span class="nv">a</span> <span class="mi">0</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">b</span> <span class="c1">;; =&gt; #u8(10 1 2 40 50)</span>
</pre></div>
<p><em>Note:</em> This procedure appears in R<sup><small>6</small></sup>RS, but places the source
before the destination, contrary to other such procedures in Scheme.</p>
<p>(bytevector-append *<em>bytevector</em> … *)  procedure
Returns a newly allocated bytevector whose elements are the
concatenation of the elements in the given bytevectors.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">bytevector-append</span> <span class="o">#</span><span class="nv">u8</span><span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="o">#</span><span class="nv">u8</span><span class="p">(</span><span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">;; =&gt; #u8(0 1 2 3 4 5)</span>
</pre></div>
<p>(utf8-&gt;string <em>bytevector</em>)  procedure
(utf8-&gt;string <em>bytevector start</em>)  procedure
(utf8-&gt;string <em>bytevector start end</em>)  procedure
(string-&gt;utf8 <em>string</em>)  procedure
(string-&gt;utf8 <em>string start</em>)  procedure
(string-&gt;utf8 <em>string start end</em>)  procedure
It is an error for <em>bytevector</em> to contain invalid UTF-8 byte sequences.</p>
<p>These procedures translate between strings and bytevectors that encode
those strings using the UTF-8 encoding. The utf8string procedure decodes
the bytes of a bytevector between <em>start</em> and <em>end</em> and returns the
corresponding string; the stringutf8 procedure encodes the characters of
a string between <em>start</em> and <em>end</em> and returns the corresponding
bytevector.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">utf8-&gt;string</span> <span class="o">#</span><span class="nv">u8</span><span class="p">(</span><span class="o">#</span><span class="nv">x41</span><span class="p">))</span> <span class="c1">;; =&gt; &quot;A&quot;</span>
<span class="p">(</span><span class="nf">string-&gt;utf8</span> <span class="s">&quot;λ&quot;</span><span class="p">)</span> <span class="c1">;; =&gt; #u8(#xCE #xBB)</span>
</pre></div>
<h3>Control features</h3>
<p>This section describes various primitive procedures which control the
flow of program execution in special ways. Procedures in this section
that invoke procedure arguments always do so in the same dynamic
environment as the call of the original procedure. The
procedure? predicate is also described here.</p>
<p>(procedure? <em>obj</em>)  procedure
Returns <code>#t</code> if <em>obj</em> is a procedure, otherwise returns #f.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">procedure? </span><span class="nv">car</span><span class="p">)</span> <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">procedure? </span><span class="ss">&#39;car</span><span class="p">)</span> <span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">procedure? </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">)))</span>
 <span class="c1">;; =&gt; #t</span>
<span class="p">(</span><span class="nb">procedure? </span><span class="o">&#39;</span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">)))</span>
<span class="c1">;; =&gt; #f</span>
<span class="p">(</span><span class="nb">call-with-current-continuation </span><span class="nv">procedure?</span><span class="p">)</span>
<span class="c1">;; =&gt; #t</span>
</pre></div>
<p>(apply <em>proc </em>arg<sub>1</sub><em> … args</em>)  procedure
The apply procedure calls <em>proc</em> with the elements of the list (append
(list <em>arg<sub>1</sub></em> … ) <em>args</em>) as the actual arguments.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">apply </span><span class="nv">+</span> <span class="p">(</span><span class="nb">list </span><span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">;; =&gt; 7</span>

<span class="p">(</span><span class="k">define </span><span class="nv">compose</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">f</span> <span class="nv">g</span><span class="p">)</span>
    <span class="p">(</span><span class="k">lambda </span><span class="nv">args</span>
      <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">apply </span><span class="nv">g</span> <span class="nv">args</span><span class="p">)))))</span>

<span class="p">((</span><span class="nf">compose</span> <span class="nv">sqrt</span> <span class="nv">*</span><span class="p">)</span> <span class="mi">12</span> <span class="mi">75</span><span class="p">)</span> <span class="c1">;; =&gt; 30</span>
</pre></div>
<p>(map <em>proc </em>list<sub>1</sub><em> </em>list<sub>2</sub><em> … </em>)  procedure
It is an error if <em>proc</em> does not accept as many arguments as there are
<em>list</em>s and return a single value.</p>
<p>The map procedure applies <em>proc</em> element-wise to the elements of the
<em>list</em>s and returns a list of the results, in order. If more than one
<em>list</em> is given and not all lists have the same length, map terminates
when the shortest list runs out. The <em>list</em>s can be circular, but it is
an error if all of them are circular. It is an error for <em>proc</em> to
mutate any of the lists. The dynamic order in which <em>proc</em> is applied to
the elements of the <em>list</em>s is unspecified. If multiple returns occur
from map, the values returned by earlier returns are not mutated.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">map </span><span class="nv">cadr</span> <span class="o">&#39;</span><span class="p">((</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">d</span> <span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nf">g</span> <span class="nv">h</span><span class="p">)))</span> <span class="c1">;; =&gt; (b e h)</span>

<span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">expt </span><span class="nv">n</span> <span class="nv">n</span><span class="p">))</span>
     <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">;; =&gt; (1 4 27 256 3125)</span>

<span class="p">(</span><span class="nb">map </span><span class="nv">+</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span><span class="p">))</span> <span class="c1">;; =&gt; (5 7 9)</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">count</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">ignored</span><span class="p">)</span>
         <span class="p">(</span><span class="k">set! </span><span class="nv">count</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">count</span> <span class="mi">1</span><span class="p">))</span>
         <span class="nv">count</span><span class="p">)</span>
       <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span> <span class="c1">;; =&gt; (1 2) \var{or} (2 1)</span>
</pre></div>
<p>(string-map <em>proc </em>string<sub>1</sub><em> </em>string<sub>2</sub><em> … </em>)
 procedure
It is an error if <em>proc</em> does not accept as many arguments as there are
<em>string</em>s and return a single character.</p>
<p>The string-map procedure applies <em>proc</em> element-wise to the elements of
the <em>string</em>s and returns a string of the results, in order. If more
than one <em>string</em> is given and not all strings have the same length,
string-map terminates when the shortest string runs out. The dynamic
order in which <em>proc</em> is applied to the elements of the <em>string</em>s is
unspecified. If multiple returns occur from string-map, the values
returned by earlier returns are not mutated.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">string-map</span> <span class="nv">char-foldcase</span> <span class="s">&quot;AbdEgH&quot;</span><span class="p">)</span> <span class="c1">;; =&gt; &quot;abdegh&quot;</span>

<span class="p">(</span><span class="nf">string-map</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">c</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">integer-&gt;char </span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nb">char-&gt;integer </span><span class="nv">c</span><span class="p">))))</span>
 <span class="s">&quot;HAL&quot;</span><span class="p">)</span> <span class="c1">;; =&gt; &quot;IBM&quot;</span>

<span class="p">(</span><span class="nf">string-map</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">c</span> <span class="nv">k</span><span class="p">)</span>
   <span class="p">((</span><span class="k">if </span><span class="p">(</span><span class="nb">eqv? </span><span class="nv">k</span> <span class="sc">#\u</span><span class="p">)</span> <span class="nv">char-upcase</span> <span class="nv">char-downcase</span><span class="p">)</span>
    <span class="nv">c</span><span class="p">))</span>
 <span class="s">&quot;studlycaps xxx&quot;</span>
 <span class="s">&quot;ululululul&quot;</span><span class="p">)</span> <span class="c1">;; =&gt; &quot;StUdLyCaPs&quot;</span>
</pre></div>
<p>(vector-map <em>proc </em>vector<sub>1</sub><em> </em>vector<sub>2</sub><em> … </em>)
 procedure
It is an error if <em>proc</em> does not accept as many arguments as there are
<em>vector</em>s and return a single value.</p>
<p>The vector-map procedure applies <em>proc</em> element-wise to the elements of
the <em>vector</em>s and returns a vector of the results, in order. If more
than one <em>vector</em> is given and not all vectors have the same length,
vector-map terminates when the shortest vector runs out. The dynamic
order in which <em>proc</em> is applied to the elements of the <em>vector</em>s is
unspecified. If multiple returns occur from vector-map, the values
returned by earlier returns are not mutated.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">vector-map</span> <span class="nv">cadr</span> <span class="o">&#39;#</span><span class="p">((</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">d</span> <span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nf">g</span> <span class="nv">h</span><span class="p">)))</span> <span class="c1">;; =&gt; #(b e h)</span>

<span class="p">(</span><span class="nf">vector-map</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">expt </span><span class="nv">n</span> <span class="nv">n</span><span class="p">))</span>
            <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">;; =&gt; #(1 4 27 256 3125)</span>

<span class="p">(</span><span class="nf">vector-map</span> <span class="nv">+</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span><span class="p">))</span> <span class="c1">;; =&gt; #(5 7 9)</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">count</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">vector-map</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">ignored</span><span class="p">)</span>
     <span class="p">(</span><span class="k">set! </span><span class="nv">count</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">count</span> <span class="mi">1</span><span class="p">))</span>
     <span class="nv">count</span><span class="p">)</span>
   <span class="o">&#39;#</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span> <span class="c1">;; =&gt; #(1 2) \var{or} #(2 1)</span>
</pre></div>
<p>(for-each <em>proc </em>list<sub>1</sub><em> </em>list<sub>2</sub><em> … </em>)  procedure
It is an error if <em>proc</em> does not accept as many arguments as there are
<em>list</em>s.</p>
<p>The arguments to for-each are like the arguments to map, but for-each
calls <em>proc</em> for its side effects rather than for its values. Unlike
map, for-each is guaranteed to call <em>proc</em> on the elements of the
<em>list</em>s in order from the first element(s) to the last, and the value
returned by for-each is unspecified. If more than one <em>list</em> is given
and not all lists have the same length, for-each terminates when the
shortest list runs out. The <em>list</em>s can be circular, but it is an error
if all of them are circular.</p>
<p>It is an error for <em>proc</em> to mutate any of the lists.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">v</span> <span class="p">(</span><span class="nb">make-vector </span><span class="mi">5</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">i</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">v</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">* </span><span class="nv">i</span> <span class="nv">i</span><span class="p">)))</span>
            <span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
  <span class="nv">v</span><span class="p">)</span> <span class="c1">;; =&gt; #(0 1 4 9 16)</span>
</pre></div>
<p>(string-for-each <em>proc </em>string<sub>1</sub><em> </em>string<sub>2</sub><em> … </em>)
 procedure
It is an error if <em>proc</em> does not accept as many arguments as there are
<em>string</em>s.</p>
<p>The arguments to string-for-each are like the arguments to string-map,
but string-for-each calls <em>proc</em> for its side effects rather than for
its values. Unlike string-map, string-for-each is guaranteed to call
<em>proc</em> on the elements of the <em>string</em>s in order from the first
element(s) to the last, and the value returned by string-for-each is
unspecified. If more than one <em>string</em> is given and not all strings have
the same length, string-for-each terminates when the shortest string
runs out. It is an error for <em>proc</em> to mutate any of the strings.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">v</span> <span class="o">&#39;</span><span class="p">()))</span>
  <span class="p">(</span><span class="nf">string-for-each</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">c</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">v</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">char-&gt;integer </span><span class="nv">c</span><span class="p">)</span> <span class="nv">v</span><span class="p">)))</span>
   <span class="s">&quot;abcde&quot;</span><span class="p">)</span>
  <span class="nv">v</span><span class="p">)</span> <span class="c1">;; =&gt; (101 100 99 98 97)</span>
</pre></div>
<p>(vector-for-each <em>proc </em>vector<sub>1</sub><em> </em>vector<sub>2</sub><em> … </em>)
 procedure
It is an error if <em>proc</em> does not accept as many arguments as there are
<em>vector</em>s.</p>
<p>The arguments to vector-for-each are like the arguments to vector-map,
but vector-for-each calls <em>proc</em> for its side effects rather than for
its values. Unlike vector-map, vector-for-each is guaranteed to call
<em>proc</em> on the elements of the <em>vector</em>s in order from the first
element(s) to the last, and the value returned by vector-for-each is
unspecified. If more than one <em>vector</em> is given and not all vectors have
the same length, vector-for-each terminates when the shortest vector
runs out. It is an error for <em>proc</em> to mutate any of the vectors.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">v</span> <span class="p">(</span><span class="nf">make-list</span> <span class="mi">5</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">vector-for-each</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">i</span><span class="p">)</span> <span class="p">(</span><span class="nf">list-set!</span> <span class="nv">v</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">* </span><span class="nv">i</span> <span class="nv">i</span><span class="p">)))</span>
   <span class="o">&#39;#</span><span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
  <span class="nv">v</span><span class="p">)</span> <span class="c1">;; =&gt; (0 1 4 9 16)</span>
</pre></div>
<p>(call-with-current-continuation <em>proc</em>)  procedure
(call/cc <em>proc</em>)  procedure
It is an error if <em>proc</em> does not accept one argument.</p>
<p>The procedure call-with-current-continuation (or its equivalent
abbreviation call/cc) packages the current continuation (see the
rationale below) as an “escape procedure” and passes it as an argument
to <em>proc</em>. The escape procedure is a Scheme procedure that, if it is
later called, will abandon whatever continuation is in effect at that
later time and will instead use the continuation that was in effect when
the escape procedure was created. Calling the escape procedure will
cause the invocation of <em>before</em> and <em>after</em> thunks installed using
<code>dynamic-wind</code>.</p>
<p>The escape procedure accepts the same number of arguments as the
continuation to the original call to <code>call-with-current-continuation</code>.
Most continuations take only one value. Continuations created by the
call-with-values procedure (including the initialization expressions of
define-values, let-values, and let*-values expressions), take the
number of values that the consumer expects. The continuations of all
non-final expressions within a sequence of expressions, such as in
lambda, case-lambda, begin, let, let*, letrec, letrec*, let-values,
let*-values, let-syntax, letrec-syntax, parameterize, guard, case,
cond, when, and unless expressions, take an arbitrary number of values
because they discard the values passed to them in any event. The effect
of passing no values or more than one value to continuations that were
not created in one of these ways is unspecified.</p>
<p>The escape procedure that is passed to <em>proc</em> has unlimited extent just
like any other procedure in Scheme. It can be stored in variables or
data structures and can be called as many times as desired. However,
like the raise and error procedures, it never returns to its caller.</p>
<p>The following examples show only the simplest ways in which
call-with-current-continuation is used. If all real uses were as simple
as these examples, there would be no need for a procedure with the power
of call-with-current-continuation.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">call-with-current-continuation</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">exit</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
               <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">negative? </span><span class="nv">x</span><span class="p">)</span>
                   <span class="p">(</span><span class="nf">exit</span> <span class="nv">x</span><span class="p">)))</span>
             <span class="o">&#39;</span><span class="p">(</span><span class="mi">54</span> <span class="mi">0</span> <span class="mi">37</span> <span class="mi">-3</span> <span class="mi">245</span> <span class="mi">19</span><span class="p">))</span>
   <span class="no">#t</span><span class="p">))</span> <span class="c1">;; =&gt; -3</span>

<span class="p">(</span><span class="k">define </span><span class="nv">list-length</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">obj</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">call-with-current-continuation</span>
     <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">return</span><span class="p">)</span>
       <span class="p">(</span><span class="k">letrec </span><span class="p">((</span><span class="nf">r</span>
                 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">obj</span><span class="p">)</span>
                   <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">obj</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
                         <span class="p">((</span><span class="nb">pair? </span><span class="nv">obj</span><span class="p">)</span>
                          <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">r</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">obj</span><span class="p">))</span> <span class="mi">1</span><span class="p">))</span>
                         <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">return</span> <span class="no">#f</span><span class="p">))))))</span>
         <span class="p">(</span><span class="nf">r</span> <span class="nv">obj</span><span class="p">))))))</span>

<span class="p">(</span><span class="nf">list-length</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">;; =&gt; 4</span>

<span class="p">(</span><span class="nf">list-length</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="o">.</span> <span class="nv">c</span><span class="p">))</span> <span class="c1">;; =&gt; #f</span>
</pre></div>
<p><em>Rationale:</em></p>
<p>A common use of call-with-current-continuation is for structured,
non-local exits from loops or procedure bodies, but in fact
call-with-current-continuation is useful for implementing a wide variety
of advanced control structures. In fact, raise and guard provide a more
structured mechanism for non-local exits.</p>
<p>Whenever a Scheme expression is evaluated there is a <em>continuation</em>
wanting the result of the expression. The continuation represents an
entire (default) future for the computation. If the expression is
evaluated at the REPL, for example, then the continuation might take the
result, print it on the screen, prompt for the next input, evaluate it,
and so on forever. Most of the time the continuation includes actions
specified by user code, as in a continuation that will take the result,
multiply it by the value stored in a local variable, add seven, and give
the answer to the REPL’s continuation to be printed. Normally these
ubiquitous continuations are hidden behind the scenes and programmers do
not think much about them. On rare occasions, however, a programmer
needs to deal with continuations explicitly. The
call-with-current-continuation procedure allows Scheme programmers to do
that by creating a procedure that acts just like the current
continuation.</p>
<p>(values <em>obj …</em>)  procedure
Delivers all of its arguments to its continuation. The <code>values</code>
procedure might be defined as follows:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">values </span><span class="o">.</span> <span class="nv">things</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">call-with-current-continuation</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">cont</span><span class="p">)</span> <span class="p">(</span><span class="nb">apply </span><span class="nv">cont</span> <span class="nv">things</span><span class="p">))))</span>
</pre></div>
<p>(call-with-values <em>producer consumer</em>)  procedure
Calls its <em>producer</em> argument with no arguments and a continuation that,
when passed some values, calls the <em>consumer</em> procedure with those
values as arguments. The continuation for the call to <em>consumer</em> is the
continuation of the call to <code>call-with-values</code>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">call-with-values </span><span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nb">values </span><span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">b</span><span class="p">))</span>
<span class="c1">;; =&gt; 5</span>

<span class="p">(</span><span class="nb">call-with-values </span><span class="nv">*</span> <span class="nv">-</span><span class="p">)</span> <span class="c1">;; =&gt; -1</span>
</pre></div>
<p>(dynamic-wind <em>before thunk after</em>)  procedure
Calls <em>thunk</em> without arguments, returning the result(s) of this call.
<em>Before</em> and <em>after</em> are called, also without arguments, as required by
the following rules. Note that, in the absence of calls to continuations
captured using <code>call-with-current-continuation</code>, the three arguments are
called once each, in order. <em>Before</em> is called whenever execution enters
the dynamic extent of the call to <em>thunk</em> and <em>after</em> is called whenever
it exits that dynamic extent. The dynamic extent of a procedure call is
the period between when the call is initiated and when it returns. The
<em>before</em> and <em>after</em> thunks are called in the same dynamic environment
as the call to dynamic-wind. In Scheme, because of
call-with-current-continuation, the dynamic extent of a call is not
always a single, connected time period. It is defined as follows:</p>
<ul>
<li><p>The dynamic extent is entered when execution of the body of the
called procedure begins.</p>
</li>
<li><p>The dynamic extent is also entered when execution is not within the
dynamic extent and a continuation is invoked that was captured
(using call-with-current-continuation) during the dynamic extent.</p>
</li>
<li><p>It is exited when the called procedure returns.</p>
</li>
<li><p>It is also exited when execution is within the dynamic extent and a
continuation is invoked that was captured while not within the
dynamic extent.</p>
</li>
</ul>
<p>If a second call to dynamic-wind occurs within the dynamic extent of the
call to <em>thunk</em> and then a continuation is invoked in such a way that
the <em>after</em>s from these two invocations of dynamic-wind are both to be
called, then the <em>after</em> associated with the second (inner) call to
dynamic-wind is called first.</p>
<p>If a second call to dynamic-wind occurs within the dynamic extent of the
call to <em>thunk</em> and then a continuation is invoked in such a way that
the <em>before</em>s from these two invocations of dynamic-wind are both to be
called, then the <em>before</em> associated with the first (outer) call to
dynamic-wind is called first.</p>
<p>If invoking a continuation requires calling the <em>before</em> from one call
to dynamic-wind and the <em>after</em> from another, then the <em>after</em> is called
first.</p>
<p>The effect of using a captured continuation to enter or exit the dynamic
extent of a call to <em>before</em> or <em>after</em> is unspecified.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">path</span> <span class="o">&#39;</span><span class="p">())</span>
      <span class="p">(</span><span class="nf">c</span> <span class="no">#f</span><span class="p">))</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">add</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">s</span><span class="p">)</span>
               <span class="p">(</span><span class="k">set! </span><span class="nv">path</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">s</span> <span class="nv">path</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nf">dynamic-wind</span>
        <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nf">add</span> <span class="ss">&#39;connect</span><span class="p">))</span>
        <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
          <span class="p">(</span><span class="nf">add</span> <span class="p">(</span><span class="nf">call-with-current-continuation</span>
                <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">c0</span><span class="p">)</span>
                  <span class="p">(</span><span class="k">set! </span><span class="nv">c</span> <span class="nv">c0</span><span class="p">)</span>
                  <span class="ss">&#39;talk1</span><span class="p">))))</span>
        <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nf">add</span> <span class="ss">&#39;disconnect</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">length </span><span class="nv">path</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">c</span> <span class="ss">&#39;talk2</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">reverse </span><span class="nv">path</span><span class="p">))))</span>
<span class="c1">;; =&gt; (connect talk1 disconnect connect talk2 disconnect)</span>
</pre></div>
<h3>Exceptions</h3>
<p>This section describes Scheme’s exception-handling and exception-raising
procedures. For the concept of Scheme exceptions, see
section <a href="#errorsituations">[errorsituations]</a>. See also
<a href="#guard">[guard]</a> for the guard syntax.</p>
<p><em>Exception handler</em>s are one-argument procedures that determine the
action the program takes when an exceptional situation is signaled. The
system implicitly maintains a current exception handler in the dynamic
environment.</p>
<p>The program raises an exception by invoking the current exception
handler, passing it an object encapsulating information about the
exception. Any procedure accepting one argument can serve as an
exception handler and any object can be used to represent an exception.</p>
<p>(with-exception-handler <strong>handler<em> </em>thunk</strong>)  procedure
It is an error if <em>handler</em> does not accept one argument. It is also an
error if <em>thunk</em> does not accept zero arguments.</p>
<p>The with-exception-handler procedure returns the results of invoking
<em>thunk</em>. <em>Handler</em> is installed as the current exception handler in the
dynamic environment used for the invocation of <em>thunk</em>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">call-with-current-continuation</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">k</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">with-exception-handler</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">display </span><span class="s">&quot;condition: &quot;</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">write </span><span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">newline</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">k</span> <span class="ss">&#39;exception</span><span class="p">))</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
      <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nf">raise</span> <span class="ss">&#39;an-error</span><span class="p">))))))</span>
<span class="c1">;; =&gt; exception and prints condition: an-error</span>

<span class="p">(</span><span class="nf">with-exception-handler</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">display </span><span class="s">&quot;something went wrong\n&quot;</span><span class="p">))</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
   <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nf">raise</span> <span class="ss">&#39;an-error</span><span class="p">))))</span>
<span class="c1">;; prints something went wrong</span>
</pre></div>
<p>After printing, the second example then raises another exception.</p>
<p>(raise <strong>obj</strong>)  procedure
Raises an exception by invoking the current exception handler on <em>obj</em>.
The handler is called with the same dynamic environment as that of the
call to raise, except that the current exception handler is the one that
was in place when the handler being called was installed. If the handler
returns, a secondary exception is raised in the same dynamic environment
as the handler. The relationship between <em>obj</em> and the object raised by
the secondary exception is unspecified.</p>
<p>(raise-continuable <strong>obj</strong>)  procedure
Raises an exception by invoking the current exception handler on <em>obj</em>.
The handler is called with the same dynamic environment as the call to
raise-continuable, except that: (1) the current exception handler is the
one that was in place when the handler being called was installed, and
(2) if the handler being called returns, then it will again become the
current exception handler. If the handler returns, the values it returns
become the values returned by the call to raise-continuable.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">with-exception-handler</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">con</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">cond</span>
    <span class="p">((</span><span class="nb">string? </span><span class="nv">con</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">display </span><span class="nv">con</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">else</span>
     <span class="p">(</span><span class="nb">display </span><span class="s">&quot;a warning has been issued&quot;</span><span class="p">)))</span>
   <span class="mi">42</span><span class="p">)</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
   <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">raise-continuable</span> <span class="s">&quot;should be a number&quot;</span><span class="p">)</span>
      <span class="mi">23</span><span class="p">)))</span>
<span class="c1">;; prints: should be a number</span>
<span class="c1">;; =&gt; 65</span>
</pre></div>
<p>(error *<em>message</em> <em>obj</em> …<em>)  procedure</em>Message* should be a string.</p>
<p>Raises an exception as if by calling raise on a newly allocated
implementation-defined object which encapsulates the information
provided by <em>message</em>, as well as any <em>obj</em>s, known as the <em>irritants</em>.
The procedure error-object? must return <code>#t</code> on such objects.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">null-list?</span> <span class="nv">l</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">pair? </span><span class="nv">l</span><span class="p">)</span> <span class="no">#f</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">null? </span><span class="nv">l</span><span class="p">)</span> <span class="no">#t</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">else</span>
         <span class="p">(</span><span class="nf">error</span>
          <span class="s">&quot;null-list?: argument out of domain&quot;</span>
          <span class="nv">l</span><span class="p">))))</span>
</pre></div>
<p>(error-object? <em>obj</em>)  procedure
Returns <code>#t</code> if <em>obj</em> is an object created by error or one of an
implementation-defined set of objects. Otherwise, it returns #f. The
objects used to signal errors, including those which satisfy the
predicates file-error? and read-error?, may or may not satisfy
error-object?.</p>
<p>(error-object-message <em>error-object</em>)  procedure
Returns the message encapsulated by <em>error-object</em>.</p>
<p>(error-object-irritants <em>error-object</em>)  procedure
Returns a list of the irritants encapsulated by <em>error-object</em>.</p>
<p>(read-error? <em>obj</em>)  procedure
(file-error? <em>obj</em>)  procedure
Error type predicates. Returns <code>#t</code> if <em>obj</em> is an object raised by the
read procedure or by the inability to open an input or output port on a
file, respectively. Otherwise, it returns #f.</p>
<h3>Environments and evaluation</h3>
<p>(environment <strong>l</strong>i<strong>s</strong>t<em><sub>1</sub> … </em>)  eval library procedure
This procedure returns a specifier for the environment that results by
starting with an empty environment and then importing each <em>list</em>,
considered as an import set, into it. (See
section <a href="#libraries">[libraries]</a> for a description of import sets.)
The bindings of the environment represented by the specifier are
immutable, as is the environment itself.</p>
<p>(scheme-report-environment <em>version</em>)  r5rs library procedure
If <em>version</em> is equal to 5, corresponding to R<sup><small>5</small></sup>RS,
scheme-report-environment returns a specifier for an environment that
contains only the bindings defined in the R<sup><small>5</small></sup>RS library.
Implementations must support this value of <em>version</em>.</p>
<p>Implementations may also support other values of <em>version</em>, in which
case they return a specifier for an environment containing bindings
corresponding to the specified version of the report. If <em>version</em> is
neither 5 nor another value supported by the implementation, an error is
signaled.</p>
<p>The effect of defining or assigning (through the use of eval) an
identifier bound in a scheme-report-environment (for example car) is
unspecified. Thus both the environment and the bindings it contains may
be immutable.</p>
<p>(null-environment <em>version</em>)  r5rs library procedure
If <em>version</em> is equal to 5, corresponding to R<sup><small>5</small></sup>RS, the
null-environment procedure returns a specifier for an environment that
contains only the bindings for all syntactic keywords defined in the
R<sup><small>5</small></sup>RS library. Implementations must support this value of
<em>version</em>.</p>
<p>Implementations may also support other values of <em>version</em>, in which
case they return a specifier for an environment containing appropriate
bindings corresponding to the specified version of the report. If
<em>version</em> is neither 5 nor another value supported by the
implementation, an error is signaled.</p>
<p>The effect of defining or assigning (through the use of eval) an
identifier bound in a scheme-report-environment (for example car) is
unspecified. Thus both the environment and the bindings it contains may
be immutable.</p>
<p>(interaction-environment)  repl library procedure
This procedure returns a specifier for a mutable environment that
contains an implementation-defined set of bindings, typically a superset
of those exported by <code>(scheme base)</code>. The intent is that this procedure
will return the environment in which the implementation would evaluate
expressions entered by the user into a REPL.</p>
<p>(eval <em>expr-or-def environment-specifier</em>)  eval library procedure
If <em>expr-or-def</em> is an expression, it is evaluated in the specified
environment and its values are returned. If it is a definition, the
specified identifier(s) are defined in the specified environment,
provided the environment is not immutable. Implementations may extend
eval to allow other objects.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">eval </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">*</span> <span class="mi">7</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nf">environment</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">scheme</span> <span class="nv">base</span><span class="p">)))</span>
<span class="c1">;; =&gt; 21</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">f</span> <span class="p">(</span><span class="nb">eval </span><span class="o">&#39;</span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
               <span class="p">(</span><span class="nb">null-environment </span><span class="mi">5</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">f</span> <span class="nv">+</span> <span class="mi">10</span><span class="p">))</span>
<span class="c1">;; =&gt; 20</span>
<span class="p">(</span><span class="nb">eval </span><span class="o">&#39;</span><span class="p">(</span><span class="k">define </span><span class="nv">foo</span> <span class="mi">32</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">environment</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">scheme</span> <span class="nv">base</span><span class="p">)))</span>
<span class="c1">;; =&gt; error is signaled</span>
</pre></div>
<h3>Input and output</h3>
<h4>Ports</h4>
<p>Ports represent input and output devices. To Scheme, an input port is a
Scheme object that can deliver data upon command, while an output port
is a Scheme object that can accept data. Whether the input and output
port types are disjoint is implementation-dependent.</p>
<p>Different <em>port types</em> operate on different data. Scheme implementations
are required to support <em>textual ports</em> and <em>binary ports</em>, but may also
provide other port types.</p>
<p>A textual port supports reading or writing of individual characters from
or to a backing store containing characters using read-char and
write-char below, and it supports operations defined in terms of
characters, such as read and write.</p>
<p>A binary port supports reading or writing of individual bytes from or to
a backing store containing bytes using read-u8 and write-u8 below, as
well as operations defined in terms of bytes. Whether the textual and
binary port types are disjoint is implementation-dependent.</p>
<p>Ports can be used to access files, devices, and similar things on the
host system on which the Scheme program is running.</p>
<p>(call-with-port <em>port proc</em>)  procedure
It is an error if <em>proc</em> does not accept one argument.</p>
<p>The call-with-port procedure calls <em>proc</em> with <em>port</em> as an argument. If
<em>proc</em> returns, then the port is closed automatically and the values
yielded by the <em>proc</em> are returned. If <em>proc</em> does not return, then the
port must not be closed automatically unless it is possible to prove
that the port will never again be used for a read or write operation.</p>
<p><em>Rationale:</em> Because Scheme’s escape procedures have unlimited extent,
it is possible to escape from the current continuation but later to
resume it. If implementations were permitted to close the port on any
escape from the current continuation, then it would be impossible to
write portable code using both call-with-current-continuation and
call-with-port.</p>
<p>(call-with-input-file <em>string proc</em>)  file library procedure
(call-with-output-file <em>string proc</em>)  file library procedure
It is an error if <em>proc</em> does not accept one argument.</p>
<p>These procedures obtain a textual port obtained by opening the named
file for input or output as if by open-input-file or open-output-file.
The port and <em>proc</em> are then passed to a procedure equivalent to
call-with-port.</p>
<p>(input-port? <em>obj</em>)  procedure
(output-port? <em>obj</em>)  procedure
(textual-port? <em>obj</em>)  procedure
(binary-port? <em>obj</em>)  procedure
(port? <em>obj</em>)  procedure
These procedures return <code>#t</code> if <em>obj</em> is an input port, output port,
textual port, binary port, or any kind of port, respectively. Otherwise
they return #f.</p>
<p>(input-port-open? <em>port</em>)  procedure
(output-port-open? <em>port</em>)  procedure
Returns <code>#t</code> if <em>port</em> is still open and capable of performing input or
output, respectively, and <code>#f</code> otherwise.</p>
<p>(current-input-port)  procedure
(current-output-port)  procedure
(current-error-port)  procedure
Returns the current default input port, output port, or error port (an
output port), respectively. These procedures are parameter objects,
which can be overridden with parameterize (see
section <a href="#make-parameter">[make-parameter]</a>). The initial bindings for
these are implementation-defined textual ports.</p>
<p>(with-input-from-file <em>string thunk</em>)  file library procedure
(with-output-to-file <em>string thunk</em>)  file library procedure
The file is opened for input or output as if by open-input-file or
open-output-file, and the new port is made to be the value returned by
current-input-port or current-output-port (as used by <code>(read)</code>,
<code>(write obj)</code>, and so forth). The <em>thunk</em> is then called with no
arguments. When the <em>thunk</em> returns, the port is closed and the previous
default is restored. It is an error if <em>thunk</em> does not accept zero
arguments. Both procedures return the values yielded by <em>thunk</em>. If an
escape procedure is used to escape from the continuation of these
procedures, they behave exactly as if the current input or output port
had been bound dynamically with parameterize.</p>
<p>(open-input-file <em>string</em>)  file library procedure
(open-binary-input-file <em>string</em>)  file library procedure
Takes a <em>string</em> for an existing file and returns a textual input port
or binary input port that is capable of delivering data from the file.
If the file does not exist or cannot be opened, an error that satisfies
file-error? is signaled.</p>
<p>(open-output-file <em>string</em>)  file library procedure
(open-binary-output-file <em>string</em>)  file library procedure
Takes a <em>string</em> naming an output file to be created and returns a
textual output port or binary output port that is capable of writing
data to a new file by that name.</p>
<p>If a file with the given name already exists, the effect is unspecified.
If the file cannot be opened, an error that satisfies file-error? is
signaled.</p>
<p>(close-port <em>port</em>)  procedure
(close-input-port <em>port</em>)  procedure
(close-output-port <em>port</em>)  procedure
Closes the resource associated with <em>port</em>, rendering the <em>port</em>
incapable of delivering or accepting data. It is an error to apply the
last two procedures to a port which is not an input or output port,
respectively. Scheme implementations may provide ports which are
simultaneously input and output ports, such as sockets; the
close-input-port and close-output-port procedures can then be used to
close the input and output sides of the port independently.</p>
<p>These routines have no effect if the port has already been closed.</p>
<p>(open-input-string <em>string</em>)  procedure
Takes a string and returns a textual input port that delivers characters
from the string. If the string is modified, the effect is unspecified.</p>
<p>(open-output-string)  procedure
Returns a textual output port that will accumulate characters for
retrieval by get-output-string.</p>
<p>(get-output-string <em>port</em>)  procedure
It is an error if <em>port</em> was not created with open-output-string.</p>
<p>Returns a string consisting of the characters that have been output to
the port so far in the order they were output. If the result string is
modified, the effect is unspecified.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">parameterize</span>
    <span class="p">((</span><span class="nf">current-output-port</span>
      <span class="p">(</span><span class="nf">open-output-string</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">display </span><span class="s">&quot;piece&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display </span><span class="s">&quot; by piece &quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display </span><span class="s">&quot;by piece.&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">newline</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">get-output-string</span> <span class="p">(</span><span class="nf">current-output-port</span><span class="p">)))</span>
<span class="c1">;; =&gt; &quot;piece by piece by piece.\n&quot;</span>
</pre></div>
<p>(open-input-bytevector <em>bytevector</em>)  procedure
Takes a bytevector and returns a binary input port that delivers bytes
from the bytevector.</p>
<p>(open-output-bytevector)  procedure
Returns a binary output port that will accumulate bytes for retrieval by
get-output-bytevector.</p>
<p>(get-output-bytevector <em>port</em>)  procedure
It is an error if <em>port</em> was not created with open-output-bytevector.</p>
<p>Returns a bytevector consisting of the bytes that have been output to
the port so far in the order they were output.</p>
<h4>Input</h4>
<p>If <em>port</em> is omitted from any input procedure, it defaults to the value
returned by (current-input-port). It is an error to attempt an input
operation on a closed port.</p>
<p>(read)  read library procedure
(read <em>port</em>)  read library procedure
The read procedure converts external representations of Scheme objects
into the objects themselves. That is, it is a parser for the
non-terminal datum (see sections <a href="#datum">[datum]</a> and
<a href="#listsection">[listsection]</a>). It returns the next object parsable
from the given textual input <em>port</em>, updating <em>port</em> to point to the
first character past the end of the external representation of the
object.</p>
<p>Implementations may support extended syntax to represent record types or
other types that do not have datum representations.</p>
<p>If an end of file is encountered in the input before any characters are
found that can begin an object, then an end-of-file object is returned.
The port remains open, and further attempts to read will also return an
end-of-file object. If an end of file is encountered after the beginning
of an object’s external representation, but the external representation
is incomplete and therefore not parsable, an error that satisfies
read-error? is signaled.</p>
<p>(read-char)  procedure
(read-char <em>port</em>)  procedure
Returns the next character available from the textual input <em>port</em>,
updating the <em>port</em> to point to the following character. If no more
characters are available, an end-of-file object is returned.</p>
<p>(peek-char)  procedure
(peek-char <em>port</em>)  procedure
Returns the next character available from the textual input <em>port</em>, but
<em>without</em> updating the <em>port</em> to point to the following character. If no
more characters are available, an end-of-file object is returned.</p>
<p><em>Note:</em> The value returned by a call to peek-char is the same as the
value that would have been returned by a call to read-char with the same
<em>port</em>. The only difference is that the very next call to read-char or
peek-char on that <em>port</em> will return the value returned by the preceding
call to peek-char. In particular, a call to peek-char on an interactive
port will hang waiting for input whenever a call to read-char would have
hung.</p>
<p>(read-line)  procedure
(read-line <em>port</em>)  procedure
Returns the next line of text available from the textual input <em>port</em>,
updating the <em>port</em> to point to the following character. If an end of
line is read, a string containing all of the text up to (but not
including) the end of line is returned, and the port is updated to point
just past the end of line. If an end of file is encountered before any
end of line is read, but some characters have been read, a string
containing those characters is returned. If an end of file is
encountered before any characters are read, an end-of-file object is
returned. For the purpose of this procedure, an end of line consists of
either a linefeed character, a carriage return character, or a sequence
of a carriage return character followed by a linefeed character.
Implementations may also recognize other end of line characters or
sequences.</p>
<p>(eof-object? <em>obj</em>)  procedure
Returns <code>#t</code> if <em>obj</em> is an end-of-file object, otherwise returns #f. The
precise set of end-of-file objects will vary among implementations, but
in any case no end-of-file object will ever be an object that can be
read in using read.</p>
<p>(eof-object)  procedure
Returns an end-of-file object, not necessarily unique.</p>
<p>(char-ready?)  procedure
(char-ready? <em>port</em>)  procedure
Returns <code>#t</code> if a character is ready on the textual input <em>port</em> and
returns <code>#f</code> otherwise. If char-ready returns <code>#t</code> then the next read-char
operation on the given <em>port</em> is guaranteed not to hang. If the <em>port</em>
is at end of file then char-ready? returns #t.</p>
<p><em>Rationale:</em> The char-ready? procedure exists to make it possible for a
program to accept characters from interactive ports without getting
stuck waiting for input. Any input editors associated with such ports
must ensure that characters whose existence has been asserted by
char-ready? cannot be removed from the input. If char-ready? were to
return <code>#f</code> at end of file, a port at end of file would be
indistinguishable from an interactive port that has no ready characters.</p>
<p>(read-string <em>k</em>)  procedure
(read-string <em>k port</em>)  procedure
Reads the next <em>k</em> characters, or as many as are available before the
end of file, from the textual input <em>port</em> into a newly allocated string
in left-to-right order and returns the string. If no characters are
available before the end of file, an end-of-file object is returned.</p>
<p>(read-u8)  procedure
(read-u8 <em>port</em>)  procedure
Returns the next byte available from the binary input <em>port</em>, updating
the <em>port</em> to point to the following byte. If no more bytes are
available, an end-of-file object is returned.</p>
<p>(peek-u8)  procedure
(peek-u8 <em>port</em>)  procedure
Returns the next byte available from the binary input <em>port</em>, but
<em>without</em> updating the <em>port</em> to point to the following byte. If no more
bytes are available, an end-of-file object is returned.</p>
<p>(u8-ready?)  procedure
(u8-ready? <em>port</em>)  procedure
Returns <code>#t</code> if a byte is ready on the binary input <em>port</em> and returns #f
otherwise. If u8-ready? returns <code>#t</code> then the next read-u8 operation on
the given <em>port</em> is guaranteed not to hang. If the <em>port</em> is at end of
file then u8-ready? returns #t.</p>
<p>(read-bytevector <em>k</em>)  procedure
(read-bytevector <em>k port</em>)  procedure
Reads the next <em>k</em> bytes, or as many as are available before the end of
file, from the binary input <em>port</em> into a newly allocated bytevector in
left-to-right order and returns the bytevector. If no bytes are
available before the end of file, an end-of-file object is returned.</p>
<p>(read-bytevector! <em>bytevector</em>)  procedure
(read-bytevector! <em>bytevector port</em>)  procedure
(read-bytevector! <em>bytevector port start</em>)  procedure
(read-bytevector! <em>bytevector port start end</em>)  procedure
Reads the next <em>e<strong>n</strong>d</em> − <em>s<strong>t</strong>a<strong>r</strong>t</em> bytes, or as many as are
available before the end of file, from the binary input <em>port</em> into
<em>bytevector</em> in left-to-right order beginning at the <em>start</em> position.
If <em>end</em> is not supplied, reads until the end of <em>bytevector</em> has been
reached. If <em>start</em> is not supplied, reads beginning at position 0.
Returns the number of bytes read. If no bytes are available, an
end-of-file object is returned.</p>
<h4>Output</h4>
<p>If <em>port</em> is omitted from any output procedure, it defaults to the value
returned by (current-output-port). It is an error to attempt an output
operation on a closed port.</p>
<p>(write <em>obj</em>)  write library procedure
(write <em>obj port</em>)  write library procedure
Writes a representation of <em>obj</em> to the given textual output <em>port</em>.
Strings that appear in the written representation are enclosed in
quotation marks, and within those strings backslash and quotation mark
characters are escaped by backslashes. Symbols that contain non-ASCII
characters are escaped with vertical lines. Character objects are
written using the #<code>'</code> notation.</p>
<p>If <em>obj</em> contains cycles which would cause an infinite loop using the
normal written representation, then at least the objects that form part
of the cycle must be represented using datum labels as described in
section <a href="#labelsection">[labelsection]</a>. Datum labels must not be used
if there are no cycles.</p>
<p>Implementations may support extended syntax to represent record types or
other types that do not have datum representations.</p>
<p>The write procedure returns an unspecified value.</p>
<p>(write-shared <em>obj</em>)  write library procedure
(write-shared <em>obj port</em>)  write library procedure
The write-shared procedure is the same as write, except that shared
structure must be represented using datum labels for all pairs and
vectors that appear more than once in the output.</p>
<p>(write-simple <em>obj</em>)  write library procedure
(write-simple <em>obj port</em>)  write library procedure
The write-simple procedure is the same as write, except that shared
structure is never represented using datum labels. This can cause
write-simple not to terminate if <em>obj</em> contains circular structure.</p>
<p>(display <em>obj</em>)  write library procedure
(display <em>obj port</em>)  write library procedure
Writes a representation of <em>obj</em> to the given textual output <em>port</em>.
Strings that appear in the written representation are output as if by
write-string instead of by write. Symbols are not escaped. Character
objects appear in the representation as if written by write-char instead
of by write.</p>
<p>The display representation of other objects is unspecified. However,
display must not loop forever on self-referencing pairs, vectors, or
records. Thus if the normal write representation is used, datum labels
are needed to represent cycles as in write.</p>
<p>Implementations may support extended syntax to represent record types or
other types that do not have datum representations.</p>
<p>The display procedure returns an unspecified value.</p>
<p><em>Rationale:</em> The write procedure is intended for producing
machine-readable output and display for producing human-readable output.</p>
<p>(newline)  procedure
(newline <em>port</em>)  procedure
Writes an end of line to textual output <em>port</em>. Exactly how this is done
differs from one operating system to another. Returns an unspecified
value.</p>
<p>(write-char <em>char</em>)  procedure
(write-char <em>char port</em>)  procedure
Writes the character <em>char</em> (not an external representation of the
character) to the given textual output <em>port</em> and returns an unspecified
value.</p>
<p>(write-string <em>string</em>)  procedure
(write-string <em>string port</em>)  procedure
(write-string <em>string port start</em>)  procedure
(write-string <em>string port start end</em>)  procedure
Writes the characters of <em>string</em> from <em>start</em> to <em>end</em> in left-to-right
order to the textual output <em>port</em>.</p>
<p>(write-u8 <em>byte</em>)  procedure
(write-u8 <em>byte port</em>)  procedure
Writes the <em>byte</em> to the given binary output <em>port</em> and returns an
unspecified value.</p>
<p>(write-bytevector <em>bytevector</em>)  procedure
(write-bytevector <em>bytevector port</em>)  procedure
(write-bytevector <em>bytevector port start</em>)  procedure
(write-bytevector <em>bytevector port start end</em>)  procedure
Writes the bytes of <em>bytevector</em> from <em>start</em> to <em>end</em> in left-to-right
order to the binary output <em>port</em>.</p>
<p>(flush-output-port)  procedure
(flush-output-port <em>port</em>)  procedure
Flushes any buffered output from the buffer of output-port to the
underlying file or device and returns an unspecified value.</p>
<h3>System interface</h3>
<p>Questions of system interface generally fall outside of the domain of
this report. However, the following operations are important enough to
deserve description here.</p>
<p>(load <em>filename</em>)  load library procedure
(load <em>filename environment-specifier</em>)  load library procedure
It is an error if <em>filename</em> is not a string.</p>
<p>An implementation-dependent operation is used to transform <em>filename</em>
into the name of an existing file containing Scheme source code. The
load procedure reads expressions and definitions from the file and
evaluates them sequentially in the environment specified by
<em>environment-specifier</em>. If <em>environment-specifier</em> is omitted,
(interaction-environment) is assumed.</p>
<p>It is unspecified whether the results of the expressions are printed.
The load procedure does not affect the values returned by
current-input-port and current-output-port. It returns an unspecified
value.</p>
<p><em>Rationale:</em> For portability, load must operate on source files. Its
operation on other kinds of files necessarily varies among
implementations.</p>
<p>(file-exists? <em>filename</em>)  file library procedure
It is an error if <em>filename</em> is not a string.</p>
<p>The file-exists? procedure returns <code>#t</code> if the named file exists at the
time the procedure is called, and <code>#f</code> otherwise.</p>
<p>(delete-file <em>filename</em>)  file library procedure
It is an error if <em>filename</em> is not a string.</p>
<p>The delete-file procedure deletes the named file if it exists and can be
deleted, and returns an unspecified value. If the file does not exist or
cannot be deleted, an error that satisfies file-error? is signaled.</p>
<p>(command-line)  process-context library procedure
Returns the command line passed to the process as a list of strings. The
first string corresponds to the command name, and is
implementation-dependent. It is an error to mutate any of these strings.</p>
<p>(exit)  process-context library procedure
(exit <em>obj</em>)  process-context library procedure
Runs all outstanding dynamic-wind <em>after</em> procedures, terminates the
running program, and communicates an exit value to the operating system.
If no argument is supplied, or if <em>obj</em> is #t, the exit procedure should
communicate to the operating system that the program exited normally. If
<em>obj</em> is #f, the exit procedure should communicate to the operating
system that the program exited abnormally. Otherwise, exit should
translate <em>obj</em> into an appropriate exit value for the operating system,
if possible.</p>
<p>The exit procedure must not signal an exception or return to its
continuation.</p>
<p><em>Note:</em> Because of the requirement to run handlers, this procedure is
not just the operating system’s exit procedure.</p>
<p>(emergency-exit)  process-context library procedure
(emergency-exit <em>obj</em>)  process-context library procedure
Terminates the program without running any outstanding dynamic-wind
<em>after</em> procedures and communicates an exit value to the operating
system in the same manner as exit.</p>
<p><em>Note:</em> The emergency-exit procedure corresponds to the _exit procedure
in Windows and Posix.</p>
<p>(get-environment-variable <em>name</em>)  process-context library procedure
Many operating systems provide each running process with an
<em>environment</em> consisting of <em>environment variables</em>. (This environment
is not to be confused with the Scheme environments that can be passed to
eval: see section <a href="#environments">[environments]</a>.) Both the name and
value of an environment variable are strings. The procedure
get-environment-variable returns the value of the environment variable
<em>name</em>, or <code>#f</code> if the named environment variable is not found. It may use
locale information to encode the name and decode the value of the
environment variable. It is an error if
get-environment-variable can’t decode the value. It is also an error to
mutate the resulting string.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">get-environment-variable</span> <span class="s">&quot;PATH&quot;</span><span class="p">)</span> <span class="c1">;; =&gt; &quot;/usr/local/bin:/usr/bin:/bin&quot;</span>
</pre></div>
<p>(get-environment-variables)  process-context library procedure
Returns the names and values of all the environment variables as an
alist, where the car of each entry is the name of an environment
variable and the cdr is its value, both as strings. The order of the
list is unspecified. It is an error to mutate any of these strings or
the alist itself.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">get-environment-variables</span><span class="p">)</span> <span class="c1">;; =&gt; ((&quot;USER&quot; . &quot;root&quot;) (&quot;HOME&quot; . &quot;/&quot;))</span>
</pre></div>
<p>(current-second)  time library procedure
Returns an inexact number representing the current time on the
International Atomic Time (TAI) scale. The value 0.0 represents midnight
on January 1, 1970 TAI (equivalent to 8.000082 seconds before midnight
Universal Time) and the value 1.0 represents one TAI second later.
Neither high accuracy nor high precision are required; in particular,
returning Coordinated Universal Time plus a suitable constant might be
the best an implementation can do.</p>
<p>As of 2018, a TAI-UTC offset table can be found at <span
class="citation" cites="TAI"></span>.</p>
<p>(current-jiffy)  time library procedure
Returns the number of <em>jiffies</em> as an exact integer that have elapsed
since an arbitrary, implementation-defined epoch. A jiffy is an
implementation-defined fraction of a second which is defined by the
return value of the jiffies-per-second procedure. The starting epoch is
guaranteed to be constant during a run of the program, but may vary
between runs.</p>
<p><em>Rationale:</em> Jiffies are allowed to be implementation-dependent so that
current-jiffy can execute with minimum overhead. It should be very
likely that a compactly represented integer will suffice as the returned
value. Any particular jiffy size will be inappropriate for some
implementations: a microsecond is too long for a very fast machine,
while a much smaller unit would force many implementations to return
integers which have to be allocated for most calls, rendering
current-jiffy less useful for accurate timing measurements.</p>
<p>(jiffies-per-second)  time library procedure
Returns an exact integer representing the number of jiffies per SI
second. This value is an implementation-specified constant.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">time-length</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nb">list </span><span class="p">(</span><span class="nf">make-list</span> <span class="mi">100000</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">start</span> <span class="p">(</span><span class="nf">current-jiffy</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">length </span><span class="nv">list</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">current-jiffy</span><span class="p">)</span> <span class="nv">start</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">jiffies-per-second</span><span class="p">))))</span>
</pre></div>
<p>(features)  procedure
Returns a list of the feature identifiers which cond-expand treats as
true. It is an error to modify this list. Here is an example of what
features might return:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">features</span><span class="p">)</span> <span class="err">\</span><span class="nv">ev</span>
<span class="p">(</span><span class="nf">r7rs</span> <span class="nv">ratios</span> <span class="nv">exact-complex</span> <span class="nv">full-unicode</span>
      <span class="nv">gnu-linux</span> <span class="nv">little-endian</span>
      <span class="nv">fantastic-scheme</span>
      <span class="nv">fantastic-scheme-1</span><span class="o">.</span><span class="mi">0</span>
      <span class="nv">space-ship-control-system</span><span class="p">)</span>
</pre></div>
<h3>Derived expression types</h3>
<p>This section gives syntax definitions for the derived expression types
in terms of the primitive expression types (literal, variable, call,
lambda, if, and set!), except for quasiquote.</p>
<p>Conditional derived syntax types:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define-syntax </span><span class="nv">cond</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">(</span><span class="k">else </span><span class="nv">=&gt;</span><span class="p">)</span>
    <span class="p">((</span><span class="k">cond </span><span class="p">(</span><span class="k">else </span><span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">))</span>
     <span class="p">(</span><span class="k">begin </span><span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">))</span>
    <span class="p">((</span><span class="k">cond </span><span class="p">(</span><span class="nf">test</span> <span class="k">=&gt; </span><span class="nv">result</span><span class="p">))</span>
     <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">temp</span> <span class="nv">test</span><span class="p">))</span>
       <span class="p">(</span><span class="k">if </span><span class="nv">temp</span> <span class="p">(</span><span class="nf">result</span> <span class="nv">temp</span><span class="p">))))</span>
    <span class="p">((</span><span class="k">cond </span><span class="p">(</span><span class="nf">test</span> <span class="k">=&gt; </span><span class="nv">result</span><span class="p">)</span> <span class="nv">clause1</span> <span class="nv">clause2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">temp</span> <span class="nv">test</span><span class="p">))</span>
       <span class="p">(</span><span class="k">if </span><span class="nv">temp</span>
           <span class="p">(</span><span class="nf">result</span> <span class="nv">temp</span><span class="p">)</span>
           <span class="p">(</span><span class="k">cond </span><span class="nv">clause1</span> <span class="nv">clause2</span> <span class="o">...</span><span class="p">))))</span>
    <span class="p">((</span><span class="k">cond </span><span class="p">(</span><span class="nf">test</span><span class="p">))</span> <span class="nv">test</span><span class="p">)</span>
    <span class="p">((</span><span class="k">cond </span><span class="p">(</span><span class="nf">test</span><span class="p">)</span> <span class="nv">clause1</span> <span class="nv">clause2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">temp</span> <span class="nv">test</span><span class="p">))</span>
       <span class="p">(</span><span class="k">if </span><span class="nv">temp</span>
           <span class="nv">temp</span>
           <span class="p">(</span><span class="k">cond </span><span class="nv">clause1</span> <span class="nv">clause2</span> <span class="o">...</span><span class="p">))))</span>
    <span class="p">((</span><span class="k">cond </span><span class="p">(</span><span class="nf">test</span> <span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">))</span>
     <span class="p">(</span><span class="k">if </span><span class="nv">test</span> <span class="p">(</span><span class="k">begin </span><span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">)))</span>
    <span class="p">((</span><span class="k">cond </span><span class="p">(</span><span class="nf">test</span> <span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">)</span>
           <span class="nv">clause1</span> <span class="nv">clause2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">if </span><span class="nv">test</span>
         <span class="p">(</span><span class="k">begin </span><span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">)</span>
         <span class="p">(</span><span class="k">cond </span><span class="nv">clause1</span> <span class="nv">clause2</span> <span class="o">...</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define-syntax </span><span class="nv">case</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">(</span><span class="k">else </span><span class="nv">=&gt;</span><span class="p">)</span>
    <span class="p">((</span><span class="k">case </span><span class="p">(</span><span class="nf">key</span> <span class="o">...</span><span class="p">)</span>
       <span class="nv">clauses</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">atom-key</span> <span class="p">(</span><span class="nf">key</span> <span class="o">...</span><span class="p">)))</span>
       <span class="p">(</span><span class="k">case </span><span class="nv">atom-key</span> <span class="nv">clauses</span> <span class="o">...</span><span class="p">)))</span>
    <span class="p">((</span><span class="k">case </span><span class="nv">key</span>
       <span class="p">(</span><span class="k">else =&gt; </span><span class="nv">result</span><span class="p">))</span>
     <span class="p">(</span><span class="nf">result</span> <span class="nv">key</span><span class="p">))</span>
    <span class="p">((</span><span class="k">case </span><span class="nv">key</span>
       <span class="p">(</span><span class="k">else </span><span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">))</span>
     <span class="p">(</span><span class="k">begin </span><span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">))</span>
    <span class="p">((</span><span class="k">case </span><span class="nv">key</span>
       <span class="p">((</span><span class="nf">atoms</span> <span class="o">...</span><span class="p">)</span> <span class="k">=&gt; </span><span class="nv">result</span><span class="p">))</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">memv </span><span class="nv">key</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">atoms</span> <span class="o">...</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">result</span> <span class="nv">key</span><span class="p">)))</span>
    <span class="p">((</span><span class="k">case </span><span class="nv">key</span>
       <span class="p">((</span><span class="nf">atoms</span> <span class="o">...</span><span class="p">)</span> <span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">))</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">memv </span><span class="nv">key</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">atoms</span> <span class="o">...</span><span class="p">))</span>
         <span class="p">(</span><span class="k">begin </span><span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">)))</span>
    <span class="p">((</span><span class="k">case </span><span class="nv">key</span>
       <span class="p">((</span><span class="nf">atoms</span> <span class="o">...</span><span class="p">)</span> <span class="k">=&gt; </span><span class="nv">result</span><span class="p">)</span>
       <span class="nv">clause</span> <span class="nv">clauses</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">memv </span><span class="nv">key</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">atoms</span> <span class="o">...</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">result</span> <span class="nv">key</span><span class="p">)</span>
         <span class="p">(</span><span class="k">case </span><span class="nv">key</span> <span class="nv">clause</span> <span class="nv">clauses</span> <span class="o">...</span><span class="p">)))</span>
    <span class="p">((</span><span class="k">case </span><span class="nv">key</span>
       <span class="p">((</span><span class="nf">atoms</span> <span class="o">...</span><span class="p">)</span> <span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">)</span>
       <span class="nv">clause</span> <span class="nv">clauses</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">memv </span><span class="nv">key</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">atoms</span> <span class="o">...</span><span class="p">))</span>
         <span class="p">(</span><span class="k">begin </span><span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">)</span>
         <span class="p">(</span><span class="k">case </span><span class="nv">key</span> <span class="nv">clause</span> <span class="nv">clauses</span> <span class="o">...</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define-syntax </span><span class="nv">and</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="nf">and</span><span class="p">)</span> <span class="no">#t</span><span class="p">)</span>
    <span class="p">((</span><span class="k">and </span><span class="nv">test</span><span class="p">)</span> <span class="nv">test</span><span class="p">)</span>
    <span class="p">((</span><span class="k">and </span><span class="nv">test1</span> <span class="nv">test2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">if </span><span class="nv">test1</span> <span class="p">(</span><span class="k">and </span><span class="nv">test2</span> <span class="o">...</span><span class="p">)</span> <span class="no">#f</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define-syntax </span><span class="nv">or</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="nf">or</span><span class="p">)</span> <span class="no">#f</span><span class="p">)</span>
    <span class="p">((</span><span class="k">or </span><span class="nv">test</span><span class="p">)</span> <span class="nv">test</span><span class="p">)</span>
    <span class="p">((</span><span class="k">or </span><span class="nv">test1</span> <span class="nv">test2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="nv">test1</span><span class="p">))</span>
       <span class="p">(</span><span class="k">if </span><span class="nv">x</span> <span class="nv">x</span> <span class="p">(</span><span class="k">or </span><span class="nv">test2</span> <span class="o">...</span><span class="p">))))))</span>

<span class="p">(</span><span class="k">define-syntax </span><span class="nv">when</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="nf">when</span> <span class="nv">test</span> <span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">if </span><span class="nv">test</span>
         <span class="p">(</span><span class="k">begin </span><span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define-syntax </span><span class="nv">unless</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="nf">unless</span> <span class="nv">test</span> <span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">test</span><span class="p">)</span>
         <span class="p">(</span><span class="k">begin </span><span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">)))))</span>
</pre></div>
<p>Binding constructs:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define-syntax </span><span class="nv">let</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="k">let </span><span class="p">((</span><span class="nf">name</span> <span class="nv">val</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span> <span class="nv">body1</span> <span class="nv">body2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">name</span> <span class="o">...</span><span class="p">)</span> <span class="nv">body1</span> <span class="nv">body2</span> <span class="o">...</span><span class="p">)</span>
      <span class="nv">val</span> <span class="o">...</span><span class="p">))</span>
    <span class="p">((</span><span class="k">let </span><span class="nv">tag</span> <span class="p">((</span><span class="nf">name</span> <span class="nv">val</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span> <span class="nv">body1</span> <span class="nv">body2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">((</span><span class="k">letrec </span><span class="p">((</span><span class="nf">tag</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">name</span> <span class="o">...</span><span class="p">)</span>
                      <span class="nv">body1</span> <span class="nv">body2</span> <span class="o">...</span><span class="p">)))</span>
        <span class="nv">tag</span><span class="p">)</span>
      <span class="nv">val</span> <span class="o">...</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define-syntax </span><span class="nv">let*</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="k">let* </span><span class="p">()</span> <span class="nv">body1</span> <span class="nv">body2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">let </span><span class="p">()</span> <span class="nv">body1</span> <span class="nv">body2</span> <span class="o">...</span><span class="p">))</span>
    <span class="p">((</span><span class="k">let* </span><span class="p">((</span><span class="nf">name1</span> <span class="nv">val1</span><span class="p">)</span> <span class="p">(</span><span class="nf">name2</span> <span class="nv">val2</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
       <span class="nv">body1</span> <span class="nv">body2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">name1</span> <span class="nv">val1</span><span class="p">))</span>
       <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">name2</span> <span class="nv">val2</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
         <span class="nv">body1</span> <span class="nv">body2</span> <span class="o">...</span><span class="p">)))))</span>
</pre></div>
<p>The following letrec macro uses the symbol \<undefined> in place of an
expression which returns something that when stored in a location makes
it an error to try to obtain the value stored in the location. (No such
expression is defined in Verbatim.) A trick is used to generate the
temporary names needed to avoid specifying the order in which the values
are evaluated. This could also be accomplished by using an auxiliary
macro.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define-syntax </span><span class="nv">letrec</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="k">letrec </span><span class="p">((</span><span class="nf">var1</span> <span class="nv">init1</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span> <span class="nv">body</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">letrec </span><span class="s">&quot;generate_temp_names&quot;</span>
       <span class="p">(</span><span class="nf">var1</span> <span class="o">...</span><span class="p">)</span>
       <span class="p">()</span>
       <span class="p">((</span><span class="nf">var1</span> <span class="nv">init1</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
       <span class="nv">body</span> <span class="o">...</span><span class="p">))</span>
    <span class="p">((</span><span class="k">letrec </span><span class="s">&quot;generate_temp_names&quot;</span>
       <span class="p">()</span>
       <span class="p">(</span><span class="nf">temp1</span> <span class="o">...</span><span class="p">)</span>
       <span class="p">((</span><span class="nf">var1</span> <span class="nv">init1</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
       <span class="nv">body</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">var1</span> <span class="nv">&lt;undefined&gt;</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
       <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">temp1</span> <span class="nv">init1</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
         <span class="p">(</span><span class="k">set! </span><span class="nv">var1</span> <span class="nv">temp1</span><span class="p">)</span>
         <span class="o">...</span>
         <span class="nv">body</span> <span class="o">...</span><span class="p">)))</span>
    <span class="p">((</span><span class="k">letrec </span><span class="s">&quot;generate_temp_names&quot;</span>
       <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span> <span class="o">...</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">temp</span> <span class="o">...</span><span class="p">)</span>
       <span class="p">((</span><span class="nf">var1</span> <span class="nv">init1</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
       <span class="nv">body</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">letrec </span><span class="s">&quot;generate_temp_names&quot;</span>
       <span class="p">(</span><span class="nf">y</span> <span class="o">...</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">newtemp</span> <span class="nv">temp</span> <span class="o">...</span><span class="p">)</span>
       <span class="p">((</span><span class="nf">var1</span> <span class="nv">init1</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
       <span class="nv">body</span> <span class="o">...</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define-syntax </span><span class="nv">letrec*</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="nf">letrec*</span> <span class="p">((</span><span class="nf">var1</span> <span class="nv">init1</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span> <span class="nv">body1</span> <span class="nv">body2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">var1</span> <span class="nv">&lt;undefined&gt;</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
       <span class="p">(</span><span class="k">set! </span><span class="nv">var1</span> <span class="nv">init1</span><span class="p">)</span>
       <span class="o">...</span>
       <span class="p">(</span><span class="k">let </span><span class="p">()</span> <span class="nv">body1</span> <span class="nv">body2</span> <span class="o">...</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define-syntax </span><span class="nv">let-values</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="nf">let-values</span> <span class="p">(</span><span class="nf">binding</span> <span class="o">...</span><span class="p">)</span> <span class="nv">body0</span> <span class="nv">body1</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">let-values</span> <span class="s">&quot;bind&quot;</span>
       <span class="p">(</span><span class="nf">binding</span> <span class="o">...</span><span class="p">)</span> <span class="p">()</span> <span class="p">(</span><span class="k">begin </span><span class="nv">body0</span> <span class="nv">body1</span> <span class="o">...</span><span class="p">)))</span>

    <span class="p">((</span><span class="nf">let-values</span> <span class="s">&quot;bind&quot;</span> <span class="p">()</span> <span class="nv">tmps</span> <span class="nv">body</span><span class="p">)</span>
     <span class="p">(</span><span class="k">let </span><span class="nv">tmps</span> <span class="nv">body</span><span class="p">))</span>

    <span class="p">((</span><span class="nf">let-values</span> <span class="s">&quot;bind&quot;</span> <span class="p">((</span><span class="nf">b0</span> <span class="nv">e0</span><span class="p">)</span>
                         <span class="nv">binding</span> <span class="o">...</span><span class="p">)</span> <span class="nv">tmps</span> <span class="nv">body</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">let-values</span> <span class="s">&quot;mktmp&quot;</span> <span class="nv">b0</span> <span class="nv">e0</span> <span class="p">()</span>
                 <span class="p">(</span><span class="nf">binding</span> <span class="o">...</span><span class="p">)</span> <span class="nv">tmps</span> <span class="nv">body</span><span class="p">))</span>

    <span class="p">((</span><span class="nf">let-values</span> <span class="s">&quot;mktmp&quot;</span> <span class="p">()</span> <span class="nv">e0</span> <span class="nv">args</span>
                 <span class="nv">bindings</span> <span class="nv">tmps</span> <span class="nv">body</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">call-with-values</span>
         <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">e0</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="nv">args</span>
         <span class="p">(</span><span class="nf">let-values</span> <span class="s">&quot;bind&quot;</span>
           <span class="nv">bindings</span> <span class="nv">tmps</span> <span class="nv">body</span><span class="p">))))</span>

    <span class="p">((</span><span class="nf">let-values</span> <span class="s">&quot;mktmp&quot;</span> <span class="p">(</span><span class="nf">a</span> <span class="o">.</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">e0</span> <span class="p">(</span><span class="nf">arg</span> <span class="o">...</span><span class="p">)</span>
                 <span class="nv">bindings</span> <span class="p">(</span><span class="nf">tmp</span> <span class="o">...</span><span class="p">)</span> <span class="nv">body</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">let-values</span> <span class="s">&quot;mktmp&quot;</span> <span class="nv">b</span> <span class="nv">e0</span> <span class="p">(</span><span class="nf">arg</span> <span class="o">...</span> <span class="nv">x</span><span class="p">)</span>
                 <span class="nv">bindings</span> <span class="p">(</span><span class="nf">tmp</span> <span class="o">...</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">x</span><span class="p">))</span> <span class="nv">body</span><span class="p">))</span>

    <span class="p">((</span><span class="nf">let-values</span> <span class="s">&quot;mktmp&quot;</span> <span class="nv">a</span> <span class="nv">e0</span> <span class="p">(</span><span class="nf">arg</span> <span class="o">...</span><span class="p">)</span>
                 <span class="nv">bindings</span> <span class="p">(</span><span class="nf">tmp</span> <span class="o">...</span><span class="p">)</span> <span class="nv">body</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">call-with-values</span>
         <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">e0</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">arg</span> <span class="o">...</span> <span class="o">.</span> <span class="nv">x</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">let-values</span> <span class="s">&quot;bind&quot;</span>
           <span class="nv">bindings</span> <span class="p">(</span><span class="nf">tmp</span> <span class="o">...</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">x</span><span class="p">))</span> <span class="nv">body</span><span class="p">))))))</span>

<span class="p">(</span><span class="k">define-syntax </span><span class="nv">let*-values</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="nf">let*-values</span> <span class="p">()</span> <span class="nv">body0</span> <span class="nv">body1</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">let </span><span class="p">()</span> <span class="nv">body0</span> <span class="nv">body1</span> <span class="o">...</span><span class="p">))</span>

    <span class="p">((</span><span class="nf">let*-values</span> <span class="p">(</span><span class="nf">binding0</span> <span class="nv">binding1</span> <span class="o">...</span><span class="p">)</span>
       <span class="nv">body0</span> <span class="nv">body1</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">let-values</span> <span class="p">(</span><span class="nf">binding0</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">let*-values</span> <span class="p">(</span><span class="nf">binding1</span> <span class="o">...</span><span class="p">)</span>
         <span class="nv">body0</span> <span class="nv">body1</span> <span class="o">...</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define-syntax </span><span class="nv">define-values</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="nf">define-values</span> <span class="p">()</span> <span class="nv">expr</span><span class="p">)</span>
     <span class="p">(</span><span class="k">define </span><span class="nv">dummy</span>
       <span class="p">(</span><span class="nb">call-with-values </span><span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">expr</span><span class="p">)</span>
         <span class="p">(</span><span class="k">lambda </span><span class="nv">args</span> <span class="no">#f</span><span class="p">))))</span>
    <span class="p">((</span><span class="nf">define-values</span> <span class="p">(</span><span class="nf">var</span><span class="p">)</span> <span class="nv">expr</span><span class="p">)</span>
     <span class="p">(</span><span class="k">define </span><span class="nv">var</span> <span class="nv">expr</span><span class="p">))</span>
    <span class="p">((</span><span class="nf">define-values</span> <span class="p">(</span><span class="nf">var0</span> <span class="nv">var1</span> <span class="o">...</span> <span class="nv">varn</span><span class="p">)</span> <span class="nv">expr</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">begin</span>
       <span class="p">(</span><span class="k">define </span><span class="nv">var0</span>
         <span class="p">(</span><span class="nb">call-with-values </span><span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">expr</span><span class="p">)</span>
           <span class="nv">list</span><span class="p">))</span>
       <span class="p">(</span><span class="k">define </span><span class="nv">var1</span>
         <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">v</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">var0</span><span class="p">)))</span>
           <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">var0</span> <span class="p">(</span><span class="nb">cddr </span><span class="nv">var0</span><span class="p">))</span>
           <span class="nv">v</span><span class="p">))</span> <span class="o">...</span>
           <span class="p">(</span><span class="k">define </span><span class="nv">varn</span>
             <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">v</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">var0</span><span class="p">)))</span>
               <span class="p">(</span><span class="k">set! </span><span class="nv">var0</span> <span class="p">(</span><span class="nb">car </span><span class="nv">var0</span><span class="p">))</span>
               <span class="nv">v</span><span class="p">))))</span>
    <span class="p">((</span><span class="nf">define-values</span> <span class="p">(</span><span class="nf">var0</span> <span class="nv">var1</span> <span class="o">...</span> <span class="o">.</span> <span class="nv">varn</span><span class="p">)</span> <span class="nv">expr</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">begin</span>
       <span class="p">(</span><span class="k">define </span><span class="nv">var0</span>
         <span class="p">(</span><span class="nb">call-with-values </span><span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">expr</span><span class="p">)</span>
           <span class="nv">list</span><span class="p">))</span>
       <span class="p">(</span><span class="k">define </span><span class="nv">var1</span>
         <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">v</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">var0</span><span class="p">)))</span>
           <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">var0</span> <span class="p">(</span><span class="nb">cddr </span><span class="nv">var0</span><span class="p">))</span>
           <span class="nv">v</span><span class="p">))</span> <span class="o">...</span>
           <span class="p">(</span><span class="k">define </span><span class="nv">varn</span>
             <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">v</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">var0</span><span class="p">)))</span>
               <span class="p">(</span><span class="k">set! </span><span class="nv">var0</span> <span class="p">(</span><span class="nb">car </span><span class="nv">var0</span><span class="p">))</span>
               <span class="nv">v</span><span class="p">))))</span>
    <span class="p">((</span><span class="nf">define-values</span> <span class="nv">var</span> <span class="nv">expr</span><span class="p">)</span>
     <span class="p">(</span><span class="k">define </span><span class="nv">var</span>
       <span class="p">(</span><span class="nb">call-with-values </span><span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">expr</span><span class="p">)</span>
         <span class="nv">list</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define-syntax </span><span class="nv">begin</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="k">begin </span><span class="nv">exp</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">((</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">exp</span> <span class="o">...</span><span class="p">)))))</span>
</pre></div>
<p>The following alternative expansion for begin does not make use of the
ability to write more than one expression in the body of a lambda
expression. In any case, note that these rules apply only if the body of
the begin contains no definitions.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define-syntax </span><span class="nv">begin</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="k">begin </span><span class="nv">exp</span><span class="p">)</span>
     <span class="nv">exp</span><span class="p">)</span>
    <span class="p">((</span><span class="k">begin </span><span class="nv">exp1</span> <span class="nv">exp2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">call-with-values</span>
         <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">exp1</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="nv">args</span>
         <span class="p">(</span><span class="k">begin </span><span class="nv">exp2</span> <span class="o">...</span><span class="p">))))))</span>
</pre></div>
<p>The following syntax definition of do uses a trick to expand the
variable clauses. As with letrec above, an auxiliary macro would also
work. The expression (if <code>#f</code> #f) is used to obtain an unspecific value.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define-syntax </span><span class="nv">do</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="k">do </span><span class="p">((</span><span class="nf">var</span> <span class="nv">init</span> <span class="nv">step</span> <span class="o">...</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">test</span> <span class="nv">expr</span> <span class="o">...</span><span class="p">)</span>
       <span class="nv">command</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">letrec</span>
         <span class="p">((</span><span class="nf">loop</span>
           <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">var</span> <span class="o">...</span><span class="p">)</span>
             <span class="p">(</span><span class="k">if </span><span class="nv">test</span>
                 <span class="p">(</span><span class="nf">begin</span>
                   <span class="p">(</span><span class="k">if </span><span class="no">#f</span> <span class="no">#f</span><span class="p">)</span>
                   <span class="nv">expr</span> <span class="o">...</span><span class="p">)</span>
                 <span class="p">(</span><span class="nf">begin</span>
                   <span class="nv">command</span>
                   <span class="o">...</span>
                   <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="k">do </span><span class="s">&quot;step&quot;</span> <span class="nv">var</span> <span class="nv">step</span> <span class="o">...</span><span class="p">)</span>
                         <span class="o">...</span><span class="p">))))))</span>
       <span class="p">(</span><span class="nf">loop</span> <span class="nv">init</span> <span class="o">...</span><span class="p">)))</span>
    <span class="p">((</span><span class="k">do </span><span class="s">&quot;step&quot;</span> <span class="nv">x</span><span class="p">)</span>
     <span class="nv">x</span><span class="p">)</span>
    <span class="p">((</span><span class="k">do </span><span class="s">&quot;step&quot;</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
     <span class="nv">y</span><span class="p">)))</span>
</pre></div>
<p>Here is a possible implementation of delay, force and delay-force. We
define the expression</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">delay-force</span> <span class="nv">&lt;expression&gt;</span><span class="p">)</span>
</pre></div>
<p>to have the same meaning as the procedure call</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">make-promise</span> <span class="no">#f</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">&lt;expression&gt;</span><span class="p">))</span>
</pre></div>
<p>as follows</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define-syntax </span><span class="nv">delay-force</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="nf">delay-force</span> <span class="nv">expression</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">make-promise</span> <span class="no">#f</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">expression</span><span class="p">)))))</span>
</pre></div>
<p>and we define the expression</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">delay </span><span class="nv">&lt;expression&gt;</span><span class="p">)</span>
</pre></div>
<p>to have the same meaning as:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">delay-force</span> <span class="p">(</span><span class="nf">make-promise</span> <span class="no">#t</span> <span class="nv">&lt;expression&gt;</span><span class="p">))</span>
</pre></div>
<p>as follows</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define-syntax </span><span class="nv">delay</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="k">delay </span><span class="nv">expression</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">delay-force</span> <span class="p">(</span><span class="nf">make-promise</span> <span class="no">#t</span> <span class="nv">expression</span><span class="p">)))))</span>
</pre></div>
<p>where make-promise is defined as follows:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">make-promise</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">done?</span> <span class="nv">proc</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">cons </span><span class="nv">done?</span> <span class="nv">proc</span><span class="p">))))</span>
</pre></div>
<p>Finally, we define force to call the procedure expressions in promises
iteratively using a trampoline technique following <span
class="citation" cites="srfi45"></span> until a non-lazy result (i.e. a
value created by delay instead of delay-force) is returned, as follows:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">force </span><span class="nv">promise</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">promise-done?</span> <span class="nv">promise</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">promise-value</span> <span class="nv">promise</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">promise*</span> <span class="p">((</span><span class="nf">promise-value</span> <span class="nv">promise</span><span class="p">))))</span>
        <span class="p">(</span><span class="nf">unless</span> <span class="p">(</span><span class="nf">promise-done?</span> <span class="nv">promise</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">promise-update!</span> <span class="nv">promise*</span> <span class="nv">promise</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">force </span><span class="nv">promise</span><span class="p">))))</span>
</pre></div>
<p>with the following promise accessors:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">promise-done?</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">promise-value</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">promise-update!</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">new</span> <span class="nv">old</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">set-car! </span><span class="p">(</span><span class="nb">car </span><span class="nv">old</span><span class="p">)</span> <span class="p">(</span><span class="nf">promise-done?</span> <span class="nv">new</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">set-cdr! </span><span class="p">(</span><span class="nb">car </span><span class="nv">old</span><span class="p">)</span> <span class="p">(</span><span class="nf">promise-value</span> <span class="nv">new</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">set-car! </span><span class="nv">new</span> <span class="p">(</span><span class="nb">car </span><span class="nv">old</span><span class="p">))))</span>
</pre></div>
<p>The following implementation of make-parameter and parameterize is
suitable for an implementation with no threads. Parameter objects are
implemented here as procedures, using two arbitrary unique objects
\&lt;param-set!&gt; and \<param-convert>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-parameter</span> <span class="nv">init</span> <span class="o">.</span> <span class="nv">o</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">converter</span>
          <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">o</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">o</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">value</span> <span class="p">(</span><span class="nf">converter</span> <span class="nv">init</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">lambda </span><span class="nv">args</span>
      <span class="p">(</span><span class="nf">cond</span>
       <span class="p">((</span><span class="nb">null? </span><span class="nv">args</span><span class="p">)</span>
        <span class="nv">value</span><span class="p">)</span>
       <span class="p">((</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">car </span><span class="nv">args</span><span class="p">)</span> <span class="nv">&lt;param-set!&gt;</span><span class="p">)</span>
        <span class="p">(</span><span class="k">set! </span><span class="nv">value</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">args</span><span class="p">)))</span>
       <span class="p">((</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">car </span><span class="nv">args</span><span class="p">)</span> <span class="nv">&lt;param-convert&gt;</span><span class="p">)</span>
        <span class="nv">converter</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">else</span>
        <span class="p">(</span><span class="nf">error</span> <span class="s">&quot;bad parameter syntax&quot;</span><span class="p">))))))</span>
</pre></div>
<p>Then parameterize uses dynamic-wind to dynamically rebind the associated
value:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define-syntax </span><span class="nv">parameterize</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="nf">parameterize</span> <span class="p">(</span><span class="s">&quot;step&quot;</span><span class="p">)</span>
       <span class="p">((</span><span class="nf">param</span> <span class="nv">value</span> <span class="nv">p</span> <span class="nv">old</span> <span class="nv">new</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
       <span class="p">()</span>
       <span class="nv">body</span><span class="p">)</span>
     <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">p</span> <span class="nv">param</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
       <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">old</span> <span class="p">(</span><span class="nf">p</span><span class="p">))</span> <span class="o">...</span>
             <span class="p">(</span><span class="nf">new</span> <span class="p">((</span><span class="nf">p</span> <span class="nv">&lt;param-convert&gt;</span><span class="p">)</span> <span class="nv">value</span><span class="p">))</span> <span class="o">...</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">dynamic-wind</span>
             <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nf">p</span> <span class="nv">&lt;param-set!&gt;</span> <span class="nv">new</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
             <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="o">.</span> <span class="nv">body</span><span class="p">)</span>
             <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nf">p</span> <span class="nv">&lt;param-set!&gt;</span> <span class="nv">old</span><span class="p">)</span> <span class="o">...</span><span class="p">)))))</span>
    <span class="p">((</span><span class="nf">parameterize</span> <span class="p">(</span><span class="s">&quot;step&quot;</span><span class="p">)</span>
       <span class="nv">args</span>
       <span class="p">((</span><span class="nf">param</span> <span class="nv">value</span><span class="p">)</span> <span class="o">.</span> <span class="nv">rest</span><span class="p">)</span>
       <span class="nv">body</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">parameterize</span> <span class="p">(</span><span class="s">&quot;step&quot;</span><span class="p">)</span>
       <span class="p">((</span><span class="nf">param</span> <span class="nv">value</span> <span class="nv">p</span> <span class="nv">old</span> <span class="nv">new</span><span class="p">)</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
       <span class="nv">rest</span>
       <span class="nv">body</span><span class="p">))</span>
    <span class="p">((</span><span class="nf">parameterize</span> <span class="p">((</span><span class="nf">param</span> <span class="nv">value</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span> <span class="o">.</span> <span class="nv">body</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">parameterize</span> <span class="p">(</span><span class="s">&quot;step&quot;</span><span class="p">)</span>
       <span class="p">()</span>
       <span class="p">((</span><span class="nf">param</span> <span class="nv">value</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
       <span class="nv">body</span><span class="p">))))</span>
</pre></div>
<p>The following implementation of guard depends on an auxiliary macro,
here called guard-aux.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define-syntax </span><span class="nv">guard</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="nf">guard</span> <span class="p">(</span><span class="nf">var</span> <span class="nv">clause</span> <span class="o">...</span><span class="p">)</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">((</span><span class="nf">call/cc</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">guard-k</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">with-exception-handler</span>
          <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">condition</span><span class="p">)</span>
            <span class="p">((</span><span class="nf">call/cc</span>
              <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">handler-k</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">guard-k</span>
                 <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
                   <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">var</span> <span class="nv">condition</span><span class="p">))</span>
                     <span class="p">(</span><span class="nf">guard-aux</span>
                      <span class="p">(</span><span class="nf">handler-k</span>
                       <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
                         <span class="p">(</span><span class="nf">raise-continuable</span> <span class="nv">condition</span><span class="p">)))</span>
                      <span class="nv">clause</span> <span class="o">...</span><span class="p">))))))))</span>
          <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
            <span class="p">(</span><span class="nf">call-with-values</span>
                <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="o">...</span><span class="p">)</span>
              <span class="p">(</span><span class="k">lambda </span><span class="nv">args</span>
                <span class="p">(</span><span class="nf">guard-k</span>
                 <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
                   <span class="p">(</span><span class="nb">apply </span><span class="nv">values</span> <span class="nv">args</span><span class="p">)))))))))))))</span>

<span class="p">(</span><span class="k">define-syntax </span><span class="nv">guard-aux</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">(</span><span class="k">else </span><span class="nv">=&gt;</span><span class="p">)</span>
    <span class="p">((</span><span class="nf">guard-aux</span> <span class="nv">reraise</span> <span class="p">(</span><span class="k">else </span><span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">))</span>
     <span class="p">(</span><span class="k">begin </span><span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">))</span>
    <span class="p">((</span><span class="nf">guard-aux</span> <span class="nv">reraise</span> <span class="p">(</span><span class="nf">test</span> <span class="k">=&gt; </span><span class="nv">result</span><span class="p">))</span>
     <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">temp</span> <span class="nv">test</span><span class="p">))</span>
       <span class="p">(</span><span class="k">if </span><span class="nv">temp</span>
           <span class="p">(</span><span class="nf">result</span> <span class="nv">temp</span><span class="p">)</span>
           <span class="nv">reraise</span><span class="p">)))</span>
    <span class="p">((</span><span class="nf">guard-aux</span> <span class="nv">reraise</span> <span class="p">(</span><span class="nf">test</span> <span class="k">=&gt; </span><span class="nv">result</span><span class="p">)</span>
                <span class="nv">clause1</span> <span class="nv">clause2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">temp</span> <span class="nv">test</span><span class="p">))</span>
       <span class="p">(</span><span class="k">if </span><span class="nv">temp</span>
           <span class="p">(</span><span class="nf">result</span> <span class="nv">temp</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">guard-aux</span> <span class="nv">reraise</span> <span class="nv">clause1</span> <span class="nv">clause2</span> <span class="o">...</span><span class="p">))))</span>
    <span class="p">((</span><span class="nf">guard-aux</span> <span class="nv">reraise</span> <span class="p">(</span><span class="nf">test</span><span class="p">))</span>
     <span class="p">(</span><span class="k">or </span><span class="nv">test</span> <span class="nv">reraise</span><span class="p">))</span>
    <span class="p">((</span><span class="nf">guard-aux</span> <span class="nv">reraise</span> <span class="p">(</span><span class="nf">test</span><span class="p">)</span> <span class="nv">clause1</span> <span class="nv">clause2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">temp</span> <span class="nv">test</span><span class="p">))</span>
       <span class="p">(</span><span class="k">if </span><span class="nv">temp</span>
           <span class="nv">temp</span>
           <span class="p">(</span><span class="nf">guard-aux</span> <span class="nv">reraise</span> <span class="nv">clause1</span> <span class="nv">clause2</span> <span class="o">...</span><span class="p">))))</span>
    <span class="p">((</span><span class="nf">guard-aux</span> <span class="nv">reraise</span> <span class="p">(</span><span class="nf">test</span> <span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">))</span>
     <span class="p">(</span><span class="k">if </span><span class="nv">test</span>
         <span class="p">(</span><span class="k">begin </span><span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">)</span>
         <span class="nv">reraise</span><span class="p">))</span>
    <span class="p">((</span><span class="nf">guard-aux</span> <span class="nv">reraise</span>
                <span class="p">(</span><span class="nf">test</span> <span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">)</span>
                <span class="nv">clause1</span> <span class="nv">clause2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">if </span><span class="nv">test</span>
         <span class="p">(</span><span class="k">begin </span><span class="nv">result1</span> <span class="nv">result2</span> <span class="o">...</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">guard-aux</span> <span class="nv">reraise</span> <span class="nv">clause1</span> <span class="nv">clause2</span> <span class="o">...</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define-syntax </span><span class="nv">case-lambda</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="nf">case-lambda</span> <span class="p">(</span><span class="nf">params</span> <span class="nv">body0</span> <span class="o">...</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">lambda </span><span class="nv">args</span>
       <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">len</span> <span class="p">(</span><span class="nb">length </span><span class="nv">args</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">letrec-syntax</span>
             <span class="p">((</span><span class="nf">cl</span> <span class="p">(</span><span class="k">syntax-rules </span><span class="nv">:::</span> <span class="p">()</span>
                                <span class="p">((</span><span class="nf">cl</span><span class="p">)</span>
                                 <span class="p">(</span><span class="nf">error</span> <span class="s">&quot;no matching clause&quot;</span><span class="p">))</span>
                                <span class="p">((</span><span class="nf">cl</span> <span class="p">((</span><span class="nf">p</span> <span class="nv">:::</span><span class="p">)</span> <span class="o">.</span> <span class="nv">body</span><span class="p">)</span> <span class="o">.</span> <span class="nv">rest</span><span class="p">)</span>
                                 <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">len</span> <span class="p">(</span><span class="nb">length </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">p</span> <span class="nv">:::</span><span class="p">)))</span>
                                     <span class="p">(</span><span class="nb">apply </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p</span> <span class="nv">:::</span><span class="p">)</span>
                                              <span class="o">.</span> <span class="nv">body</span><span class="p">)</span>
                                            <span class="nv">args</span><span class="p">)</span>
                                     <span class="p">(</span><span class="nf">cl</span> <span class="o">.</span> <span class="nv">rest</span><span class="p">)))</span>
                                <span class="p">((</span><span class="nf">cl</span> <span class="p">((</span><span class="nf">p</span> <span class="nv">:::</span> <span class="o">.</span> <span class="nv">tail</span><span class="p">)</span> <span class="o">.</span> <span class="nv">body</span><span class="p">)</span>
                                     <span class="o">.</span> <span class="nv">rest</span><span class="p">)</span>
                                 <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">len</span> <span class="p">(</span><span class="nb">length </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">p</span> <span class="nv">:::</span><span class="p">)))</span>
                                     <span class="p">(</span><span class="nf">apply</span>
                                      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p</span> <span class="nv">:::</span> <span class="o">.</span> <span class="nv">tail</span><span class="p">)</span>
                                        <span class="o">.</span> <span class="nv">body</span><span class="p">)</span>
                                      <span class="nv">args</span><span class="p">)</span>
                                     <span class="p">(</span><span class="nf">cl</span> <span class="o">.</span> <span class="nv">rest</span><span class="p">))))))</span>
           <span class="p">(</span><span class="nf">cl</span> <span class="p">(</span><span class="nf">params</span> <span class="nv">body0</span> <span class="o">...</span><span class="p">)</span> <span class="o">...</span><span class="p">)))))))</span>
</pre></div>
<p>This definition of cond-expand does not interact with the features
procedure. It requires that each feature identifier provided by the
implementation be explicitly mentioned.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define-syntax </span><span class="nv">cond-expand</span>
  <span class="c1">;; Extend this to mention all feature ids and libraries</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">(</span><span class="k">and or </span><span class="nv">not</span> <span class="k">else </span><span class="nv">r7rs</span> <span class="nv">library</span> <span class="nv">verbatim</span> <span class="nv">base</span><span class="p">)</span>
    <span class="p">((</span><span class="nf">cond-expand</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">syntax-error</span> <span class="s">&quot;Unfulfilled cond-expand&quot;</span><span class="p">))</span>
    <span class="p">((</span><span class="nf">cond-expand</span> <span class="p">(</span><span class="k">else </span><span class="nv">body</span> <span class="o">...</span><span class="p">))</span>
     <span class="p">(</span><span class="k">begin </span><span class="nv">body</span> <span class="o">...</span><span class="p">))</span>
    <span class="p">((</span><span class="nf">cond-expand</span> <span class="p">((</span><span class="nf">and</span><span class="p">)</span> <span class="nv">body</span> <span class="o">...</span><span class="p">)</span> <span class="nv">more-clauses</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">begin </span><span class="nv">body</span> <span class="o">...</span><span class="p">))</span>
    <span class="p">((</span><span class="nf">cond-expand</span> <span class="p">((</span><span class="k">and </span><span class="nv">req1</span> <span class="nv">req2</span> <span class="o">...</span><span class="p">)</span> <span class="nv">body</span> <span class="o">...</span><span class="p">)</span>
                  <span class="nv">more-clauses</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond-expand</span>
      <span class="p">(</span><span class="nf">req1</span>
       <span class="p">(</span><span class="nf">cond-expand</span>
        <span class="p">((</span><span class="k">and </span><span class="nv">req2</span> <span class="o">...</span><span class="p">)</span> <span class="nv">body</span> <span class="o">...</span><span class="p">)</span>
        <span class="nv">more-clauses</span> <span class="o">...</span><span class="p">))</span>
      <span class="nv">more-clauses</span> <span class="o">...</span><span class="p">))</span>
    <span class="p">((</span><span class="nf">cond-expand</span> <span class="p">((</span><span class="nf">or</span><span class="p">)</span> <span class="nv">body</span> <span class="o">...</span><span class="p">)</span> <span class="nv">more-clauses</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond-expand</span> <span class="nv">more-clauses</span> <span class="o">...</span><span class="p">))</span>
    <span class="p">((</span><span class="nf">cond-expand</span> <span class="p">((</span><span class="k">or </span><span class="nv">req1</span> <span class="nv">req2</span> <span class="o">...</span><span class="p">)</span> <span class="nv">body</span> <span class="o">...</span><span class="p">)</span>
                  <span class="nv">more-clauses</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond-expand</span>
      <span class="p">(</span><span class="nf">req1</span>
       <span class="p">(</span><span class="k">begin </span><span class="nv">body</span> <span class="o">...</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">else</span>
       <span class="p">(</span><span class="nf">cond-expand</span>
        <span class="p">((</span><span class="k">or </span><span class="nv">req2</span> <span class="o">...</span><span class="p">)</span> <span class="nv">body</span> <span class="o">...</span><span class="p">)</span>
        <span class="nv">more-clauses</span> <span class="o">...</span><span class="p">))))</span>
    <span class="p">((</span><span class="nf">cond-expand</span> <span class="p">((</span><span class="nb">not </span><span class="nv">req</span><span class="p">)</span> <span class="nv">body</span> <span class="o">...</span><span class="p">)</span>
                  <span class="nv">more-clauses</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond-expand</span>
      <span class="p">(</span><span class="nf">req</span>
       <span class="p">(</span><span class="nf">cond-expand</span> <span class="nv">more-clauses</span> <span class="o">...</span><span class="p">))</span>
      <span class="p">(</span><span class="k">else </span><span class="nv">body</span> <span class="o">...</span><span class="p">)))</span>
    <span class="p">((</span><span class="nf">cond-expand</span> <span class="p">(</span><span class="nf">r7rs</span> <span class="nv">body</span> <span class="o">...</span><span class="p">)</span>
                  <span class="nv">more-clauses</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">begin </span><span class="nv">body</span> <span class="o">...</span><span class="p">))</span>
    <span class="c1">;; Add clauses here for each</span>
    <span class="c1">;; supported feature identifier.</span>
    <span class="c1">;; Samples:</span>
    <span class="c1">;; ((cond-expand (exact-closed body ...)</span>
    <span class="c1">;;               more-clauses ...)</span>
    <span class="c1">;;   (begin body ...))</span>
    <span class="c1">;; ((cond-expand (ieee-float body ...)</span>
    <span class="c1">;;               more-clauses ...)</span>
    <span class="c1">;;   (begin body ...))</span>
    <span class="p">((</span><span class="nf">cond-expand</span> <span class="p">((</span><span class="nf">library</span> <span class="p">(</span><span class="nf">verbatim</span> <span class="nv">base</span><span class="p">))</span>
                   <span class="nv">body</span> <span class="o">...</span><span class="p">)</span>
                  <span class="nv">more-clauses</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">begin </span><span class="nv">body</span> <span class="o">...</span><span class="p">))</span>
    <span class="c1">;; Add clauses here for each library</span>
    <span class="p">((</span><span class="nf">cond-expand</span> <span class="p">(</span><span class="nf">feature-id</span> <span class="nv">body</span> <span class="o">...</span><span class="p">)</span>
                  <span class="nv">more-clauses</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond-expand</span> <span class="nv">more-clauses</span> <span class="o">...</span><span class="p">))</span>
    <span class="p">((</span><span class="nf">cond-expand</span> <span class="p">((</span><span class="nf">library</span> <span class="p">(</span><span class="nf">name</span> <span class="o">...</span><span class="p">))</span>
                   <span class="nv">body</span> <span class="o">...</span><span class="p">)</span>
                  <span class="nv">more-clauses</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond-expand</span> <span class="nv">more-clauses</span> <span class="o">...</span><span class="p">))))</span>
</pre></div>
<h2>Standard Libraries</h2>
<p>This section lists the exports provided by the standard libraries. The
libraries are factored so as to separate features which might not be
supported by all implementations, or which might be expensive to load.</p>
<p>The scheme library prefix is used for all standard libraries, and is
reserved for use by future standards.</p>
<h3>Base Library</h3>
<p>The <code>(scheme base)</code> library exports many of the procedures and syntax
bindings that are traditionally associated with Scheme. The division
between the base library and the other standard libraries is based on
use, not on construction. In particular, some facilities that are
typically implemented as primitives by a compiler or the run-time system
rather than in terms of other standard procedures or syntax are not part
of the base library, but are defined in separate libraries. By the same
token, some exports of the base library are implementable in terms of
other exports. They are redundant in the strict sense of the word, but
they capture common patterns of usage, and are therefore provided as
convenient abbreviations.</p>
<div class="highlight"><pre><span></span><span class="nv">*</span>
<span class="nv">+</span>
<span class="nv">-</span>
<span class="o">...</span>
<span class="nv">/</span>
<span class="nv">&lt;</span>
<span class="nv">&lt;=</span>
<span class="nv">=</span>
<span class="nv">=&gt;</span>
<span class="nv">&gt;</span>
<span class="nv">&gt;=</span>
<span class="nv">_</span>
<span class="nv">abs</span>
<span class="nv">and</span>
<span class="nv">append</span>
<span class="nv">apply</span>
<span class="nv">assoc</span>
<span class="nv">assq</span>
<span class="nv">assv</span>
<span class="nv">begin</span>
<span class="nv">binary-port?</span>
<span class="nv">boolean=?</span>
<span class="nv">boolean?</span>
<span class="nv">bytevector</span>
<span class="nv">bytevector-append</span>
<span class="nv">bytevector-copy</span>
<span class="nv">bytevector-copy!</span>
<span class="nv">bytevector-length</span>
<span class="nv">bytevector-u8-ref</span>
<span class="nv">bytevector-u8-set!</span>
<span class="nv">bytevector?</span>
<span class="nv">caar</span>
<span class="nv">cadr</span>
<span class="nv">call-with-current-continuation</span>
<span class="nv">call-with-port</span>
<span class="nv">call-with-values</span>
<span class="nv">call/cc</span>
<span class="nv">car</span>
<span class="nv">case</span>
<span class="nv">cdar</span>
<span class="nv">cddr</span>
<span class="nv">cdr</span>
<span class="nv">ceiling</span>
<span class="nv">char-&gt;integer</span>
<span class="nv">char-ready?</span>
<span class="nv">char&lt;=?</span>
<span class="nv">char&lt;?</span>
<span class="nv">char=?</span>
<span class="nv">char&gt;=?</span>
<span class="nv">char&gt;?</span>
<span class="nv">char?</span>
<span class="nv">close-input-port</span>
<span class="nv">close-output-port</span>
<span class="nv">close-port</span>
<span class="nv">complex?</span>
<span class="nv">cond</span>
<span class="nv">cond-expand</span>
<span class="nv">cons</span>
<span class="nv">current-error-port</span>
<span class="nv">current-input-port</span>
<span class="nv">current-output-port</span>
<span class="nv">define</span>
<span class="nv">define-record-type</span>
<span class="nv">define-syntax</span>
<span class="nv">define-values</span>
<span class="nv">denominator</span>
<span class="nv">do</span>
<span class="nv">dynamic-wind</span>
<span class="nv">else</span>
<span class="nv">eof-object</span>
<span class="nv">eof-object?</span>
<span class="nv">eq?</span>
<span class="nv">equal?</span>
<span class="nv">eqv?</span>
<span class="nv">error</span>
<span class="nv">error-object-irritants</span>
<span class="nv">error-object-message</span>
<span class="nv">error-object?</span>
<span class="nv">even?</span>
<span class="nv">exact</span>
<span class="nv">exact-integer-sqrt</span>
<span class="nv">exact-integer?</span>
<span class="nv">exact?</span>
<span class="nv">expt</span>
<span class="nv">features</span>
<span class="nv">file-error?</span>
<span class="nv">floor</span>
<span class="nv">floor-quotient</span>
<span class="nv">floor-remainder</span>
<span class="nv">floor/</span>
<span class="nv">flush-output-port</span>
<span class="nv">for-each</span>
<span class="nv">gcd</span>
<span class="nv">get-output-bytevector</span>
<span class="nv">get-output-string</span>
<span class="nv">guard</span>
<span class="nv">if</span>
<span class="nv">include</span>
<span class="nv">include-ci</span>
<span class="nv">inexact</span>
<span class="nv">inexact?</span>
<span class="nv">input-port-open?</span>
<span class="nv">input-port?</span>
<span class="nv">integer-&gt;char</span>
<span class="nv">integer?</span>
<span class="nv">lambda</span>
<span class="nv">lcm</span>
<span class="nv">length</span>
<span class="nv">let</span>
<span class="nv">let*</span>
<span class="nv">let*-values</span>
<span class="nv">let-syntax</span>
<span class="nv">let-values</span>
<span class="nv">letrec</span>
<span class="nv">letrec*</span>
<span class="nv">letrec-syntax</span>
<span class="nv">list</span>
<span class="nv">list-&gt;string</span>
<span class="nv">list-&gt;vector</span>
<span class="nv">list-copy</span>
<span class="nv">list-ref</span>
<span class="nv">list-set!</span>
<span class="nv">list-tail</span>
<span class="nv">list?</span>
<span class="nv">make-bytevector</span>
<span class="nv">make-list</span>
<span class="nv">make-parameter</span>
<span class="nv">make-string</span>
<span class="nv">make-vector</span>
<span class="nv">map</span>
<span class="nv">max</span>
<span class="nv">member</span>
<span class="nv">memq</span>
<span class="nv">memv</span>
<span class="nv">min</span>
<span class="nv">modulo</span>
<span class="nv">negative?</span>
<span class="nv">newline</span>
<span class="nv">not</span>
<span class="nv">null?</span>
<span class="nv">number-&gt;string</span>
<span class="nv">number?</span>
<span class="nv">numerator</span>
<span class="nv">odd?</span>
<span class="nv">open-input-bytevector</span>
<span class="nv">open-input-string</span>
<span class="nv">open-output-bytevector</span>
<span class="nv">open-output-string</span>
<span class="nv">or</span>
<span class="nv">output-port-open?</span>
<span class="nv">output-port?</span>
<span class="nv">pair?</span>
<span class="nv">parameterize</span>
<span class="nv">peek-char</span>
<span class="nv">peek-u8</span>
<span class="nv">port?</span>
<span class="nv">positive?</span>
<span class="nv">procedure?</span>
<span class="nv">quasiquote</span>
<span class="nv">quote</span>
<span class="nv">quotient</span>
<span class="nv">raise</span>
<span class="nv">raise-continuable</span>
<span class="nv">rational?</span>
<span class="nv">rationalize</span>
<span class="nv">read-bytevector</span>
<span class="nv">read-bytevector!</span>
<span class="nv">read-char</span>
<span class="nv">read-error?</span>
<span class="nv">read-line</span>
<span class="nv">read-string</span>
<span class="nv">read-u8</span>
<span class="nv">real?</span>
<span class="nv">remainder</span>
<span class="nv">reverse</span>
<span class="nv">round</span>
<span class="nv">set!</span>
<span class="nv">set-car!</span>
<span class="nv">set-cdr!</span>
<span class="nv">square</span>
<span class="nv">string</span>
<span class="nv">string-&gt;list</span>
<span class="nv">string-&gt;number</span>
<span class="nv">string-&gt;symbol</span>
<span class="nv">string-&gt;utf8</span>
<span class="nv">string-&gt;vector</span>
<span class="nv">string-append</span>
<span class="nv">string-copy</span>
<span class="nv">string-copy!</span>
<span class="nv">string-fill!</span>
<span class="nv">string-for-each</span>
<span class="nv">string-length</span>
<span class="nv">string-map</span>
<span class="nv">string-ref</span>
<span class="nv">string-set!</span>
<span class="nv">string&lt;=?</span>
<span class="nv">string&lt;?</span>
<span class="nv">string=?</span>
<span class="nv">string&gt;=?</span>
<span class="nv">string&gt;?</span>
<span class="nv">string?</span>
<span class="nv">substring</span>
<span class="nv">symbol-&gt;string</span>
<span class="nv">symbol=?</span>
<span class="nv">symbol?</span>
<span class="nv">syntax-error</span>
<span class="nv">syntax-rules</span>
<span class="nv">textual-port?</span>
<span class="nv">truncate</span>
<span class="nv">truncate-quotient</span>
<span class="nv">truncate-remainder</span>
<span class="nv">truncate/</span>
<span class="nv">u8-ready?</span>
<span class="nv">unless</span>
<span class="nv">unquote</span>
<span class="nv">unquote-splicing</span>
<span class="nv">utf8-&gt;string</span>
<span class="nv">values</span>
<span class="nv">vector</span>
<span class="nv">vector-&gt;list</span>
<span class="nv">vector-&gt;string</span>
<span class="nv">vector-append</span>
<span class="nv">vector-copy</span>
<span class="nv">vector-copy!</span>
<span class="nv">vector-fill!</span>
<span class="nv">vector-for-each</span>
<span class="nv">vector-length</span>
<span class="nv">vector-map</span>
<span class="nv">vector-ref</span>
<span class="nv">vector-set!</span>
<span class="nv">vector?</span>
<span class="nv">when</span>
<span class="nv">with-exception-handler</span>
<span class="nv">write-bytevector</span>
<span class="nv">write-char</span>
<span class="nv">write-string</span>
<span class="nv">write-u8</span>
<span class="nv">zero?</span>
</pre></div>
<h3>Case-Lambda Library</h3>
<p>The <code>(scheme case-lambda)</code> library exports the <code>case-lambda</code> syntax.</p>
<div class="highlight"><pre><span></span><span class="nv">case-lambda</span>
</pre></div>
<h3>Char Library</h3>
<p>The <code>(scheme char)</code> library provides the procedures for dealing with
characters that involve potentially large tables when supporting all of
Unicode.</p>
<div class="highlight"><pre><span></span><span class="nv">char-alphabetic?</span>
<span class="nv">char-ci&lt;=?</span>
<span class="nv">char-ci&lt;?</span>
<span class="nv">char-ci=?</span>
<span class="nv">char-ci&gt;=?</span>
<span class="nv">char-ci&gt;?</span>
<span class="nv">char-downcase</span>
<span class="nv">char-foldcase</span>
<span class="nv">char-lower-case?</span>
<span class="nv">char-numeric?</span>
<span class="nv">char-upcase</span>
<span class="nv">char-upper-case?</span>
<span class="nv">char-whitespace?</span>
<span class="nv">digit-value</span>
<span class="nv">string-ci&lt;=?</span>
<span class="nv">string-ci&lt;?</span>
<span class="nv">string-ci=?</span>
<span class="nv">string-ci&gt;=?</span>
<span class="nv">string-ci&gt;?</span>
<span class="nv">string-downcase</span>
<span class="nv">string-foldcase</span>
<span class="nv">string-upcase</span>
</pre></div>
<h3>Complex Library</h3>
<p>The <code>(scheme complex)</code> library exports procedures which are typically only
useful with non-real numbers.</p>
<div class="highlight"><pre><span></span><span class="nv">angle</span>                   <span class="nv">imag-part</span>
<span class="nv">magnitude</span>               <span class="nv">make-polar</span>
<span class="nv">make-rectangular</span>        <span class="nv">real-part</span>
</pre></div>
<h3>CxR Library</h3>
<p>The <code>(scheme cxr)</code> library exports twenty-four procedures which are the
compositions of from three to four car and cdr operations. For example
caddar could be defined by</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">caddar</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">))))))</span>
</pre></div>
<p>The procedures car and cdr themselves and the four two-level
compositions are included in the base library. See
section <a href="#listsection">[listsection]</a>.</p>
<div class="highlight"><pre><span></span><span class="nv">caaaar</span>                  <span class="nv">caaadr</span>
<span class="nv">caaar</span>                   <span class="nv">caadar</span>
<span class="nv">caaddr</span>                  <span class="nv">caadr</span>
<span class="nv">cadaar</span>                  <span class="nv">cadadr</span>
<span class="nv">cadar</span>                   <span class="nv">caddar</span>
<span class="nv">cadddr</span>                  <span class="nv">caddr</span>
<span class="nv">cdaaar</span>                  <span class="nv">cdaadr</span>
<span class="nv">cdaar</span>                   <span class="nv">cdadar</span>
<span class="nv">cdaddr</span>                  <span class="nv">cdadr</span>
<span class="nv">cddaar</span>                  <span class="nv">cddadr</span>
<span class="nv">cddar</span>                   <span class="nv">cdddar</span>
<span class="nv">cddddr</span>                  <span class="nv">cdddr</span>
</pre></div>
<h3>Eval Library</h3>
<p>The <code>(scheme eval)</code> library exports procedures for evaluating Scheme data
as programs.</p>

<div><pre>environment
eval</pre></div>
<h3>File Library</h3>
<p>The <code>(scheme file)</code> library provides procedures for accessing files.</p>

<div><pre>call-with-input-file
call-with-output-file
delete-file
file-exists?
open-binary-input-file
open-binary-output-file
open-input-file
open-output-file
with-input-from-file
with-output-to-file</pre></div>
<h3>Inexact Library</h3>
<p>The <code>(scheme inexact)</code> library exports procedures which are typically only
useful with inexact values.</p>
<div class="highlight"><pre><span></span><span class="nv">acos</span>
<span class="nv">asin</span>
<span class="nv">atan</span>
<span class="nv">cos</span>
<span class="nv">exp</span>
<span class="nv">finite?</span>
<span class="nv">infinite?</span>
<span class="nv">log</span>
<span class="nv">nan?</span>
<span class="nv">sin</span>
<span class="nv">sqrt</span>
<span class="nv">tan</span>
</pre></div>
<h3>Lazy Library</h3>
<p>The <code>(scheme lazy)</code> library exports procedures and syntax keywords for
lazy evaluation.</p>
<div class="highlight"><pre><span></span><span class="k">delay </span>                  <span class="nv">delay-force</span>
<span class="nv">force</span>                   <span class="nv">make-promise</span>
<span class="nv">promise?</span>
</pre></div>
<h3>Load Library</h3>
<p>The <code>(scheme load)</code> library exports procedures for loading Scheme
expressions from files.</p>
<div class="highlight"><pre><span></span><span class="nv">load</span>
</pre></div>
<h3>Process-Context Library</h3>
<p>The <code>(scheme process-context)</code> library exports procedures for accessing
with the program’s calling context.</p>
<div class="highlight"><pre><span></span><span class="nv">command-line</span>            <span class="nv">emergency-exit</span>
<span class="nv">exit</span>
<span class="nv">get-environment-variable</span>
<span class="nv">get-environment-variables</span>
</pre></div>
<h3>Read Library</h3>
<p>The <code>(scheme read)</code> library provides procedures for reading Scheme
objects.</p>
<div class="highlight"><pre><span></span><span class="nv">read</span>
</pre></div>
<h3>Repl Library</h3>
<p>The <code>(scheme repl)</code> library exports the interaction-environment procedure.</p>

<div><pre>interaction-environment</pre></div>
<h3>Time Library</h3>
<p>The <code>(scheme time)</code> library provides access to time-related values.</p>

<div><pre>current-jiffy           current-second
jiffies-per-second</pre></div>
<h3>Write Library</h3>
<p>The <code>(scheme write)</code> library provides procedures for writing Scheme
objects.</p>

<div><pre>display                 write
write-shared            write-simple</pre></div>
<h3>R5RS Library</h3>
<p>The <code>(scheme r5rs)</code> library provides the identifiers defined by
R<sup><small>5</small></sup>RS, except that transcript-on and transcript-off are not
present. Note that the exact and inexact procedures appear under their
R<sup><small>5</small></sup>RS names inexact-&gt;exact and exact-&gt;inexact respectively.
However, if an implementation does not provide a particular library such
as the complex library, the corresponding identifiers will not appear in
this library either.</p>
<div class="highlight"><pre><span></span><span class="err">\</span><span class="nv">*</span> <span class="nv">+</span> <span class="nv">-</span> <span class="o">...</span> <span class="nv">/</span> <span class="err">\</span><span class="nv">&lt;</span> <span class="err">\</span><span class="nv">&lt;=</span> <span class="nv">=</span> <span class="k">=&gt; </span><span class="err">\</span><span class="nv">&gt;</span> <span class="err">\</span><span class="nv">&gt;=</span> <span class="nv">_</span> <span class="nv">abs</span> <span class="nv">acos</span> <span class="k">and </span><span class="nv">angle</span> <span class="nv">append</span> <span class="nv">apply</span> <span class="nv">asin</span>
<span class="nv">assoc</span> <span class="nv">assq</span> <span class="nv">assv</span> <span class="nv">atan</span> <span class="k">begin </span><span class="nv">boolean?</span>  <span class="nv">caaaar</span> <span class="nv">caaadr</span> <span class="nv">caaar</span> <span class="nv">caadar</span> <span class="nv">caaddr</span>
<span class="nv">caadr</span> <span class="nv">caar</span> <span class="nv">cadaar</span> <span class="nv">cadadr</span> <span class="nv">cadar</span> <span class="nv">caddar</span> <span class="nv">cadddr</span> <span class="nv">caddr</span> <span class="nv">cadr</span>
<span class="nv">call-with-current-continuation</span> <span class="nv">call-with-input-file</span>
<span class="nv">call-with-output-file</span> <span class="nv">call-with-values</span> <span class="nv">car</span> <span class="k">case </span><span class="nv">cdaaar</span> <span class="nv">cdaadr</span> <span class="nv">cdaar</span>
<span class="nv">cdadar</span> <span class="nv">cdaddr</span> <span class="nv">cdadr</span> <span class="nv">cdar</span> <span class="nv">cddaar</span> <span class="nv">cddadr</span> <span class="nv">cddar</span> <span class="nv">cdddar</span> <span class="nv">cddddr</span> <span class="nv">cdddr</span> <span class="nv">cddr</span>
<span class="nv">cdr</span> <span class="nv">ceiling</span> <span class="nv">char-&gt;integer</span> <span class="nv">char-alphabetic?</span>  <span class="nv">char-ci</span><span class="err">\</span><span class="nv">&lt;=?</span> <span class="nv">char-ci</span><span class="err">\</span><span class="nv">&lt;?</span>
<span class="nv">char-ci=?</span> <span class="nv">char-ci&gt;=?</span>  <span class="nv">char-ci&gt;?</span> <span class="nv">char-downcase</span> <span class="nv">char-lower-case?</span>
<span class="nv">char-numeric?</span>  <span class="nv">char-ready?</span> <span class="nv">char-upcase</span> <span class="nv">char-upper-case?</span>
<span class="nv">char-whitespace?</span>  <span class="nv">char</span><span class="err">\</span><span class="nv">&lt;=?</span> <span class="nv">char</span><span class="err">\</span><span class="nv">&lt;?</span>  <span class="nv">char=?</span> <span class="nv">char&gt;=?</span>  <span class="nv">char&gt;?</span> <span class="nv">char?</span>
<span class="nv">close-input-port</span> <span class="nv">close-output-port</span> <span class="nv">complex?</span> <span class="k">cond </span><span class="nv">cons</span> <span class="nv">cos</span>
<span class="nv">current-input-port</span> <span class="nv">current-output-port</span> <span class="k">define define-syntax </span><span class="nv">delay</span>
<span class="nv">denominator</span> <span class="nv">display</span> <span class="k">do </span><span class="nv">dynamic-wind</span> <span class="k">else </span><span class="nv">eof-object?</span> <span class="nv">eq?</span>  <span class="nv">equal?</span> <span class="nv">eqv?</span>
<span class="nv">eval</span> <span class="nv">even?</span>  <span class="nv">exact-&gt;inexact</span> <span class="nv">exact?</span>  <span class="nv">exp</span> <span class="nv">expt</span> <span class="nv">floor</span> <span class="nv">for-each</span> <span class="nv">force</span> <span class="nv">gcd</span> <span class="nv">if</span>
<span class="nv">imag-part</span> <span class="nv">inexact-&gt;exact</span> <span class="nv">inexact?</span>  <span class="nv">input-port?</span> <span class="nv">integer-&gt;char</span> <span class="nv">integer?</span>
<span class="nv">interaction-environment</span> <span class="k">lambda </span><span class="nv">lcm</span> <span class="nv">length</span> <span class="k">let </span><span class="nv">let</span><span class="err">\</span><span class="nv">*</span> <span class="k">let-syntax </span><span class="nv">letrec</span>
<span class="k">letrec-syntax </span><span class="nv">list</span> <span class="nv">list-&gt;string</span> <span class="nv">list-&gt;vector</span> <span class="nv">list-ref</span> <span class="nv">list-tail</span> <span class="nv">list?</span>
<span class="nv">load</span> <span class="nv">log</span> <span class="nv">magnitude</span> <span class="nv">make-polar</span> <span class="nv">make-rectangular</span> <span class="nv">make-string</span> <span class="nv">make-vector</span>
<span class="nv">map</span> <span class="nv">max</span> <span class="nv">member</span> <span class="nv">memq</span> <span class="nv">memv</span> <span class="nv">min</span> <span class="nv">modulo</span> <span class="nv">negative?</span> <span class="nv">newline</span> <span class="nv">not</span>
<span class="nv">null-environment</span> <span class="nv">null?</span> <span class="nv">number-&gt;string</span> <span class="nv">number?</span> <span class="nv">numerator</span> <span class="nv">odd?</span>
<span class="nv">open-input-file</span> <span class="nv">open-output-file</span> <span class="k">or </span><span class="nv">output-port?</span> <span class="nv">pair?</span>  <span class="nv">peek-char</span>
<span class="nv">positive?</span>  <span class="nv">procedure?</span> <span class="k">quasiquote quote </span><span class="nv">quotient</span> <span class="nv">rational?</span> <span class="nv">rationalize</span>
<span class="nv">read</span> <span class="nv">read-char</span> <span class="nv">real-part</span> <span class="nv">real?</span>  <span class="nv">remainder</span> <span class="nv">reverse</span> <span class="nv">round</span>
<span class="nv">scheme-report-environment</span> <span class="k">set! </span><span class="nv">set-car!</span> <span class="nv">set-cdr!</span> <span class="nv">sin</span> <span class="nv">sqrt</span> <span class="nv">string</span>
<span class="nv">string-&gt;list</span> <span class="nv">string-&gt;number</span> <span class="nv">string-&gt;symbol</span> <span class="nv">string-append</span> <span class="nv">string-ci</span><span class="err">\</span><span class="nv">&lt;=?</span>
<span class="nv">string-ci</span><span class="err">\</span><span class="nv">&lt;?</span> <span class="nv">string-ci=?</span>  <span class="nv">string-ci&gt;=?</span> <span class="nv">string-ci&gt;?</span>  <span class="nv">string-copy</span>
<span class="nv">string-fill!</span> <span class="nv">string-length</span> <span class="nv">string-ref</span> <span class="nv">string-set!</span> <span class="nv">string</span><span class="err">\</span><span class="nv">&lt;=?</span>  <span class="nv">string</span><span class="err">\</span><span class="nv">&lt;?</span>
<span class="nv">string=?</span>  <span class="nv">string&gt;=?</span> <span class="nv">string&gt;?</span>  <span class="nv">string?</span> <span class="nv">substring</span> <span class="nv">symbol-&gt;string</span> <span class="nv">symbol?</span>
<span class="k">syntax-rules </span><span class="nv">tan</span> <span class="nv">truncate</span> <span class="nv">values</span> <span class="nv">vector</span> <span class="nv">vector-&gt;list</span> <span class="nv">vector-fill!</span>
<span class="nv">vector-length</span> <span class="nv">vector-ref</span> <span class="nv">vector-set!</span> <span class="nv">vector?</span> <span class="nv">with-input-from-file</span>
<span class="nv">with-output-to-file</span> <span class="nv">write</span> <span class="nv">write-char</span> <span class="nv">zero?</span>
</pre></div>
<h3>Standard Feature Identifiers</h3>
<p>An implementation may provide any or all of the feature identifiers
listed below for use by cond-expand and features, but must not provide a
feature identifier if it does not provide the corresponding feature.</p>
<p>r7rs</p>
<p>All R<sup><small>7</small></sup>RS Scheme implementations have this feature.</p>
<p>exact-closed</p>
<p>The algebraic operations +, -, *, and expt where the second argument is
a non-negative integer produce exact values given exact inputs.</p>
<p>exact-complex</p>
<p>Exact complex numbers are provided.</p>
<p>ieee-float</p>
<p>Inexact numbers are IEEE 754 binary floating point values.</p>
<p>full-unicode</p>
<p>All Unicode characters present in Unicode version 6.0 are supported as
Scheme characters.</p>
<p>ratios</p>
<p>/ with exact arguments produces an exact result when the divisor is
nonzero.</p>
<p>posix</p>
<p>This implementation is running on a POSIX system.</p>
<p>windows</p>
<p>This implementation is running on Windows.</p>
<p>unix, darwin, gnu-linux, bsd, freebsd, solaris, ...</p>
<p>Operating system flags (perhaps more than one).</p>
<p>i386, x86-64, ppc, sparc, jvm, clr, llvm, ...</p>
<p>CPU architecture flags.</p>
<p>ilp32, lp64, ilp64, ...</p>
<p>C memory model flags.</p>
<p>big-endian, little-endian</p>
<p>Byte order flags.</p>
<p>The name of this implementation.</p>
<p>The name and version of this implementation.</p>
<h2>Language changes</h2>
<h4>Incompatibilities with R<sup><small>5</small></sup>RS</h4>
<p>This section enumerates the incompatibilities between this report and
the “Revised<sup><small>5</small></sup> report” <span class="citation"
cites="R5RS"></span>.</p>
<p><em>This list is not authoritative, but is believed to be correct and
complete.</em></p>
<ul>
<li><p>Case sensitivity is now the default in symbols and character names.
This means that code written under the assumption that symbols could
be written FOO or Foo in some contexts and foo in other contexts can
either be changed, be marked with the new #!fold-case directive, or
be included in a library using the include-ci library declaration.
All standard identifiers are entirely in lower case.</p>
</li>
<li><p>The syntax-rules construct now recognizes <em>_</em> (underscore) as a
wildcard, which means it cannot be used as a syntax variable. It can
still be used as a literal.</p>
</li>
<li><p>The R<sup><small>5</small></sup>RS procedures exact-&gt;inexact and inexact-&gt;exact
have been renamed to their R<sup><small>6</small></sup>RS names, inexact and exact,
respectively, as these names are shorter and more correct. The
former names are still available in the R<sup><small>5</small></sup>RS library.</p>
</li>
<li><p>The guarantee that string comparison (with string\&lt;? and the related
predicates) is a lexicographical extension of character comparison
(with char\&lt;? and the related predicates) has been removed.</p>
</li>
<li><p>Support for the # character in numeric literals is no longer
required.</p>
</li>
<li><p>Support for the letters s, f, d, and l as exponent markers is no
longer required.</p>
</li>
<li><p>Implementations of stringnumber are no longer permitted to return #f
when the argument contains an explicit radix prefix, and must be
compatible with read and the syntax of numbers in programs.</p>
</li>
<li><p>The procedures transcript-on and transcript-off have been removed.</p>
</li>
</ul>
<h4>Other language changes since R<sup><small>5</small></sup>RS</h4>
<p>This section enumerates the additional differences between this report
and the “Revised<sup><small>5</small></sup> report” <span class="citation"
cites="R5RS"></span>.</p>
<p><em>This list is not authoritative, but is believed to be correct and
complete.</em></p>
<ul>
<li><p>Various minor ambiguities and unclarities in R<sup><small>5</small></sup>RS have
been cleaned up.</p>
</li>
<li><p>Libraries have been added as a new program structure to improve
encapsulation and sharing of code. Some existing and new identifiers
have been factored out into separate libraries. Libraries can be
imported into other libraries or main programs, with controlled
exposure and renaming of identifiers. The contents of a library can
be made conditional on the features of the implementation on which
it is to be used. There is an R<sup><small>5</small></sup>RS compatibility library.</p>
</li>
<li><p>The expressions types include, include-ci, and cond-expand have been
added to the base library; they have the same semantics as the
corresponding library declarations.</p>
</li>
<li><p>Exceptions can now be signaled explicitly with raise,
raise-continuable or error, and can be handled with
with-exception-handler and the guard syntax. Any object can specify
an error condition; the implementation-defined conditions signaled
by error have a predicate to detect them and accessor functions to
retrieve the arguments passed to error. Conditions signaled by read
and by file-related procedures also have predicates to detect them.</p>
</li>
<li><p>New disjoint types supporting access to multiple fields can be
generated with the define-record-type of SRFI 9 <span
class="citation" cites="srfi9"></span></p>
</li>
<li><p>Parameter objects can be created with make-parameter, and
dynamically rebound with parameterize. The procedures
current-input-port and current-output-port are now parameter
objects, as is the newly introduced current-error-port.</p>
</li>
<li><p>Support for promises has been enhanced based on SRFI 45 <span
class="citation" cites="srfi45"></span>.</p>
</li>
<li><p><em>Bytevectors</em>, vectors of exact integers in the range from 0 to 255
inclusive, have been added as a new disjoint type. A subset of the
vector procedures is provided. Bytevectors can be converted to and
from strings in accordance with the UTF-8 character encoding.
Bytevectors have a datum representation and evaluate to themselves.</p>
</li>
<li><p>Vector constants evaluate to themselves.</p>
</li>
<li><p>The procedure read-line is provided to make line-oriented textual
input simpler.</p>
</li>
<li><p>The procedure flush-output-port is provided to allow minimal control
of output port buffering.</p>
</li>
<li><p><em>Ports</em> can now be designated as <em>textual</em> or <em>binary</em> ports, with
new procedures for reading and writing binary data. The new
predicates input-port-open? and output-port-open? return whether a
port is open or closed. The new procedure close-port now closes a
port; if the port has both input and output sides, both are closed.</p>
</li>
<li><p><em>String ports</em> have been added as a way to read and write characters
to and from strings, and <em>bytevector ports</em> to read and write bytes
to and from bytevectors.</p>
</li>
<li><p>There are now I/O procedures specific to strings and bytevectors.</p>
</li>
<li><p>The write procedure now generates datum labels when applied to
circular objects. The new procedure write-simple never generates
labels; write-shared generates labels for all shared and circular
structure. The display procedure must not loop on circular objects.</p>
</li>
<li><p>The R<sup><small>6</small></sup>RS procedure eof-object has been added. Eof-objects
are now required to be a disjoint type.</p>
</li>
<li><p>Syntax definitions are now allowed wherever variable definitions
are.</p>
</li>
<li><p>The syntax-rules construct now allows the ellipsis symbol to be
specified explicitly instead of the default ..., allows template
escapes with an ellipsis-prefixed list, and allows tail patterns to
follow an ellipsis pattern.</p>
</li>
<li><p>The syntax-error syntax has been added as a way to signal immediate
and more informative errors when a macro is expanded.</p>
</li>
<li><p>The letrec* binding construct has been added, and internal define
is specified in terms of it.</p>
</li>
<li><p>Support for capturing multiple values has been enhanced with
define-values, let-values, and let*-values. Standard expression
types which contain a sequence of expressions now permit passing
zero or more than one value to the continuations of all non-final
expressions of the sequence.</p>
</li>
<li><p>The case conditional now supports <code>=&gt;</code> syntax analogous to cond not
only in regular clauses but in the else clause as well.</p>
</li>
<li><p>To support dispatching on the number of arguments passed to a
procedure, case-lambda has been added in its own library.</p>
</li>
<li><p>The convenience conditionals when and unless have been added.</p>
</li>
<li><p>The behavior of eqv? on inexact numbers now conforms to the
R<sup><small>6</small></sup>RS definition.</p>
</li>
<li><p>When applied to procedures, eq? and eqv? are permitted to return
different answers.</p>
</li>
<li><p>The R<sup><small>6</small></sup>RS procedures boolean=? and symbol=? have been
added.</p>
</li>
<li><p>Positive infinity, negative infinity, NaN, and negative inexact zero
have been added to the numeric tower as inexact values with the
written representations <code>+inf.0</code>, <code>-inf.0</code>, <code>+nan.0</code>, and -0.0
respectively. Support for them is not required. The representation
<code>-nan.0</code> is synonymous with <code>+nan.0</code>.</p>
</li>
<li><p>The log procedure now accepts a second argument specifying the
logarithm base.</p>
</li>
<li><p>The procedures map and for-each are now required to terminate on the
shortest argument list.</p>
</li>
<li><p>The procedures member and assoc now take an optional third argument
specifying the equality predicate to be used.</p>
</li>
<li><p>The numeric procedures finite?, infinite?, nan?, exact-integer?,
square, and exact-integer-sqrt have been added.</p>
</li>
<li><p>The - and / procedures and the character and string comparison
predicates are now required to support more than two arguments.</p>
</li>
<li><p>The forms <code>#true</code> and <code>#false</code> are now supported as well as <code>#t</code> and <code>#f</code>.</p>
</li>
<li><p>The procedures make-list, list-copy, list-set!, string-map,
string-for-each, string-&gt;vector, vector-append, vector-copy,
vector-map, vector-for-each, vector-&gt;string, vector-copy!, and
string-copy! have been added to round out the sequence operations.</p>
</li>
<li><p>Some string and vector procedures support processing of part of a
string or vector using optional <em>start</em> and <em>end</em> arguments.</p>
</li>
<li><p>Some list procedures are now defined on circular lists.</p>
</li>
<li><p>Implementations may provide any subset of the full Unicode
repertoire that includes ASCII, but implementations must support any
such subset in a way consistent with Unicode. Various character and
string procedures have been extended accordingly, and case
conversion procedures added for strings. String comparison is no
longer required to be consistent with character comparison, which is
based solely on Unicode scalar values. The new digit-value procedure
has been added to obtain the numerical value of a numeric character.</p>
</li>
<li><p>There are now two additional comment syntaxes: <code>#;</code> to skip the next
datum, and <code>#| ... |#</code> for nestable block comments.</p>
</li>
<li><p>Data prefixed with datum labels <code>#&lt;n&gt;=</code> can be referenced with
<code>#&lt;n&gt;#</code>, allowing for reading and writing of data with shared
structure.</p>
</li>
<li><p>Strings and symbols now allow mnemonic and numeric escape sequences,
and the list of named characters has been extended.</p>
</li>
<li><p>The procedures file-exists? and delete-file are available in the
<code>(scheme file)</code> library.</p>
</li>
<li><p>An interface to the system environment, command line, and process
exit status is available in the <code>(scheme process-context)</code> library.</p>
</li>
<li><p>Procedures for accessing time-related values are available in the
<code>(scheme time)</code> library.</p>
</li>
<li><p>A less irregular set of integer division operators is provided with
new and clearer names.</p>
</li>
<li><p>The load procedure now accepts a second argument specifying the
environment to load into.</p>
</li>
<li><p>The call-with-current-continuation procedure now has the synonym
call/cc.</p>
</li>
<li><p>The semantics of read-eval-print loops are now partly prescribed,
requiring the redefinition of procedures, but not syntax keywords,
to have retroactive effect.</p>
</li>
<li><p>The formal semantics now handles dynamic-wind.</p>
</li>
</ul>
<h4>Incompatibilities with R<sup><small>6</small></sup>RS</h4>
<p>This section enumerates the incompatibilities between
R<sup><small>7</small></sup>RS and the “Revised<sup><small>6</small></sup> report” <span
class="citation" cites="R6RS"></span> and its accompanying Standard
Libraries document.</p>
<p><em>This list is not authoritative, and is possibly incomplete.</em></p>
<ul>
<li><p>R<sup><small>7</small></sup>RS libraries begin with the keyword define-library
rather than library in order to make them syntactically
distinguishable from R<sup><small>6</small></sup>RS libraries. In
R<sup><small>7</small></sup>RS terms, the body of an R<sup><small>6</small></sup>RS library
consists of a single export declaration followed by a single import
declaration, followed by commands and definitions. In
R<sup><small>7</small></sup>RS, commands and definitions are not permitted directly
within the body: they have to be wrapped in a begin library
declaration.</p>
</li>
<li><p>There is no direct R<sup><small>6</small></sup>RS equivalent of the include,
include-ci, include-library-declarations, or cond-expand library
declarations. On the other hand, the R<sup><small>7</small></sup>RS library syntax
does not support phase or version specifications.</p>
</li>
<li><p>The grouping of standardized identifiers into libraries is different
from the R<sup><small>6</small></sup>RS approach. In particular, procedures which
are optional in R<sup><small>5</small></sup>RS  either expressly or by implication,
have been removed from the base library. Only the base library
itself is an absolute requirement.</p>
</li>
<li><p>No form of identifier syntax is provided.</p>
</li>
<li><p>Internal syntax definitions are allowed, but uses of a syntax form
cannot appear before its definition; the even/odd example given in
R<sup><small>6</small></sup>RS is not allowed.</p>
</li>
<li><p>The R<sup><small>6</small></sup>RS exception system was incorporated as-is, but the
condition types have been left unspecified. In particular, where
R<sup><small>6</small></sup>RS requires a condition of a specified type to be
signaled, R<sup><small>7</small></sup>RS says only “it is an error”, leaving the
question of signaling open.</p>
</li>
<li><p>Full Unicode support is not required. Normalization is not provided.
Character comparisons are defined by Unicode, but string comparisons
are implementation-dependent. Non-Unicode characters are permitted.</p>
</li>
<li><p>The full numeric tower is optional as in R<sup><small>5</small></sup>RS, but
optional support for IEEE infinities, NaN, and -0.0 was adopted from
R<sup><small>6</small></sup>RS. Most clarifications on numeric results were also
adopted, but the semantics of the R<sup><small>6</small></sup>RS procedures real?,
rational?, and integer? were not adopted. (Note that the
R<sup><small>5</small></sup>RS/R<sup><small>7</small></sup>RS semantics are available in
R<sup><small>6</small></sup>RS using real-valued?, rational-valued?, and
integer-valued?). The R<sup><small>6</small></sup>RS division operators div, mod,
div-and-mod, div0, mod0 and div0-and-mod0 are not provided.</p>
</li>
<li><p>When a result is unspecified, it is still required to be a single
value. However, non-final expressions in a body can return any
number of values.</p>
</li>
<li><p>The semantics of map and for-each have been changed to use the SRFI
1 <span class="citation" cites="srfi1"></span> early termination
behavior. Likewise, assoc and member take an optional equal?
argument as in SRFI 1, instead of the separate assp and memp
procedures of R<sup><small>6</small></sup>RS.</p>
</li>
<li><p>The R<sup><small>6</small></sup>RS quasiquote clarifications have been adopted,
with the exception of multiple-argument unquote and
unquote-splicing.</p>
</li>
<li><p>The R<sup><small>6</small></sup>RS method of specifying mantissa widths was not
adopted.</p>
</li>
<li><p>String ports are compatible with SRFI 6 <span class="citation"
cites="srfi6"></span> rather than R<sup><small>6</small></sup>RS.</p>
</li>
<li><p>R<sup><small>6</small></sup>RS-style bytevectors are included, but only the
unsigned byte (u8) procedures have been provided. The lexical syntax
uses #u8 for compatibility with SRFI 4 <span class="citation"
cites="srfi4"></span>, rather than the R<sup><small>6</small></sup>RS #vu8 style.</p>
</li>
<li><p>The utility macros when and unless are provided, but their result is
left unspecified.</p>
</li>
<li><p>The remaining features of the Standard Libraries document were left
to future standardization efforts.</p>
</li>
</ul>
<h2>Additional material</h2>
<p>The Scheme community website at <a href="http://schemers.org">http://schemers.org</a> contains additional
resources for learning and programming, job and event postings, and
Scheme user group information.</p>
<p>A bibliography of Scheme-related research at
<a href="http://library.readscheme.org">http://library.readscheme.org</a> links to technical papers and theses
related to the Scheme language, including both classic papers and recent
research.</p>
<p>On-line Scheme discussions are held using IRC on the #scheme channel at
irc.freenode.net and on the Usenet discussion group comp.lang.scheme.</p>
<h2>Example</h2>
<p>The procedure integrate-system integrates the system
<em>y</em><sub>*k*</sub><sup>′</sup> = <em>f</em><sub>*k*</sub>(<em>y</em><sub>1</sub>,<em>y</em><sub>2</sub>,…,<em>y</em><sub>*n*</sub>), <em>k</em> = 1, …, <em>n</em>
of differential equations with the method of Runge-Kutta.</p>
<p>The parameter <code>system-derivative</code> is a function that takes a system
state (a vector of values for the state variables
<em>y</em><sub>1</sub>, …, <em>y</em><sub>*n*</sub>) and produces a system derivative
(the values
<em>y</em><sub>1</sub><sup>′</sup>, …, <em>y</em><sub>*n*</sub><sup>′</sup>). The
parameter <code>initial-state</code> provides an initial system state, and <code>h</code> is
an initial guess for the length of the integration step.</p>
<p>The value returned by integrate-system is an infinite stream of system
states.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">integrate-system</span> <span class="nv">system-derivative</span>
                          <span class="nv">initial-state</span>
                          <span class="nv">h</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">next</span> <span class="p">(</span><span class="nf">runge-kutta-4</span> <span class="nv">system-derivative</span> <span class="nv">h</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">letrec </span><span class="p">((</span><span class="nf">states</span>
              <span class="p">(</span><span class="nb">cons </span><span class="nv">initial-state</span>
                    <span class="p">(</span><span class="k">delay </span><span class="p">(</span><span class="nf">map-streams</span> <span class="nv">next</span>
                                        <span class="nv">states</span><span class="p">)))))</span>
      <span class="nv">states</span><span class="p">)))</span>
</pre></div>
<p>The procedure runge-kutta-4 takes a function, <code>f</code>, that produces a
system derivative from a system state. It produces a function that takes
a system state and produces a new system state.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">runge-kutta-4</span> <span class="nv">f</span> <span class="nv">h</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">*h</span> <span class="p">(</span><span class="nf">scale-vector</span> <span class="nv">h</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">*2</span> <span class="p">(</span><span class="nf">scale-vector</span> <span class="mi">2</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">*1/2</span> <span class="p">(</span><span class="nf">scale-vector</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="p">(</span><span class="nf">*1/6</span> <span class="p">(</span><span class="nf">scale-vector</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">1</span> <span class="mi">6</span><span class="p">))))</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">y</span><span class="p">)</span>
      <span class="c1">;; y is a system state</span>
      <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">k0</span> <span class="p">(</span><span class="nf">*h</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">y</span><span class="p">)))</span>
             <span class="p">(</span><span class="nf">k1</span> <span class="p">(</span><span class="nf">*h</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">add-vectors</span> <span class="nv">y</span> <span class="p">(</span><span class="nf">*1/2</span> <span class="nv">k0</span><span class="p">)))))</span>
             <span class="p">(</span><span class="nf">k2</span> <span class="p">(</span><span class="nf">*h</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">add-vectors</span> <span class="nv">y</span> <span class="p">(</span><span class="nf">*1/2</span> <span class="nv">k1</span><span class="p">)))))</span>
             <span class="p">(</span><span class="nf">k3</span> <span class="p">(</span><span class="nf">*h</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">add-vectors</span> <span class="nv">y</span> <span class="nv">k2</span><span class="p">)))))</span>
        <span class="p">(</span><span class="nf">add-vectors</span> <span class="nv">y</span>
                     <span class="p">(</span><span class="nf">*1/6</span> <span class="p">(</span><span class="nf">add-vectors</span> <span class="nv">k0</span>
                                        <span class="p">(</span><span class="nf">*2</span> <span class="nv">k1</span><span class="p">)</span>
                                        <span class="p">(</span><span class="nf">*2</span> <span class="nv">k2</span><span class="p">)</span>
                                        <span class="nv">k3</span><span class="p">)))))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">elementwise</span> <span class="nv">f</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda </span><span class="nv">vectors</span>
    <span class="p">(</span><span class="nf">generate-vector</span>
     <span class="p">(</span><span class="nb">vector-length </span><span class="p">(</span><span class="nb">car </span><span class="nv">vectors</span><span class="p">))</span>
     <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">i</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">apply </span><span class="nv">f</span>
              <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">v</span><span class="p">)</span> <span class="p">(</span><span class="nb">vector-ref </span> <span class="nv">v</span> <span class="nv">i</span><span class="p">))</span>
                   <span class="nv">vectors</span><span class="p">))))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">generate-vector</span> <span class="nv">size</span> <span class="nv">proc</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">ans</span> <span class="p">(</span><span class="nb">make-vector </span><span class="nv">size</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">letrec </span><span class="p">((</span><span class="nf">loop</span>
              <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">i</span><span class="p">)</span>
                <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="nv">size</span><span class="p">)</span> <span class="nv">ans</span><span class="p">)</span>
                      <span class="p">(</span><span class="nf">else</span>
                       <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">ans</span> <span class="nv">i</span> <span class="p">(</span><span class="nf">proc</span> <span class="nv">i</span><span class="p">))</span>
                       <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)))))))</span>
      <span class="p">(</span><span class="nf">loop</span> <span class="mi">0</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">add-vectors</span> <span class="p">(</span><span class="nf">elementwise</span> <span class="nv">+</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">scale-vector</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">elementwise</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">s</span><span class="p">))))</span>
</pre></div>
<p>The map-streams procedure is analogous to map: it applies its first
argument (a procedure) to all the elements of its second argument (a
stream).</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">map-streams</span> <span class="nv">f</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">head</span> <span class="nv">s</span><span class="p">))</span>
        <span class="p">(</span><span class="k">delay </span><span class="p">(</span><span class="nf">map-streams</span> <span class="nv">f</span> <span class="p">(</span><span class="nf">tail</span> <span class="nv">s</span><span class="p">)))))</span>
</pre></div>
<p>Infinite streams are implemented as pairs whose car holds the first
element of the stream and whose cdr holds a promise to deliver the rest
of the stream.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">head</span> <span class="nv">car</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">tail</span> <span class="nv">stream</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">force </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">stream</span><span class="p">)))</span>
</pre></div>
<p>The following illustrates the use of integrate-system in integrating the
system <span class="math display">$$C {dv_C \\over dt} = -i_L - {v_C
\\over R}$$</span> <span class="math display">$$L {di_L \\over dt} =
v_C$$</span> which models a damped oscillator.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">damped-oscillator</span> <span class="nv">R</span> <span class="nv">L</span> <span class="nv">C</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">state</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">Vc</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">state</span> <span class="mi">0</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">Il</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">state</span> <span class="mi">1</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">vector </span><span class="p">(</span><span class="nb">- </span><span class="mi">0</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">/ </span><span class="nv">Vc</span> <span class="p">(</span><span class="nb">* </span><span class="nv">R</span> <span class="nv">C</span><span class="p">))</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">Il</span> <span class="nv">C</span><span class="p">)))</span>
              <span class="p">(</span><span class="nb">/ </span><span class="nv">Vc</span> <span class="nv">L</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">the-states</span>
  <span class="p">(</span><span class="nf">integrate-system</span>
   <span class="p">(</span><span class="nf">damped-oscillator</span> <span class="mi">10000</span> <span class="mi">1000</span> <span class="o">.</span><span class="mi">001</span><span class="p">)</span>
   <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">0</span><span class="p">)</span>
   <span class="o">.</span><span class="mi">01</span><span class="p">))</span>
</pre></div>
<h2>Bibliography</h2>
<p>Harold Abelson and Gerald Jay Sussman with Julie Sussman. <em>Structure and
Interpretation of Computer Programs, second edition.</em> MIT Press,
Cambridge, 1996.</p>
<p>Alan Bawden and Jonathan Rees. Syntactic closures. In <em>Proceedings of
the 1988 ACM Symposium on Lisp and Functional Programming</em>, pages 86–95.</p>
<p>S. Bradner. Key words for use in RFCs to Indicate Requirement Levels.
<a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>, 1997.</p>
<p>Robert G. Burger and R. Kent Dybvig. Printing floating-point numbers
quickly and accurately. In <em>Proceedings of the ACM SIGPLAN ’96
Conference on Programming Language Design and Implementation</em>,
pages 108–116.</p>
<p>William Clinger. How to read floating point numbers accurately. In
<em>Proceedings of the ACM SIGPLAN ’90 Conference on Programming Language
Design and Implementation</em>, pages 92–101. Proceedings published as
<em>SIGPLAN Notices</em> 25(6), June 1990.</p>
<p>William Clinger. Proper Tail Recursion and Space Efficiency. In
<em>Proceedings of the 1998 ACM Conference on Programming Language Design
and Implementation</em>, June 1998.</p>
<p>William Clinger. SRFI 6: Basic String Ports.
<a href="http://srfi.schemers.org/srfi-6/">http://srfi.schemers.org/srfi-6/</a>, 1999.</p>
<p>William Clinger, editor. The revised revised report on Scheme, or an
uncommon Lisp. MIT Artificial Intelligence Memo 848, August 1985. Also
published as Computer Science Department Technical Report 174, Indiana
University, June 1985.</p>
<p>William Clinger and Jonathan Rees. Macros that work. In <em>Proceedings of
the 1991 ACM Conference on Principles of Programming Languages</em>,
pages 155–162.</p>
<p>William Clinger and Jonathan Rees, editors. The revised<sup><small>4</small></sup>
report on the algorithmic language Scheme. In <em>ACM Lisp Pointers</em> 4(3),
pages 1–55, 1991.</p>
<p>Mark Davis. Unicode Standard Annex #44, Unicode Character Database.
<a href="http://unicode.org/reports/tr44/">http://unicode.org/reports/tr44/</a>, 2010.</p>
<p>R. Kent Dybvig, Robert Hieb, and Carl Bruggeman. Syntactic abstraction
in Scheme. <em>Lisp and Symbolic Computation</em> 5(4):295–326, 1993.</p>
<p>Marc Feeley. SRFI 4: Homogeneous Numeric Vector Datatypes.
<a href="http://srfi.schemers.org/srfi-4/">http://srfi.schemers.org/srfi-4/</a>, 1999.</p>
<p>Carol Fessenden, William Clinger, Daniel P. Friedman, and Christopher
Haynes. Scheme 311 version 4 reference manual. Indiana University
Computer Science Technical Report 137, February 1983. Superseded
by <span class="citation" cites="Scheme84"></span>.</p>
<p>D. Friedman, C. Haynes, E. Kohlbecker, and M. Wand. Scheme 84 interim
reference manual. Indiana University Computer Science Technical Report
153, January 1985.</p>
<p>Martin Gardner. Mathematical Games: The fantastic combinations of John
Conway’s new solitaire game “Life.” In <em>Scientific American</em>,
223:120–123, October 1970.</p>
<p><em>IEEE Standard 754-2008. IEEE Standard for Floating-Point Arithmetic.</em>
IEEE, New York, 2008.</p>
<p><em>IEEE Standard 1178-1990. IEEE Standard for the Scheme Programming
Language.</em> IEEE, New York, 1991.</p>
<p>Richard Kelsey. SRFI 9: Defining Record Types.
<a href="http://srfi.schemers.org/srfi-9/">http://srfi.schemers.org/srfi-9/</a>, 1999.</p>
<p>Richard Kelsey, William Clinger, and Jonathan Rees, editors. The
revised<sup><small>5</small></sup> report on the algorithmic language Scheme.
<em>Higher-Order and Symbolic Computation</em>, 11(1):7-105, 1998.</p>
<p>Eugene E. Kohlbecker Jr. <em>Syntactic Extensions in the Programming
Language Lisp.</em> PhD thesis, Indiana University, August 1986.</p>
<p>Eugene E. Kohlbecker Jr., Daniel P. Friedman, Matthias Felleisen, and
Bruce Duba. Hygienic macro expansion. In <em>Proceedings of the 1986 ACM
Conference on Lisp and Functional Programming</em>, pages 151–161.</p>
<p>John McCarthy. Recursive Functions of Symbolic Expressions and Their
Computation by Machine, Part I. <em>Communications of the ACM</em>
3(4):184–195, April 1960.</p>
<p>MIT Department of Electrical Engineering and Computer Science. Scheme
manual, seventh edition. September 1984.</p>
<p>Peter Naur et al. Revised report on the algorithmic language Algol 60.
<em>Communications of the ACM</em> 6(1):1–17, January 1963.</p>
<p>Paul Penfield, Jr. Principal values and branch cuts in complex APL. In
<em>APL ’81 Conference Proceedings,</em> pages 248–256. ACM SIGAPL, San
Francisco, September 1981. Proceedings published as <em>APL Quote Quad</em>
12(1), ACM, September 1981.</p>
<p>Jonathan A. Rees and Norman I. Adams IV. T: A dialect of Lisp or,
lambda: The ultimate software tool. In <em>Conference Record of the 1982
ACM Symposium on Lisp and Functional Programming</em>, pages 114–122.</p>
<p>Jonathan A. Rees, Norman I. Adams IV, and James R. Meehan. The T manual,
fourth edition. Yale University Computer Science Department, January
1984.</p>
<p>Jonathan Rees and William Clinger, editors. The revised<sup><small>3</small></sup>
report on the algorithmic language Scheme. In <em>ACM SIGPLAN Notices</em>
21(12), pages 37–79, December 1986.</p>
<p>Olin Shivers. SRFI 1: List Library. <a href="http://srfi.schemers.org/srfi-1/">http://srfi.schemers.org/srfi-1/</a>,
1999.</p>
<p>Guy Lewis Steele Jr. and Gerald Jay Sussman. The revised report on
Scheme, a dialect of Lisp. MIT Artificial Intelligence Memo 452, January
1978.</p>
<p>Guy Lewis Steele Jr. Rabbit: a compiler for Scheme. MIT Artificial
Intelligence Laboratory Technical Report 474, May 1978.</p>
<p>Michael Sperber, R. Kent Dybvig, Mathew Flatt, and Anton van Straaten,
editors. <em>The revised<sup><small>6</small></sup> report on the algorithmic language
Scheme.</em> Cambridge University Press, 2010.</p>
<p>Guy Lewis Steele Jr. <em>Common Lisp: The Language, second edition.</em>
Digital Press, Burlington MA, 1990.</p>
<p>Gerald Jay Sussman and Guy Lewis Steele Jr. Scheme: an interpreter for
extended lambda calculus. MIT Artificial Intelligence Memo 349, December
1975.</p>
<p>Joseph E. Stoy. <em>Denotational Semantics: The Scott-Strachey Approach to
Programming Language Theory.</em> MIT Press, Cambridge, 1977.</p>
<p>Texas Instruments, Inc. TI Scheme Language Reference Manual. Preliminary
version 1.0, November 1985.</p>
<p>Andre van Tonder. SRFI 45: Primitives for Expressing Iterative Lazy
Algorithms. <a href="http://srfi.schemers.org/srfi-45/">http://srfi.schemers.org/srfi-45/</a>, 2002.</p>
<p>Martin Gasbichler, Eric Knauel, Michael Sperber and Richard Kelsey. How
to Add Threads to a Sequential Language Without Getting Tangled Up.
<em>Proceedings of the Fourth Workshop on Scheme and Functional
Programming</em>, November 2003.</p>
<p>International Earth Rotation Service. Historical table of TAI-UTC
offsets. <a href="http://maia.usno.navy.mil/ser7/tai-utc.dat">http://maia.usno.navy.mil/ser7/tai-utc.dat</a></p>
</div>
    </div>
  </body>
</html>